{
  "inferred":true,
  "kind":"libraries",
  "mod_name":"spawn",
  "summary":"Spawning of programs.",
  "sections":{
    "by_name":[]
  },
  "name":"awful.spawn",
  "modifiers":{
    "copyright":[[],[]],
    "author":[[],[]]
  },
  "description":"",
  "items":[{
      "inferred":true,
      "subparams":[],
      "parameter":"field",
      "params":{
        "1":"cmd",
        "2":"sn_rules",
        "3":"callback",
        "map":{
          "callback":" A callback function to be run after startup.",
          "sn_rules":" A table of properties to be applied\n   after startup; `false` to disable startup notifications.",
          "cmd":" The command."
        }
      },
      "summary":"Spawn a program, and optionally apply properties and/or run a callback.",
      "name":"awful.spawn",
      "modifiers":{
        "return":[{
            "1":true,
            "type":"integer"
          },{
            "1":true,
            "type":"?string"
          },{
            "type":"string",
            "2":true
          }],
        "param":{
          "1":{
            "type":"string|table"
          },
          "2":{
            "optchain":"true",
            "type":"table|boolean",
            "opt":"true"
          },
          "3":{
            "optchain":true,
            "type":"function",
            "opt":true
          },
          "callback":{
            "optchain":true,
            "type":"function",
            "opt":true
          },
          "sn_rules":{
            "optchain":"true",
            "type":"table|boolean",
            "opt":"true"
          },
          "cmd":{
            "type":"string|table"
          }
        },
        "field":{
          "1":{
            "type":"string|table"
          },
          "2":{
            "optchain":"true",
            "type":"table|boolean",
            "opt":"true"
          },
          "3":{
            "optchain":true,
            "type":"function",
            "opt":true
          },
          "callback":{
            "optchain":true,
            "type":"function",
            "opt":true
          },
          "sn_rules":{
            "optchain":"true",
            "type":"table|boolean",
            "opt":"true"
          },
          "cmd":{
            "type":"string|table"
          }
        }
      },
      "description":"\n\n Applying properties or running a callback requires the program/client to\n support startup notifications.\n\n See `ruled.client.execute` for more details about the format of `sn_rules`.\n",
      "type":"staticfct",
      "section":"staticfct",
      "kind":"static module functions",
      "args":"(cmd[, sn_rules=true[, callback]])",
      "tags":[],
      "lineno":422
    },{
      "inferred":true,
      "subparams":[],
      "parameter":"field",
      "params":{
        "1":"cmd",
        "map":{
          "cmd":" The command."
        }
      },
      "summary":"Spawn a program using the shell.",
      "name":"awful.spawn.with_shell",
      "modifiers":{
        "return":[],
        "param":{
          "1":{
            "type":"string"
          },
          "cmd":{
            "type":"string"
          }
        },
        "field":{
          "1":{
            "type":"string"
          },
          "cmd":{
            "type":"string"
          }
        }
      },
      "description":"\n This calls `cmd` with `$SHELL -c` (via `awful.util.shell`).",
      "type":"staticfct",
      "section":"staticfct",
      "kind":"static module functions",
      "args":"(cmd)",
      "tags":[],
      "lineno":442
    },{
      "inferred":true,
      "subparams":{
        "callbacks":["callbacks.stdout","callbacks.stderr","callbacks.output_done","callbacks.exit"]
      },
      "parameter":"field",
      "params":{
        "1":"cmd",
        "2":"callbacks",
        "map":{
          "callbacks.stderr":" Function that is called with each\n   line of output on stderr, e.g. `stderr(line)`.",
          "callbacks.exit":" Function to call when the spawned\n   process exits. This function gets the exit reason and code as its\n   arguments.\n   The reason can be \"exit\" or \"signal\".\n   For \"exit\", the second argument is the exit code.\n   For \"signal\", the second argument is the signal causing process\n   termination.",
          "cmd":" The command.",
          "callbacks.output_done":" Function to call when no more\n   output is produced.",
          "callbacks":" Table containing callbacks that should be invoked on\n   various conditions.",
          "callbacks.stdout":" Function that is called with each\n   line of output on stdout, e.g. `stdout(line)`."
        }
      },
      "summary":"Spawn a program and asynchronously capture its output line by line.",
      "name":"awful.spawn.with_line_callback",
      "modifiers":{
        "return":[{
            "1":true,
            "type":"Integer"
          },{
            "type":"string",
            "2":true
          }],
        "param":{
          "1":{
            "type":"string|table"
          },
          "2":{
            "type":"table"
          },
          "3":{
            "type":"function",
            "opt":true
          },
          "4":{
            "type":"function",
            "opt":true
          },
          "5":{
            "type":"function",
            "opt":true
          },
          "6":{
            "type":"function",
            "opt":true
          },
          "callbacks.stderr":{
            "type":"function",
            "opt":true
          },
          "callbacks.exit":{
            "type":"function",
            "opt":true
          },
          "cmd":{
            "type":"string|table"
          },
          "callbacks.output_done":{
            "type":"function",
            "opt":true
          },
          "callbacks":{
            "type":"table"
          },
          "callbacks.stdout":{
            "type":"function",
            "opt":true
          }
        },
        "field":{
          "1":{
            "type":"string|table"
          },
          "2":{
            "type":"table"
          },
          "3":{
            "type":"function",
            "opt":true
          },
          "4":{
            "type":"function",
            "opt":true
          },
          "5":{
            "type":"function",
            "opt":true
          },
          "6":{
            "type":"function",
            "opt":true
          },
          "callbacks.stderr":{
            "type":"function",
            "opt":true
          },
          "callbacks.exit":{
            "type":"function",
            "opt":true
          },
          "cmd":{
            "type":"string|table"
          },
          "callbacks.output_done":{
            "type":"function",
            "opt":true
          },
          "callbacks":{
            "type":"table"
          },
          "callbacks.stdout":{
            "type":"function",
            "opt":true
          }
        }
      },
      "description":"",
      "type":"staticfct",
      "section":"staticfct",
      "kind":"static module functions",
      "args":"(cmd, callbacks)",
      "tags":[],
      "lineno":469
    },{
      "parameter":"field",
      "params":{
        "1":"cmd",
        "2":"callback",
        "map":{
          "callback.exitcode":" Exit code (exit code or signal number,\n   depending on `exitreason`).",
          "callback.stdout":" Output on stdout.",
          "callback":" Function with the following arguments",
          "callback.exitreason":" Exit reason (\"exit\" or \"signal\").",
          "callback.stderr":" Output on stderr.",
          "cmd":" The command."
        }
      },
      "modifiers":{
        "see":[[]],
        "return":[{
            "1":true,
            "type":"Integer"
          },{
            "type":"string",
            "2":true
          }],
        "param":{
          "1":{
            "type":"string|table"
          },
          "2":{
            "type":"table"
          },
          "3":{
            "type":"string"
          },
          "4":{
            "type":"string"
          },
          "5":{
            "type":"string"
          },
          "6":{
            "type":"integer"
          },
          "callback.exitcode":{
            "type":"integer"
          },
          "callback.stdout":{
            "type":"string"
          },
          "callback":{
            "type":"table"
          },
          "callback.exitreason":{
            "type":"string"
          },
          "callback.stderr":{
            "type":"string"
          },
          "cmd":{
            "type":"string|table"
          }
        },
        "field":{
          "1":{
            "type":"string|table"
          },
          "2":{
            "type":"table"
          },
          "3":{
            "type":"string"
          },
          "4":{
            "type":"string"
          },
          "5":{
            "type":"string"
          },
          "6":{
            "type":"integer"
          },
          "callback.exitcode":{
            "type":"integer"
          },
          "callback.stdout":{
            "type":"string"
          },
          "callback":{
            "type":"table"
          },
          "callback.exitreason":{
            "type":"string"
          },
          "callback.stderr":{
            "type":"string"
          },
          "cmd":{
            "type":"string|table"
          }
        }
      },
      "description":"\n (wraps `spawn.with_line_callback`).",
      "tags":{
        "see":[]
      },
      "section":"staticfct",
      "inferred":true,
      "subparams":{
        "callback":["callback.stdout","callback.stderr","callback.exitreason","callback.exitcode"]
      },
      "summary":"Asynchronously spawn a program and capture its output.",
      "name":"awful.spawn.easy_async",
      "type":"staticfct",
      "args":"(cmd, callback)",
      "kind":"static module functions",
      "lineno":515
    },{
      "parameter":"field",
      "params":{
        "1":"cmd",
        "2":"callback",
        "map":{
          "callback.exitcode":" Exit code (exit code or signal number,\n   depending on `exitreason`).",
          "callback.stdout":" Output on stdout.",
          "callback":" Function with the following arguments",
          "callback.exitreason":" Exit reason (\"exit\" or \"signal\").",
          "callback.stderr":" Output on stderr.",
          "cmd":" The command."
        }
      },
      "modifiers":{
        "see":[[]],
        "return":[{
            "1":true,
            "type":"Integer"
          },{
            "type":"string",
            "2":true
          }],
        "param":{
          "1":{
            "type":"string"
          },
          "2":{
            "type":"table"
          },
          "3":{
            "type":"string"
          },
          "4":{
            "type":"string"
          },
          "5":{
            "type":"string"
          },
          "6":{
            "type":"integer"
          },
          "callback.exitcode":{
            "type":"integer"
          },
          "callback.stdout":{
            "type":"string"
          },
          "callback":{
            "type":"table"
          },
          "callback.exitreason":{
            "type":"string"
          },
          "callback.stderr":{
            "type":"string"
          },
          "cmd":{
            "type":"string"
          }
        },
        "field":{
          "1":{
            "type":"string"
          },
          "2":{
            "type":"table"
          },
          "3":{
            "type":"string"
          },
          "4":{
            "type":"string"
          },
          "5":{
            "type":"string"
          },
          "6":{
            "type":"integer"
          },
          "callback.exitcode":{
            "type":"integer"
          },
          "callback.stdout":{
            "type":"string"
          },
          "callback":{
            "type":"table"
          },
          "callback.exitreason":{
            "type":"string"
          },
          "callback.stderr":{
            "type":"string"
          },
          "cmd":{
            "type":"string"
          }
        }
      },
      "description":"\n This calls `cmd` with `$SHELL -c` (via `awful.util.shell`).",
      "tags":{
        "see":[]
      },
      "section":"staticfct",
      "inferred":true,
      "subparams":{
        "callback":["callback.stdout","callback.stderr","callback.exitreason","callback.exitcode"]
      },
      "summary":"Call `spawn.easy_async` with a shell.",
      "name":"awful.spawn.easy_async_with_shell",
      "type":"staticfct",
      "args":"(cmd, callback)",
      "kind":"static module functions",
      "lineno":566
    },{
      "inferred":true,
      "subparams":[],
      "parameter":"field",
      "params":{
        "1":"input_stream",
        "2":"line_callback",
        "3":"done_callback",
        "4":"close",
        "map":{
          "input_stream":" The input stream to read from.",
          "close":" Should the stream be closed after end-of-file?",
          "line_callback":" Function that is called with each line\n   read, e.g. `line_callback(line_from_stream)`.",
          "done_callback":" Function that is called when the\n   operation finishes (e.g. due to end of file)."
        }
      },
      "summary":"Read lines from a Gio input stream",
      "name":"awful.spawn.read_lines",
      "modifiers":{
        "return":[],
        "param":{
          "1":{
            "type":"Gio.InputStream"
          },
          "2":{
            "type":"function"
          },
          "3":{
            "optchain":true,
            "type":"function",
            "opt":true
          },
          "4":{
            "optchain":"false",
            "type":"boolean",
            "opt":"false"
          },
          "input_stream":{
            "type":"Gio.InputStream"
          },
          "close":{
            "optchain":"false",
            "type":"boolean",
            "opt":"false"
          },
          "line_callback":{
            "type":"function"
          },
          "done_callback":{
            "optchain":true,
            "type":"function",
            "opt":true
          }
        },
        "field":{
          "1":{
            "type":"Gio.InputStream"
          },
          "2":{
            "type":"function"
          },
          "3":{
            "optchain":true,
            "type":"function",
            "opt":true
          },
          "4":{
            "optchain":"false",
            "type":"boolean",
            "opt":"false"
          },
          "input_stream":{
            "type":"Gio.InputStream"
          },
          "close":{
            "optchain":"false",
            "type":"boolean",
            "opt":"false"
          },
          "line_callback":{
            "type":"function"
          },
          "done_callback":{
            "optchain":true,
            "type":"function",
            "opt":true
          }
        }
      },
      "description":"",
      "type":"staticfct",
      "section":"staticfct",
      "kind":"static module functions",
      "args":"(input_stream, line_callback[, done_callback[, close=false]])",
      "tags":[],
      "lineno":578
    },{
      "parameter":"field",
      "params":{
        "1":"cmd",
        "2":"rules",
        "3":"matcher",
        "4":"unique_id",
        "5":"callback",
        "map":{
          "unique_id":" A string to identify the client so it isn't executed\n  multiple time.",
          "matcher":" A matching function to find the instance\n  among running clients.",
          "cmd":" The command.",
          "callback":" A callback function when the client is created.",
          "rules":" The properties that need to be applied to the client."
        }
      },
      "modifiers":{
        "see":[[]],
        "return":[],
        "param":{
          "1":{
            "type":"string|table"
          },
          "2":{
            "optchain":true,
            "type":"table",
            "opt":true
          },
          "3":{
            "optchain":true,
            "type":"function",
            "opt":true
          },
          "4":{
            "optchain":true,
            "type":"string",
            "opt":true
          },
          "5":{
            "optchain":true,
            "type":"function",
            "opt":true
          },
          "unique_id":{
            "optchain":true,
            "type":"string",
            "opt":true
          },
          "matcher":{
            "optchain":true,
            "type":"function",
            "opt":true
          },
          "cmd":{
            "type":"string|table"
          },
          "callback":{
            "optchain":true,
            "type":"function",
            "opt":true
          },
          "rules":{
            "optchain":true,
            "type":"table",
            "opt":true
          }
        },
        "field":{
          "1":{
            "type":"string|table"
          },
          "2":{
            "optchain":true,
            "type":"table",
            "opt":true
          },
          "3":{
            "optchain":true,
            "type":"function",
            "opt":true
          },
          "4":{
            "optchain":true,
            "type":"string",
            "opt":true
          },
          "5":{
            "optchain":true,
            "type":"function",
            "opt":true
          },
          "unique_id":{
            "optchain":true,
            "type":"string",
            "opt":true
          },
          "matcher":{
            "optchain":true,
            "type":"function",
            "opt":true
          },
          "cmd":{
            "type":"string|table"
          },
          "callback":{
            "optchain":true,
            "type":"function",
            "opt":true
          },
          "rules":{
            "optchain":true,
            "type":"table",
            "opt":true
          }
        }
      },
      "description":"\n\n This function tries its best to preserve the state across `awesome.restart()`.\n\n By default, when no `unique_id` is specified, this function will generate one by\n hashing the command and its rules. If you have multiple instance of the same\n command and rules, you need to specify an UID or only the first one will be\n executed.\n\n The `rules` are standard `ruled.client`.\n\n This function depends on the startup notification protocol to be correctly\n implemented by the command. See `client.startup_id` for more information.\n Note that this also won't work with shell or terminal commands.\n",
      "tags":{
        "see":[]
      },
      "section":"staticfct",
      "inferred":true,
      "subparams":[],
      "summary":"Spawn a command if it has not been spawned before.",
      "name":"awful.spawn.once",
      "type":"staticfct",
      "args":"(cmd[, rules[, matcher[, unique_id[, callback]]]])",
      "kind":"static module functions",
      "lineno":728
    },{
      "parameter":"field",
      "params":{
        "1":"cmd",
        "2":"rules",
        "3":"matcher",
        "4":"unique_id",
        "5":"callback",
        "map":{
          "unique_id":" A string to identify the client so it isn't executed\n  multiple time.",
          "matcher":" A matching function to find the instance\n  among running clients.",
          "cmd":" The command.",
          "callback":" A callback function when the client is created.",
          "rules":" The properties that need to be applied to the client."
        }
      },
      "modifiers":{
        "see":[[]],
        "return":[],
        "param":{
          "1":{
            "type":"string|table"
          },
          "2":{
            "optchain":true,
            "type":"table",
            "opt":true
          },
          "3":{
            "optchain":true,
            "type":"function",
            "opt":true
          },
          "4":{
            "optchain":true,
            "type":"string",
            "opt":true
          },
          "5":{
            "optchain":true,
            "type":"function",
            "opt":true
          },
          "unique_id":{
            "optchain":true,
            "type":"string",
            "opt":true
          },
          "matcher":{
            "optchain":true,
            "type":"function",
            "opt":true
          },
          "cmd":{
            "type":"string|table"
          },
          "callback":{
            "optchain":true,
            "type":"function",
            "opt":true
          },
          "rules":{
            "optchain":true,
            "type":"table",
            "opt":true
          }
        },
        "field":{
          "1":{
            "type":"string|table"
          },
          "2":{
            "optchain":true,
            "type":"table",
            "opt":true
          },
          "3":{
            "optchain":true,
            "type":"function",
            "opt":true
          },
          "4":{
            "optchain":true,
            "type":"string",
            "opt":true
          },
          "5":{
            "optchain":true,
            "type":"function",
            "opt":true
          },
          "unique_id":{
            "optchain":true,
            "type":"string",
            "opt":true
          },
          "matcher":{
            "optchain":true,
            "type":"function",
            "opt":true
          },
          "cmd":{
            "type":"string|table"
          },
          "callback":{
            "optchain":true,
            "type":"function",
            "opt":true
          },
          "rules":{
            "optchain":true,
            "type":"table",
            "opt":true
          }
        }
      },
      "description":"\n\n This is like `awful.spawn.once`, but will spawn new instances if the previous\n has finished.\n\n The `rules` are standard `ruled.client`.\n\n This function depends on the startup notification protocol to be correctly\n implemented by the command. See `client.startup_id` for more information.\n Note that this also won't work with shell or terminal commands.\n\n Note that multiple instances can still be spawned if the command is called\n faster than the client has time to start.\n",
      "tags":{
        "see":[]
      },
      "section":"staticfct",
      "inferred":true,
      "subparams":[],
      "summary":"Spawn a command if an instance is not already running.",
      "name":"awful.spawn.single_instance",
      "type":"staticfct",
      "args":"(cmd[, rules[, matcher[, unique_id[, callback]]]])",
      "kind":"static module functions",
      "lineno":761
    },{
      "parameter":"field",
      "params":{
        "1":"cmd",
        "2":"rules",
        "3":"matcher",
        "4":"unique_id",
        "5":"callback",
        "map":{
          "unique_id":" A string to identify the client so it isn't executed\n  multiple time.",
          "matcher":" A matching function to find the instance\n  among running clients.",
          "cmd":" The command.",
          "callback":" A callback function when the client is created.",
          "rules":" The properties that need to be applied to the client."
        }
      },
      "modifiers":{
        "see":[[]],
        "field":{
          "1":{
            "type":"string|table"
          },
          "2":{
            "type":"table"
          },
          "3":{
            "optchain":true,
            "type":"function",
            "opt":true
          },
          "4":{
            "optchain":true,
            "type":"string",
            "opt":true
          },
          "5":{
            "optchain":true,
            "type":"function",
            "opt":true
          },
          "unique_id":{
            "optchain":true,
            "type":"string",
            "opt":true
          },
          "matcher":{
            "optchain":true,
            "type":"function",
            "opt":true
          },
          "cmd":{
            "type":"string|table"
          },
          "callback":{
            "optchain":true,
            "type":"function",
            "opt":true
          },
          "rules":{
            "type":"table"
          }
        },
        "return":[{
            "type":"client"
          }],
        "param":{
          "1":{
            "type":"string|table"
          },
          "2":{
            "type":"table"
          },
          "3":{
            "optchain":true,
            "type":"function",
            "opt":true
          },
          "4":{
            "optchain":true,
            "type":"string",
            "opt":true
          },
          "5":{
            "optchain":true,
            "type":"function",
            "opt":true
          },
          "unique_id":{
            "optchain":true,
            "type":"string",
            "opt":true
          },
          "matcher":{
            "optchain":true,
            "type":"function",
            "opt":true
          },
          "cmd":{
            "type":"string|table"
          },
          "callback":{
            "optchain":true,
            "type":"function",
            "opt":true
          },
          "rules":{
            "type":"table"
          }
        },
        "request":[[]]
      },
      "description":"\n\n This function depends on the startup notification protocol to be correctly\n implemented by the command. See `client.startup_id` for more information.\n Note that this also won't work with shell or terminal commands.\n",
      "tags":{
        "see":[],
        "request":["client activate spawn.raise_or_spawn granted Activate a client when\n  `awful.spawn.raise_or_spawn` is called and the client exists."]
      },
      "section":"staticfct",
      "inferred":true,
      "subparams":[],
      "summary":"Raise a client if it exists or spawn a new one then raise it.",
      "name":"awful.spawn.raise_or_spawn",
      "type":"staticfct",
      "args":"(cmd, rules[, matcher[, unique_id[, callback]]])",
      "kind":"static module functions",
      "lineno":791
    }],
  "type":"module",
  "file":"/home/cji/portless/awesome/build/lib/awful/spawn.lua",
  "package":"awful",
  "tags":{
    "author":["Julien Danjou &lt;julien@danjou.info&gt;","Emmanuel Lepage Vallee &lt;elv1313@gmail.com&gt;"],
    "copyright":["2008 Julien Danjou","2014 Emmanuel Lepage Vallee"]
  },
  "lineno":294
}
