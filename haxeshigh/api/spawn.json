{
  "inferred":true,
  "kind":"libraries",
  "mod_name":"spawn",
  "summary":"Spawning of programs.",
  "sections":{
    "by_name":[]
  },
  "name":"awful.spawn",
  "modifiers":{
    "copyright":[[],[]],
    "author":[[],[]]
  },
  "description":"\n\n This module provides methods to start programs and supports startup\n notifications, which allows for callbacks and applying properties to the\n program after it has been launched.  This requires currently that the\n application supports them.\n\n Frequently asked questions\n ===\n\n **Rules of thumb when a shell is needed**:\n\n * A shell is required when the commands contain `&&`, `;`, `||`, `&` or\n  any other unix shell language syntax\n * When shell variables are defined as part of the command\n * When the command is a shell alias\n\n Note that a shell is **not** a terminal emulator. A terminal emulator is\n something like XTerm, Gnome-terminal or Konsole. A shell is something like\n `bash`, `zsh`, `busybox sh` or `Debian ash`.\n\n If you wish to open a process in a terminal window, check that your terminal\n emulator supports the common `-e` option. If it does, then something like\n this should work:\n\n    awful.spawn(terminal..\" -e my_command\")\n\n Note that some terminals, such as rxvt-unicode (urxvt) support full commands\n using quotes, while other terminal emulators require to use quoting.\n\n **Understanding clients versus PID versus commands versus class**:\n\n A *process* has a *PID* (process identifier). It can have 0, 1 or many\n *window*s.\n\n A *command* is what is used to start *process*(es). It has no direct relation\n with *process*, *client* or *window*. When a command is executed, it will\n usually start a *process* which keeps running until it exits. This however is\n not always the case as some applications use scripts as command and others\n use various single-instance mechanisms (usually client/server) and merge\n with an existing process.\n\n A *client* corresponds to a *window*. It is owned by a process. It can have\n both a parent and one or many children. A *client* has a *class*, an\n *instance*, a *role*, and a *type*. See `client.class`, `client.instance`,\n `client.role` and `client.type` for more information about these properties.\n\n **Understanding blocking versus asynchronous execution**:\n\n Awesome is single threaded, it means only one thing is executed at any time.\n But Awesome isn't doomed to be slow. It may not have multiple threads, but\n it has something called coroutine and also has callbacks. This means things\n that take time to execute can still do so in the background (using C threads\n or external process + sockets). When they are done, they can notify the\n Awesome thread. This works perfectly and avoid blocking Awesome.\n\n If you want to update the text of a `wibox.widget.textbox` with the output\n of a shell command, you should use the `awful.spawn.easy_async_with_shell`\n command. It is strongly recommended not to use `io.popen` is explained in the\n \"Getting a command's output\" section. Asynchronous execution is at first a\n bit tricky to understand if you never used that before. The example below\n should demonstrate how it works.\n\n If we do (but *really*, don't do that):\n\n     -- **NEVER, EVER, DO THIS**: your computer will freeze\n     os.execute(\"sleep 1; echo foo > /tmp/foo.txt\")\n     mylabel.text = io.popen(\"cat /tmp/foo.txt\"):read(\"*all\")\n\n The label will display `foo`. But If we do:\n\n     -- Don't do this, it won't work.\n     -- Assumes /tmp/foo.txt does not exist\n     awful.spawn.with_shell(\"sleep 1; echo foo > /tmp/foo.txt\")\n     mylabel.text = io.popen(\"cat /tmp/foo.txt\"):read(\"*all\")\n\n Then the label will be **empty**. `awful.spawn` and `awful.spawn.with_shell`\n will **not** block and thus the `io.popen` will be executed before\n `sleep 1` finishes. This is why we have async functions to execute shell\n commands. There are many variants with difference characteristics and\n complexity. `awful.spawn.easy_async` is the most common as it is good enough\n for the general \"I want to execute a command and do something with the\n output when it finishes\".\n\n     -- This is the correct way\n     local command = \"sleep 1; echo foo > /tmp/foo.txt\"\n\n     awful.spawn.easy_async_with_shell(command, function()\n         awful.spawn.easy_async_with_shell(\"cat /tmp/foo.txt\", function(out)\n             mylabel.text = out\n         end)\n     end)\n\n In this variant, Awesome will not block. Again, like other spawn, you\n cannot add code outside of the callback function to use the result of the\n command. The code will be executed before the command is finished so the\n result won't yet be available.\n\n **Getting a command's output**:\n\n First, do **not** use `io.popen` **ever**. It is synchronous. Synchronous\n functions **block everything** until they are done. All visual applications\n lock (as Awesome no longer responds), you will probably lose some keyboard\n and mouse events and will have higher latency when playing games. This is\n also true when reading files synchronously, but this is another topic.\n\n Awesome provides a few ways to get output from commands. One is to use the\n `Gio` libraries directly. This is usually very complicated, but gives a lot\n of control on the command execution.\n\n This modules provides `with_line_callback` and `easy_async` for convenience.\n First, lets add this bash command to `rc.lua`:\n\n    local noisy = [[bash -c '\n      for I in $(seq 1 5); do\n        date\n        echo err >&2\n        sleep 2\n      done\n    ']]\n\n It prints a bunch of junk on the standard output (*stdout*) and error\n (*stderr*) streams. This command would block Awesome for 10 seconds if it\n were executed synchronously, but will not block it at all using the\n asynchronous functions.\n\n `with_line_callback` will execute the callbacks every time a new line is\n printed by the command:\n\n    awful.spawn.with_line_callback(noisy, {\n        stdout = function(line)\n            naughty.notification { message = \"LINE:\"..line }\n        end,\n        stderr = function(line)\n            naughty.notification { message = \"ERR:\"..line}\n        end,\n    })\n\n If only the full output is needed, then `easy_async` is the right choice:\n\n    awful.spawn.easy_async(noisy, function(stdout, stderr, reason, exit_code)\n        naughty.notification { message = stdout }\n    end)\n\n **Default applications**:\n\n If the intent is to open a file/document, then it is recommended to use the\n following standard command. The default application will be selected\n according to the [Shared MIME-info Database](https://specifications.freedesktop.org/shared-mime-info-spec/shared-mime-info-spec-latest.html)\n specification. The `xdg-utils` package provided by most distributions\n includes the `xdg-open` command:\n\n    awful.spawn({\"xdg-open\", \"/path/to/file\"})\n\n Awesome **does not** manage, modify or otherwise influence the database\n for default applications. For information about how to do this, consult the\n [ARCH Linux Wiki](https://wiki.archlinux.org/index.php/default_applications).\n\n If you wish to change how the default applications behave, then consult the\n [Desktop Entry](https://specifications.freedesktop.org/desktop-entry-spec/desktop-entry-spec-latest.html)\n specification.\n\n Spawning applications with specific properties\n ===\n\n **The startup notification protocol**:\n\n The startup notification protocol is an optional specification implemented\n by X11 applications to bridge the chain of knowledge between the moment a\n program is launched to the moment its window (client) is shown. It can be\n found [on the FreeDesktop.org website](https://www.freedesktop.org/wiki/Specifications/startup-notification-spec/).\n\n Awesome has support for the various events that are part of the protocol, but\n the most useful is the identifier, usually identified by its `SNID` acronym in\n the documentation. It isn't usually necessary to even know it exists, as it\n is all done automatically. However, if more control is required, the\n identifier can be specified by an environment variable called\n `DESKTOP_STARTUP_ID`. For example, let us consider execution of the following\n command:\n\n    DESKTOP_STARTUP_ID=\"something_TIME$(date '+%s')\" my_command\n\n This should (if the program correctly implements the protocol) result in\n `c.startup_id` to at least match `something`.\n This identifier can then be used in `ruled.client` to configure the client.\n\n Awesome can automatically set the `DESKTOP_STARTUP_ID` variable. This is used\n by `awful.spawn` to specify additional rules for the startup. For example:\n\n    awful.spawn(\"urxvt -e maxima -name CALCULATOR\", {\n        floating  = true,\n        tag       = mouse.screen.selected_tag,\n        placement = awful.placement.bottom_right,\n    })\n\n This can also be used from the command line:\n\n    awesome-client 'awful=require(\"awful\");\n      awful.spawn(\"urxvt -e maxima -name CALCULATOR\", {\n        floating  = true,\n        tag       = mouse.screen.selected_tag,\n        placement = awful.placement.bottom_right,\n      })'\n\n This table contains the client properties that are valid when used the\n `sn_rules` or `prop` function argument. They are the same as in `ruled.client`.\n\n<table class='widget_list' border=1>\n <tr>\n  <th align='center'>Name</th>\n  <th align='center'>Description</th>\n </tr>\n   <tr><td><a href='../core_components/client.html#placement'>placement</a></td><td>The client default placement on the screen</td></tr>\n   <tr><td><a href='../core_components/client.html#honor_padding'>honor\\_padding</a></td><td>When applying the placement, honor the screen padding</td></tr>\n   <tr><td><a href='../core_components/client.html#honor_workarea'>honor\\_workarea</a></td><td>When applying the placement, honor the screen work area</td></tr>\n   <tr><td><a href='../core_components/client.html#tag'>tag</a></td><td>The client default tag</td></tr>\n   <tr><td><a href='../core_components/client.html#tags'>tags</a></td><td>The client default tags</td></tr>\n   <tr><td><a href='../core_components/client.html#new_tag'>new\\_tag</a></td><td>Create a new tag for this client</td></tr>\n   <tr><td><a href='../core_components/client.html#switch_to_tags'>switch\\_to\\_tags</a></td><td>Unselect the current tags and select this client tags</td></tr>\n   <tr><td><a href='../core_components/client.html#focus'>focus</a></td><td>Define if the client should grab focus by default</td></tr>\n   <tr><td><a href='../core_components/client.html#titlebars_enabled'>titlebars\\_enabled</a></td><td>Should this client have a titlebar by default</td></tr>\n   <tr><td><a href='../core_components/client.html#callback'>callback</a></td><td>A function to call when this client is ready</td></tr>\n   <tr><td><a href='../core_components/client.html#marked'>marked</a></td><td>If a client is marked or not</td></tr>\n   <tr><td><a href='../core_components/client.html#is_fixed'>is\\_fixed</a></td><td>Return if a client has a fixed size or not</td></tr>\n   <tr><td><a href='../core_components/client.html#immobilized_horizontal'>immobilized\\_horizontal</a></td><td>Is the client immobilized horizontally?</td></tr>\n   <tr><td><a href='../core_components/client.html#immobilized_vertical'>immobilized\\_vertical</a></td><td>Is the client immobilized vertically?</td></tr>\n   <tr><td><a href='../core_components/client.html#floating'>floating</a></td><td>The client floating state</td></tr>\n   <tr><td><a href='../core_components/client.html#x'>x</a></td><td>The x coordinates</td></tr>\n   <tr><td><a href='../core_components/client.html#y'>y</a></td><td>The y coordinates</td></tr>\n   <tr><td><a href='../core_components/client.html#width'>width</a></td><td>The width of the client</td></tr>\n   <tr><td><a href='../core_components/client.html#height'>height</a></td><td>The height of the client</td></tr>\n   <tr><td><a href='../core_components/client.html#dockable'>dockable</a></td><td>If the client is dockable</td></tr>\n   <tr><td><a href='../core_components/client.html#requests_no_titlebar'>requests\\_no\\_titlebar</a></td><td>If the client requests not to be decorated with a titlebar</td></tr>\n   <tr><td><a href='../core_components/client.html#shape'>shape</a></td><td>Set the client shape</td></tr>\n   <tr><td><a href='../core_components/client.html#active'>active</a></td><td>Return true if the client is active (has focus)</td></tr>\n   <tr><td><a href='../core_components/client.html#window'>window</a></td><td>The X window id</td></tr>\n   <tr><td><a href='../core_components/client.html#name'>name</a></td><td>The client title</td></tr>\n   <tr><td><a href='../core_components/client.html#skip_taskbar'>skip\\_taskbar</a></td><td>True if the client does not want to be in taskbar</td></tr>\n   <tr><td><a href='../core_components/client.html#type'>type</a></td><td>The window type</td></tr>\n   <tr><td><a href='../core_components/client.html#class'>class</a></td><td>The client class</td></tr>\n   <tr><td><a href='../core_components/client.html#instance'>instance</a></td><td>The client instance</td></tr>\n   <tr><td><a href='../core_components/client.html#pid'>pid</a></td><td>The client PID, if available</td></tr>\n   <tr><td><a href='../core_components/client.html#role'>role</a></td><td>The window role, if available</td></tr>\n   <tr><td><a href='../core_components/client.html#machine'>machine</a></td><td>The machine client is running on</td></tr>\n   <tr><td><a href='../core_components/client.html#icon_name'>icon\\_name</a></td><td>The client name when iconified</td></tr>\n   <tr><td><a href='../core_components/client.html#icon'>icon</a></td><td>The client icon as a surface</td></tr>\n   <tr><td><a href='../core_components/client.html#icon_sizes'>icon\\_sizes</a></td><td>The available sizes of client icons</td></tr>\n   <tr><td><a href='../core_components/client.html#screen'>screen</a></td><td>Client screen</td></tr>\n   <tr><td><a href='../core_components/client.html#hidden'>hidden</a></td><td>Define if the client must be hidden, i</td></tr>\n   <tr><td><a href='../core_components/client.html#minimized'>minimized</a></td><td>Define it the client must be iconify, i</td></tr>\n   <tr><td><a href='../core_components/client.html#size_hints_honor'>size\\_hints\\_honor</a></td><td>Honor size hints, e</td></tr>\n   <tr><td><a href='../core_components/client.html#border_width'>border\\_width</a></td><td>The client border width</td></tr>\n   <tr><td><a href='../core_components/client.html#border_color'>border\\_color</a></td><td>The client border color</td></tr>\n   <tr><td><a href='../core_components/client.html#urgent'>urgent</a></td><td>The client urgent state</td></tr>\n   <tr><td><a href='../core_components/client.html#content'>content</a></td><td>A cairo surface for the client window content</td></tr>\n   <tr><td><a href='../core_components/client.html#opacity'>opacity</a></td><td>The client opacity</td></tr>\n   <tr><td><a href='../core_components/client.html#ontop'>ontop</a></td><td>The client is on top of every other windows</td></tr>\n   <tr><td><a href='../core_components/client.html#above'>above</a></td><td>The client is above normal windows</td></tr>\n   <tr><td><a href='../core_components/client.html#below'>below</a></td><td>The client is below normal windows</td></tr>\n   <tr><td><a href='../core_components/client.html#fullscreen'>fullscreen</a></td><td>The client is fullscreen or not</td></tr>\n   <tr><td><a href='../core_components/client.html#maximized'>maximized</a></td><td>The client is maximized (horizontally and vertically) or not</td></tr>\n   <tr><td><a href='../core_components/client.html#maximized_horizontal'>maximized\\_horizontal</a></td><td>The client is maximized horizontally or not</td></tr>\n   <tr><td><a href='../core_components/client.html#maximized_vertical'>maximized\\_vertical</a></td><td>The client is maximized vertically or not</td></tr>\n   <tr><td><a href='../core_components/client.html#transient_for'>transient\\_for</a></td><td>The client the window is transient for</td></tr>\n   <tr><td><a href='../core_components/client.html#group_window'>group\\_window</a></td><td>Window identification unique to a group of windows</td></tr>\n   <tr><td><a href='../core_components/client.html#leader_window'>leader\\_window</a></td><td>Identification unique to windows spawned by the same command</td></tr>\n   <tr><td><a href='../core_components/client.html#size_hints'>size\\_hints</a></td><td>A table with size hints of the client</td></tr>\n   <tr><td><a href='../core_components/client.html#motif_wm_hints'>motif\\_wm\\_hints</a></td><td>The motif WM hints of the client</td></tr>\n   <tr><td><a href='../core_components/client.html#sticky'>sticky</a></td><td>Set the client sticky, i</td></tr>\n   <tr><td><a href='../core_components/client.html#modal'>modal</a></td><td>Indicate if the client is modal</td></tr>\n   <tr><td><a href='../core_components/client.html#focusable'>focusable</a></td><td>True if the client can receive the input focus</td></tr>\n   <tr><td><a href='../core_components/client.html#shape_bounding'>shape\\_bounding</a></td><td>The client's bounding shape as set by awesome as a (native) cairo surface</td></tr>\n   <tr><td><a href='../core_components/client.html#shape_clip'>shape\\_clip</a></td><td>The client's clip shape as set by awesome as a (native) cairo surface</td></tr>\n   <tr><td><a href='../core_components/client.html#shape_input'>shape\\_input</a></td><td>The client's input shape as set by awesome as a (native) cairo surface</td></tr>\n   <tr><td><a href='../core_components/client.html#client_shape_bounding'>client\\_shape\\_bounding</a></td><td>The client's bounding shape as set by the program as a (native) cairo surface</td></tr>\n   <tr><td><a href='../core_components/client.html#client_shape_clip'>client\\_shape\\_clip</a></td><td>The client's clip shape as set by the program as a (native) cairo surface</td></tr>\n   <tr><td><a href='../core_components/client.html#startup_id'>startup\\_id</a></td><td>The FreeDesktop StartId</td></tr>\n   <tr><td><a href='../core_components/client.html#valid'>valid</a></td><td>If the client that this object refers to is still managed by awesome</td></tr>\n   <tr><td><a href='../core_components/client.html#first_tag'>first\\_tag</a></td><td>The first tag of the client</td></tr>\n   <tr><td><a href='../core_components/client.html#buttons'>buttons</a></td><td>Get or set mouse buttons bindings for a client</td></tr>\n   <tr><td><a href='../core_components/client.html#keys'>keys</a></td><td>Get or set keys bindings for a client</td></tr>\n </table>\n",
  "items":[{
      "inferred":true,
      "subparams":[],
      "parameter":"field",
      "params":{
        "1":"cmd",
        "2":"sn_rules",
        "3":"callback",
        "map":{
          "callback":" A callback function to be run after startup.",
          "sn_rules":" A table of properties to be applied\n   after startup; `false` to disable startup notifications.",
          "cmd":" The command."
        }
      },
      "summary":"Spawn a program, and optionally apply properties and/or run a callback.",
      "name":"awful.spawn",
      "modifiers":{
        "return":[{
            "1":true,
            "type":"integer"
          },{
            "1":true,
            "type":"?string"
          },{
            "type":"string",
            "2":true
          }],
        "param":{
          "1":{
            "type":"string|table"
          },
          "2":{
            "optchain":"true",
            "type":"table|boolean",
            "opt":"true"
          },
          "3":{
            "optchain":true,
            "type":"function",
            "opt":true
          },
          "callback":{
            "optchain":true,
            "type":"function",
            "opt":true
          },
          "sn_rules":{
            "optchain":"true",
            "type":"table|boolean",
            "opt":"true"
          },
          "cmd":{
            "type":"string|table"
          }
        },
        "field":{
          "1":{
            "type":"string|table"
          },
          "2":{
            "optchain":"true",
            "type":"table|boolean",
            "opt":"true"
          },
          "3":{
            "optchain":true,
            "type":"function",
            "opt":true
          },
          "callback":{
            "optchain":true,
            "type":"function",
            "opt":true
          },
          "sn_rules":{
            "optchain":"true",
            "type":"table|boolean",
            "opt":"true"
          },
          "cmd":{
            "type":"string|table"
          }
        }
      },
      "description":"\n\n Applying properties or running a callback requires the program/client to\n support startup notifications.\n\n See `ruled.client.execute` for more details about the format of `sn_rules`.\n",
      "type":"staticfct",
      "section":"staticfct",
      "kind":"static module functions",
      "args":"(cmd[, sn_rules=true[, callback]])",
      "tags":[],
      "lineno":422
    },{
      "inferred":true,
      "subparams":[],
      "parameter":"field",
      "params":{
        "1":"cmd",
        "map":{
          "cmd":" The command."
        }
      },
      "summary":"Spawn a program using the shell.",
      "name":"awful.spawn.with_shell",
      "modifiers":{
        "return":[],
        "param":{
          "1":{
            "type":"string"
          },
          "cmd":{
            "type":"string"
          }
        },
        "field":{
          "1":{
            "type":"string"
          },
          "cmd":{
            "type":"string"
          }
        }
      },
      "description":"\n This calls `cmd` with `$SHELL -c` (via `awful.util.shell`).",
      "type":"staticfct",
      "section":"staticfct",
      "kind":"static module functions",
      "args":"(cmd)",
      "tags":[],
      "lineno":442
    },{
      "inferred":true,
      "subparams":{
        "callbacks":["callbacks.stdout","callbacks.stderr","callbacks.output_done","callbacks.exit"]
      },
      "parameter":"field",
      "params":{
        "1":"cmd",
        "2":"callbacks",
        "map":{
          "callbacks.stderr":" Function that is called with each\n   line of output on stderr, e.g. `stderr(line)`.",
          "callbacks.exit":" Function to call when the spawned\n   process exits. This function gets the exit reason and code as its\n   arguments.\n   The reason can be \"exit\" or \"signal\".\n   For \"exit\", the second argument is the exit code.\n   For \"signal\", the second argument is the signal causing process\n   termination.",
          "cmd":" The command.",
          "callbacks.output_done":" Function to call when no more\n   output is produced.",
          "callbacks":" Table containing callbacks that should be invoked on\n   various conditions.",
          "callbacks.stdout":" Function that is called with each\n   line of output on stdout, e.g. `stdout(line)`."
        }
      },
      "summary":"Spawn a program and asynchronously capture its output line by line.",
      "name":"awful.spawn.with_line_callback",
      "modifiers":{
        "return":[{
            "1":true,
            "type":"Integer"
          },{
            "type":"string",
            "2":true
          }],
        "param":{
          "1":{
            "type":"string|table"
          },
          "2":{
            "type":"table"
          },
          "3":{
            "type":"function",
            "opt":true
          },
          "4":{
            "type":"function",
            "opt":true
          },
          "5":{
            "type":"function",
            "opt":true
          },
          "6":{
            "type":"function",
            "opt":true
          },
          "callbacks.stderr":{
            "type":"function",
            "opt":true
          },
          "callbacks.exit":{
            "type":"function",
            "opt":true
          },
          "cmd":{
            "type":"string|table"
          },
          "callbacks.output_done":{
            "type":"function",
            "opt":true
          },
          "callbacks":{
            "type":"table"
          },
          "callbacks.stdout":{
            "type":"function",
            "opt":true
          }
        },
        "field":{
          "1":{
            "type":"string|table"
          },
          "2":{
            "type":"table"
          },
          "3":{
            "type":"function",
            "opt":true
          },
          "4":{
            "type":"function",
            "opt":true
          },
          "5":{
            "type":"function",
            "opt":true
          },
          "6":{
            "type":"function",
            "opt":true
          },
          "callbacks.stderr":{
            "type":"function",
            "opt":true
          },
          "callbacks.exit":{
            "type":"function",
            "opt":true
          },
          "cmd":{
            "type":"string|table"
          },
          "callbacks.output_done":{
            "type":"function",
            "opt":true
          },
          "callbacks":{
            "type":"table"
          },
          "callbacks.stdout":{
            "type":"function",
            "opt":true
          }
        }
      },
      "description":"",
      "type":"staticfct",
      "section":"staticfct",
      "kind":"static module functions",
      "args":"(cmd, callbacks)",
      "tags":[],
      "lineno":469
    },{
      "parameter":"field",
      "params":{
        "1":"cmd",
        "2":"callback",
        "map":{
          "callback.exitcode":" Exit code (exit code or signal number,\n   depending on `exitreason`).",
          "callback.stdout":" Output on stdout.",
          "callback":" Function with the following arguments",
          "callback.exitreason":" Exit reason (\"exit\" or \"signal\").",
          "callback.stderr":" Output on stderr.",
          "cmd":" The command."
        }
      },
      "modifiers":{
        "see":[[]],
        "return":[{
            "1":true,
            "type":"Integer"
          },{
            "type":"string",
            "2":true
          }],
        "param":{
          "1":{
            "type":"string|table"
          },
          "2":{
            "type":"table"
          },
          "3":{
            "type":"string"
          },
          "4":{
            "type":"string"
          },
          "5":{
            "type":"string"
          },
          "6":{
            "type":"integer"
          },
          "callback.exitcode":{
            "type":"integer"
          },
          "callback.stdout":{
            "type":"string"
          },
          "callback":{
            "type":"table"
          },
          "callback.exitreason":{
            "type":"string"
          },
          "callback.stderr":{
            "type":"string"
          },
          "cmd":{
            "type":"string|table"
          }
        },
        "field":{
          "1":{
            "type":"string|table"
          },
          "2":{
            "type":"table"
          },
          "3":{
            "type":"string"
          },
          "4":{
            "type":"string"
          },
          "5":{
            "type":"string"
          },
          "6":{
            "type":"integer"
          },
          "callback.exitcode":{
            "type":"integer"
          },
          "callback.stdout":{
            "type":"string"
          },
          "callback":{
            "type":"table"
          },
          "callback.exitreason":{
            "type":"string"
          },
          "callback.stderr":{
            "type":"string"
          },
          "cmd":{
            "type":"string|table"
          }
        }
      },
      "description":"\n (wraps `spawn.with_line_callback`).",
      "tags":{
        "see":[]
      },
      "section":"staticfct",
      "inferred":true,
      "subparams":{
        "callback":["callback.stdout","callback.stderr","callback.exitreason","callback.exitcode"]
      },
      "summary":"Asynchronously spawn a program and capture its output.",
      "name":"awful.spawn.easy_async",
      "type":"staticfct",
      "args":"(cmd, callback)",
      "kind":"static module functions",
      "lineno":515
    },{
      "parameter":"field",
      "params":{
        "1":"cmd",
        "2":"callback",
        "map":{
          "callback.exitcode":" Exit code (exit code or signal number,\n   depending on `exitreason`).",
          "callback.stdout":" Output on stdout.",
          "callback":" Function with the following arguments",
          "callback.exitreason":" Exit reason (\"exit\" or \"signal\").",
          "callback.stderr":" Output on stderr.",
          "cmd":" The command."
        }
      },
      "modifiers":{
        "see":[[]],
        "return":[{
            "1":true,
            "type":"Integer"
          },{
            "type":"string",
            "2":true
          }],
        "param":{
          "1":{
            "type":"string"
          },
          "2":{
            "type":"table"
          },
          "3":{
            "type":"string"
          },
          "4":{
            "type":"string"
          },
          "5":{
            "type":"string"
          },
          "6":{
            "type":"integer"
          },
          "callback.exitcode":{
            "type":"integer"
          },
          "callback.stdout":{
            "type":"string"
          },
          "callback":{
            "type":"table"
          },
          "callback.exitreason":{
            "type":"string"
          },
          "callback.stderr":{
            "type":"string"
          },
          "cmd":{
            "type":"string"
          }
        },
        "field":{
          "1":{
            "type":"string"
          },
          "2":{
            "type":"table"
          },
          "3":{
            "type":"string"
          },
          "4":{
            "type":"string"
          },
          "5":{
            "type":"string"
          },
          "6":{
            "type":"integer"
          },
          "callback.exitcode":{
            "type":"integer"
          },
          "callback.stdout":{
            "type":"string"
          },
          "callback":{
            "type":"table"
          },
          "callback.exitreason":{
            "type":"string"
          },
          "callback.stderr":{
            "type":"string"
          },
          "cmd":{
            "type":"string"
          }
        }
      },
      "description":"\n This calls `cmd` with `$SHELL -c` (via `awful.util.shell`).",
      "tags":{
        "see":[]
      },
      "section":"staticfct",
      "inferred":true,
      "subparams":{
        "callback":["callback.stdout","callback.stderr","callback.exitreason","callback.exitcode"]
      },
      "summary":"Call `spawn.easy_async` with a shell.",
      "name":"awful.spawn.easy_async_with_shell",
      "type":"staticfct",
      "args":"(cmd, callback)",
      "kind":"static module functions",
      "lineno":566
    },{
      "inferred":true,
      "subparams":[],
      "parameter":"field",
      "params":{
        "1":"input_stream",
        "2":"line_callback",
        "3":"done_callback",
        "4":"close",
        "map":{
          "input_stream":" The input stream to read from.",
          "close":" Should the stream be closed after end-of-file?",
          "line_callback":" Function that is called with each line\n   read, e.g. `line_callback(line_from_stream)`.",
          "done_callback":" Function that is called when the\n   operation finishes (e.g. due to end of file)."
        }
      },
      "summary":"Read lines from a Gio input stream",
      "name":"awful.spawn.read_lines",
      "modifiers":{
        "return":[],
        "param":{
          "1":{
            "type":"Gio.InputStream"
          },
          "2":{
            "type":"function"
          },
          "3":{
            "optchain":true,
            "type":"function",
            "opt":true
          },
          "4":{
            "optchain":"false",
            "type":"boolean",
            "opt":"false"
          },
          "input_stream":{
            "type":"Gio.InputStream"
          },
          "close":{
            "optchain":"false",
            "type":"boolean",
            "opt":"false"
          },
          "line_callback":{
            "type":"function"
          },
          "done_callback":{
            "optchain":true,
            "type":"function",
            "opt":true
          }
        },
        "field":{
          "1":{
            "type":"Gio.InputStream"
          },
          "2":{
            "type":"function"
          },
          "3":{
            "optchain":true,
            "type":"function",
            "opt":true
          },
          "4":{
            "optchain":"false",
            "type":"boolean",
            "opt":"false"
          },
          "input_stream":{
            "type":"Gio.InputStream"
          },
          "close":{
            "optchain":"false",
            "type":"boolean",
            "opt":"false"
          },
          "line_callback":{
            "type":"function"
          },
          "done_callback":{
            "optchain":true,
            "type":"function",
            "opt":true
          }
        }
      },
      "description":"",
      "type":"staticfct",
      "section":"staticfct",
      "kind":"static module functions",
      "args":"(input_stream, line_callback[, done_callback[, close=false]])",
      "tags":[],
      "lineno":578
    },{
      "parameter":"field",
      "params":{
        "1":"cmd",
        "2":"rules",
        "3":"matcher",
        "4":"unique_id",
        "5":"callback",
        "map":{
          "unique_id":" A string to identify the client so it isn't executed\n  multiple time.",
          "matcher":" A matching function to find the instance\n  among running clients.",
          "cmd":" The command.",
          "callback":" A callback function when the client is created.",
          "rules":" The properties that need to be applied to the client."
        }
      },
      "modifiers":{
        "see":[[]],
        "return":[],
        "param":{
          "1":{
            "type":"string|table"
          },
          "2":{
            "optchain":true,
            "type":"table",
            "opt":true
          },
          "3":{
            "optchain":true,
            "type":"function",
            "opt":true
          },
          "4":{
            "optchain":true,
            "type":"string",
            "opt":true
          },
          "5":{
            "optchain":true,
            "type":"function",
            "opt":true
          },
          "unique_id":{
            "optchain":true,
            "type":"string",
            "opt":true
          },
          "matcher":{
            "optchain":true,
            "type":"function",
            "opt":true
          },
          "cmd":{
            "type":"string|table"
          },
          "callback":{
            "optchain":true,
            "type":"function",
            "opt":true
          },
          "rules":{
            "optchain":true,
            "type":"table",
            "opt":true
          }
        },
        "field":{
          "1":{
            "type":"string|table"
          },
          "2":{
            "optchain":true,
            "type":"table",
            "opt":true
          },
          "3":{
            "optchain":true,
            "type":"function",
            "opt":true
          },
          "4":{
            "optchain":true,
            "type":"string",
            "opt":true
          },
          "5":{
            "optchain":true,
            "type":"function",
            "opt":true
          },
          "unique_id":{
            "optchain":true,
            "type":"string",
            "opt":true
          },
          "matcher":{
            "optchain":true,
            "type":"function",
            "opt":true
          },
          "cmd":{
            "type":"string|table"
          },
          "callback":{
            "optchain":true,
            "type":"function",
            "opt":true
          },
          "rules":{
            "optchain":true,
            "type":"table",
            "opt":true
          }
        }
      },
      "description":"\n\n This function tries its best to preserve the state across `awesome.restart()`.\n\n By default, when no `unique_id` is specified, this function will generate one by\n hashing the command and its rules. If you have multiple instance of the same\n command and rules, you need to specify an UID or only the first one will be\n executed.\n\n The `rules` are standard `ruled.client`.\n\n This function depends on the startup notification protocol to be correctly\n implemented by the command. See `client.startup_id` for more information.\n Note that this also won't work with shell or terminal commands.\n",
      "tags":{
        "see":[]
      },
      "section":"staticfct",
      "inferred":true,
      "subparams":[],
      "summary":"Spawn a command if it has not been spawned before.",
      "name":"awful.spawn.once",
      "type":"staticfct",
      "args":"(cmd[, rules[, matcher[, unique_id[, callback]]]])",
      "kind":"static module functions",
      "lineno":728
    },{
      "parameter":"field",
      "params":{
        "1":"cmd",
        "2":"rules",
        "3":"matcher",
        "4":"unique_id",
        "5":"callback",
        "map":{
          "unique_id":" A string to identify the client so it isn't executed\n  multiple time.",
          "matcher":" A matching function to find the instance\n  among running clients.",
          "cmd":" The command.",
          "callback":" A callback function when the client is created.",
          "rules":" The properties that need to be applied to the client."
        }
      },
      "modifiers":{
        "see":[[]],
        "return":[],
        "param":{
          "1":{
            "type":"string|table"
          },
          "2":{
            "optchain":true,
            "type":"table",
            "opt":true
          },
          "3":{
            "optchain":true,
            "type":"function",
            "opt":true
          },
          "4":{
            "optchain":true,
            "type":"string",
            "opt":true
          },
          "5":{
            "optchain":true,
            "type":"function",
            "opt":true
          },
          "unique_id":{
            "optchain":true,
            "type":"string",
            "opt":true
          },
          "matcher":{
            "optchain":true,
            "type":"function",
            "opt":true
          },
          "cmd":{
            "type":"string|table"
          },
          "callback":{
            "optchain":true,
            "type":"function",
            "opt":true
          },
          "rules":{
            "optchain":true,
            "type":"table",
            "opt":true
          }
        },
        "field":{
          "1":{
            "type":"string|table"
          },
          "2":{
            "optchain":true,
            "type":"table",
            "opt":true
          },
          "3":{
            "optchain":true,
            "type":"function",
            "opt":true
          },
          "4":{
            "optchain":true,
            "type":"string",
            "opt":true
          },
          "5":{
            "optchain":true,
            "type":"function",
            "opt":true
          },
          "unique_id":{
            "optchain":true,
            "type":"string",
            "opt":true
          },
          "matcher":{
            "optchain":true,
            "type":"function",
            "opt":true
          },
          "cmd":{
            "type":"string|table"
          },
          "callback":{
            "optchain":true,
            "type":"function",
            "opt":true
          },
          "rules":{
            "optchain":true,
            "type":"table",
            "opt":true
          }
        }
      },
      "description":"\n\n This is like `awful.spawn.once`, but will spawn new instances if the previous\n has finished.\n\n The `rules` are standard `ruled.client`.\n\n This function depends on the startup notification protocol to be correctly\n implemented by the command. See `client.startup_id` for more information.\n Note that this also won't work with shell or terminal commands.\n\n Note that multiple instances can still be spawned if the command is called\n faster than the client has time to start.\n",
      "tags":{
        "see":[]
      },
      "section":"staticfct",
      "inferred":true,
      "subparams":[],
      "summary":"Spawn a command if an instance is not already running.",
      "name":"awful.spawn.single_instance",
      "type":"staticfct",
      "args":"(cmd[, rules[, matcher[, unique_id[, callback]]]])",
      "kind":"static module functions",
      "lineno":761
    },{
      "parameter":"field",
      "params":{
        "1":"cmd",
        "2":"rules",
        "3":"matcher",
        "4":"unique_id",
        "5":"callback",
        "map":{
          "unique_id":" A string to identify the client so it isn't executed\n  multiple time.",
          "matcher":" A matching function to find the instance\n  among running clients.",
          "cmd":" The command.",
          "callback":" A callback function when the client is created.",
          "rules":" The properties that need to be applied to the client."
        }
      },
      "modifiers":{
        "see":[[]],
        "field":{
          "1":{
            "type":"string|table"
          },
          "2":{
            "type":"table"
          },
          "3":{
            "optchain":true,
            "type":"function",
            "opt":true
          },
          "4":{
            "optchain":true,
            "type":"string",
            "opt":true
          },
          "5":{
            "optchain":true,
            "type":"function",
            "opt":true
          },
          "unique_id":{
            "optchain":true,
            "type":"string",
            "opt":true
          },
          "matcher":{
            "optchain":true,
            "type":"function",
            "opt":true
          },
          "cmd":{
            "type":"string|table"
          },
          "callback":{
            "optchain":true,
            "type":"function",
            "opt":true
          },
          "rules":{
            "type":"table"
          }
        },
        "return":[{
            "type":"client"
          }],
        "param":{
          "1":{
            "type":"string|table"
          },
          "2":{
            "type":"table"
          },
          "3":{
            "optchain":true,
            "type":"function",
            "opt":true
          },
          "4":{
            "optchain":true,
            "type":"string",
            "opt":true
          },
          "5":{
            "optchain":true,
            "type":"function",
            "opt":true
          },
          "unique_id":{
            "optchain":true,
            "type":"string",
            "opt":true
          },
          "matcher":{
            "optchain":true,
            "type":"function",
            "opt":true
          },
          "cmd":{
            "type":"string|table"
          },
          "callback":{
            "optchain":true,
            "type":"function",
            "opt":true
          },
          "rules":{
            "type":"table"
          }
        },
        "request":[[]]
      },
      "description":"\n\n This function depends on the startup notification protocol to be correctly\n implemented by the command. See `client.startup_id` for more information.\n Note that this also won't work with shell or terminal commands.\n",
      "tags":{
        "see":[],
        "request":["client activate spawn.raise_or_spawn granted Activate a client when\n  `awful.spawn.raise_or_spawn` is called and the client exists."]
      },
      "section":"staticfct",
      "inferred":true,
      "subparams":[],
      "summary":"Raise a client if it exists or spawn a new one then raise it.",
      "name":"awful.spawn.raise_or_spawn",
      "type":"staticfct",
      "args":"(cmd, rules[, matcher[, unique_id[, callback]]])",
      "kind":"static module functions",
      "lineno":791
    }],
  "type":"module",
  "file":"/home/cji/portless/awesome/build/lib/awful/spawn.lua",
  "package":"awful",
  "tags":{
    "author":["Julien Danjou &lt;julien@danjou.info&gt;","Emmanuel Lepage Vallee &lt;elv1313@gmail.com&gt;"],
    "copyright":["2008 Julien Danjou","2014 Emmanuel Lepage Vallee"]
  },
  "lineno":294
}