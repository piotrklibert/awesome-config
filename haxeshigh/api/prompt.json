{
  "inferred":true,
  "kind":"libraries",
  "mod_name":"prompt",
  "summary":"Prompt module for awful.",
  "sections":{
    "by_name":[]
  },
  "name":"awful.prompt",
  "modifiers":{
    "copyright":[],
    "author":[[]]
  },
  "description":"\n\n **Keyboard navigation**:\n\n The following readline keyboard shortcuts are implemented as expected:\n <table class='widget_list' border=1>\n   <tr><th>Name</th><th>Usage</th></tr>\n   <tr><td><kbd>CTRL+A</kbd></td><td>beginning-of-line</td></tr>\n   <tr><td><kbd>CTRL+B</kbd></td><td>backward-char</td></tr>\n   <tr><td><kbd>CTRL+C</kbd></td><td>cancel</td></tr>\n   <tr><td><kbd>CTRL+D</kbd></td><td>delete-char</td></tr>\n   <tr><td><kbd>CTRL+E</kbd></td><td>end-of-line</td></tr>\n   <tr><td><kbd>CTRL+J</kbd></td><td>accept-line</td></tr>\n   <tr><td><kbd>CTRL+M</kbd></td><td>accept-line</td></tr>\n   <tr><td><kbd>CTRL+F</kbd></td><td>move-cursor-right</td></tr>\n   <tr><td><kbd>CTRL+H</kbd></td><td>backward-delete-char</td></tr>\n   <tr><td><kbd>CTRL+K</kbd></td><td>kill-line</td></tr>\n   <tr><td><kbd>CTRL+U</kbd></td><td>unix-line-discard</td></tr>\n   <tr><td><kbd>CTRL+W</kbd></td><td>unix-word-rubout</td></tr>\n   <tr><td><kbd>CTRL+BACKSPACE</kbd></td><td>unix-word-rubout</td></tr>\n   <tr><td><kbd>SHIFT+INSERT</kbd></td><td>paste</td></tr>\n   <tr><td><kbd>HOME</kbd></td><td>beginning-of-line</td></tr>\n   <tr><td><kbd>END</kbd></td><td>end-of-line</td></tr>\n </table>\n\n The following shortcuts implement additional history manipulation commands\n where the search term is defined as the substring of the command from first\n character to cursor position.\n\n * <kbd>CTRL+R</kbd>: reverse history search, matches any history entry\n containing search term.\n * <kbd>CTRL+S</kbd>: forward history search, matches any history entry\n containing search term.\n * <kbd>CTRL+UP</kbd>: ZSH up line or search, matches any history entry\n starting with search term.\n * <kbd>CTRL+DOWN</kbd>: ZSH down line or search, matches any history\n entry starting with search term.\n * <kbd>CTRL+DELETE</kbd>: delete the currently visible history entry from\n history file. This does not delete new commands or history entries under\n user editing.\n\n **Basic usage**:\n\n By default, `rc.lua` will create one `awful.widget.prompt` per screen called\n `mypromptbox`. It is used for both the command execution (`mod4+r`) and\n Lua prompt (`mod4+x`). It can be re-used for random inputs using:\n\n \n\n![Usage example](../images/AUTOGEN_wibox_awidget_prompt_simple.svg)\n\n \n     local atextbox = wibox.widget.textbox()\n     -- Create a shortcut function\n     local function echo_test()\n         awful.prompt.run {\n             prompt       = &#34<b>Echo: </b>&#34,\n             text         = &#34default command&#34,\n             bg_cursor    = &#34#ff0000&#34,\n             -- To use the default `rc.lua` prompt:\n             --textbox      = mouse.screen.mypromptbox.widget,\n             textbox      = atextbox,\n             exe_callback = function(input)\n                 if not input or #input == 0 then return end\n                 naughty.notification { message = &#34The input was: &#34..input }\n             end\n         }\n     end\n\n     -- Then **IN THE globalkeys TABLE** add a new shortcut\n     awful.key({ modkey }, \"e\", echo_test,\n         {description = \"Echo a string\", group = \"custom\"}),\n\n Note that this assumes an `rc.lua` file based on the default one. The way\n to access the screen prompt may vary.\n\n **Extra key hooks**:\n\n The Awesome prompt also supports adding custom extensions to specific\n keyboard keybindings. Those keybindings have precedence over the built-in\n ones. Therefore, they can be used to override the default ones.\n\n *[Example one] Adding pre-configured `awful.spawn` commands:*\n\n \n\n![Usage example](../images/AUTOGEN_wibox_awidget_prompt_hooks.svg)\n\n \n     local atextbox = wibox.widget.textbox()\n     -- Custom handler for the return value. This implementation does nothing,\n     -- but you might want be notified of the failure, so it is part of this\n     -- example.\n     local function clear(result)\n         atextbox.widget.text =\n             type(result) == &#34string&#34 and result or &#34&#34\n     end\n     local hooks = {\n         -- Replace the &#34normal&#34 `Return` with a custom one\n         {{         }, &#34Return&#34, awful.spawn},\n         -- Spawn method to spawn in the current tag\n         {{&#34Mod1&#34   }, &#34Return&#34, function(command)\n             clear(awful.spawn(command,{\n                 tag       = mouse.screen.selected_tag\n             }))\n         end},\n         -- Spawn in the current tag as floating and on top\n         {{&#34Shift&#34  }, &#34Return&#34, function(command)\n             clear(awful.spawn(command,{\n                 ontop     = true,\n                 floating  = true,\n                 tag       = mouse.screen.selected_tag\n             }))\n         end},\n         -- Spawn in a new tag\n         {{&#34Control&#34}, &#34Return&#34, function(command)\n             clear(awful.spawn(command,{\n                 new_tag = true\n             }))\n         end},\n         -- Cancel\n         {{         }, &#34Escape&#34, function(_)\n             clear()\n         end},\n     }\n     awful.prompt.run {\n         prompt        = &#34<b>Run: </b>&#34,\n         hooks         = hooks,\n         textbox       = atextbox,\n         history_path  = gfs.get_cache_dir() .. &#34/history&#34,\n         done_callback = clear,\n     }\n\n *[Example two] Modifying the command (+ vi like input)*:\n\n The hook system also allows to modify the command before interpreting it in\n the `exe_callback`.\n\n \n\n![Usage example](../images/AUTOGEN_wibox_awidget_prompt_vilike.svg)\n\n \n     local atextbox = wibox.widget.textbox()\n     -- Store a list of verbs characters in a hash\n     local verbs = {\n         -- Spawn in a terminal\n         t = function(adjs, count, cmd) return {terminal, &#34-e&#34, cmd} end,  --luacheck: no unused args\n         -- Spawn with a shell\n         s = function(adjs, count, cmd) return {awful.util.shell, '-c', cmd} end, --luacheck: no unused args\n     }\n     local function vi_parse(action, command)\n         local req, ret = {count={}, adjectives={}}\n         -- Quite dumb, don't do something like <num>+<adj>+<num>+<verb>\n         for char in action:gmatch('(.)') do\n             if     tonumber(char)  then table.insert(req.count, char)\n             elseif verbs[char]     then req.verb = char\n             else   table.insert(ret.adjectives, char) end\n             if req.verb then\n                 req.count = tonumber(table.concat(req.count)) or 1\n                 ret = ret or verbs[req.verb](req.adjectives, req.count, command)\n                 req = {count={}, adjectives={}}\n             end\n         end\n         return ret\n     end\n     awful.prompt.run {\n         prompt       = '<b>Run: </b>',\n         hooks        = {\n             {{},'Return', function(cmd)\n                 if (not cmd) or cmd:sub(1,1) ~= ':' then return cmd end\n                 local act, cmd2 = cmd:gmatch(':([a-zA-Z1-9]+)[ ]+(.*)')()\n                 if not act then return cmd end\n                 return vi_parse(act, cmd2)\n             end},\n         },\n         textbox      = atextbox,\n         history_path = gfs.get_cache_dir() .. '/history',\n         exe_callback = function(cmd) awful.spawn(cmd) end\n     }\n\n *[Example three] Key listener*:\n\n The 2 previous examples were focused on changing the prompt behavior. This\n one explains how to \"spy\" on the prompt events. This can be used for\n\n * Implementing more complex mutator\n * Synchronising other widgets\n * Showing extra tips to the user\n\n \n\n![Usage example](../images/AUTOGEN_wibox_awidget_prompt_keypress.svg)\n\n \n     local atextbox = wibox.widget.textbox()\n     local notif = nil\n     awful.prompt.run {\n         prompt               = &#34<b>Run: </b>&#34,\n         keypressed_callback  = function(mod, key, cmd) --luacheck: no unused args\n             if key == &#34Shift_L&#34 then\n                 notif = naughty.notification { message = &#34Shift pressed&#34 }\n             end\n         end,\n         keyreleased_callback = function(mod, key, cmd) --luacheck: no unused args\n             if notif then\n                 naughty.destroy(notif)\n                 notif = nil\n             end\n         end,\n         textbox              = atextbox,\n         history_path         = gfs.get_cache_dir() .. &#34/history&#34,\n     }\n\n **highlighting**:\n\n The prompt also support custom highlighters:\n\n \n\n![Usage example](../images/AUTOGEN_wibox_awidget_prompt_highlight.svg)\n\n \n     local amp = &#34&amp&#34..string.char(0x3B)\n     local quot = &#34&quot&#34..string.char(0x3B)\n     local atextbox = wibox.widget.textbox()\n     -- Create a shortcut function\n     local function echo_test()\n         awful.prompt.run {\n             prompt       = &#34<b>Echo: </b>&#34,\n             bg_cursor    = &#34#ff0000&#34,\n             -- To use the default `rc.lua` prompt:\n             --textbox      = mouse.screen.mypromptbox.widget,\n             textbox      = atextbox,\n             highlighter  = function(b, a)\n                 -- Add a random marker to delimitate the cursor\n                 local cmd = b..&#34ZZZCURSORZZZ&#34..a\n                 -- Find shell variables\n                 local sub = &#34<span foreground='#CFBA5D'>%1</span>&#34\n                 cmd = cmd:gsub(&#34($[A-Za-z][a-zA-Z0-9]*)&#34, sub)\n                 -- Highlight &#34 && &#34\n                 sub = &#34<span foreground='#159040'>%1</span>&#34\n                 cmd = cmd:gsub(&#34( &#34..amp..amp..&#34)&#34, sub)\n                 -- Highlight double quotes\n                 local quote_pos = cmd:find(&#34[^\\\\]&#34..quot)\n                 while quote_pos do\n                     local old_pos = quote_pos\n                     quote_pos = cmd:find(&#34[^\\\\]&#34..quot, old_pos+2)\n                     if quote_pos then\n                         local content = cmd:sub(old_pos+1, quote_pos+6)\n                         cmd = table.concat({\n                                 cmd:sub(1, old_pos),\n                                 &#34<span foreground='#2977CF'>&#34,\n                                 content,\n                                 &#34</span>&#34,\n                                 cmd:sub(quote_pos+7, #cmd)\n                         }, &#34&#34)\n                         quote_pos = cmd:find(&#34[^\\\\]&#34..quot, old_pos+38)\n                     end\n                 end\n                 -- Split the string back to the original content\n                 -- (ignore the recursive and escaped ones)\n                 local pos = cmd:find(&#34ZZZCURSORZZZ&#34)\n                 b,a = cmd:sub(1, pos-1), cmd:sub(pos+12, #cmd)\n                 return b,a\n             end,\n         }\n     end\n",
  "items":[{
      "parameter":"field",
      "params":{
        "1":"color",
        "map":{
          "color":""
        }
      },
      "modifiers":{
        "see":[[]],
        "return":[],
        "param":{
          "1":[],
          "color":[]
        },
        "field":{
          "1":[],
          "color":[]
        }
      },
      "description":"",
      "tags":{
        "see":[]
      },
      "section":"beautiful",
      "inferred":true,
      "subparams":[],
      "summary":"The prompt cursor foreground color.",
      "name":"beautiful.prompt_fg_cursor",
      "type":"beautiful",
      "args":"(color)",
      "kind":"theme variables",
      "lineno":281
    },{
      "parameter":"field",
      "params":{
        "1":"color",
        "map":{
          "color":""
        }
      },
      "modifiers":{
        "see":[[]],
        "return":[],
        "param":{
          "1":[],
          "color":[]
        },
        "field":{
          "1":[],
          "color":[]
        }
      },
      "description":"",
      "tags":{
        "see":[]
      },
      "section":"beautiful",
      "inferred":true,
      "subparams":[],
      "summary":"The prompt cursor background color.",
      "name":"beautiful.prompt_bg_cursor",
      "type":"beautiful",
      "args":"(color)",
      "kind":"theme variables",
      "lineno":286
    },{
      "parameter":"field",
      "params":{
        "1":"string",
        "map":{
          "string":""
        }
      },
      "modifiers":{
        "see":[[]],
        "return":[],
        "param":{
          "1":[],
          "string":[]
        },
        "field":{
          "1":[],
          "string":[]
        }
      },
      "description":"",
      "tags":{
        "see":[]
      },
      "section":"beautiful",
      "inferred":true,
      "subparams":[],
      "summary":"The prompt text font.",
      "name":"beautiful.prompt_font",
      "type":"beautiful",
      "args":"(string)",
      "kind":"theme variables",
      "lineno":291
    },{
      "parameter":"field",
      "params":{
        "1":"command",
        "map":{
          "command":" The command (as entered)."
        }
      },
      "modifiers":{
        "field":{
          "1":{
            "type":"string"
          },
          "command":{
            "type":"string"
          }
        },
        "return":[],
        "param":{
          "1":{
            "type":"string"
          },
          "command":{
            "type":"string"
          }
        },
        "usage":[[]]
      },
      "description":"",
      "tags":[],
      "section":"callback",
      "inferred":true,
      "subparams":[],
      "summary":"The callback function to call with command as argument when finished.",
      "name":"exe_callback",
      "kind":"callback functions prototype",
      "usage":["local function my_exe_cb(command)\n   -- do something\nend\n"],
      "args":"(command)",
      "type":"callback",
      "lineno":501
    },{
      "parameter":"field",
      "params":{
        "1":"command_before_comp",
        "2":"cur_pos_before_comp",
        "3":"ncomp",
        "map":{
          "command_before_comp":" The current command.",
          "ncomp":" The number of the currently completed element.",
          "cur_pos_before_comp":" The current cursor position."
        }
      },
      "modifiers":{
        "field":{
          "1":{
            "type":"string"
          },
          "2":{
            "type":"number"
          },
          "3":{
            "type":"number"
          },
          "command_before_comp":{
            "type":"string"
          },
          "ncomp":{
            "type":"number"
          },
          "cur_pos_before_comp":{
            "type":"number"
          }
        },
        "return":[{
            "type":"string"
          },{
            "type":"number"
          },{
            "type":"number"
          }],
        "param":{
          "1":{
            "type":"string"
          },
          "2":{
            "type":"number"
          },
          "3":{
            "type":"number"
          },
          "command_before_comp":{
            "type":"string"
          },
          "ncomp":{
            "type":"number"
          },
          "cur_pos_before_comp":{
            "type":"number"
          }
        },
        "usage":[[]]
      },
      "description":"",
      "tags":[],
      "section":"callback",
      "inferred":true,
      "subparams":[],
      "summary":"The callback function to get completions.",
      "name":"completion_callback",
      "kind":"callback functions prototype",
      "usage":["local function my_completion_cb(command_before_comp, cur_pos_before_comp, ncomp)\n   return command_before_comp..\"foo\", cur_pos_before_comp+3, 1\nend\n"],
      "args":"(command_before_comp, cur_pos_before_comp, ncomp)",
      "type":"callback",
      "lineno":514
    },{
      "parameter":"field",
      "params":{
        "map":[]
      },
      "modifiers":{
        "return":[],
        "field":[],
        "usage":[[]]
      },
      "description":"",
      "tags":[],
      "section":"callback",
      "inferred":true,
      "subparams":[],
      "summary":"The callback function to always call without arguments, regardless of\n whether the prompt was cancelled.",
      "name":"done_callback",
      "kind":"callback functions prototype",
      "usage":["local function my_done_cb()\n   -- do something\nend\n"],
      "args":"()",
      "type":"callback",
      "lineno":521
    },{
      "parameter":"field",
      "params":{
        "1":"command",
        "map":{
          "command":" The current command."
        }
      },
      "modifiers":{
        "field":{
          "1":{
            "type":"string"
          },
          "command":{
            "type":"string"
          }
        },
        "return":[],
        "param":{
          "1":{
            "type":"string"
          },
          "command":{
            "type":"string"
          }
        },
        "usage":[[]]
      },
      "description":"",
      "tags":[],
      "section":"callback",
      "inferred":true,
      "subparams":[],
      "summary":"The callback function to call with command as argument when a command was\n changed.",
      "name":"changed_callback",
      "kind":"callback functions prototype",
      "usage":["local function my_changed_cb(command)\n   -- do something\nend\n"],
      "args":"(command)",
      "type":"callback",
      "lineno":529
    },{
      "parameter":"field",
      "params":{
        "1":"mod",
        "2":"key",
        "3":"command",
        "map":{
          "mod":" The current modifiers (like \"Control\" or \"Shift\").",
          "key":" The key name.",
          "command":" The current command."
        }
      },
      "modifiers":{
        "field":{
          "1":{
            "type":"table"
          },
          "2":{
            "type":"string"
          },
          "3":{
            "type":"string"
          },
          "mod":{
            "type":"table"
          },
          "key":{
            "type":"string"
          },
          "command":{
            "type":"string"
          }
        },
        "return":[],
        "param":{
          "1":{
            "type":"table"
          },
          "2":{
            "type":"string"
          },
          "3":{
            "type":"string"
          },
          "mod":{
            "type":"table"
          },
          "key":{
            "type":"string"
          },
          "command":{
            "type":"string"
          }
        },
        "usage":[[]]
      },
      "description":"",
      "tags":[],
      "section":"callback",
      "inferred":true,
      "subparams":[],
      "summary":"The callback function to call with mod table, key and command as arguments\n when a key was pressed.",
      "name":"keypressed_callback",
      "kind":"callback functions prototype",
      "usage":["local function my_keypressed_cb(mod, key, command)\n   -- do something\nend\n"],
      "args":"(mod, key, command)",
      "type":"callback",
      "lineno":539
    },{
      "parameter":"field",
      "params":{
        "1":"mod",
        "2":"key",
        "3":"command",
        "map":{
          "mod":" The current modifiers (like \"Control\" or \"Shift\").",
          "key":" The key name.",
          "command":" The current command."
        }
      },
      "modifiers":{
        "field":{
          "1":{
            "type":"table"
          },
          "2":{
            "type":"string"
          },
          "3":{
            "type":"string"
          },
          "mod":{
            "type":"table"
          },
          "key":{
            "type":"string"
          },
          "command":{
            "type":"string"
          }
        },
        "return":[],
        "param":{
          "1":{
            "type":"table"
          },
          "2":{
            "type":"string"
          },
          "3":{
            "type":"string"
          },
          "mod":{
            "type":"table"
          },
          "key":{
            "type":"string"
          },
          "command":{
            "type":"string"
          }
        },
        "usage":[[]]
      },
      "description":"",
      "tags":[],
      "section":"callback",
      "inferred":true,
      "subparams":[],
      "summary":"The callback function to call with mod table, key and command as arguments\n when a key was released.",
      "name":"keyreleased_callback",
      "kind":"callback functions prototype",
      "usage":["local function my_keyreleased_cb(mod, key, command)\n   -- do something\nend\n"],
      "args":"(mod, key, command)",
      "type":"callback",
      "lineno":549
    },{
      "parameter":"field",
      "params":{
        "1":"before_cursor",
        "2":"after_cursor",
        "map":{
          "before_cursor":"",
          "after_cursor":""
        }
      },
      "modifiers":{
        "field":{
          "1":{
            "type":"string"
          },
          "2":{
            "type":"string"
          },
          "before_cursor":{
            "type":"string"
          },
          "after_cursor":{
            "type":"string"
          }
        },
        "return":[],
        "param":{
          "1":{
            "type":"string"
          },
          "2":{
            "type":"string"
          },
          "before_cursor":{
            "type":"string"
          },
          "after_cursor":{
            "type":"string"
          }
        },
        "usage":[[]]
      },
      "description":"",
      "tags":[],
      "section":"callback",
      "inferred":true,
      "subparams":[],
      "summary":"A function to add syntax highlighting to the command.",
      "name":"highlighter",
      "kind":"callback functions prototype",
      "usage":["local function my_highlighter(before_cursor, after_cursor)\n   -- do something\n   return before_cursor, after_cursor\nend\n"],
      "args":"(before_cursor, after_cursor)",
      "type":"callback",
      "lineno":558
    },{
      "parameter":"field",
      "params":{
        "1":"command",
        "map":{
          "command":" The current command."
        }
      },
      "modifiers":{
        "field":{
          "1":{
            "type":"string"
          },
          "command":{
            "type":"string"
          }
        },
        "return":[],
        "param":{
          "1":{
            "type":"string"
          },
          "command":{
            "type":"string"
          }
        },
        "usage":[[]]
      },
      "description":"\n This callback can return many things:\n\n * a modified command\n * `true` If the command is successful (then it won't exit)\n * nothing or `nil` to execute the `exe_callback` and `done_callback` and exit\n\n An optional second return value controls if the prompt should exit or simply\n update the command (from the first return value) and keep going. The default\n is to execute the `exe_callback` and `done_callback` before exiting.\n",
      "tags":[],
      "section":"callback",
      "inferred":true,
      "subparams":[],
      "summary":"A callback when a key combination is triggered.",
      "name":"hook",
      "kind":"callback functions prototype",
      "usage":["local function my_hook(command)\n   return command..\"foo\", false\nend\n"],
      "args":"(command)",
      "type":"callback",
      "lineno":576
    },{
      "parameter":"field",
      "params":{
        "1":"args",
        "2":"textbox",
        "3":"exe_callback",
        "4":"completion_callback",
        "5":"history_path",
        "6":"history_max",
        "7":"done_callback",
        "8":"changed_callback",
        "9":"keypressed_callback",
        "map":{
          "args.done_callback":" The callback function to always call\n without arguments, regardless of whether the prompt was cancelled.",
          "keypressed_callback":" The callback function to call\n   with mod table, key and command as arguments when a key was pressed.\n   [**DEPRECATED**]",
          "exe_callback":" The callback function to call with command as argument\n when finished. [**DEPRECATED**]",
          "args.highlighter":" A function to add syntax highlighting to\n  the command.",
          "completion_callback":" The callback function to call to get completion.\n   [**DEPRECATED**]",
          "args.selectall":"",
          "args.exe_callback":" The callback function to call with command as argument\n when finished.",
          "args.changed_callback":" The callback function to call\n with command as argument when a command was changed.",
          "changed_callback":" The callback function to call\n with command as argument when a command was changed. [**DEPRECATED**]",
          "args.autoexec":"",
          "args.font":"",
          "history_max":" Set the maximum entries in history\n file, 50 by default [**DEPRECATED**]",
          "args.textbox":" The textbox to use for the prompt.",
          "args.keyreleased_callback":" The callback function to call\n   with mod table, key and command as arguments when a key was pressed.",
          "args.completion_callback":" The callback function to call to get completion.",
          "textbox":" The textbox to use for the prompt. [**DEPRECATED**]",
          "history_path":" File path where the history should be\n saved, set nil to disable history [**DEPRECATED**]",
          "args.hooks":" The \"hooks\" argument uses a syntax similar to\n   `awful.key`.  It will call a function for the matching modifiers + key.\n   It receives the command (widget text/input) as an argument.\n   If the callback returns a command, this will be passed to the\n   `exe_callback`, otherwise nothing gets executed by default, and the hook\n   needs to handle it.\n     hooks = {\n       -- Apply startup notification properties with Shift-Return.\n       {{\"Shift\"  }, \"Return\", function(command)\n         awful.screen.focused().mypromptbox:spawn_and_handle_error(\n           command, {floating=true})\n       end},\n       -- Override default behavior of \"Return\": launch commands prefixed\n       -- with \":\" in a terminal.\n       {{}, \"Return\", function(command)\n         if command:sub(1,1) == \":\" then\n           return terminal .. ' -e ' .. command:sub(2)\n         end\n         return command\n       end}\n     }",
          "args.keypressed_callback":" The callback function to call\n   with mod table, key and command as arguments when a key was pressed.",
          "args.history_path":" File path where the history should be\n saved, set nil to disable history",
          "done_callback":" The callback function to always call\n without arguments, regardless of whether the prompt was cancelled.\n  [**DEPRECATED**]",
          "args.fg_cursor":"",
          "args.prompt":"",
          "args":" A table with optional arguments",
          "args.bg_cursor":"",
          "args.history_max":" Set the maximum entries in history\n file, 50 by default",
          "args.text":"",
          "args.ul_cursor":""
        }
      },
      "modifiers":{
        "see":[[]],
        "return":[],
        "param":{
          "1":{
            "optchain":"{}",
            "type":"table",
            "opt":"{}"
          },
          "2":{
            "optchain":true,
            "type":"gears.color",
            "opt":true
          },
          "3":{
            "optchain":true,
            "type":"gears.color",
            "opt":true
          },
          "4":{
            "optchain":true,
            "type":"gears.color",
            "opt":true
          },
          "5":{
            "optchain":true,
            "type":"widget",
            "opt":true
          },
          "6":{
            "optchain":true,
            "type":"string",
            "opt":true
          },
          "7":{
            "optchain":true,
            "type":"boolean",
            "opt":true
          },
          "8":{
            "optchain":true,
            "type":"string",
            "opt":true
          },
          "9":{
            "optchain":true,
            "type":"boolean",
            "opt":true
          },
          "10":{
            "type":"widget"
          },
          "11":{
            "type":"function",
            "opt":true
          },
          "12":{
            "type":"function"
          },
          "13":{
            "type":"function"
          },
          "14":{
            "type":"string",
            "opt":true
          },
          "15":{
            "type":"function",
            "opt":true
          },
          "16":{
            "type":"function",
            "opt":true
          },
          "17":{
            "type":"function",
            "opt":true
          },
          "18":{
            "type":"function",
            "opt":true
          },
          "19":{
            "type":"function",
            "opt":true
          },
          "20":{
            "type":"table",
            "opt":true
          },
          "21":[],
          "22":[],
          "23":[],
          "24":{
            "opt":true
          },
          "25":{
            "opt":true
          },
          "26":{
            "opt":true
          },
          "27":{
            "opt":true
          },
          "28":{
            "opt":true
          },
          "args.done_callback":{
            "type":"function",
            "opt":true
          },
          "keypressed_callback":{
            "opt":true
          },
          "exe_callback":[],
          "args.highlighter":{
            "type":"function",
            "opt":true
          },
          "completion_callback":[],
          "args.selectall":{
            "optchain":true,
            "type":"boolean",
            "opt":true
          },
          "args.exe_callback":{
            "type":"function"
          },
          "args.changed_callback":{
            "type":"function",
            "opt":true
          },
          "changed_callback":{
            "opt":true
          },
          "args.autoexec":{
            "optchain":true,
            "type":"boolean",
            "opt":true
          },
          "args.font":{
            "optchain":true,
            "type":"string",
            "opt":true
          },
          "history_max":{
            "opt":true
          },
          "args.textbox":{
            "type":"widget"
          },
          "args.keyreleased_callback":{
            "type":"function",
            "opt":true
          },
          "args.completion_callback":{
            "type":"function"
          },
          "textbox":[],
          "history_path":{
            "opt":true
          },
          "args.hooks":{
            "type":"table",
            "opt":true
          },
          "args.keypressed_callback":{
            "type":"function",
            "opt":true
          },
          "args.history_path":{
            "type":"string",
            "opt":true
          },
          "done_callback":{
            "opt":true
          },
          "args.fg_cursor":{
            "optchain":true,
            "type":"gears.color",
            "opt":true
          },
          "args.prompt":{
            "optchain":true,
            "type":"widget",
            "opt":true
          },
          "args":{
            "optchain":"{}",
            "type":"table",
            "opt":"{}"
          },
          "args.bg_cursor":{
            "optchain":true,
            "type":"gears.color",
            "opt":true
          },
          "args.history_max":{
            "type":"function",
            "opt":true
          },
          "args.text":{
            "optchain":true,
            "type":"string",
            "opt":true
          },
          "args.ul_cursor":{
            "optchain":true,
            "type":"gears.color",
            "opt":true
          }
        },
        "field":{
          "1":{
            "optchain":"{}",
            "type":"table",
            "opt":"{}"
          },
          "2":{
            "optchain":true,
            "type":"gears.color",
            "opt":true
          },
          "3":{
            "optchain":true,
            "type":"gears.color",
            "opt":true
          },
          "4":{
            "optchain":true,
            "type":"gears.color",
            "opt":true
          },
          "5":{
            "optchain":true,
            "type":"widget",
            "opt":true
          },
          "6":{
            "optchain":true,
            "type":"string",
            "opt":true
          },
          "7":{
            "optchain":true,
            "type":"boolean",
            "opt":true
          },
          "8":{
            "optchain":true,
            "type":"string",
            "opt":true
          },
          "9":{
            "optchain":true,
            "type":"boolean",
            "opt":true
          },
          "10":{
            "type":"widget"
          },
          "11":{
            "type":"function",
            "opt":true
          },
          "12":{
            "type":"function"
          },
          "13":{
            "type":"function"
          },
          "14":{
            "type":"string",
            "opt":true
          },
          "15":{
            "type":"function",
            "opt":true
          },
          "16":{
            "type":"function",
            "opt":true
          },
          "17":{
            "type":"function",
            "opt":true
          },
          "18":{
            "type":"function",
            "opt":true
          },
          "19":{
            "type":"function",
            "opt":true
          },
          "20":{
            "type":"table",
            "opt":true
          },
          "21":[],
          "22":[],
          "23":[],
          "24":{
            "opt":true
          },
          "25":{
            "opt":true
          },
          "26":{
            "opt":true
          },
          "27":{
            "opt":true
          },
          "28":{
            "opt":true
          },
          "args.done_callback":{
            "type":"function",
            "opt":true
          },
          "keypressed_callback":{
            "opt":true
          },
          "exe_callback":[],
          "args.highlighter":{
            "type":"function",
            "opt":true
          },
          "completion_callback":[],
          "args.selectall":{
            "optchain":true,
            "type":"boolean",
            "opt":true
          },
          "args.exe_callback":{
            "type":"function"
          },
          "args.changed_callback":{
            "type":"function",
            "opt":true
          },
          "changed_callback":{
            "opt":true
          },
          "args.autoexec":{
            "optchain":true,
            "type":"boolean",
            "opt":true
          },
          "args.font":{
            "optchain":true,
            "type":"string",
            "opt":true
          },
          "history_max":{
            "opt":true
          },
          "args.textbox":{
            "type":"widget"
          },
          "args.keyreleased_callback":{
            "type":"function",
            "opt":true
          },
          "args.completion_callback":{
            "type":"function"
          },
          "textbox":[],
          "history_path":{
            "opt":true
          },
          "args.hooks":{
            "type":"table",
            "opt":true
          },
          "args.keypressed_callback":{
            "type":"function",
            "opt":true
          },
          "args.history_path":{
            "type":"string",
            "opt":true
          },
          "done_callback":{
            "opt":true
          },
          "args.fg_cursor":{
            "optchain":true,
            "type":"gears.color",
            "opt":true
          },
          "args.prompt":{
            "optchain":true,
            "type":"widget",
            "opt":true
          },
          "args":{
            "optchain":"{}",
            "type":"table",
            "opt":"{}"
          },
          "args.bg_cursor":{
            "optchain":true,
            "type":"gears.color",
            "opt":true
          },
          "args.history_max":{
            "type":"function",
            "opt":true
          },
          "args.text":{
            "optchain":true,
            "type":"string",
            "opt":true
          },
          "args.ul_cursor":{
            "optchain":true,
            "type":"gears.color",
            "opt":true
          }
        }
      },
      "description":"",
      "tags":{
        "see":[]
      },
      "section":"staticfct",
      "inferred":true,
      "subparams":{
        "args":["args.fg_cursor","args.bg_cursor","args.ul_cursor","args.prompt","args.text","args.selectall","args.font","args.autoexec","args.textbox","args.highlighter","args.exe_callback","args.completion_callback","args.history_path","args.history_max","args.done_callback","args.changed_callback","args.keypressed_callback","args.keyreleased_callback","args.hooks"]
      },
      "summary":"Run a prompt in a box.",
      "name":"awful.prompt.run",
      "type":"staticfct",
      "args":"([args={}[, textbox[, exe_callback[, completion_callback[, history_path[, history_max[, done_callback[, changed_callback[, keypressed_callback]]]]]]]]])",
      "kind":"static module functions",
      "lineno":645
    }],
  "type":"module",
  "file":"/home/cji/portless/awesome/build/lib/awful/prompt.lua",
  "package":"awful",
  "tags":{
    "author":["Julien Danjou &lt;julien@danjou.info&gt;"],
    "copyright":"2008 Julien Danjou"
  },
  "lineno":276
}