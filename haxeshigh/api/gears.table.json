{
  "inferred":true,
  "kind":"utility_libraries",
  "mod_name":"gears.table",
  "summary":"Table module for gears.",
  "sections":{
    "by_name":[]
  },
  "name":"gears.table",
  "modifiers":{
    "usage":[[]]
  },
  "description":"\n\n Examples\n =======\n\n Using `cycle_value`, you can cycle through values in a table.\n When the end of the table is reached, `cycle_value` loops around to the beginning.\n \n\n\n**Usage example output**:\n\n    b\n    c\n    d\n    e\n    a\n\n",
  "items":[{
      "inferred":true,
      "subparams":[],
      "parameter":"field",
      "params":{
        "1":"...",
        "map":{
          "...":" Tables to join."
        }
      },
      "summary":"Join all tables given as arguments.",
      "name":"join",
      "modifiers":{
        "return":[{
            "type":"table"
          }],
        "param":{
          "1":{
            "type":"table"
          },
          "...":{
            "type":"table"
          }
        },
        "field":{
          "1":{
            "type":"table"
          },
          "...":{
            "type":"table"
          }
        }
      },
      "description":"\n This will iterate over all tables and insert their entries into a new table.",
      "type":"staticfct",
      "section":"staticfct",
      "kind":"static module functions",
      "args":"(...)",
      "tags":[],
      "lineno":43
    },{
      "inferred":true,
      "subparams":[],
      "parameter":"field",
      "params":{
        "1":"target",
        "2":"source",
        "3":"raw",
        "map":{
          "target":" The target table. Values from `source` will be copied\n   into this table.",
          "raw":" If `true`, values will be assigned with `rawset`.\n   This will bypass metamethods on `target`.",
          "source":" The source table. Its values will be copied into\n   `target`."
        }
      },
      "summary":"Override elements in the target table with values from the source table.",
      "name":"crush",
      "modifiers":{
        "return":[{
            "type":"table"
          }],
        "param":{
          "1":{
            "type":"table"
          },
          "2":{
            "type":"table"
          },
          "3":{
            "optchain":"false",
            "type":"bool",
            "opt":"false"
          },
          "target":{
            "type":"table"
          },
          "raw":{
            "optchain":"false",
            "type":"bool",
            "opt":"false"
          },
          "source":{
            "type":"table"
          }
        },
        "field":{
          "1":{
            "type":"table"
          },
          "2":{
            "type":"table"
          },
          "3":{
            "optchain":"false",
            "type":"bool",
            "opt":"false"
          },
          "target":{
            "type":"table"
          },
          "raw":{
            "optchain":"false",
            "type":"bool",
            "opt":"false"
          },
          "source":{
            "type":"table"
          }
        }
      },
      "description":"\n\n Note that this method doesn't copy entries found in `__index`.\n Nested tables are copied by reference and not recursed into.\n",
      "type":"staticfct",
      "section":"staticfct",
      "kind":"static module functions",
      "args":"(target, source[, raw=false])",
      "tags":[],
      "lineno":73
    },{
      "inferred":true,
      "subparams":[],
      "parameter":"field",
      "params":{
        "1":"t",
        "map":{
          "t":" A potentially sparse table."
        }
      },
      "summary":"Pack all elements with an integer key into a new table.",
      "name":"from_sparse",
      "modifiers":{
        "return":[{
            "type":"table"
          }],
        "param":{
          "1":{
            "type":"table"
          },
          "t":{
            "type":"table"
          }
        },
        "field":{
          "1":{
            "type":"table"
          },
          "t":{
            "type":"table"
          }
        }
      },
      "description":"\n While both lua and luajit implement __len over sparse\n tables, the standard defines it as an implementation\n detail.\n\n This function removes any entries with non-numeric keys.\n",
      "type":"staticfct",
      "section":"staticfct",
      "kind":"static module functions",
      "args":"(t)",
      "tags":[],
      "lineno":97
    },{
      "inferred":true,
      "subparams":[],
      "parameter":"field",
      "params":{
        "1":"t",
        "2":"item",
        "map":{
          "item":" The item to look for in values of the table.",
          "t":" The table."
        }
      },
      "summary":"Check if a table has an item and return its key.",
      "name":"hasitem",
      "modifiers":{
        "return":[{
            "1":true,
            "type":"string|number"
          },{
            "type":"nil",
            "2":true
          }],
        "param":{
          "1":{
            "type":"table"
          },
          "2":[],
          "item":[],
          "t":{
            "type":"table"
          }
        },
        "field":{
          "1":{
            "type":"table"
          },
          "2":[],
          "item":[],
          "t":{
            "type":"table"
          }
        }
      },
      "description":"",
      "type":"staticfct",
      "section":"staticfct",
      "kind":"static module functions",
      "args":"(t, item)",
      "tags":[],
      "lineno":122
    },{
      "inferred":true,
      "subparams":[],
      "parameter":"field",
      "params":{
        "1":"t",
        "2":"matcher",
        "3":"ordered",
        "4":"max",
        "map":{
          "max":" The maximum number of entries to find.",
          "ordered":" If true, only look for continuous\n   numeric keys.",
          "matcher":" A function taking the key and value as arguments and\n   returning a boolean.",
          "t":" The table."
        }
      },
      "summary":"Get all matching table keys for a `matcher` function.",
      "name":"find_keys",
      "modifiers":{
        "return":[{
            "type":"table|nil"
          }],
        "param":{
          "1":{
            "type":"table"
          },
          "2":{
            "type":"function"
          },
          "3":{
            "optchain":"false",
            "type":"boolean",
            "opt":"false"
          },
          "4":{
            "optchain":"nil",
            "type":"number",
            "opt":"nil"
          },
          "max":{
            "optchain":"nil",
            "type":"number",
            "opt":"nil"
          },
          "ordered":{
            "optchain":"false",
            "type":"boolean",
            "opt":"false"
          },
          "matcher":{
            "type":"function"
          },
          "t":{
            "type":"table"
          }
        },
        "field":{
          "1":{
            "type":"table"
          },
          "2":{
            "type":"function"
          },
          "3":{
            "optchain":"false",
            "type":"boolean",
            "opt":"false"
          },
          "4":{
            "optchain":"nil",
            "type":"number",
            "opt":"nil"
          },
          "max":{
            "optchain":"nil",
            "type":"number",
            "opt":"nil"
          },
          "ordered":{
            "optchain":"false",
            "type":"boolean",
            "opt":"false"
          },
          "matcher":{
            "type":"function"
          },
          "t":{
            "type":"table"
          }
        }
      },
      "description":"",
      "type":"staticfct",
      "section":"staticfct",
      "kind":"static module functions",
      "args":"(t, matcher[, ordered=false[, max=nil]])",
      "tags":[],
      "lineno":141
    },{
      "inferred":true,
      "subparams":[],
      "parameter":"field",
      "params":{
        "1":"t",
        "2":"matcher",
        "3":"ordered",
        "map":{
          "ordered":" If true, only look for continuous\n   numeric keys.",
          "matcher":" A function taking the key and value as arguments and\n   returning a boolean.",
          "t":" The table."
        }
      },
      "summary":"Find the first key that matches a function.",
      "name":"find_first_key",
      "modifiers":{
        "return":[[]],
        "param":{
          "1":{
            "type":"table"
          },
          "2":{
            "type":"function"
          },
          "3":{
            "optchain":"false",
            "type":"boolean",
            "opt":"false"
          },
          "ordered":{
            "optchain":"false",
            "type":"boolean",
            "opt":"false"
          },
          "matcher":{
            "type":"function"
          },
          "t":{
            "type":"table"
          }
        },
        "field":{
          "1":{
            "type":"table"
          },
          "2":{
            "type":"function"
          },
          "3":{
            "optchain":"false",
            "type":"boolean",
            "opt":"false"
          },
          "ordered":{
            "optchain":"false",
            "type":"boolean",
            "opt":"false"
          },
          "matcher":{
            "type":"function"
          },
          "t":{
            "type":"table"
          }
        }
      },
      "description":"",
      "type":"staticfct",
      "section":"staticfct",
      "kind":"static module functions",
      "args":"(t, matcher[, ordered=false])",
      "tags":[],
      "lineno":167
    },{
      "inferred":true,
      "subparams":[],
      "parameter":"field",
      "params":{
        "1":"t",
        "map":{
          "t":" The table for which the keys to get."
        }
      },
      "summary":"Get a sorted table with all keys from a table.",
      "name":"keys",
      "modifiers":{
        "return":[{
            "type":"table"
          }],
        "param":{
          "1":{
            "type":"table"
          },
          "t":{
            "type":"table"
          }
        },
        "field":{
          "1":{
            "type":"table"
          },
          "t":{
            "type":"table"
          }
        }
      },
      "description":"",
      "type":"staticfct",
      "section":"staticfct",
      "kind":"static module functions",
      "args":"(t)",
      "tags":[],
      "lineno":179
    },{
      "parameter":"field",
      "params":{
        "1":"t",
        "map":{
          "t":" The table for which to count the keys."
        }
      },
      "modifiers":{
        "field":{
          "1":{
            "type":"table"
          },
          "t":{
            "type":"table"
          }
        },
        "return":[{
            "type":"number"
          }],
        "param":{
          "1":{
            "type":"table"
          },
          "t":{
            "type":"table"
          }
        },
        "usage":[[]]
      },
      "description":"\n\n This is functionally equivalent, but faster than `#gears.table.keys(t)`.\n\n \n\n\n**Usage example output**:\n\n    The table has 4 keys\n\n",
      "tags":[],
      "section":"staticfct",
      "inferred":true,
      "subparams":[],
      "summary":"Get the number of keys in a table, both integer and string indicies.",
      "name":"count_keys",
      "kind":"static module functions",
      "usage":["local tab = { 1, nil, &#34a&#34, &#34b&#34, foo = &#34bar&#34 }\nlocal count = gears.table.count_keys(tab)\nprint(&#34The table has &#34 .. count .. &#34 keys&#34)\n"],
      "args":"(t)",
      "type":"staticfct",
      "lineno":210
    },{
      "inferred":true,
      "subparams":[],
      "parameter":"field",
      "params":{
        "1":"t",
        "2":"...",
        "map":{
          "...":" The types to look for.",
          "t":" The table to retrieve the keys for."
        }
      },
      "summary":"Filter a table's keys for certain content type.",
      "name":"keys_filter",
      "modifiers":{
        "return":[{
            "type":"table"
          }],
        "param":{
          "1":{
            "type":"table"
          },
          "2":{
            "type":"string"
          },
          "...":{
            "type":"string"
          },
          "t":{
            "type":"table"
          }
        },
        "field":{
          "1":{
            "type":"table"
          },
          "2":{
            "type":"string"
          },
          "...":{
            "type":"string"
          },
          "t":{
            "type":"table"
          }
        }
      },
      "description":"",
      "type":"staticfct",
      "section":"staticfct",
      "kind":"static module functions",
      "args":"(t, ...)",
      "tags":[],
      "lineno":224
    },{
      "inferred":true,
      "subparams":[],
      "parameter":"field",
      "params":{
        "1":"t",
        "map":{
          "t":" The table to reverse."
        }
      },
      "summary":"Reverse a table.",
      "name":"reverse",
      "modifiers":{
        "return":[{
            "type":"table"
          }],
        "param":{
          "1":{
            "type":"table"
          },
          "t":{
            "type":"table"
          }
        },
        "field":{
          "1":{
            "type":"table"
          },
          "t":{
            "type":"table"
          }
        }
      },
      "description":"",
      "type":"staticfct",
      "section":"staticfct",
      "kind":"static module functions",
      "args":"(t)",
      "tags":[],
      "lineno":243
    },{
      "inferred":true,
      "subparams":[],
      "parameter":"field",
      "params":{
        "1":"t",
        "2":"deep",
        "map":{
          "deep":" If `true`, recurse into nested tables to create\n   a deep clone.",
          "t":" The table to clone."
        }
      },
      "summary":"Clone a table.",
      "name":"clone",
      "modifiers":{
        "return":[{
            "type":"table"
          }],
        "param":{
          "1":{
            "type":"table"
          },
          "2":{
            "optchain":"true",
            "type":"bool",
            "opt":"true"
          },
          "deep":{
            "optchain":"true",
            "type":"bool",
            "opt":"true"
          },
          "t":{
            "type":"table"
          }
        },
        "field":{
          "1":{
            "type":"table"
          },
          "2":{
            "optchain":"true",
            "type":"bool",
            "opt":"true"
          },
          "deep":{
            "optchain":"true",
            "type":"bool",
            "opt":"true"
          },
          "t":{
            "type":"table"
          }
        }
      },
      "description":"",
      "type":"staticfct",
      "section":"staticfct",
      "kind":"static module functions",
      "args":"(t[, deep=true])",
      "tags":[],
      "lineno":265
    },{
      "inferred":true,
      "subparams":[],
      "parameter":"field",
      "params":{
        "1":"t",
        "2":"value",
        "3":"step_size",
        "4":"filter",
        "5":"start_at",
        "map":{
          "value":" The start value. Must be an element of the input table `t`.",
          "t":" The input table.",
          "step_size":" The amount to increment the index by.\n   When this is negative, the function will cycle through the table backwards.",
          "start_at":" Where to start the lookup from.",
          "filter":" An optional filter function. It receives a\n   value from the table as parameter and should return a boolean. If it\n   returns `false`, the value is skipped and `cycle_value` tries the next one."
        }
      },
      "summary":"Get the next (or previous) value from a table and cycle if necessary.",
      "name":"cycle_value",
      "modifiers":{
        "return":[[],{
            "type":"number|nil"
          }],
        "param":{
          "1":{
            "type":"table"
          },
          "2":[],
          "3":{
            "optchain":"1",
            "type":"number",
            "opt":"1"
          },
          "4":{
            "optchain":"nil",
            "type":"function",
            "opt":"nil"
          },
          "5":{
            "optchain":"1",
            "type":"number",
            "opt":"1"
          },
          "value":[],
          "t":{
            "type":"table"
          },
          "step_size":{
            "optchain":"1",
            "type":"number",
            "opt":"1"
          },
          "start_at":{
            "optchain":"1",
            "type":"number",
            "opt":"1"
          },
          "filter":{
            "optchain":"nil",
            "type":"function",
            "opt":"nil"
          }
        },
        "field":{
          "1":{
            "type":"table"
          },
          "2":[],
          "3":{
            "optchain":"1",
            "type":"number",
            "opt":"1"
          },
          "4":{
            "optchain":"nil",
            "type":"function",
            "opt":"nil"
          },
          "5":{
            "optchain":"1",
            "type":"number",
            "opt":"1"
          },
          "value":[],
          "t":{
            "type":"table"
          },
          "step_size":{
            "optchain":"1",
            "type":"number",
            "opt":"1"
          },
          "start_at":{
            "optchain":"1",
            "type":"number",
            "opt":"1"
          },
          "filter":{
            "optchain":"nil",
            "type":"function",
            "opt":"nil"
          }
        }
      },
      "description":"\n\n If the table contains the same value multiple type (aka, is not a set), the\n `first_index` has to be specified.\n",
      "type":"staticfct",
      "section":"staticfct",
      "kind":"static module functions",
      "args":"(t, value[, step_size=1[, filter=nil[, start_at=1]]])",
      "tags":[],
      "lineno":295
    },{
      "inferred":true,
      "subparams":{
        "func":["func.item"]
      },
      "parameter":"field",
      "params":{
        "1":"t",
        "2":"filter",
        "3":"start",
        "map":{
          "func.item":" The item to filter.",
          "filter":" A function that returns true to indicate a positive\n   match.",
          "start":" Index to start iterating from.\n   Default is 1 (=> start of the table).",
          "t":" The table to iterate."
        }
      },
      "summary":"Iterate over a table.",
      "name":"iterate",
      "modifiers":{
        "return":[{
            "type":"func"
          }],
        "param":{
          "1":{
            "type":"table"
          },
          "2":{
            "type":"func"
          },
          "3":[],
          "4":{
            "type":"int",
            "opt":"1"
          },
          "func.item":[],
          "filter":{
            "type":"func"
          },
          "start":{
            "type":"int",
            "opt":"1"
          },
          "t":{
            "type":"table"
          }
        },
        "field":{
          "1":{
            "type":"table"
          },
          "2":{
            "type":"func"
          },
          "3":[],
          "4":{
            "type":"int",
            "opt":"1"
          },
          "func.item":[],
          "filter":{
            "type":"func"
          },
          "start":{
            "type":"int",
            "opt":"1"
          },
          "t":{
            "type":"table"
          }
        }
      },
      "description":"\n\n Returns an iterator to cycle through all elements of a table that match a\n given criteria, starting from the first element or the given index.\n",
      "type":"staticfct",
      "section":"staticfct",
      "kind":"static module functions",
      "args":"(t, filter, start)",
      "tags":[],
      "lineno":328
    },{
      "inferred":true,
      "subparams":[],
      "parameter":"field",
      "params":{
        "1":"target",
        "2":"source",
        "map":{
          "target":" The target table. Values from `source` will be copied\n   into this table.",
          "source":" The source table. Its values will be copied into\n   `target`."
        }
      },
      "summary":"Merge items from the source table into the target table.",
      "name":"merge",
      "modifiers":{
        "return":[{
            "type":"table"
          }],
        "param":{
          "1":{
            "type":"table"
          },
          "2":{
            "type":"table"
          },
          "target":{
            "type":"table"
          },
          "source":{
            "type":"table"
          }
        },
        "field":{
          "1":{
            "type":"table"
          },
          "2":{
            "type":"table"
          },
          "target":{
            "type":"table"
          },
          "source":{
            "type":"table"
          }
        }
      },
      "description":"\n\n Note that this only considers the array part of `source` (same semantics\n as `ipairs`).\n Nested tables are copied by reference and not recursed into.\n",
      "type":"staticfct",
      "section":"staticfct",
      "kind":"static module functions",
      "args":"(target, source)",
      "tags":[],
      "lineno":355
    },{
      "parameter":"field",
      "params":{
        "1":"target",
        "2":"new",
        "3":"identifier",
        "4":"merger",
        "map":{
          "target":" The table to modify.",
          "identifier":" A function which take the table entry (either\n  from the `target` or `new` table) and return an unique identifier. The\n  identifier type isn't important as long as `==` works to compare them.",
          "merger":" A function takes the entry to modify as first\n  parameter and the new entry as second. The function must return the merged\n  value. If none is provided, there is no attempt to merge the content.",
          "new":" The table which contains the new content."
        }
      },
      "modifiers":{
        "field":{
          "1":{
            "type":"table"
          },
          "2":{
            "type":"table"
          },
          "3":{
            "type":"function"
          },
          "4":{
            "optchain":true,
            "type":"function",
            "opt":true
          },
          "target":{
            "type":"table"
          },
          "identifier":{
            "type":"function"
          },
          "merger":{
            "optchain":true,
            "type":"function",
            "opt":true
          },
          "new":{
            "type":"table"
          }
        },
        "return":[{
            "type":"table"
          },{
            "type":"table"
          },{
            "type":"table"
          },{
            "type":"table"
          }],
        "param":{
          "1":{
            "type":"table"
          },
          "2":{
            "type":"table"
          },
          "3":{
            "type":"function"
          },
          "4":{
            "optchain":true,
            "type":"function",
            "opt":true
          },
          "target":{
            "type":"table"
          },
          "identifier":{
            "type":"function"
          },
          "merger":{
            "optchain":true,
            "type":"function",
            "opt":true
          },
          "new":{
            "type":"table"
          }
        },
        "usage":[[]]
      },
      "description":"\n\n Compared to `gears.table.merge`, this version is intended to work using both\n an `identifier` function and a `merger` function. This works only for\n indexed tables.\n\n The main use case is when changing the table reference is not possible or\n when the `target` contains additional content that must be kept.\n\n Note that calling this function involve a lot of looping and should not be\n done often.\n",
      "tags":[],
      "section":"staticfct",
      "inferred":true,
      "subparams":[],
      "summary":"Update the `target` table with entries from the `new` table.",
      "name":"diff_merge",
      "kind":"static module functions",
      "usage":["local output, added, removed, updated = gears.table.diff_merge(\n    output, input, function(v) return v.id end, gears.table.crush,\n)\n"],
      "args":"(target, new, identifier[, merger])",
      "type":"staticfct",
      "lineno":390
    },{
      "inferred":true,
      "subparams":[],
      "parameter":"field",
      "params":{
        "1":"f",
        "2":"tbl",
        "map":{
          "tbl":" The container table whose values will be operated on.",
          "f":" The function to be applied to each value in the table."
        }
      },
      "summary":"Map a function to a table.",
      "name":"map",
      "modifiers":{
        "return":[{
            "type":"table"
          }],
        "param":{
          "1":{
            "type":"function"
          },
          "2":{
            "type":"table"
          },
          "tbl":{
            "type":"table"
          },
          "f":{
            "type":"function"
          }
        },
        "field":{
          "1":{
            "type":"function"
          },
          "2":{
            "type":"table"
          },
          "tbl":{
            "type":"table"
          },
          "f":{
            "type":"function"
          }
        }
      },
      "description":"\n\n The function is applied to each value in the table, returning a modified\n table.\n",
      "type":"staticfct",
      "section":"staticfct",
      "kind":"static module functions",
      "args":"(f, tbl)",
      "tags":[],
      "lineno":453
    }],
  "type":"utillib",
  "usage":["local res = {&#34a&#34, &#34b&#34, &#34c&#34, &#34d&#34, &#34e&#34}\nfor i=1, #res do\n    local k = res[i]\n    local v = gears.table.cycle_value(res, k, 1)\n    print(v)\nend\n"],
  "file":"/home/cji/portless/awesome/build/lib/gears/table.lua",
  "package":"",
  "tags":[],
  "lineno":33
}