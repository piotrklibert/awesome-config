{
  "inferred":true,
  "kind":"popups_and_bars",
  "mod_name":"awful.wallpaper",
  "summary":"Allows to use the wibox widget system to draw the wallpaper.",
  "sections":{
    "by_name":[]
  },
  "name":"awful.wallpaper",
  "modifiers":{
    "copyright":[],
    "author":[[]]
  },
  "description":"\n\n Rather than simply having a function to set an image\n (stretched, centered or tiled) like most wallpaper tools, this module\n leverage the full widget system to draw the wallpaper. Note that the result\n is **not** interactive. If you want an interactive wallpaper, better use\n a `wibox` object with the `below` property set to `true` and maximized\n using `awful.placement.maximized`.\n\n It is possible to create an `awful.wallpaper` object from any places, but\n it is recommanded to do it from the `request::wallpaper` signal handler.\n That signal is called everytime something which could affect the wallpaper\n rendering changes, such as new screens.\n\n Single image\n ============\n\n This is the default `rc.lua` wallpaper format. It fills the whole screen\n and stretches the image while keeping the aspect ratio.\n\n\n\n![Usage example](../images/AUTOGEN_awful_wallpaper_mazimized1.svg)\n\n \n    awful.wallpaper {\n        screen = s,\n        widget = {\n            {\n                image  = beautiful.wallpaper,\n                resize = true,\n                widget = wibox.widget.imagebox,\n            },\n            valign = &#34center&#34,\n            halign = &#34center&#34,\n            tiled  = false,\n            widget = wibox.container.tile,\n        }\n    }\n\n If the image aspect ratio doesn't match, the `bg` property can be used to\n fill the empty area:\n\n\n\n![Usage example](../images/AUTOGEN_awful_wallpaper_mazimized2.svg)\n\n \n    awful.wallpaper {\n        screen = s,\n        bg     = &#34#0000ff&#34,\n        widget = {\n            {\n                image  = beautiful.wallpaper,\n                resize = true,\n                widget = wibox.widget.imagebox,\n            },\n            valign = &#34center&#34,\n            halign = &#34center&#34,\n            tiled  = false,\n            widget = wibox.container.tile,\n        }\n    }\n\n It is also possible to stretch the image:\n\n\n\n![Usage example](../images/AUTOGEN_awful_wallpaper_mazimized3.svg)\n\n \n    awful.wallpaper {\n        screen = s,\n        widget = {\n             horizontal_fit_policy = &#34fit&#34,\n             vertical_fit_policy   = &#34fit&#34,\n             image                 = beautiful.wallpaper,\n             widget                = wibox.widget.imagebox,\n         },\n    }\n\n Finally, it is also possible to use simpler \"branding\" in a corner using\n `awful.placement`:\n\n\n\n![Usage example](../images/AUTOGEN_awful_wallpaper_corner1.svg)\n\n \n    awful.wallpaper {\n        screen = s,\n        bg     = &#34#000000&#34,\n        widget = {\n            {\n                {\n                    image  = beautiful.awesome_icon,\n                    resize = false,\n                    point  = awful.placement.bottom_right,\n                    widget = wibox.widget.imagebox,\n                },\n                widget = wibox.layout.manual,\n            },\n            margins = 5,\n            widget  = wibox.container.margin\n        }\n    }\n\n Tiled\n =====\n\n This example tiles an image:\n\n\n\n![Usage example](../images/AUTOGEN_awful_wallpaper_tiled1.svg)\n\n \n    awful.wallpaper {\n        screen = s,\n        bg     = &#34#0000ff&#34,\n        widget = {\n            {\n                image  = beautiful.awesome_icon,\n                resize = false,\n                widget = wibox.widget.imagebox,\n            },\n            horizontal_spacing = 5,\n            vertical_spacing   = 5,\n            valign             = &#34top&#34,\n            halign             = &#34left&#34,\n            tiled              = true,\n            widget             = wibox.container.tile,\n        }\n    }\n\n This one tiles a shape using the `wibox.widget.separator` widget:\n\n\n\n![Usage example](../images/AUTOGEN_awful_wallpaper_tiled2.svg)\n\n \n    awful.wallpaper {\n        screen = s,\n        bg     = &#34#0000ff&#34,\n        widget = {\n            {\n                shape         = gears.shape.star,\n                forced_width  = 30,\n                forced_height = 30,\n                widget        = wibox.widget.separator,\n            },\n            horizontal_spacing = 5,\n            vertical_spacing   = 5,\n            vertical_crop      = true,\n            horizontal_crop    = true,\n            valign             = &#34center&#34,\n            halign             = &#34center&#34,\n            tiled              = true,\n            widget             = wibox.container.tile,\n        }\n    }\n\n See the `wibox.container.tile` for more advanced tiling configuration\n options.\n\n Solid colors and gradients\n ==========================\n\n Solid colors can be set using the `bg` property mentionned above. It\n is also possible to set gradients:\n\n\n\n![Usage example](../images/AUTOGEN_awful_wallpaper_gradient1.svg)\n\n \n    awful.wallpaper {\n        screen = s,\n        bg     = {\n            type  = &#34linear&#34 ,\n            from  = { 0, 0  },\n            to    = { 0, 240 },\n            stops = {\n                { 0, &#34#0000ff&#34 },\n                { 1, &#34#ff0000&#34 }\n            }\n         }\n    }\n\n\n\n![Usage example](../images/AUTOGEN_awful_wallpaper_gradient2.svg)\n\n \n    awful.wallpaper {\n        screen = s,\n        bg     = {\n            type = &#34radial&#34,\n            from  = { 160, 98, 20  },\n            to    = { 160, 98, 120 },\n            stops = {\n                { 0  , &#34#ff0000&#34 },\n                { 0.5, &#34#00ff00&#34 },\n                { 1  , &#34#0000ff&#34 },\n            }\n        }\n    }\n\n Widgets\n =======\n\n It is possible to create a wallpaper using any widgets. However, keep\n in mind that the wallpaper surface is not interactive, so some widgets\n like the sliders will render, but will not behave correctly. Also, it\n is not recommanded to update the wallpaper too often. This is very slow.\n\n\n\n![Usage example](../images/AUTOGEN_awful_wallpaper_widget2.svg)\n\n \n    local function binary()\n        local ret = {}\n        for _=1, 15 do\n            for _=1, 57 do\n                table.insert(ret, math.random() > 0.5 and 1 or 0)\n            end\n            table.insert(ret, &#34\\n&#34)\n        end\n        return table.concat(ret)\n    end\n     \n    awful.wallpaper {\n        bg     = &#34#000000&#34,\n        fg     = &#34#55ff5577&#34,\n        widget = wibox.widget {\n            {\n                {\n                    markup = &#34<tt><b>[SYSTEM FAILURE]</b></tt>&#34,\n                    valign = &#34center&#34,\n                    align  = &#34center&#34,\n                    widget = wibox.widget.textbox\n                },\n                fg = &#34#00ff00&#34,\n                widget = wibox.container.background\n            },\n            {\n                wrap   = &#34word&#34,\n                text   = binary(),\n                widget = wibox.widget.textbox,\n            },\n            widget = wibox.layout.stack\n        },\n    }\n\n Cairo graphics API\n ==================\n\n AwesomeWM widgets are backed by Cairo. So it is always possible to get\n access to the Cairo context directly to do some vector art:\n\n\n\n![Usage example](../images/AUTOGEN_awful_wallpaper_widget1.svg)\n\n \n    awful.wallpaper {\n        screen = s,\n        widget = wibox.widget {\n             fit = function(_, width, height)\n                 return width, height\n             end,\n             draw = function(_, _, cr, width, height)\n                 cr:set_source(gears.color {\n                     type  = 'linear',\n                     from  = { 0, 0      },\n                     to    = { 0, height },\n                     stops = {\n                         { 0   , '#030d27' },\n                         { 0.75, '#3a183f' },\n                         { 0.75, '#000000' },\n                         { 1   , '#222222' }\n                     }\n                 })\n                 cr:paint()\n                 -- Clip the first 33% of the screen\n                 cr:rectangle(0,0, width, height/3)\n                  \n                 -- Clip-out some increasingly large sections of add the sun &#34bars&#34\n                 for i=0, 6 do\n                     cr:rectangle(0, height*.28 + i*(height*.055 + i/2), width, height*.055)\n                 end\n                 cr:clip()\n                  \n                 -- Draw the sun\n                 cr:set_source(gears.color {\n                     type  = 'linear' ,\n                     from  = { 0, 0      },\n                     to    = { 0, height },\n                     stops = {\n                         { 0, '#f0d64f' },\n                         { 1, '#e484c6' }\n                     }\n                 })\n                 cr:arc(width/2, height/2, height*.35, 0, math.pi*2)\n                 cr:fill()\n                  \n                 -- Draw the grid\n                 local lines = width/8\n                 cr:reset_clip()\n                 cr:set_line_width(0.5)\n                 cr:set_source(gears.color(&#34#8922a3&#34))\n                  \n                 for i=1, lines do\n                     cr:move_to((-width) + i* math.sin(i * (math.pi/(lines*2)))*30, height)\n                     cr:line_to(width/4 + i*((width/2)/lines), height*0.75 + 2)\n                     cr:stroke()\n                 end\n                  \n                 for i=1, 5 do\n                     cr:move_to(0, height*0.75 + i*10 + i*2)\n                     cr:line_to(width, height*0.75 + i*10 + i*2)\n                     cr:stroke()\n                 end\n             end,\n        }\n    }\n\n\n SVG vector images\n =================\n\n SVG are supported if `librsvg` is installed. Please note that `librsvg`\n doesn't implement all filters you might find in the latest version of\n your web browser. It is possible some advanced SVG will not look exactly\n as they do in a web browser or even Inkscape. However, for most images,\n it should look identical.\n\n Our SVG support goes beyond simple rendering. It is possible to set a\n custom CSS stylesheet (see `wibox.widget.imagebox.stylesheet`):\n\n\n\n![Usage example](../images/AUTOGEN_awful_wallpaper_svg.svg)\n\n \n    local image = '<?xml version=&#341.0&#34 encoding=&#34UTF-8&#34 standalone=&#34no&#34?>'..\n        '<svg width=&#34190&#34 height=&#3460&#34>'..\n            '<rect x=&#3410&#34  y=&#3410&#34 width=&#3450&#34 height=&#3450&#34 />'..\n            '<rect x=&#3470&#34  y=&#3410&#34 width=&#3450&#34 height=&#3450&#34 class=&#34my_class&#34 />'..\n            '<rect x=&#34130&#34 y=&#3410&#34 width=&#3450&#34 height=&#3450&#34 id=&#34my_id&#34 />'..\n        '</svg>'\n     \n    local stylesheet = &#34&#34 ..\n         &#34rect { fill: #ffff00&#59 } &#34..\n         &#34.my_class { fill: #00ff00&#59 } &#34..\n         &#34#my_id { fill: #0000ff&#59 }&#34\n     \n    awful.wallpaper {\n        widget = wibox.widget {\n            stylesheet = stylesheet,\n            image      = image,\n            widget     = wibox.widget.imagebox\n        }\n    }\n\n Note that in the example above, it is raw SVG code, but it is also possible\n to use a file path. If you have a `.svgz`, you need to uncompress it first\n using `gunzip` or a software like Inkscape.\n\n Multiple screen\n ===============\n\n The default `rc.lua` creates a new wallpaper everytime `request::wallpaper`\n is emitted. This is well suited for having a single wallpaper per screen.\n It is also much simpler to implement slideshows and add/remove screens.\n\n However, it isn't wall suited for wallpaper rendered across multiple screens.\n For this case, it is better to capture the return value of `awful.wallpaper {}`\n as a global variable. Then manually call `add_screen` and `remove_screen` when\n needed. A shortcut can be to do:\n\n \n\n\n \n    local global_wallpaper = awful.wallpaper {\n        -- [...] your content\n    }\n  \n    screen.connect_signal(&#34request::wallpaper&#34, function()\n        -- `screen` is the global screen module. It is also a list of all screens.\n        global_wallpaper.screens = screen\n    end)\n\n Slideshow\n =========\n\n Slideshows (changing the wallpaper after a few minutes) can be implemented\n directly using a timer and callback, but it is more elegant to simply request\n a new wallpaper, then get a random image from within the request handler. This\n way, corner cases such as adding and removing screens are handled:\n\n\n\n\n \n    -- The &#34request::wallpaper&#34 section is already in the default\n    -- `rc.lua`, replace it with this.\n    screen.connect_signal(&#34request::wallpaper&#34, function(s)\n        awful.wallpaper {\n            screen = s,\n            bg     = &#34#0000ff&#34,\n            widget = {\n                {\n                    image  = gears.filesystem.get_random_file_from_dir(\n                        &#34path/to/dir&#34,\n                        {&#34.jpg&#34, &#34.png&#34, &#34.svg&#34},\n                        true\n                    ),\n                    resize = true,\n                    widget = wibox.widget.imagebox,\n                },\n                valign = &#34center&#34,\n                halign = &#34center&#34,\n                tiled  = false,\n                widget = wibox.container.tile,\n            }\n        }\n    end)\n     \n    -- **Somewhere else** in the code, **not** in the `request::wallpaper` handler.\n    gears.timer {\n        timeout   = 1800,\n        autostart = true,\n        callback  = function()\n            for s in screen do\n                s:emit_signal(&#34request::wallpaper&#34)\n            end\n        end,\n    }\n",
  "items":[{
      "parameter":"field",
      "params":{
        "1":"widget",
        "map":{
          "widget":""
        }
      },
      "modifiers":{
        "see":[[],[]],
        "return":[],
        "param":{
          "1":{
            "type":"wibox.widget"
          },
          "widget":{
            "type":"wibox.widget"
          }
        },
        "field":{
          "1":{
            "type":"wibox.widget"
          },
          "widget":{
            "type":"wibox.widget"
          }
        }
      },
      "description":"\n\n When set, instead of using the `image_path` or `surface` properties, the\n wallpaper will be defined as a normal `wibox` widget tree.\n",
      "tags":{
        "see":[]
      },
      "section":"property",
      "inferred":true,
      "subparams":[],
      "summary":"The wallpaper widget.",
      "name":"widget",
      "type":"property",
      "args":"(widget)",
      "kind":"object properties",
      "lineno":742
    },{
      "parameter":"field",
      "params":{
        "1":"dpi",
        "map":{
          "dpi":""
        }
      },
      "modifiers":{
        "see":[[],[]],
        "field":{
          "1":{
            "optchain":"screen.dpi",
            "type":"number",
            "opt":"screen.dpi"
          },
          "dpi":{
            "optchain":"screen.dpi",
            "type":"number",
            "opt":"screen.dpi"
          }
        },
        "return":[],
        "param":{
          "1":{
            "optchain":"screen.dpi",
            "type":"number",
            "opt":"screen.dpi"
          },
          "dpi":{
            "optchain":"screen.dpi",
            "type":"number",
            "opt":"screen.dpi"
          }
        },
        "usage":[[]]
      },
      "description":"\n\n Each screen has a DPI. This value will be used by default, but sometime it\n is useful to override the screen DPI and use a custom one. This makes\n possible, for example, to draw the widgets bigger than they would otherwise\n be.\n\n If not DPI is defined, it will use the smallest DPI from any of the screen.\n\n In this example, there is 3 screens with DPI of 100, 200 and 300. As you can\n see, only the text size is affected. Many widgetds are DPI aware, but not all\n of them. This is either because DPI isn't relevant to them or simply because it\n isn't supported (like `wibox.widget.graph`).\n\n \n\n![Usage example](../images/AUTOGEN_awful_wallpaper_dpi1.svg)\n",
      "tags":{
        "see":[]
      },
      "section":"property",
      "inferred":true,
      "subparams":[],
      "summary":"The wallpaper DPI (dots per inch).",
      "name":"dpi",
      "kind":"object properties",
      "usage":["for s in screen do\n    local dpi = s.index * 100\n      \n    awful.wallpaper {\n        screen = s,\n        dpi    = dpi,\n        widget = wibox.widget {\n            text   = &#34DPI: &#34 .. dpi,\n            valign = &#34center&#34,\n            align  = &#34center&#34,\n            widget = wibox.widget.textbox,\n     }\nend\n"],
      "args":"([dpi=screen.dpi])",
      "type":"property",
      "lineno":780
    },{
      "parameter":"field",
      "params":{
        "1":"screen",
        "map":{
          "screen":""
        }
      },
      "modifiers":{
        "see":[[],[],[]],
        "return":[],
        "param":{
          "1":{
            "type":"screen"
          },
          "screen":{
            "type":"screen"
          }
        },
        "field":{
          "1":{
            "type":"screen"
          },
          "screen":{
            "type":"screen"
          }
        }
      },
      "description":"\n\n Note that there can only be one wallpaper per screen. If there is more, one\n will be chosen and all other ignored.\n",
      "tags":{
        "see":[]
      },
      "section":"property",
      "inferred":true,
      "subparams":[],
      "summary":"The wallpaper screen.",
      "name":"screen",
      "type":"property",
      "args":"(screen)",
      "kind":"object properties",
      "lineno":791
    },{
      "parameter":"field",
      "params":{
        "1":"screens",
        "map":{
          "screens":""
        }
      },
      "modifiers":{
        "see":[[],[],[],[]],
        "field":{
          "1":{
            "type":"table"
          },
          "screens":{
            "type":"table"
          }
        },
        "return":[],
        "param":{
          "1":{
            "type":"table"
          },
          "screens":{
            "type":"table"
          }
        },
        "usage":[[]]
      },
      "description":"\n\n\n\n![Usage example](../images/AUTOGEN_awful_wallpaper_screens1.svg)\n",
      "tags":{
        "see":[]
      },
      "section":"property",
      "inferred":true,
      "subparams":[],
      "summary":"A list of screen for this wallpaper.",
      "name":"screens",
      "kind":"object properties",
      "usage":["   -- There is 3 screens. This will add the wallpaper to the last 2.\n   awful.wallpaper {\n       screens = {\n           screen[2],\n           screen[3],\n       },\n       bg      = &#34#222222&#34,\n       widget  = wibox.widget {\n           {\n               fit = function(_, width, height)\n                   return width, height\n               end,\n               draw = function(_, _, cr, width, height)\n                   cr:set_source(gears.color(&#34#0000ff&#34))\n                   cr:line_to(width, height)\n                   cr:line_to(width, 0)\n                   cr:line_to(0, 0)\n                   cr:close_path()\n                   cr:fill()\n                   cr:set_source(gears.color(&#34#ff00ff&#34))\n                   cr:move_to(0, 0)\n                   cr:line_to(0, height)\n                   cr:line_to(width, height)\n                   cr:close_path()\n                   cr:fill()\n               end,\n               widget = wibox.widget.base.make_widget()\n           },\n           {\n               text   = &#34Center&#34,\n               valign = &#34center&#34,\n               align  = &#34center&#34,\n               widget = wibox.widget.textbox,\n           },\n           widget = wibox.layout.stack\n       }\n   }\n\nSome large wallpaper are made to span multiple screens.\n"],
      "args":"(screens)",
      "type":"property",
      "lineno":844
    },{
      "parameter":"field",
      "params":{
        "1":"bg",
        "map":{
          "bg":""
        }
      },
      "modifiers":{
        "see":[[]],
        "return":[],
        "param":{
          "1":{
            "type":"gears.color"
          },
          "bg":{
            "type":"gears.color"
          }
        },
        "field":{
          "1":{
            "type":"gears.color"
          },
          "bg":{
            "type":"gears.color"
          }
        }
      },
      "description":"\n\n It will be used as the \"fill\" color if the `image` doesn't take all the\n screen space. It will also be the default background for the `widget.\n\n As usual with colors in `AwesomeWM`, it can also be a gradient or a pattern.\n",
      "tags":{
        "see":[]
      },
      "section":"property",
      "inferred":true,
      "subparams":[],
      "summary":"The background color.",
      "name":"bg",
      "type":"property",
      "args":"(bg)",
      "kind":"object properties",
      "lineno":855
    },{
      "parameter":"field",
      "params":{
        "1":"fg",
        "map":{
          "fg":""
        }
      },
      "modifiers":{
        "see":[[]],
        "return":[],
        "param":{
          "1":{
            "type":"gears.color"
          },
          "fg":{
            "type":"gears.color"
          }
        },
        "field":{
          "1":{
            "type":"gears.color"
          },
          "fg":{
            "type":"gears.color"
          }
        }
      },
      "description":"\n\n This will be used by the `widget` (if any).\n\n As usual with colors in `AwesomeWM`, it can also be a gradient or a pattern.\n",
      "tags":{
        "see":[]
      },
      "section":"property",
      "inferred":true,
      "subparams":[],
      "summary":"The foreground color.",
      "name":"fg",
      "type":"property",
      "args":"(fg)",
      "kind":"object properties",
      "lineno":865
    },{
      "parameter":"field",
      "params":{
        "1":"wallpaper_bg",
        "map":{
          "wallpaper_bg":""
        }
      },
      "modifiers":{
        "see":[[]],
        "return":[],
        "param":{
          "1":{
            "type":"gears.color"
          },
          "wallpaper_bg":{
            "type":"gears.color"
          }
        },
        "field":{
          "1":{
            "type":"gears.color"
          },
          "wallpaper_bg":{
            "type":"gears.color"
          }
        }
      },
      "description":"",
      "tags":{
        "see":[]
      },
      "section":"beautiful",
      "inferred":true,
      "subparams":[],
      "summary":"The default wallpaper background color.",
      "name":"beautiful.wallpaper_bg",
      "type":"beautiful",
      "args":"(wallpaper_bg)",
      "kind":"theme variables",
      "lineno":870
    },{
      "parameter":"field",
      "params":{
        "1":"wallpaper_fg",
        "map":{
          "wallpaper_fg":""
        }
      },
      "modifiers":{
        "see":[[]],
        "return":[],
        "param":{
          "1":{
            "type":"gears.color"
          },
          "wallpaper_fg":{
            "type":"gears.color"
          }
        },
        "field":{
          "1":{
            "type":"gears.color"
          },
          "wallpaper_fg":{
            "type":"gears.color"
          }
        }
      },
      "description":"\n\n This is useful when using widgets or text in the wallpaper. A wallpaper\n created from a single image wont use this.\n",
      "tags":{
        "see":[]
      },
      "section":"beautiful",
      "inferred":true,
      "subparams":[],
      "summary":"The default wallpaper foreground color.",
      "name":"beautiful.wallpaper_fg",
      "type":"beautiful",
      "args":"(wallpaper_fg)",
      "kind":"theme variables",
      "lineno":879
    },{
      "parameter":"field",
      "params":{
        "1":"honor_workarea",
        "map":{
          "honor_workarea":""
        }
      },
      "modifiers":{
        "see":[[],[]],
        "return":[],
        "param":{
          "1":{
            "optchain":"false",
            "type":"boolean",
            "opt":"false"
          },
          "honor_workarea":{
            "optchain":"false",
            "type":"boolean",
            "opt":"false"
          }
        },
        "field":{
          "1":{
            "optchain":"false",
            "type":"boolean",
            "opt":"false"
          },
          "honor_workarea":{
            "optchain":"false",
            "type":"boolean",
            "opt":"false"
          }
        }
      },
      "description":"\n\n When set to `true`, the wallpaper will only fill the workarea space instead\n of the entire screen. This means it wont be drawn below the `awful.wibar` or\n docked clients. This is useful when using opaque bars. Note that it can cause\n aspect ratio issues for the wallpaper `image` and add bars colored with the\n `bg` color on the sides.\n\n\n\n![Usage example](../images/AUTOGEN_awful_wallpaper_workarea1.svg)\n\n",
      "tags":{
        "see":[]
      },
      "section":"property",
      "inferred":true,
      "subparams":[],
      "summary":"Honor the workarea.",
      "name":"honor_workarea",
      "type":"property",
      "args":"([honor_workarea=false])",
      "kind":"object properties",
      "lineno":897
    },{
      "parameter":"field",
      "params":{
        "1":"honor_padding",
        "map":{
          "honor_padding":""
        }
      },
      "modifiers":{
        "see":[[],[]],
        "field":{
          "1":{
            "type":"boolean"
          },
          "honor_padding":{
            "type":"boolean"
          }
        },
        "return":[],
        "param":{
          "1":{
            "type":"boolean"
          },
          "honor_padding":{
            "type":"boolean"
          }
        },
        "usage":[[]]
      },
      "description":"\n\n When set, this will look at the `screen.padding` property to restrict the\n area where the wallpaper is rendered.\n\n \n\n![Usage example](../images/AUTOGEN_awful_wallpaper_padding1.svg)\n\n**Usage example output**:\n\n\n",
      "tags":{
        "see":[]
      },
      "section":"property",
      "inferred":true,
      "subparams":[],
      "summary":"Honor the screen padding.",
      "name":"honor_padding",
      "kind":"object properties",
      "usage":["-- Add some padding to the first screen.\nscreen[1].padding = {\n    left  = 30,\n    right = 10,\n}\n \nlocal wall = awful.wallpaper {\n    screen                = screen[1],\n    honor_workarea        = true,\n    honor_padding         = true,\n    bg                    = &#34#222222&#34,\n    uncovered_areas_color = &#34#ff0000&#34,\n    widget =  wibox.widget {\n        fit = function(_, width, height)\n            return width, height\n        end,\n        draw = function(_, _, cr, width, height)\n            local radius = math.min(width, height)/2\n            cr:arc(width/2, height/2, radius, 0, 2 * math.pi)\n            cr:set_source(gears.color {\n                type = &#34radial&#34,\n                from  = { width/2, radius, 20  },\n                to    = { width/2, radius, 120 },\n                stops = {\n                    { 0, &#34#0000ff&#34 },\n                    { 1, &#34#ff0000&#34 },\n                    { 1, &#34#000000&#34 },\n                }\n            })\n            cr:fill()\n        end,\n        widget = wibox.widget.base.make_widget()\n    }\n}\n\n-- Areas due to the padding and the wibar (workarea).\nfor _, area in ipairs(wall.uncovered_areas) do\n   print(&#34Uncovered area:&#34, area.x, area.y, area.width, area.height)\nend\n"],
      "args":"(honor_padding)",
      "type":"property",
      "lineno":956
    },{
      "parameter":"field",
      "params":{
        "1":"uncovered_areas",
        "map":{
          "uncovered_areas":""
        }
      },
      "modifiers":{
        "see":[[],[],[]],
        "return":[],
        "param":{
          "1":{
            "type":"table"
          },
          "uncovered_areas":{
            "type":"table"
          }
        },
        "field":{
          "1":{
            "type":"table"
          },
          "uncovered_areas":{
            "type":"table"
          }
        }
      },
      "description":"\n\n When `honor_workarea`, `honor_padding` or panning are used, some section of\n the screen won't have a wallpaper. This returns a list of areas tables. Each\n table has a `x`, `y`, `width` and `height` key.\n",
      "tags":{
        "see":[]
      },
      "section":"property",
      "inferred":true,
      "subparams":[],
      "summary":"Returns the list of screen(s) area which won't be covered by the wallpaper.",
      "name":"uncovered_areas",
      "type":"property",
      "args":"(uncovered_areas)",
      "kind":"object properties",
      "lineno":968
    },{
      "parameter":"field",
      "params":{
        "1":"uncovered_areas_color",
        "map":{
          "uncovered_areas_color":""
        }
      },
      "modifiers":{
        "see":[[]],
        "return":[],
        "param":{
          "1":{
            "type":"gears.color"
          },
          "uncovered_areas_color":{
            "type":"gears.color"
          }
        },
        "field":{
          "1":{
            "type":"gears.color"
          },
          "uncovered_areas_color":{
            "type":"gears.color"
          }
        }
      },
      "description":"\n\n Some application rely on the wallpaper for \"fake\" transparency. Even if an\n area is hidden under a wibar (or other clients), its background can still\n become visible. If you use such application and change your screen geometry\n often enough, it is possible some areas would become filled with the remains\n of previous wallpapers. This property allows to clean those areas with a solid\n color or a gradient.\n",
      "tags":{
        "see":[]
      },
      "section":"property",
      "inferred":true,
      "subparams":[],
      "summary":"The color for the uncovered areas.",
      "name":"uncovered_areas_color",
      "type":"property",
      "args":"(uncovered_areas_color)",
      "kind":"object properties",
      "lineno":981
    },{
      "parameter":"field",
      "params":{
        "1":"panning_area",
        "map":{
          "panning_area":""
        }
      },
      "modifiers":{
        "see":[[]],
        "return":[],
        "param":{
          "1":{
            "type":"function|string"
          },
          "panning_area":{
            "type":"function|string"
          }
        },
        "field":{
          "1":{
            "type":"function|string"
          },
          "panning_area":{
            "type":"function|string"
          }
        }
      },
      "description":"\n\n When there is more than 1 screen, it is possible they don't have the same\n resolution, position or orientation. Panning the wallpaper over them may look\n better if a continuous rectangle is used rather than creating a virtual rectangle\n around all screens.\n\n The default algorithms are:\n\n **outer:** *(default)*\n\n Draw an imaginary rectangle around all screens.\n\n \n\n![Usage example](../images/AUTOGEN_awful_wallpaper_panning_outer.svg)\n\n\n **inner:**\n\n Take the largest area or either `inner_horizontal` or `inner_vertical`.\n\n \n\n![Usage example](../images/AUTOGEN_awful_wallpaper_panning_inner.svg)\n\n\n **inner_horizontal:**\n\n Take the smallest `x` value, the largest `x+width`, the smallest `y`\n and the smallest `y+height`.\n\n \n\n![Usage example](../images/AUTOGEN_awful_wallpaper_panning_inner_horizontal.svg)\n\n\n **inner_vertical:**\n\n Take the smallest `y` value, the largest `y+height`, the smallest `x`\n and the smallest `x+width`.\n\n \n\n![Usage example](../images/AUTOGEN_awful_wallpaper_panning_inner_vertical.svg)\n\n\n **Custom function:**\n\n It is also possible to define a custom function.\n\n \n\n![Usage example](../images/AUTOGEN_awful_wallpaper_panning_custom.svg)\n\n**Usage example output**:\n\n **Usage example:**\n\n\n \n    local function custom_panning_area(wallpaper)\n         return {\n             x      = wallpaper.screens[1].geometry.x + 50,\n             y      = wallpaper.screens[2].geometry.y + 50,\n             width  = 96,\n             height = 96,\n         }\n    end\n  \n    -- Areas due to the padding and the wibar (workarea).\n    for k, wall in ipairs(walls) do\n        for _, area in ipairs(wall.uncovered_areas) do\n             print(&#34Uncovered wallpaper #&#34.. k ..&#34 area:&#34, area.x, area.y, area.width, area.height)\n        end\n    end\n",
      "tags":{
        "see":[]
      },
      "section":"property",
      "inferred":true,
      "subparams":[],
      "summary":"Defines where the wallpaper is placed when there is multiple screens.",
      "name":"panning_area",
      "type":"property",
      "args":"(panning_area)",
      "kind":"object properties",
      "lineno":1062
    },{
      "parameter":"field",
      "params":{
        "1":"screen",
        "map":{
          "screen":" The screen object."
        }
      },
      "modifiers":{
        "see":[[]],
        "return":[],
        "param":{
          "1":{
            "type":"screen"
          },
          "screen":{
            "type":"screen"
          }
        },
        "field":{
          "1":{
            "type":"screen"
          },
          "screen":{
            "type":"screen"
          }
        }
      },
      "description":"\n\n **Before:**\n\n\n\n![Usage example](../images/AUTOGEN_awful_wallpaper_add_screen1.svg)\n\n\n **After:**\n\n\n\n![Usage example](../images/AUTOGEN_awful_wallpaper_add_screen2.svg)\n\n\n Also note that adding a non-continuous screen might not work well,\n but will not automatically add the screens in between:\n\n\n\n![Usage example](../images/AUTOGEN_awful_wallpaper_add_screen3.svg)\n\n",
      "tags":{
        "see":[]
      },
      "section":"method",
      "inferred":true,
      "subparams":[],
      "summary":"Add another screen (enable panning).",
      "name":"add_screen",
      "type":"method",
      "args":"(screen)",
      "kind":"object methods ",
      "lineno":1190
    },{
      "parameter":"field",
      "params":{
        "map":[]
      },
      "modifiers":{
        "see":[[],[]],
        "return":[],
        "field":[]
      },
      "description":"\n\n Adding a new wallpaper to a screen will automatically\n detach the older one. However there is some case when\n it is useful to call this manually. For example, when\n adding a new panned wallpaper, it is possible that 2\n wallpaper will have an overlap.\n",
      "tags":{
        "see":[]
      },
      "section":"method",
      "inferred":true,
      "subparams":[],
      "summary":"Detach the wallpaper from all screens.",
      "name":"detach",
      "type":"method",
      "args":"()",
      "kind":"object methods ",
      "lineno":1219
    },{
      "inferred":true,
      "subparams":[],
      "parameter":"field",
      "params":{
        "map":[]
      },
      "summary":"Repaint the wallpaper.",
      "name":"repaint",
      "modifiers":{
        "field":[],
        "return":[]
      },
      "description":"\n\n By default, even if the widget changes, the wallpaper will **NOT** be\n automatically repainted. Repainting the native X11 wallpaper is slow and\n it would be too easy to accidentally cause a performance problem. If you\n really need to repaint the wallpaper, call this method.\n",
      "type":"method",
      "section":"method",
      "kind":"object methods ",
      "args":"()",
      "tags":[],
      "lineno":1240
    },{
      "parameter":"field",
      "params":{
        "1":"screen",
        "map":{
          "screen":" The screen to remove."
        }
      },
      "modifiers":{
        "see":[[],[],[]],
        "return":[],
        "param":{
          "1":{
            "type":"screen"
          },
          "screen":{
            "type":"screen"
          }
        },
        "field":{
          "1":{
            "type":"screen"
          },
          "screen":{
            "type":"screen"
          }
        }
      },
      "description":"\n\n Calling this will remove a screen, but will **not** repaint its area.\n In this example, the wallpaper was spanning all 3 screens and the\n first screen was removed:\n\n \n\n![Usage example](../images/AUTOGEN_awful_wallpaper_remove_screen1.svg)\n\n \n    wall:remove_screen(screen[1])\n\n As you can see, the content of screen 1 still looks like it is part of\n the 3 screen wallpaper. The only use case for calling this method is if\n you use a 3rd party tools to change the wallpaper.\n\n If you wish to simply remove a screen and not have leftover content, it is\n simpler to just create a new wallpaper for that screen:\n\n \n\n![Usage example](../images/AUTOGEN_awful_wallpaper_remove_screen2.svg)\n\n \n    awful.wallpaper {\n        screen = screen[1],\n        bg     = &#34#00ffff&#34,\n    }\n",
      "tags":{
        "see":[]
      },
      "section":"method",
      "inferred":true,
      "subparams":[],
      "summary":"Remove a screen.",
      "name":"remove_screen",
      "type":"method",
      "args":"(screen)",
      "kind":"object methods ",
      "lineno":1283
    },{
      "inferred":true,
      "subparams":{
        "args":["args.widget","args.dpi","args.screen","args.screens","args.bg","args.fg","args.uncovered_areas_color","args.honor_workarea","args.honor_padding","args.uncovered_areas","args.panning_area"]
      },
      "parameter":"field",
      "params":{
        "1":"args",
        "map":{
          "args.screen":" The wallpaper screen.",
          "args.uncovered_areas":" Returns the list of screen(s) area which won't be covered by the wallpaper.",
          "args.uncovered_areas_color":" The color for the uncovered areas.",
          "args.bg":" The background color.",
          "args.screens":" A list of screen for this wallpaper.\n  Use this parameter as a remplacement for `args.screen` to manage multiscreen wallpaper.\n  (Note: the expected table should be an array-like table `{screen1, screen2, ...}`)",
          "args.widget":" The wallpaper widget.",
          "args.panning_area":" Defines where the wallpaper is placed when there is multiple screens.",
          "args.honor_padding":" Honor the screen padding.",
          "args.fg":" The foreground color.",
          "args":"",
          "args.dpi":" The wallpaper DPI (dots per inch).",
          "args.honor_workarea":" Honor the workarea."
        }
      },
      "summary":"Create a wallpaper.",
      "name":"awful.wallpaper",
      "modifiers":{
        "return":[],
        "param":{
          "1":{
            "type":"table"
          },
          "2":{
            "type":"wibox.widget",
            "opt":true
          },
          "3":{
            "type":"number",
            "opt":true
          },
          "4":{
            "type":"screen",
            "opt":true
          },
          "5":{
            "type":"table",
            "opt":true
          },
          "6":{
            "type":"gears.color",
            "opt":true
          },
          "7":{
            "type":"gears.color",
            "opt":true
          },
          "8":{
            "type":"gears.color",
            "opt":true
          },
          "9":{
            "type":"boolean",
            "opt":true
          },
          "10":{
            "type":"boolean",
            "opt":true
          },
          "11":{
            "type":"table",
            "opt":true
          },
          "12":{
            "type":"function|string",
            "opt":true
          },
          "args.screen":{
            "type":"screen",
            "opt":true
          },
          "args.uncovered_areas":{
            "type":"table",
            "opt":true
          },
          "args.uncovered_areas_color":{
            "type":"gears.color",
            "opt":true
          },
          "args.bg":{
            "type":"gears.color",
            "opt":true
          },
          "args.screens":{
            "type":"table",
            "opt":true
          },
          "args.widget":{
            "type":"wibox.widget",
            "opt":true
          },
          "args.panning_area":{
            "type":"function|string",
            "opt":true
          },
          "args.honor_padding":{
            "type":"boolean",
            "opt":true
          },
          "args.fg":{
            "type":"gears.color",
            "opt":true
          },
          "args":{
            "type":"table"
          },
          "args.dpi":{
            "type":"number",
            "opt":true
          },
          "args.honor_workarea":{
            "type":"boolean",
            "opt":true
          }
        },
        "field":{
          "1":{
            "type":"table"
          },
          "2":{
            "type":"wibox.widget",
            "opt":true
          },
          "3":{
            "type":"number",
            "opt":true
          },
          "4":{
            "type":"screen",
            "opt":true
          },
          "5":{
            "type":"table",
            "opt":true
          },
          "6":{
            "type":"gears.color",
            "opt":true
          },
          "7":{
            "type":"gears.color",
            "opt":true
          },
          "8":{
            "type":"gears.color",
            "opt":true
          },
          "9":{
            "type":"boolean",
            "opt":true
          },
          "10":{
            "type":"boolean",
            "opt":true
          },
          "11":{
            "type":"table",
            "opt":true
          },
          "12":{
            "type":"function|string",
            "opt":true
          },
          "args.screen":{
            "type":"screen",
            "opt":true
          },
          "args.uncovered_areas":{
            "type":"table",
            "opt":true
          },
          "args.uncovered_areas_color":{
            "type":"gears.color",
            "opt":true
          },
          "args.bg":{
            "type":"gears.color",
            "opt":true
          },
          "args.screens":{
            "type":"table",
            "opt":true
          },
          "args.widget":{
            "type":"wibox.widget",
            "opt":true
          },
          "args.panning_area":{
            "type":"function|string",
            "opt":true
          },
          "args.honor_padding":{
            "type":"boolean",
            "opt":true
          },
          "args.fg":{
            "type":"gears.color",
            "opt":true
          },
          "args":{
            "type":"table"
          },
          "args.dpi":{
            "type":"number",
            "opt":true
          },
          "args.honor_workarea":{
            "type":"boolean",
            "opt":true
          }
        }
      },
      "description":"\n\n Note that all parameters are not required. Please refer to the\n module description and examples to understand parameters usages.\n",
      "type":"constructorfct",
      "section":"constructorfct",
      "kind":"constructors",
      "args":"(args)",
      "tags":[],
      "lineno":1318
    }],
  "type":"popupmod",
  "file":"/home/cji/portless/awesome/build/lib/awful/wallpaper.lua",
  "package":"",
  "tags":{
    "author":["Emmanuel Lepage Vallee &lt;elv1313@gmail.com&gt;"],
    "copyright":"2019 Emmanuel Lepage Vallee"
  },
  "lineno":449
}