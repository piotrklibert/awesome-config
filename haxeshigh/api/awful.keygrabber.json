{
  "inferred":true,
  "kind":"core_components",
  "mod_name":"awful.keygrabber",
  "summary":"A keyboard grabbing and transaction object.",
  "sections":{
    "by_name":[]
  },
  "name":"awful.keygrabber",
  "modifiers":{
    "copyright":[[],[]],
    "author":[[],[]]
  },
  "description":"\n\n This module allows to grab all keyboard inputs until stopped. It is used\n to gather input data (such as in `awful.prompt`), implement VI-like keybindings\n or multi key transactions such as emulating the Alt+Tab behavior.\n\n Note that this module has been redesigned in Awesome 4.3 to be object oriented\n and stateful. The use of the older global keygrabbing API is discouraged\n going forward since it had problem with recursive keygrabbers and required\n a lot of boiler plate code to get anything done.\n\n Using keygrabber as transactions\n --------------------------------\n\n The transactional keybindings are keybindings that start with a normal\n keybindings, but only end when a (mod)key is released. In the classic\n \"Alt+Tab\" transaction, first pressing \"Alt+Tab\" will display a popup listing\n all windows (clients). This popup will only disappear when \"Alt\" is released.\n\n \n\n\n \n     awful.keygrabber {\n         keybindings = {\n             awful.key {\n                 modifiers = {&#34Mod1&#34},\n                 key       = &#34Tab&#34,\n                 on_press  = awful.client.focus.history.select_previous\n             },\n             awful.key {\n                 modifiers = {&#34Mod1&#34, &#34Shift&#34},\n                 key       = &#34Tab&#34,\n                 on_press  = awful.client.focus.history.select_next\n             },\n         },\n         -- Note that it is using the key name and not the modifier name.\n         stop_key           = &#34Mod1&#34,\n         stop_event         = &#34release&#34,\n         start_callback     = awful.client.focus.history.disable_tracking,\n         stop_callback      = awful.client.focus.history.enable_tracking,\n         export_keybindings = true,\n     }\n\n In that example, because `export_keybindings` is set to `true`, pressing\n `alt+tab` or `alt+shift+tab` will start the transaction even if the\n keygrabber is not (yet) running.\n\n Using keygrabber for modal keybindings (VI like)\n ------------------------------------------------\n\n VI-like modal keybindings are triggered by a key, like `Escape`, followed by\n either a number, an adjective (or noun) and closed by a verb. For example\n `<Escape>+2+t+f` could mean \"focus (f) the second (2) tag (t)\".\n `<Escape>+2+h+t+f` would \"focus (f) two (2) tags (t) to the right (h)\".\n\n Here is a basic implementation of such a system. Note that the action\n functions themselves are not implemented to keep the example size and\n complexity to a minimum. The implementation is just if/elseif of all action\n and the code can be found in the normal `rc.lua` keybindings section:\n\n \n\n\n \n     local map, actions = {\n         verbs = {\n             m = &#34move&#34 , f = &#34focus&#34 , d = &#34delete&#34 , a = &#34append&#34,\n             w = &#34swap&#34 , p = &#34print&#34 , n = &#34new&#34    ,\n         },\n         adjectives = { h = &#34left&#34  , j = &#34down&#34 , k = &#34up&#34    , l = &#34right&#34 , },\n         nouns      = { c = &#34client&#34, t = &#34tag&#34  , s = &#34screen&#34, y = &#34layout&#34, },\n     }, {}\n  \n     function actions.client(action, adj) print(&#34IN CLIENT!&#34) end --luacheck: no unused args\n     function actions.tag   (action, adj) print(&#34IN TAG!&#34   ) end --luacheck: no unused args\n     function actions.screen(action, adj) print(&#34IN SCREEN!&#34) end --luacheck: no unused args\n     function actions.layout(action, adj) print(&#34IN LAYOUT!&#34) end --luacheck: no unused args\n  \n     local function parse(_, stop_key, _, sequence)\n         local parsed, count = { verbs = &#34&#34, adjectives = &#34&#34, nouns = &#34&#34, }, &#34&#34\n         sequence = sequence..stop_key\n  \n         for i=1, #sequence do\n             local char = sequence:sub(i,i)\n             if char >= &#340&#34 and char <= &#349&#34 then\n                 count = count .. char\n             else\n                 for kind in pairs(parsed) do\n                     parsed[kind] = map[kind][char] or parsed[kind]\n                 end\n             end\n         end\n  \n         if parsed.nouns == &#34&#34 then return end\n         for _=1, count == &#34&#34 and 1 or tonumber(count) do\n             actions[parsed.nouns](parsed.verbs, parsed.adjectives)\n         end\n     end\n  \n     awful.keygrabber {\n         stop_callback = parse,\n         stop_key   = gears.table.keys(map.verbs),\n         root_keybindings = {\n             awful.key({&#34Mod4&#34}, &#34v&#34)\n         },\n     }\n\n Using signals\n -------------\n\n When the keygrabber is running, it will emit signals on each event. The\n format is \"key_name\"..\"::\"..\"pressed_or_released\". For example, to attach\n a callback to `Escape` being pressed, do:\n\n    mykeygrabber:connect_signal(\"Escape::pressed\", function(self, modifiers, modset)\n        print(\"Escape called!\")\n    end)\n\n The `self` argument is the keygrabber instance. The `modifiers` is a list of\n all the currently pressed modifiers and the `modset` is the same table, but\n with the modifiers as keys instead of value. It allow to save time by\n checking `if modset.Mod4 then ... end` instead of looping into the `modifiers`\n table or using `gears.table`.\n",
  "items":[{
      "inferred":true,
      "subparams":[],
      "parameter":"field",
      "params":{
        "1":"g",
        "map":{
          "g":" The key grabber that must be removed."
        }
      },
      "summary":"Stop grabbing the keyboard for the provided callback.",
      "name":"stop",
      "modifiers":{
        "return":[],
        "param":{
          "1":{
            "optchain":true,
            "opt":true
          },
          "g":{
            "optchain":true,
            "opt":true
          }
        },
        "field":{
          "1":{
            "optchain":true,
            "opt":true
          },
          "g":{
            "optchain":true,
            "opt":true
          }
        }
      },
      "description":"\n\n When no callback is given, the last grabber gets removed (last one added to\n the stack).\n",
      "type":"deprecated",
      "section":"deprecated",
      "kind":"deprecated functions",
      "args":"([g])",
      "tags":[],
      "lineno":317
    },{
      "parameter":"field",
      "params":{
        "1":"number",
        "map":{
          "number":""
        }
      },
      "modifiers":{
        "see":[[],[]],
        "field":{
          "1":[],
          "number":[]
        },
        "return":[],
        "param":{
          "1":[],
          "number":[]
        },
        "usage":[[]]
      },
      "description":"\n\n \n\n",
      "tags":{
        "see":[]
      },
      "section":"property",
      "inferred":true,
      "subparams":[],
      "summary":"The keygrabber timeout.",
      "name":"timeout",
      "kind":"object properties",
      "usage":["awful.keygrabber {\n    autostart      = true,\n    timeout        = 1, -- second\n    timeout_callback  = function()\n        print(&#34The keygrabber has expired&#34)\n    end,\n}\n"],
      "args":"(number)",
      "type":"property",
      "lineno":361
    },{
      "parameter":"field",
      "params":{
        "1":"string",
        "map":{
          "string":"|table stop_key"
        }
      },
      "modifiers":{
        "see":[[]],
        "return":[],
        "param":{
          "1":{
            "optchain":"nil",
            "opt":"nil"
          },
          "string":{
            "optchain":"nil",
            "opt":"nil"
          }
        },
        "field":{
          "1":{
            "optchain":"nil",
            "opt":"nil"
          },
          "string":{
            "optchain":"nil",
            "opt":"nil"
          }
        }
      },
      "description":"\n\n When this is set, the running keygrabber will quit when [one of] the stop\n key event occurs.\n\n By default, the event is `press`. It is common for use case like the\n `awful.prompt` where `return` (enter) will terminate the keygrabbing. Using\n `release` as an event is more appropriate when the keygrabber is tied to a\n modifier key. For example, an Alt+Tab implementation stops when `mod1` (Alt)\n is released.\n\n It can also be a table containing many keys (as values).\n\n \n\n \n\n Please note that modkeys are not accepted as `stop_key`s. You have to use\n their corresponding key names such as `Control_L`.\n",
      "tags":{
        "see":[]
      },
      "section":"property",
      "inferred":true,
      "subparams":[],
      "summary":"The key on which the keygrabber listen to terminate itself.",
      "name":"stop_key",
      "type":"property",
      "args":"([string=nil])",
      "kind":"object properties",
      "lineno":385
    },{
      "parameter":"field",
      "params":{
        "1":"string",
        "map":{
          "string":""
        }
      },
      "modifiers":{
        "see":[[]],
        "return":[],
        "param":{
          "1":[],
          "string":[]
        },
        "field":{
          "1":[],
          "string":[]
        }
      },
      "description":"\n\n the valid values are:\n\n * \"press\" (default)\n * \"release\"\n",
      "tags":{
        "see":[]
      },
      "section":"property",
      "inferred":true,
      "subparams":[],
      "summary":"The event on which the keygrabbing will be terminated.",
      "name":"stop_event",
      "type":"property",
      "args":"(string)",
      "kind":"object properties",
      "lineno":396
    },{
      "parameter":"field",
      "params":{
        "1":"boolean",
        "map":{
          "boolean":""
        }
      },
      "modifiers":{
        "see":[[],[],[]],
        "return":[],
        "param":{
          "1":{
            "optchain":"true",
            "opt":"true"
          },
          "boolean":{
            "optchain":"true",
            "opt":"true"
          }
        },
        "field":{
          "1":{
            "optchain":"true",
            "opt":"true"
          },
          "boolean":{
            "optchain":"true",
            "opt":"true"
          }
        }
      },
      "description":"\n\n When this property is set to false, the `keyreleased_callback` and\n `keypressed_callback` callbacks will be executed even when the event was\n consumed by a `keybinding`.\n\n By default, keybindings block those callbacks from being executed.\n",
      "tags":{
        "see":[]
      },
      "section":"property",
      "inferred":true,
      "subparams":[],
      "summary":"Whether or not to execute the key press/release callbacks when keybindings are called.",
      "name":"mask_event_callback",
      "type":"property",
      "args":"([boolean=true])",
      "kind":"object properties",
      "lineno":410
    },{
      "parameter":"field",
      "params":{
        "1":"boolean",
        "map":{
          "boolean":""
        }
      },
      "modifiers":{
        "see":[[]],
        "return":[],
        "param":{
          "1":{
            "optchain":"false",
            "opt":"false"
          },
          "boolean":{
            "optchain":"false",
            "opt":"false"
          }
        },
        "field":{
          "1":{
            "optchain":"false",
            "opt":"false"
          },
          "boolean":{
            "optchain":"false",
            "opt":"false"
          }
        }
      },
      "description":"",
      "tags":{
        "see":[]
      },
      "section":"property",
      "inferred":true,
      "subparams":[],
      "summary":"Do not call the callbacks on modifier keys (like `Control` or `Mod4`) events.",
      "name":"mask_modkeys",
      "type":"property",
      "args":"([boolean=false])",
      "kind":"object properties",
      "lineno":415
    },{
      "inferred":true,
      "subparams":[],
      "parameter":"field",
      "params":{
        "1":"boolean",
        "map":{
          "boolean":""
        }
      },
      "summary":"Export all keygrabber keybindings as root (global) keybindings.",
      "name":"export_keybindings",
      "modifiers":{
        "return":[],
        "param":{
          "1":{
            "optchain":"false",
            "opt":"false"
          },
          "boolean":{
            "optchain":"false",
            "opt":"false"
          }
        },
        "field":{
          "1":{
            "optchain":"false",
            "opt":"false"
          },
          "boolean":{
            "optchain":"false",
            "opt":"false"
          }
        }
      },
      "description":"\n\n When this is enabled, calling all of the keygrabber object `keybinding`s will\n will create root `awful.key` and will automatically starts the grabbing.\n\n Use this with caution. If many keygrabber or \"real\" root keybindings are set\n on the same key combination, they are all executed and there is almost no\n safe way to undo that. Make sure the `keygrabber` that use this option\n have a single instance.\n",
      "type":"property",
      "section":"property",
      "kind":"object properties",
      "args":"([boolean=false])",
      "tags":[],
      "lineno":428
    },{
      "parameter":"field",
      "params":{
        "1":"table",
        "map":{
          "table":""
        }
      },
      "modifiers":{
        "see":[[],[]],
        "field":{
          "1":[],
          "table":[]
        },
        "return":[],
        "param":{
          "1":[],
          "table":[]
        },
        "usage":[[]]
      },
      "description":"\n\n Instead of adding an entry to `root.keys` or `rc.lua` `globalkeys` section,\n this property can be used to take care of everything. This way, it becomes\n easier to package modules using keygrabbers.\n\n \n\n\n**Usage example output**:\n\n    Is now active!\tnil\n    A key was pressed:\ta\twith\t0\tmodifier!\n    A key was pressed:\ti\twith\t1\tmodifier!\n    Called again!\n\n",
      "tags":{
        "see":[]
      },
      "section":"property",
      "inferred":true,
      "subparams":[],
      "summary":"The root (global) keybinding to start this keygrabber.",
      "name":"root_keybindings",
      "kind":"object properties",
      "usage":["awful.keygrabber {\n    mask_modkeys = true,\n    root_keybindings = {\n        awful.key {\n            modifiers = {&#34Mod4&#34},\n            key       = &#34i&#34,\n            on_press  = function(self)\n                print(&#34Is now active!&#34, self)\n            end\n        },\n    },\n    keybindings = {\n        awful.key {\n            modifiers = {&#34Mod4&#34, &#34Shift&#34},\n            key       = &#34i&#34,\n            on_press  = function(self)\n                print(&#34Called again!&#34)\n                self:stop()\n            end\n        },\n    },\n    keypressed_callback  = function(_, modifiers, key)\n        print(&#34A key was pressed:&#34, key, &#34with&#34, #modifiers, &#34modifier!&#34)\n    end,\n}\n \n-- The following will **NOT** trigger the keygrabbing because it isn't exported\n-- to the root (global) keys. Adding `export_keybindings` would solve that\nroot._execute_keybinding({&#34Mod4&#34, &#34Shift&#34}, &#34i&#34)\nassert(#keybinding_works == 0)\n \n-- But this will start the keygrabber because it is part of the root_keybindings\nroot._execute_keybinding({&#34Mod4&#34}, &#34i&#34)\n \n-- Note that that keygrabber is running, all callbacks should work:\nroot.fake_input(&#34key_press&#34  , &#34a&#34)\nroot.fake_input(&#34key_release&#34  , &#34a&#34)\n \n-- Calling the root keybindings now wont work because they are not part of\n-- the keygrabber internal (own) keybindings, so `keypressed_callback` will\n-- be called.\nroot._execute_keybinding({&#34Mod4&#34}, &#34i&#34)\n \n-- Now the keygrabber own keybindings will work\nroot._execute_keybinding({&#34Mod4&#34, &#34Shift&#34}, &#34i&#34)\n"],
      "args":"(table)",
      "type":"property",
      "lineno":497
    },{
      "parameter":"field",
      "params":{
        "1":"table",
        "map":{
          "table":""
        }
      },
      "modifiers":{
        "see":[[],[],[]],
        "return":[],
        "param":{
          "1":[],
          "table":[]
        },
        "field":{
          "1":[],
          "table":[]
        }
      },
      "description":"\n\n This property contains a table of `awful.key` objects.\n",
      "tags":{
        "see":[]
      },
      "section":"property",
      "inferred":true,
      "subparams":[],
      "summary":"The keybindings associated with this keygrabber.",
      "name":"keybindings",
      "type":"property",
      "args":"(table)",
      "kind":"object properties",
      "lineno":507
    },{
      "parameter":"field",
      "params":{
        "1":"allowed_keys",
        "map":{
          "allowed_keys":" The list of keys."
        }
      },
      "modifiers":{
        "field":{
          "1":{
            "optchain":"nil",
            "type":"table|nil",
            "opt":"nil"
          },
          "allowed_keys":{
            "optchain":"nil",
            "type":"table|nil",
            "opt":"nil"
          }
        },
        "return":[],
        "param":{
          "1":{
            "optchain":"nil",
            "type":"table|nil",
            "opt":"nil"
          },
          "allowed_keys":{
            "optchain":"nil",
            "type":"table|nil",
            "opt":"nil"
          }
        },
        "usage":[[]]
      },
      "description":"\n\n When defined, this property allows to define an implicit way to release the\n keygrabber. It helps save some boilerplate code in the handler callbacks.\n\n It is useful when a transaction only handle a limited number of keys. If\n a key unhandled by the transaction is triggered, the transaction is\n canceled.\n\n \n\n",
      "tags":[],
      "section":"property",
      "inferred":true,
      "subparams":[],
      "summary":"If any key is pressed that is not in this list, the keygrabber is stopped.",
      "name":"allowed_keys",
      "kind":"object properties",
      "usage":["awful.keygrabber {\n    autostart      = true,\n    allowed_keys   = {&#34a&#34, &#34w&#34, &#34e&#34, &#34s&#34, &#34o&#34, &#34m&#34, &#34e&#34},\n}\n"],
      "args":"([allowed_keys=nil])",
      "type":"property",
      "lineno":528
    },{
      "parameter":"field",
      "params":{
        "1":"string",
        "map":{
          "string":""
        }
      },
      "modifiers":{
        "field":{
          "1":[],
          "string":[]
        },
        "return":[],
        "param":{
          "1":[],
          "string":[]
        },
        "usage":[[]]
      },
      "description":"\n\n In this example, the `stop_callback` is used to retrieve the final key\n sequence.\n\n Please note that backspace will remove elements from the sequence and\n named keys and modifiers are ignored.\n\n \n\n",
      "tags":[],
      "section":"property",
      "inferred":true,
      "subparams":[],
      "summary":"The sequence of keys recorded since the start of the keygrabber.",
      "name":"sequence",
      "kind":"object properties",
      "usage":["awful.keygrabber {\n    autostart      = true,\n    stop_key       = &#34Return&#34,\n    stop_callback  = function(_, _, _, sequence)\n        naughty.notification {message=&#34The keys were:&#34..sequence}\n    end,\n}\n"],
      "args":"(string)",
      "type":"property",
      "lineno":552
    },{
      "inferred":false,
      "subparams":[],
      "parameter":"field",
      "params":{
        "1":"current_instance",
        "map":{
          "current_instance":""
        }
      },
      "summary":"The current (running) instance of this keygrabber.",
      "name":"current_instance",
      "modifiers":{
        "return":[],
        "field":{
          "1":{
            "type":"keygrabber"
          },
          "current_instance":{
            "type":"keygrabber"
          }
        },
        "emits":[[]]
      },
      "description":"\n\n The keygrabber instance is created when the keygrabber starts. It is an object\n mirroring this keygrabber object, but where extra properties can be added. It\n is useful to keep some contextual data part of the current transaction without\n polluting the original object of having extra boilerplate code.\n",
      "type":"field",
      "section":"field",
      "kind":"fields",
      "args":"(current_instance)",
      "tags":{
        "emits":["property::current_instance"]
      },
      "lineno":562
    },{
      "inferred":true,
      "subparams":[],
      "parameter":"field",
      "params":{
        "map":[]
      },
      "summary":"The global signal used to track the `current_instance`.",
      "name":"property::current_instance",
      "modifiers":{
        "field":[],
        "return":[]
      },
      "description":"",
      "type":"signal",
      "section":"signal",
      "kind":"signals",
      "args":"()",
      "tags":[],
      "lineno":566
    },{
      "inferred":false,
      "subparams":[],
      "parameter":"field",
      "params":{
        "1":"is_running",
        "map":{
          "is_running":""
        }
      },
      "summary":"If a keygrabber is currently running.",
      "name":"is_running",
      "modifiers":{
        "return":[],
        "field":{
          "1":{
            "type":"boolean"
          },
          "is_running":{
            "type":"boolean"
          }
        }
      },
      "description":"",
      "type":"field",
      "section":"field",
      "kind":"fields",
      "args":"(is_running)",
      "tags":[],
      "lineno":569
    },{
      "inferred":true,
      "subparams":[],
      "parameter":"field",
      "params":{
        "map":[]
      },
      "summary":"Start the keygrabber.",
      "name":"start",
      "modifiers":{
        "return":[{
            "type":"boolean"
          }],
        "field":[],
        "emits":[[],[]]
      },
      "description":"\n\n Note that only a single keygrabber can be started at any one time. If another\n keygrabber (or this one) is currently running. This method returns false.\n",
      "type":"method",
      "section":"method",
      "kind":"object methods ",
      "args":"()",
      "tags":{
        "emits":["started","property::current_instance"]
      },
      "lineno":578
    },{
      "inferred":true,
      "subparams":[],
      "parameter":"field",
      "params":{
        "map":[]
      },
      "summary":"Stop the keygrabber.",
      "name":"stop",
      "modifiers":{
        "return":[],
        "field":[],
        "emits":[[],[]]
      },
      "description":"\n\n Also stops any `timeout`.\n",
      "type":"method",
      "section":"method",
      "kind":"object methods ",
      "args":"()",
      "tags":{
        "emits":["stopped","property::current_instance"]
      },
      "lineno":634
    },{
      "inferred":true,
      "subparams":{
        "description":["description.group"]
      },
      "parameter":"field",
      "params":{
        "1":"key",
        "map":{
          "key":" The key.",
          "description.group":" The keybinding group"
        }
      },
      "summary":"Add a keybinding to this keygrabber.",
      "name":"add_keybinding",
      "modifiers":{
        "return":[],
        "param":{
          "1":{
            "type":"awful.key"
          },
          "2":{
            "type":"string"
          },
          "key":{
            "type":"awful.key"
          },
          "description.group":{
            "type":"string"
          }
        },
        "field":{
          "1":{
            "type":"awful.key"
          },
          "2":{
            "type":"string"
          },
          "key":{
            "type":"awful.key"
          },
          "description.group":{
            "type":"string"
          }
        }
      },
      "description":"\n\n Those keybindings will automatically start the keygrabbing when hit.\n",
      "type":"method",
      "section":"method",
      "kind":"object methods ",
      "args":"(key)",
      "tags":[],
      "lineno":662
    },{
      "inferred":true,
      "subparams":[],
      "parameter":"field",
      "params":{
        "map":[]
      },
      "summary":"When the keygrabber starts.",
      "name":"started",
      "modifiers":{
        "field":[],
        "return":[]
      },
      "description":"",
      "type":"signal",
      "section":"signal",
      "kind":"signals",
      "args":"()",
      "tags":[],
      "lineno":740
    },{
      "inferred":true,
      "subparams":[],
      "parameter":"field",
      "params":{
        "map":[]
      },
      "summary":"When the keygrabber stops.",
      "name":"stopped",
      "modifiers":{
        "field":[],
        "return":[]
      },
      "description":"",
      "type":"signal",
      "section":"signal",
      "kind":"signals",
      "args":"()",
      "tags":[],
      "lineno":743
    },{
      "inferred":true,
      "subparams":[],
      "parameter":"field",
      "params":{
        "1":"keygrabber",
        "map":{
          "keygrabber":" The keygrabber."
        }
      },
      "summary":"A function called when a keygrabber starts.",
      "name":"start_callback",
      "modifiers":{
        "return":[],
        "param":{
          "1":{
            "type":"keygrabber"
          },
          "keygrabber":{
            "type":"keygrabber"
          }
        },
        "field":{
          "1":{
            "type":"keygrabber"
          },
          "keygrabber":{
            "type":"keygrabber"
          }
        }
      },
      "description":"",
      "type":"callback",
      "section":"callback",
      "kind":"callback functions prototype",
      "args":"(keygrabber)",
      "tags":[],
      "lineno":747
    },{
      "parameter":"field",
      "params":{
        "1":"self",
        "2":"stop_key",
        "3":"stop_mods",
        "4":"sequence",
        "map":{
          "self":" The current transaction object.",
          "sequence":" The recorded key sequence.",
          "stop_mods":" The modifiers key (if any)",
          "stop_key":" The key(s) that stop the keygrabbing (if any)"
        }
      },
      "modifiers":{
        "see":[[],[]],
        "field":{
          "1":{
            "type":"table"
          },
          "2":{
            "type":"string"
          },
          "3":{
            "type":"table"
          },
          "4":{
            "type":"string"
          },
          "self":{
            "type":"table"
          },
          "sequence":{
            "type":"string"
          },
          "stop_mods":{
            "type":"table"
          },
          "stop_key":{
            "type":"string"
          }
        },
        "return":[],
        "param":{
          "1":{
            "type":"table"
          },
          "2":{
            "type":"string"
          },
          "3":{
            "type":"table"
          },
          "4":{
            "type":"string"
          },
          "self":{
            "type":"table"
          },
          "sequence":{
            "type":"string"
          },
          "stop_mods":{
            "type":"table"
          },
          "stop_key":{
            "type":"string"
          }
        },
        "usage":[[]]
      },
      "description":"",
      "tags":{
        "see":[]
      },
      "section":"callback",
      "inferred":true,
      "subparams":[],
      "summary":"The callback when the keygrabbing stops.",
      "name":"stop_callback",
      "kind":"callback functions prototype",
      "usage":["local function my_done_cb(self, stop_key, stop_mods, sequence)\n   -- do something\nend\n"],
      "args":"(self, stop_key, stop_mods, sequence)",
      "type":"callback",
      "lineno":760
    },{
      "parameter":"field",
      "params":{
        "map":[]
      },
      "modifiers":{
        "see":[[]],
        "return":[],
        "field":[]
      },
      "description":"\n\n Note that the `stop_callback` is also called when the keygrabbers timeout.\n",
      "tags":{
        "see":[]
      },
      "section":"callback",
      "inferred":true,
      "subparams":[],
      "summary":"The function called when the keygrabber stops because of a `timeout`.",
      "name":"timeout_callback",
      "type":"callback",
      "args":"()",
      "kind":"callback functions prototype",
      "lineno":767
    },{
      "parameter":"field",
      "params":{
        "1":"self",
        "2":"mod",
        "3":"key",
        "4":"event",
        "map":{
          "self":" The current transaction object.",
          "mod":" The current modifiers (like \"Control\" or \"Shift\").",
          "key":" The key name.",
          "event":" The event (\"press\" or \"release\")."
        }
      },
      "modifiers":{
        "field":{
          "1":{
            "type":"table"
          },
          "2":{
            "type":"table"
          },
          "3":{
            "type":"string"
          },
          "4":{
            "type":"string"
          },
          "self":{
            "type":"table"
          },
          "mod":{
            "type":"table"
          },
          "key":{
            "type":"string"
          },
          "event":{
            "type":"string"
          }
        },
        "return":[],
        "param":{
          "1":{
            "type":"table"
          },
          "2":{
            "type":"table"
          },
          "3":{
            "type":"string"
          },
          "4":{
            "type":"string"
          },
          "self":{
            "type":"table"
          },
          "mod":{
            "type":"table"
          },
          "key":{
            "type":"string"
          },
          "event":{
            "type":"string"
          }
        },
        "usage":[[]]
      },
      "description":"",
      "tags":[],
      "section":"callback",
      "inferred":true,
      "subparams":[],
      "summary":"The callback function to call with mod table, key and command as arguments\n when a key was pressed.",
      "name":"keypressed_callback",
      "kind":"callback functions prototype",
      "usage":["local function my_keypressed_cb(self, mod, key, command)\n   -- do something\nend\n"],
      "args":"(self, mod, key, event)",
      "type":"callback",
      "lineno":779
    },{
      "parameter":"field",
      "params":{
        "1":"self",
        "2":"mod",
        "3":"key",
        "4":"event",
        "map":{
          "self":" The current transaction object.",
          "mod":" The current modifiers (like \"Control\" or \"Shift\").",
          "key":" The key name.",
          "event":" The event (\"press\" or \"release\")"
        }
      },
      "modifiers":{
        "field":{
          "1":{
            "type":"table"
          },
          "2":{
            "type":"table"
          },
          "3":{
            "type":"string"
          },
          "4":{
            "type":"string"
          },
          "self":{
            "type":"table"
          },
          "mod":{
            "type":"table"
          },
          "key":{
            "type":"string"
          },
          "event":{
            "type":"string"
          }
        },
        "return":[],
        "param":{
          "1":{
            "type":"table"
          },
          "2":{
            "type":"table"
          },
          "3":{
            "type":"string"
          },
          "4":{
            "type":"string"
          },
          "self":{
            "type":"table"
          },
          "mod":{
            "type":"table"
          },
          "key":{
            "type":"string"
          },
          "event":{
            "type":"string"
          }
        },
        "usage":[[]]
      },
      "description":"",
      "tags":[],
      "section":"callback",
      "inferred":true,
      "subparams":[],
      "summary":"The callback function to call with mod table, key and command as arguments\n when a key was released.",
      "name":"keyreleased_callback",
      "kind":"callback functions prototype",
      "usage":["local function my_keyreleased_cb(self, mod, key, command)\n   -- do something\nend\n"],
      "args":"(self, mod, key, event)",
      "type":"callback",
      "lineno":790
    },{
      "inferred":true,
      "subparams":{
        "args":["args.stop_event","args.stop_key","args.keybindings","args.timeout","args.mask_event_callback","args.start_callback","args.stop_callback","args.timeout_callback","args.keypressed_callback","args.keyreleased_callback","args.allowed_keys","args.root_keybindings","args.export_keybindings","args.autostart","args.mask_modkeys"]
      },
      "parameter":"field",
      "params":{
        "1":"args",
        "map":{
          "args.allowed_keys":" A table with all keys that\n  **won't** stop the keygrabber.",
          "args.start_callback":"",
          "args.keybindings":" All keybindings.",
          "args.stop_event":" Release event (\"press\" or \"release\")",
          "args.stop_callback":"",
          "args.mask_modkeys":" Do not call the callbacks on\n  modifier keys (like `Control` or `Mod4`) events.",
          "args.root_keybindings":" The root (global) keybindings.",
          "args.timeout_callback":"",
          "args.stop_key":" The key that has to be kept pressed.",
          "args.export_keybindings":" Create root (global) keybindings.",
          "args.mask_event_callback":" Do not call `keypressed_callback`\n  or `keyreleased_callback` when a hook is called.",
          "args.keyreleased_callback":"",
          "args.keypressed_callback":"",
          "args":"",
          "args.autostart":" Start the grabbing immediately",
          "args.timeout":" The maximum inactivity delay."
        }
      },
      "summary":"A wrapper around the keygrabber to make it easier to add keybindings.",
      "name":"awful.keygrabber",
      "modifiers":{
        "return":[],
        "param":{
          "1":{
            "type":"table"
          },
          "2":{
            "type":"string",
            "opt":"\"press\""
          },
          "3":{
            "type":"string|table",
            "opt":"nil"
          },
          "4":{
            "type":"table"
          },
          "5":{
            "type":"number",
            "opt":"-1"
          },
          "6":{
            "type":"boolean",
            "opt":"true"
          },
          "7":{
            "type":"function",
            "opt":true
          },
          "8":{
            "type":"function",
            "opt":true
          },
          "9":{
            "type":"function",
            "opt":true
          },
          "10":{
            "type":"function",
            "opt":true
          },
          "11":{
            "type":"function",
            "opt":true
          },
          "12":{
            "type":"table|nil",
            "opt":"nil"
          },
          "13":{
            "type":"table",
            "opt":true
          },
          "14":{
            "type":"boolean",
            "opt":"false"
          },
          "15":{
            "type":"boolean",
            "opt":"false"
          },
          "16":{
            "type":"boolean",
            "opt":"false"
          },
          "args.allowed_keys":{
            "type":"table|nil",
            "opt":"nil"
          },
          "args.start_callback":{
            "type":"function",
            "opt":true
          },
          "args.keybindings":{
            "type":"table"
          },
          "args.stop_event":{
            "type":"string",
            "opt":"\"press\""
          },
          "args.stop_callback":{
            "type":"function",
            "opt":true
          },
          "args.mask_modkeys":{
            "type":"boolean",
            "opt":"false"
          },
          "args.root_keybindings":{
            "type":"table",
            "opt":true
          },
          "args.timeout_callback":{
            "type":"function",
            "opt":true
          },
          "args.stop_key":{
            "type":"string|table",
            "opt":"nil"
          },
          "args.export_keybindings":{
            "type":"boolean",
            "opt":"false"
          },
          "args.mask_event_callback":{
            "type":"boolean",
            "opt":"true"
          },
          "args.keyreleased_callback":{
            "type":"function",
            "opt":true
          },
          "args.keypressed_callback":{
            "type":"function",
            "opt":true
          },
          "args":{
            "type":"table"
          },
          "args.autostart":{
            "type":"boolean",
            "opt":"false"
          },
          "args.timeout":{
            "type":"number",
            "opt":"-1"
          }
        },
        "field":{
          "1":{
            "type":"table"
          },
          "2":{
            "type":"string",
            "opt":"\"press\""
          },
          "3":{
            "type":"string|table",
            "opt":"nil"
          },
          "4":{
            "type":"table"
          },
          "5":{
            "type":"number",
            "opt":"-1"
          },
          "6":{
            "type":"boolean",
            "opt":"true"
          },
          "7":{
            "type":"function",
            "opt":true
          },
          "8":{
            "type":"function",
            "opt":true
          },
          "9":{
            "type":"function",
            "opt":true
          },
          "10":{
            "type":"function",
            "opt":true
          },
          "11":{
            "type":"function",
            "opt":true
          },
          "12":{
            "type":"table|nil",
            "opt":"nil"
          },
          "13":{
            "type":"table",
            "opt":true
          },
          "14":{
            "type":"boolean",
            "opt":"false"
          },
          "15":{
            "type":"boolean",
            "opt":"false"
          },
          "16":{
            "type":"boolean",
            "opt":"false"
          },
          "args.allowed_keys":{
            "type":"table|nil",
            "opt":"nil"
          },
          "args.start_callback":{
            "type":"function",
            "opt":true
          },
          "args.keybindings":{
            "type":"table"
          },
          "args.stop_event":{
            "type":"string",
            "opt":"\"press\""
          },
          "args.stop_callback":{
            "type":"function",
            "opt":true
          },
          "args.mask_modkeys":{
            "type":"boolean",
            "opt":"false"
          },
          "args.root_keybindings":{
            "type":"table",
            "opt":true
          },
          "args.timeout_callback":{
            "type":"function",
            "opt":true
          },
          "args.stop_key":{
            "type":"string|table",
            "opt":"nil"
          },
          "args.export_keybindings":{
            "type":"boolean",
            "opt":"false"
          },
          "args.mask_event_callback":{
            "type":"boolean",
            "opt":"true"
          },
          "args.keyreleased_callback":{
            "type":"function",
            "opt":true
          },
          "args.keypressed_callback":{
            "type":"function",
            "opt":true
          },
          "args":{
            "type":"table"
          },
          "args.autostart":{
            "type":"boolean",
            "opt":"false"
          },
          "args.timeout":{
            "type":"number",
            "opt":"-1"
          }
        }
      },
      "description":"\n\n This is similar to the `awful.prompt`, but without an actual widget. It can\n be used to implement custom transactions such as alt+tab or keyboard menu\n navigation.\n\n Note that the object returned can be used as a client or global keybinding\n callback without modification. Make sure to set `stop_key` and `stop_event`\n to proper values to avoid permanently locking the keyboard.\n",
      "type":"constructorfct",
      "section":"constructorfct",
      "kind":"constructors",
      "args":"(args)",
      "tags":[],
      "lineno":820
    },{
      "parameter":"field",
      "params":{
        "1":"g",
        "map":{
          "g":" The key grabber callback that will get the key events until it\n  will be deleted or a new grabber is added."
        }
      },
      "modifiers":{
        "field":{
          "1":[],
          "g":[]
        },
        "return":[[]],
        "param":{
          "1":[],
          "g":[]
        },
        "usage":[[]]
      },
      "description":"\n\n Grab keyboard input and read pressed keys, calling the least callback\n function from the stack at each keypress, until the stack is empty.\n\n Calling run with the same callback again will bring the callback\n to the top of the stack.\n\n The callback function receives three arguments:\n\n * a table containing modifiers keys\n * a string with the pressed key\n * a string with either \"press\" or \"release\" to indicate the event type.\n\n Here is the content of the modifier table:\n\n <table class='widget_list' border=1>\n  <tr style='font-weight: bold;'>\n   <th align='center'>Modifier name </th>\n   <th align='center'>Key name</th>\n   <th align='center'>Alternate key name</th>\n  </tr>\n  <tr><td> Mod4</td><td align='center'> Super_L </td><td align='center'> Super_R </td></tr>\n  <tr><td> Control </td><td align='center'> Control_L </td><td align='center'> Control_R </td></tr>\n  <tr><td> Shift </td><td align='center'> Shift_L </td><td align='center'> Shift_R </td></tr>\n  <tr><td> Mod1</td><td align='center'> Alt_L </td><td align='center'> Alt_R </td></tr>\n </table>\n\n A callback can return `false` to pass the events to the next\n keygrabber in the stack.\n",
      "tags":[],
      "section":"deprecated",
      "inferred":true,
      "subparams":[],
      "summary":"A lower level API to interact with the keygrabber directly.",
      "name":"run",
      "kind":"deprecated functions",
      "usage":["-- The following function can be bound to a key, and be used to resize a\n-- client using the keyboard.\n\nfunction resize(c)\n  local grabber\n  grabber = awful.keygrabber.run(function(mod, key, event)\n    if event == \"release\" then return end\n\n    if     key == 'Up'    then c:relative_move(0, 0, 0, 5)\n    elseif key == 'Down'  then c:relative_move(0, 0, 0, -5)\n    elseif key == 'Right' then c:relative_move(0, 0, 5, 0)\n    elseif key == 'Left'  then c:relative_move(0, 0, -5, 0)\n    else   awful.keygrabber.stop(grabber)\n    end\n  end)\nend\n"],
      "args":"(g)",
      "type":"deprecated",
      "lineno":948
    },{
      "inferred":true,
      "subparams":[],
      "parameter":"field",
      "params":{
        "1":"name",
        "2":"callback",
        "map":{
          "name":" The signal name.",
          "callback":" The callback."
        }
      },
      "summary":"Connect to a signal for all keygrabbers at once.",
      "name":"connect_signal",
      "modifiers":{
        "return":[],
        "param":{
          "1":{
            "type":"string"
          },
          "2":{
            "type":"function"
          },
          "name":{
            "type":"string"
          },
          "callback":{
            "type":"function"
          }
        },
        "field":{
          "1":{
            "type":"string"
          },
          "2":{
            "type":"function"
          },
          "name":{
            "type":"string"
          },
          "callback":{
            "type":"function"
          }
        }
      },
      "description":"",
      "type":"staticfct",
      "section":"staticfct",
      "kind":"static module functions",
      "args":"(name, callback)",
      "tags":[],
      "lineno":972
    },{
      "inferred":true,
      "subparams":[],
      "parameter":"field",
      "params":{
        "1":"name",
        "2":"callback",
        "map":{
          "name":" The signal name.",
          "callback":" The callback."
        }
      },
      "summary":"Disconnect to a signal for all keygrabbers at once.",
      "name":"disconnect_signal",
      "modifiers":{
        "return":[],
        "param":{
          "1":{
            "type":"string"
          },
          "2":{
            "type":"function"
          },
          "name":{
            "type":"string"
          },
          "callback":{
            "type":"function"
          }
        },
        "field":{
          "1":{
            "type":"string"
          },
          "2":{
            "type":"function"
          },
          "name":{
            "type":"string"
          },
          "callback":{
            "type":"function"
          }
        }
      },
      "description":"",
      "type":"staticfct",
      "section":"staticfct",
      "kind":"static module functions",
      "args":"(name, callback)",
      "tags":[],
      "lineno":985
    },{
      "inferred":true,
      "subparams":[],
      "parameter":"field",
      "params":{
        "1":"name",
        "2":"...",
        "map":{
          "name":" The signal name.",
          "...":" Other arguments for the callbacks."
        }
      },
      "summary":"Emit a signal on the keygrabber module itself.",
      "name":"emit_signal",
      "modifiers":{
        "return":[],
        "param":{
          "1":{
            "type":"string"
          },
          "2":[],
          "name":{
            "type":"string"
          },
          "...":[]
        },
        "field":{
          "1":{
            "type":"string"
          },
          "2":[],
          "name":{
            "type":"string"
          },
          "...":[]
        }
      },
      "description":"\n\n Warning, usually don't use this directly, use\n `my_keygrabber:emit_signal(name, ...)`. This function works on the whole\n keygrabber module, not one of its instance.\n",
      "type":"staticfct",
      "section":"staticfct",
      "kind":"static module functions",
      "args":"(name, ...)",
      "tags":[],
      "lineno":1005
    },{
      "inferred":true,
      "subparams":[],
      "parameter":"field",
      "params":{
        "1":"name",
        "2":"...",
        "map":{
          "name":" The name of the signal.",
          "...":" Extra arguments for the callback functions. Each connected\n   function receives the object as first argument and then any extra\n   arguments that are given to emit_signal()."
        }
      },
      "summary":"Emit a signal.",
      "name":"emit_signal",
      "modifiers":{
        "return":[],
        "baseclass":[[]],
        "param":{
          "1":{
            "type":"string"
          },
          "2":[],
          "name":{
            "type":"string"
          },
          "...":[]
        },
        "field":{
          "1":{
            "type":"string"
          },
          "2":[],
          "name":{
            "type":"string"
          },
          "...":[]
        }
      },
      "description":"",
      "type":"method",
      "section":"method",
      "kind":"object methods ",
      "args":"(name, ...)",
      "tags":{
        "baseclass":["gears.object"]
      },
      "lineno":1033
    },{
      "inferred":true,
      "subparams":[],
      "parameter":"field",
      "params":{
        "1":"name",
        "2":"func",
        "map":{
          "name":" The name of the signal.",
          "func":" The callback to call when the signal is emitted."
        }
      },
      "summary":"Connect to a signal.",
      "name":"connect_signal",
      "modifiers":{
        "return":[],
        "baseclass":[[]],
        "param":{
          "1":{
            "type":"string"
          },
          "2":{
            "type":"function"
          },
          "name":{
            "type":"string"
          },
          "func":{
            "type":"function"
          }
        },
        "field":{
          "1":{
            "type":"string"
          },
          "2":{
            "type":"function"
          },
          "name":{
            "type":"string"
          },
          "func":{
            "type":"function"
          }
        }
      },
      "description":"",
      "type":"method",
      "section":"method",
      "kind":"object methods ",
      "args":"(name, func)",
      "tags":{
        "baseclass":["gears.object"]
      },
      "lineno":1039
    },{
      "inferred":true,
      "subparams":[],
      "parameter":"field",
      "params":{
        "1":"name",
        "2":"func",
        "map":{
          "name":" The name of the signal.",
          "func":" The callback to call when the signal is emitted."
        }
      },
      "summary":"Connect to a signal weakly.",
      "name":"weak_connect_signal",
      "modifiers":{
        "return":[],
        "baseclass":[[]],
        "param":{
          "1":{
            "type":"string"
          },
          "2":{
            "type":"function"
          },
          "name":{
            "type":"string"
          },
          "func":{
            "type":"function"
          }
        },
        "field":{
          "1":{
            "type":"string"
          },
          "2":{
            "type":"function"
          },
          "name":{
            "type":"string"
          },
          "func":{
            "type":"function"
          }
        }
      },
      "description":"\n\n This allows the callback function to be garbage collected and\n automatically disconnects the signal when that happens.\n\n **Warning:**\n Only use this function if you really, really, really know what you\n are doing.",
      "type":"method",
      "section":"method",
      "kind":"object methods ",
      "args":"(name, func)",
      "tags":{
        "baseclass":["gears.object"]
      },
      "lineno":1052
    }],
  "type":"coreclassmod",
  "file":"/home/cji/portless/awesome/build/lib/awful/keygrabber.lua",
  "package":"",
  "tags":{
    "author":["dodo","Emmanuel Lepage Vallee &lt;elv1313@gmail.com&gt;"],
    "copyright":["2012 dodo","2017 Emmanuel Lepage Vallee"]
  },
  "lineno":134
}