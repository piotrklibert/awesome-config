{
  "inferred":true,
  "kind":"libraries",
  "see":[{
      "label":"ruled.client",
      "mod":{
        "inferred":true,
        "kind":"declarative_rules",
        "mod_name":"ruled.client",
        "summary":"Rules for clients.",
        "sections":{
          "by_name":[]
        },
        "name":"ruled.client",
        "modifiers":{
          "copyright":[],
          "author":[[]]
        },
        "description":"\n\n This module applies @{rules} to clients during startup (via @{client.manage},\n but its functions can be used for client matching in general.\n\n All existing `client` properties can be used in rules. It is also possible\n to add random properties that will be later accessible as `c.property_name`\n (where `c` is a valid client object)\n\n Syntax\n ===\n You should fill this table with your rule and properties to apply.\n For example, if you want to set xterm maximized at startup, you can add:\n\n \n\n![Usage example](../images/AUTOGEN_sequences_client_rules_maximized.svg)\n\n \n     ruled.client.append_rule {\n         rule = { class = &#34xterm&#34 },\n         properties = {\n             maximized_vertical   = true,\n             maximized_horizontal = true\n         },\n     }\n  \n     -- Spawn xterm\n     awful.spawn(&#34xterm&#34)\n\n If you want to set mplayer floating at startup, you can add:\n\n \n\n![Usage example](../images/AUTOGEN_sequences_client_rules_floating.svg)\n\n \n     ruled.client.append_rule {\n         rule = { class = &#34mplayer&#34 },\n         properties = {\n             floating  = true,\n             placement = awful.placement.centered,\n             width     = 640,\n             height    = 480,\n         },\n     }\n  \n     -- Spawn xterm\n     for _=1, 5 do\n         awful.spawn(&#34xterm&#34)\n     end\n  \n     -- Spawn mplayer\n     awful.spawn(&#34mplayer&#34)\n\n If you want to put Firefox on a specific tag at startup. It is possible to\n specify the tag with it's object or by name:\n\n \n\n![Usage example](../images/AUTOGEN_sequences_client_rules_tags.svg)\n\n \n    -- Select tag by object reference:\n    ruled.client.append_rule {\n        rule_any    = {\n            class = {&#34firefox&#34}\n        },\n        properties = {\n            tag = screen[1].tags[3],\n        },\n    }\n  \n    -- Select tag by name:\n    ruled.client.append_rule {\n        rule_any    = {\n            class = {&#34thunderbird&#34}\n        },\n        properties = {\n            tag = &#34five&#34,\n        },\n    }\n  \n    -- Spawn firefox and thunderbird\n    awful.spawn(&#34firefox&#34)\n    awful.spawn(&#34thunderbird&#34)\n\n If you want to put Thunderbird on a specific screen at startup, use:\n\n \n\n![Usage example](../images/AUTOGEN_sequences_client_rules_screens.svg)\n\n \n     mouse.coords {x = 2500, y = 100 }\n  \n     -- Screen by IDs:\n     ruled.client.append_rule {\n         rule_any    = {\n             class = {&#34firefox&#34}\n         },\n         properties = {\n             screen = 2,\n         },\n     }\n  \n     -- Screen by object:\n     ruled.client.append_rule {\n         rule_any    = {\n             class = {&#34thunderbird&#34}\n         },\n         properties = {\n             screen = mouse.screen,\n         },\n     }\n  \n     -- Screen by output name:\n     ruled.client.append_rule {\n         rule_any    = {\n             class = {&#34xterm&#34}\n         },\n         properties = {\n             screen = &#34LVDS1&#34,\n         },\n     }\n  \n     -- Spawn firefox, thunderbird and xterm\n     awful.spawn(&#34firefox&#34)\n     awful.spawn(&#34thunderbird&#34)\n     awful.spawn(&#34xterm&#34)\n\n If you want to put Emacs on a specific tag at startup, and immediately switch\n to that tag you can add:\n\n \n\n![Usage example](../images/AUTOGEN_sequences_client_rules_switch_to_tags.svg)\n\n \n     -- Select tag by object reference:\n     ruled.client.append_rule {\n         rule = { class = &#34firefox&#34 },\n         properties = {\n             tag            = screen[1].tags[4],\n             switch_to_tags = true\n         }\n     }\n  \n     -- Spawn firefox\n     awful.spawn(&#34firefox&#34)\n\n If you want to apply a custom callback to execute when a rule matched,\n for example to pause playing music from mpd when you start dosbox, you\n can add:\n\n     { rule = { class = \"dosbox\" },\n       callback = function(c)\n          awful.spawn('mpc pause')\n       end }\n\n Note that all \"rule\" entries need to match. If any of the entry does not\n match, the rule won't be applied.\n\n If a client matches multiple rules, they are applied in the order they are\n put in this global rules table. If the value of a rule is a string, then the\n match function is used to determine if the client matches the rule.\n\n If the value of a property is a function, that function gets called and\n function's return value is used for the property.\n\n To match multiple clients to a rule one need to use slightly different\n syntax:\n\n     { rule_any = { class = { \"MPlayer\", \"Nitrogen\" }, instance = { \"xterm\" } },\n       properties = { floating = true } }\n\n To match multiple clients with an exception one can couple `rules.except` or\n `rules.except_any` with the rules:\n\n     { rule = { class = \"Firefox\" },\n       except = { instance = \"Navigator\" },\n       properties = {floating = true},\n     },\n\n     { rule_any = { class = { \"Pidgin\", \"Xchat\" } },\n       except_any = { role = { \"conversation\" } },\n       properties = { tag = \"1\" }\n     }\n\n     { rule = {},\n       except_any = { class = { \"Firefox\", \"Vim\" } },\n       properties = { floating = true }\n     }\n\n Note that all rules can have an `id` field. This can then be used to find\n the rule. For example, it can be used in `remove_rule` instead of the table.\n\n Flowchart\n =========\n\n ![Client rules](../images/client_rules.svg)\n\n Applicable client properties\n ===\n\n The table below holds the list of default client properties along with\n some extra properties that are specific to the rules. Note that any property\n can be set in the rules and interpreted by user provided code. This table\n only represent those offered by default.\n\n<table class='widget_list' border=1>\n <tr>\n  <th align='center'>Name</th>\n  <th align='center'>Description</th>\n </tr>\n   <tr><td><a href='../core_components/client.html#placement'>placement</a></td><td>The client default placement on the screen</td></tr>\n   <tr><td><a href='../core_components/client.html#honor_padding'>honor\\_padding</a></td><td>When applying the placement, honor the screen padding</td></tr>\n   <tr><td><a href='../core_components/client.html#honor_workarea'>honor\\_workarea</a></td><td>When applying the placement, honor the screen work area</td></tr>\n   <tr><td><a href='../core_components/client.html#tag'>tag</a></td><td>The client default tag</td></tr>\n   <tr><td><a href='../core_components/client.html#tags'>tags</a></td><td>The client default tags</td></tr>\n   <tr><td><a href='../core_components/client.html#new_tag'>new\\_tag</a></td><td>Create a new tag for this client</td></tr>\n   <tr><td><a href='../core_components/client.html#switch_to_tags'>switch\\_to\\_tags</a></td><td>Unselect the current tags and select this client tags</td></tr>\n   <tr><td><a href='../core_components/client.html#focus'>focus</a></td><td>Define if the client should grab focus by default</td></tr>\n   <tr><td><a href='../core_components/client.html#titlebars_enabled'>titlebars\\_enabled</a></td><td>Should this client have a titlebar by default</td></tr>\n   <tr><td><a href='../core_components/client.html#callback'>callback</a></td><td>A function to call when this client is ready</td></tr>\n   <tr><td><a href='../core_components/client.html#marked'>marked</a></td><td>If a client is marked or not</td></tr>\n   <tr><td><a href='../core_components/client.html#is_fixed'>is\\_fixed</a></td><td>Return if a client has a fixed size or not</td></tr>\n   <tr><td><a href='../core_components/client.html#immobilized_horizontal'>immobilized\\_horizontal</a></td><td>Is the client immobilized horizontally?</td></tr>\n   <tr><td><a href='../core_components/client.html#immobilized_vertical'>immobilized\\_vertical</a></td><td>Is the client immobilized vertically?</td></tr>\n   <tr><td><a href='../core_components/client.html#floating'>floating</a></td><td>The client floating state</td></tr>\n   <tr><td><a href='../core_components/client.html#x'>x</a></td><td>The x coordinates</td></tr>\n   <tr><td><a href='../core_components/client.html#y'>y</a></td><td>The y coordinates</td></tr>\n   <tr><td><a href='../core_components/client.html#width'>width</a></td><td>The width of the client</td></tr>\n   <tr><td><a href='../core_components/client.html#height'>height</a></td><td>The height of the client</td></tr>\n   <tr><td><a href='../core_components/client.html#dockable'>dockable</a></td><td>If the client is dockable</td></tr>\n   <tr><td><a href='../core_components/client.html#requests_no_titlebar'>requests\\_no\\_titlebar</a></td><td>If the client requests not to be decorated with a titlebar</td></tr>\n   <tr><td><a href='../core_components/client.html#shape'>shape</a></td><td>Set the client shape</td></tr>\n   <tr><td><a href='../core_components/client.html#active'>active</a></td><td>Return true if the client is active (has focus)</td></tr>\n   <tr><td><a href='../core_components/client.html#window'>window</a></td><td>The X window id</td></tr>\n   <tr><td><a href='../core_components/client.html#name'>name</a></td><td>The client title</td></tr>\n   <tr><td><a href='../core_components/client.html#skip_taskbar'>skip\\_taskbar</a></td><td>True if the client does not want to be in taskbar</td></tr>\n   <tr><td><a href='../core_components/client.html#type'>type</a></td><td>The window type</td></tr>\n   <tr><td><a href='../core_components/client.html#class'>class</a></td><td>The client class</td></tr>\n   <tr><td><a href='../core_components/client.html#instance'>instance</a></td><td>The client instance</td></tr>\n   <tr><td><a href='../core_components/client.html#pid'>pid</a></td><td>The client PID, if available</td></tr>\n   <tr><td><a href='../core_components/client.html#role'>role</a></td><td>The window role, if available</td></tr>\n   <tr><td><a href='../core_components/client.html#machine'>machine</a></td><td>The machine the client is running on</td></tr>\n   <tr><td><a href='../core_components/client.html#icon_name'>icon\\_name</a></td><td>The client name when iconified</td></tr>\n   <tr><td><a href='../core_components/client.html#icon'>icon</a></td><td>The client icon as a surface</td></tr>\n   <tr><td><a href='../core_components/client.html#icon_sizes'>icon\\_sizes</a></td><td>The available sizes of client icons</td></tr>\n   <tr><td><a href='../core_components/client.html#screen'>screen</a></td><td>Client screen</td></tr>\n   <tr><td><a href='../core_components/client.html#hidden'>hidden</a></td><td>Define if the client must be hidden (Never mapped, invisible in taskbar)</td></tr>\n   <tr><td><a href='../core_components/client.html#minimized'>minimized</a></td><td>Define if the client must be iconified (Only visible in taskbar)</td></tr>\n   <tr><td><a href='../core_components/client.html#size_hints_honor'>size\\_hints\\_honor</a></td><td>Honor size hints, e</td></tr>\n   <tr><td><a href='../core_components/client.html#border_width'>border\\_width</a></td><td>The client border width</td></tr>\n   <tr><td><a href='../core_components/client.html#border_color'>border\\_color</a></td><td>The client border color</td></tr>\n   <tr><td><a href='../core_components/client.html#urgent'>urgent</a></td><td>Set to `true` when the client ask for attention</td></tr>\n   <tr><td><a href='../core_components/client.html#content'>content</a></td><td>A cairo surface for the client window content</td></tr>\n   <tr><td><a href='../core_components/client.html#opacity'>opacity</a></td><td>The client opacity</td></tr>\n   <tr><td><a href='../core_components/client.html#ontop'>ontop</a></td><td>The client is on top of every other windows</td></tr>\n   <tr><td><a href='../core_components/client.html#above'>above</a></td><td>The client is above normal windows</td></tr>\n   <tr><td><a href='../core_components/client.html#below'>below</a></td><td>The client is below normal windows</td></tr>\n   <tr><td><a href='../core_components/client.html#fullscreen'>fullscreen</a></td><td>The client is fullscreen or not</td></tr>\n   <tr><td><a href='../core_components/client.html#maximized'>maximized</a></td><td>The client is maximized (horizontally and vertically) or not</td></tr>\n   <tr><td><a href='../core_components/client.html#maximized_horizontal'>maximized\\_horizontal</a></td><td>The client is maximized horizontally or not</td></tr>\n   <tr><td><a href='../core_components/client.html#maximized_vertical'>maximized\\_vertical</a></td><td>The client is maximized vertically or not</td></tr>\n   <tr><td><a href='../core_components/client.html#transient_for'>transient\\_for</a></td><td>The client the window is transient for</td></tr>\n   <tr><td><a href='../core_components/client.html#group_window'>group\\_window</a></td><td>Window identification unique to a group of windows</td></tr>\n   <tr><td><a href='../core_components/client.html#leader_window'>leader\\_window</a></td><td>Identification unique to windows spawned by the same command</td></tr>\n   <tr><td><a href='../core_components/client.html#size_hints'>size\\_hints</a></td><td>A table with size hints of the client</td></tr>\n   <tr><td><a href='../core_components/client.html#motif_wm_hints'>motif\\_wm\\_hints</a></td><td>The motif WM hints of the client</td></tr>\n   <tr><td><a href='../core_components/client.html#sticky'>sticky</a></td><td>Set the client sticky (Available on all tags)</td></tr>\n   <tr><td><a href='../core_components/client.html#modal'>modal</a></td><td>Indicate if the client is modal</td></tr>\n   <tr><td><a href='../core_components/client.html#focusable'>focusable</a></td><td>True if the client can receive the input focus</td></tr>\n   <tr><td><a href='../core_components/client.html#shape_bounding'>shape\\_bounding</a></td><td>The client's bounding shape as set by awesome as a (native) cairo surface</td></tr>\n   <tr><td><a href='../core_components/client.html#shape_clip'>shape\\_clip</a></td><td>The client's clip shape as set by awesome as a (native) cairo surface</td></tr>\n   <tr><td><a href='../core_components/client.html#shape_input'>shape\\_input</a></td><td>The client's input shape as set by awesome as a (native) cairo surface</td></tr>\n   <tr><td><a href='../core_components/client.html#client_shape_bounding'>client\\_shape\\_bounding</a></td><td>The client's bounding shape as set by the program as a (native) cairo surface</td></tr>\n   <tr><td><a href='../core_components/client.html#client_shape_clip'>client\\_shape\\_clip</a></td><td>The client's clip shape as set by the program as a (native) cairo surface</td></tr>\n   <tr><td><a href='../core_components/client.html#startup_id'>startup\\_id</a></td><td>The FreeDesktop StartId</td></tr>\n   <tr><td><a href='../core_components/client.html#valid'>valid</a></td><td>If the client that this object refers to is still managed by awesome</td></tr>\n   <tr><td><a href='../core_components/client.html#first_tag'>first\\_tag</a></td><td>The first tag of the client</td></tr>\n   <tr><td><a href='../core_components/client.html#buttons'>buttons</a></td><td>Get or set mouse buttons bindings for a client</td></tr>\n   <tr><td><a href='../core_components/client.html#keys'>keys</a></td><td>Get or set keys bindings for a client</td></tr>\n </table>\n",
        "items":[{
            "inferred":true,
            "subparams":[],
            "parameter":"field",
            "params":{
              "1":"c",
              "2":"rule",
              "map":{
                "c":" The client.",
                "rule":" The rule to check."
              }
            },
            "summary":"Check if a client matches a rule.",
            "name":"match",
            "modifiers":{
              "return":[{
                  "type":"bool"
                }],
              "param":{
                "1":{
                  "type":"client"
                },
                "2":{
                  "type":"table"
                },
                "c":{
                  "type":"client"
                },
                "rule":{
                  "type":"table"
                }
              },
              "field":{
                "1":{
                  "type":"client"
                },
                "2":{
                  "type":"table"
                },
                "c":{
                  "type":"client"
                },
                "rule":{
                  "type":"table"
                }
              }
            },
            "description":"",
            "type":"staticfct",
            "section":"staticfct",
            "kind":"static module functions",
            "args":"(c, rule)",
            "tags":[],
            "lineno":321
          },{
            "inferred":true,
            "subparams":[],
            "parameter":"field",
            "params":{
              "1":"c",
              "2":"rule",
              "map":{
                "c":" The client.",
                "rule":" The rule to check."
              }
            },
            "summary":"Check if a client matches any part of a rule.",
            "name":"match_any",
            "modifiers":{
              "return":[{
                  "type":"bool"
                }],
              "param":{
                "1":{
                  "type":"client"
                },
                "2":{
                  "type":"table"
                },
                "c":{
                  "type":"client"
                },
                "rule":{
                  "type":"table"
                }
              },
              "field":{
                "1":{
                  "type":"client"
                },
                "2":{
                  "type":"table"
                },
                "c":{
                  "type":"client"
                },
                "rule":{
                  "type":"table"
                }
              }
            },
            "description":"",
            "type":"staticfct",
            "section":"staticfct",
            "kind":"static module functions",
            "args":"(c, rule)",
            "tags":[],
            "lineno":330
          },{
            "inferred":true,
            "subparams":[],
            "parameter":"field",
            "params":{
              "1":"c",
              "2":"entry",
              "map":{
                "c":" The client.",
                "entry":" Rule entry (with keys `rule`, `rule_any`, `except` and/or\n   `except_any`)."
              }
            },
            "summary":"Does a given rule entry match a client?",
            "name":"matches",
            "modifiers":{
              "return":[{
                  "type":"bool"
                }],
              "param":{
                "1":{
                  "type":"client"
                },
                "2":{
                  "type":"table"
                },
                "c":{
                  "type":"client"
                },
                "entry":{
                  "type":"table"
                }
              },
              "field":{
                "1":{
                  "type":"client"
                },
                "2":{
                  "type":"table"
                },
                "c":{
                  "type":"client"
                },
                "entry":{
                  "type":"table"
                }
              }
            },
            "description":"",
            "type":"staticfct",
            "section":"staticfct",
            "kind":"static module functions",
            "args":"(c, entry)",
            "tags":[],
            "lineno":340
          },{
            "inferred":true,
            "subparams":[],
            "parameter":"field",
            "params":{
              "1":"c",
              "2":"_rules",
              "map":{
                "c":" The client.",
                "_rules":" The rules to check. List with \"rule\", \"rule_any\", \"except\" and\n   \"except_any\" keys."
              }
            },
            "summary":"Get list of matching rules for a client.",
            "name":"matching_rules",
            "modifiers":{
              "return":[{
                  "type":"table"
                }],
              "param":{
                "1":{
                  "type":"client"
                },
                "2":{
                  "type":"table"
                },
                "c":{
                  "type":"client"
                },
                "_rules":{
                  "type":"table"
                }
              },
              "field":{
                "1":{
                  "type":"client"
                },
                "2":{
                  "type":"table"
                },
                "c":{
                  "type":"client"
                },
                "_rules":{
                  "type":"table"
                }
              }
            },
            "description":"",
            "type":"staticfct",
            "section":"staticfct",
            "kind":"static module functions",
            "args":"(c, _rules)",
            "tags":[],
            "lineno":350
          },{
            "inferred":true,
            "subparams":[],
            "parameter":"field",
            "params":{
              "1":"c",
              "2":"_rules",
              "map":{
                "c":" The client.",
                "_rules":" The rules to check. List of tables with `rule`, `rule_any`,\n   `except` and `except_any` keys."
              }
            },
            "summary":"Check if a client matches a given set of rules.",
            "name":"matches_list",
            "modifiers":{
              "return":[{
                  "type":"bool"
                }],
              "param":{
                "1":{
                  "type":"client"
                },
                "2":{
                  "type":"table"
                },
                "c":{
                  "type":"client"
                },
                "_rules":{
                  "type":"table"
                }
              },
              "field":{
                "1":{
                  "type":"client"
                },
                "2":{
                  "type":"table"
                },
                "c":{
                  "type":"client"
                },
                "_rules":{
                  "type":"table"
                }
              }
            },
            "description":"",
            "type":"staticfct",
            "section":"staticfct",
            "kind":"static module functions",
            "args":"(c, _rules)",
            "tags":[],
            "lineno":360
          },{
            "inferred":true,
            "subparams":[],
            "parameter":"field",
            "params":{
              "1":"name",
              "map":{
                "name":" The source name."
              }
            },
            "summary":"Remove a source.",
            "name":"remove_rule_source",
            "modifiers":{
              "return":[{
                  "type":"boolean"
                }],
              "param":{
                "1":{
                  "type":"string"
                },
                "name":{
                  "type":"string"
                }
              },
              "field":{
                "1":{
                  "type":"string"
                },
                "name":{
                  "type":"string"
                }
              }
            },
            "description":"",
            "type":"staticfct",
            "section":"staticfct",
            "kind":"static module functions",
            "args":"(name)",
            "tags":[],
            "lineno":368
          },{
            "inferred":true,
            "subparams":[],
            "parameter":"field",
            "params":{
              "1":"c",
              "map":{
                "c":" The client."
              }
            },
            "summary":"Apply ruled.client.rules to a client.",
            "name":"apply",
            "modifiers":{
              "return":[],
              "param":{
                "1":{
                  "type":"client"
                },
                "c":{
                  "type":"client"
                }
              },
              "field":{
                "1":{
                  "type":"client"
                },
                "c":{
                  "type":"client"
                }
              }
            },
            "description":"",
            "type":"staticfct",
            "section":"staticfct",
            "kind":"static module functions",
            "args":"(c)",
            "tags":[],
            "lineno":375
          },{
            "parameter":"param",
            "params":{
              "1":"rule",
              "map":{
                "rule":" A valid rule."
              }
            },
            "modifiers":{
              "param":{
                "1":{
                  "type":"table"
                },
                "rule":{
                  "type":"table"
                }
              },
              "return":[]
            },
            "description":"",
            "tags":[],
            "section":"function",
            "inferred":true,
            "subparams":[],
            "summary":"Add a new rule to the default set.",
            "name":"module.append_rule",
            "kind":"functions",
            "lineno":382,
            "args":"(rule)",
            "type":"function"
          },{
            "parameter":"param",
            "params":{
              "1":"rules",
              "map":{
                "rules":" A table with rules."
              }
            },
            "modifiers":{
              "param":{
                "1":{
                  "type":"table"
                },
                "rules":{
                  "type":"table"
                }
              },
              "return":[]
            },
            "description":"",
            "tags":[],
            "section":"function",
            "inferred":true,
            "subparams":[],
            "summary":"Add a new rules to the default set.",
            "name":"module.append_rules",
            "kind":"functions",
            "lineno":388,
            "args":"(rules)",
            "type":"function"
          },{
            "parameter":"param",
            "params":{
              "1":"rule",
              "map":{
                "rule":" A valid rule or a name passed in the `id` value\n  when calling `append_rule`."
              }
            },
            "modifiers":{
              "param":{
                "1":{
                  "type":"table|string"
                },
                "rule":{
                  "type":"table|string"
                }
              },
              "return":[]
            },
            "description":"",
            "tags":[],
            "section":"function",
            "inferred":true,
            "subparams":[],
            "summary":"Remove a new rule to the default set.",
            "name":"module.remove_rule",
            "kind":"functions",
            "lineno":395,
            "args":"(rule)",
            "type":"function"
          },{
            "inferred":true,
            "subparams":{
              "callback":["callback.c","callback.properties","callback.callbacks"]
            },
            "parameter":"field",
            "params":{
              "1":"name",
              "2":"callback",
              "3":"depends_on",
              "4":"precede",
              "map":{
                "callback.callbacks":" A table of all callbacks scheduled to be\n  executed after the main properties are applied.",
                "callback.properties":" The current properties. The callback should\n  add to and overwrite properties in this table",
                "depends_on":" A list of names of sources this source depends on\n  (sources that must be executed *before* `name`.",
                "callback":" The callback that is called to produce properties.",
                "precede":" A list of names of sources this source have a\n  priority over.",
                "name":" The provider name. It must be unique.",
                "callback.c":" The client"
              }
            },
            "summary":"Add a new rule source.",
            "name":"add_rule_source",
            "modifiers":{
              "return":[{
                  "type":"boolean"
                }],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "type":"function"
                },
                "3":{
                  "type":"client"
                },
                "4":{
                  "type":"table"
                },
                "5":{
                  "type":"table"
                },
                "6":{
                  "type":"table",
                  "opt":"{}"
                },
                "7":{
                  "type":"table",
                  "opt":"{}"
                },
                "callback.callbacks":{
                  "type":"table"
                },
                "callback.properties":{
                  "type":"table"
                },
                "depends_on":{
                  "type":"table",
                  "opt":"{}"
                },
                "callback":{
                  "type":"function"
                },
                "precede":{
                  "type":"table",
                  "opt":"{}"
                },
                "name":{
                  "type":"string"
                },
                "callback.c":{
                  "type":"client"
                }
              },
              "field":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "type":"function"
                },
                "3":{
                  "type":"client"
                },
                "4":{
                  "type":"table"
                },
                "5":{
                  "type":"table"
                },
                "6":{
                  "type":"table",
                  "opt":"{}"
                },
                "7":{
                  "type":"table",
                  "opt":"{}"
                },
                "callback.callbacks":{
                  "type":"table"
                },
                "callback.properties":{
                  "type":"table"
                },
                "depends_on":{
                  "type":"table",
                  "opt":"{}"
                },
                "callback":{
                  "type":"function"
                },
                "precede":{
                  "type":"table",
                  "opt":"{}"
                },
                "name":{
                  "type":"string"
                },
                "callback.c":{
                  "type":"client"
                }
              }
            },
            "description":"\n\n A rule source is a provider called when a client is managed (started). It\n allows to configure the client by providing properties that should be applied.\n By default, Awesome provides 2 sources:\n\n * `awful.rules`: A declarative matcher\n * `awful.spawn`: Launch clients with pre-defined properties\n\n It is possible to register new callbacks to modify the properties table\n before it is applied. Each provider is executed sequentially and modifies the\n same table. If the first provider set a property, then the second can\n override it, then the third, etc. Once the providers are exhausted, the\n properties are applied on the client.\n\n It is important to note that properties themselves have their own\n dependencies. For example, a `tag` property implies a `screen`. Therefor, if\n a `screen` is already specified, then it will be ignored when the rule is\n executed. Properties also have their own priorities. For example, the\n `titlebar` and `border_width` need to be applied before the `x` and `y`\n positions are set. Otherwise, it will be off or the client will shift\n upward everytime Awesome is restarted. A rule source *cannot* change this.\n It is up to the callback to be aware of the dependencies and avoid to\n introduce issues. For example, if the source wants to set a `screen`, it has\n to check if the `tag`, `tags` or `new_tag` are on that `screen` or remove\n those properties. Otherwise, they will be ignored once the rule is applied.\n",
            "type":"staticfct",
            "section":"staticfct",
            "kind":"static module functions",
            "args":"(name, callback, depends_on, precede)",
            "tags":[],
            "lineno":440
          },{
            "inferred":true,
            "subparams":[],
            "parameter":"field",
            "params":{
              "map":[]
            },
            "summary":"The default `ruled.client` source.",
            "name":"awful.rules",
            "modifiers":{
              "field":[],
              "return":[]
            },
            "description":"\n\n It is called `awful.rules` for historical reasons.\n\n **Has priority over:**\n\n *nothing*\n",
            "type":"rulesources",
            "section":"rulesources",
            "kind":"rule sources",
            "args":"()",
            "tags":[],
            "lineno":457
          },{
            "inferred":true,
            "subparams":[],
            "parameter":"field",
            "params":{
              "map":[]
            },
            "summary":"The rule source for clients spawned by `awful.spawn`.",
            "name":"awful.spawn",
            "modifiers":{
              "field":[],
              "return":[]
            },
            "description":"\n\n **Has priority over:**\n\n * `awful.rules`\n",
            "type":"rulesources",
            "section":"rulesources",
            "kind":"rule sources",
            "args":"()",
            "tags":[],
            "lineno":482
          },{
            "inferred":true,
            "subparams":[],
            "parameter":"field",
            "params":{
              "map":[]
            },
            "summary":"The rule source for clients spawned by `awful.spawn.once` and `single_instance`.",
            "name":"awful.spawn_once",
            "modifiers":{
              "field":[],
              "return":[]
            },
            "description":"\n\n **Has priority over:**\n\n * `awful.rules`\n\n **Depends on:**\n\n * `awful.spawn`\n",
            "type":"rulesources",
            "section":"rulesources",
            "kind":"rule sources",
            "args":"()",
            "tags":[],
            "lineno":524
          },{
            "parameter":"field",
            "params":{
              "map":{
                "ruled.client.extra_properties":""
              }
            },
            "modifiers":{
              "return":[],
              "field":{
                "1":{
                  "type":"table"
                },
                "ruled.client.extra_properties":{
                  "type":"table"
                }
              }
            },
            "description":"\n\n These properties are used in the rules only and are not sent to the client\n afterward.\n\n To add a new properties, just do:\n\n    function ruled.client.extra_properties.my_new_property(c, value, props)\n        -- do something\n    end\n\n By default, the table has the following functions:\n\n * geometry\n * placement\n",
            "tags":[],
            "section":"table",
            "inferred":true,
            "subparams":{
              "ruled":["ruled.client.extra_properties"]
            },
            "summary":"Extra rules properties.",
            "name":"module.extra_properties",
            "kind":"tables",
            "lineno":551,
            "args":"()",
            "type":"table"
          },{
            "parameter":"field",
            "params":{
              "map":{
                "ruled.client.high_priority_properties":""
              }
            },
            "modifiers":{
              "return":[],
              "field":{
                "1":{
                  "type":"table"
                },
                "ruled.client.high_priority_properties":{
                  "type":"table"
                }
              }
            },
            "description":"\n\n Some properties, such as anything related to tags, geometry or focus, will\n cause a race condition if set in the main property section. This is why\n they have a section for them.\n\n To add a new properties, just do:\n\n    function ruled.client.high_priority_properties.my_new_property(c, value, props)\n        -- do something\n    end\n\n By default, the table has the following functions:\n\n * tag\n * new_tag\n",
            "tags":[],
            "section":"table",
            "inferred":true,
            "subparams":{
              "ruled":["ruled.client.high_priority_properties"]
            },
            "summary":"Extra high priority properties.",
            "name":"module.high_priority_properties",
            "kind":"tables",
            "lineno":571,
            "args":"()",
            "type":"table"
          },{
            "parameter":"field",
            "params":{
              "map":{
                "ruled.client.delayed_properties":"\n By default, the table has the following functions:\n\n * switch_to_tags"
              }
            },
            "modifiers":{
              "return":[],
              "field":{
                "1":{
                  "type":"table"
                },
                "ruled.client.delayed_properties":{
                  "type":"table"
                }
              }
            },
            "description":"\n Properties applied after all other categories.",
            "tags":[],
            "section":"table",
            "inferred":true,
            "subparams":{
              "ruled":["ruled.client.delayed_properties"]
            },
            "summary":"Delayed properties.",
            "name":"module.delayed_properties",
            "kind":"tables",
            "lineno":579,
            "args":"()",
            "type":"table"
          },{
            "inferred":true,
            "subparams":[],
            "parameter":"field",
            "params":{
              "1":"c",
              "2":"props",
              "3":"callbacks",
              "map":{
                "props":" Properties to apply.",
                "c":" The client.",
                "callbacks":" Callbacks to apply."
              }
            },
            "summary":"Apply properties and callbacks to a client.",
            "name":"execute",
            "modifiers":{
              "field":{
                "1":{
                  "type":"client"
                },
                "2":{
                  "type":"table"
                },
                "3":{
                  "optchain":true,
                  "type":"table",
                  "opt":true
                },
                "props":{
                  "type":"table"
                },
                "c":{
                  "type":"client"
                },
                "callbacks":{
                  "optchain":true,
                  "type":"table",
                  "opt":true
                }
              },
              "return":[],
              "param":{
                "1":{
                  "type":"client"
                },
                "2":{
                  "type":"table"
                },
                "3":{
                  "optchain":true,
                  "type":"table",
                  "opt":true
                },
                "props":{
                  "type":"table"
                },
                "c":{
                  "type":"client"
                },
                "callbacks":{
                  "optchain":true,
                  "type":"table",
                  "opt":true
                }
              },
              "request":[[]]
            },
            "description":"",
            "type":"staticfct",
            "section":"staticfct",
            "kind":"static module functions",
            "args":"(c, props[, callbacks])",
            "tags":{
              "request":["client titlebars rules granted The `titlebars_enabled` is set in the\n  rules."]
            },
            "lineno":726
          },{
            "parameter":"field",
            "params":{
              "1":"table",
              "map":{
                "table":""
              }
            },
            "modifiers":{
              "see":[[]],
              "return":[],
              "param":{
                "1":[],
                "table":[]
              },
              "field":{
                "1":[],
                "table":[]
              }
            },
            "description":"",
            "tags":{
              "see":[]
            },
            "section":"rulecomponent",
            "inferred":true,
            "subparams":[],
            "summary":"A table whose content will be used to set the target object properties.",
            "name":"properties",
            "type":"rulecomponent",
            "args":"(table)",
            "kind":"rule components",
            "lineno":874
          },{
            "inferred":true,
            "subparams":[],
            "parameter":"field",
            "params":{
              "1":"function",
              "map":{
                "function":""
              }
            },
            "summary":"A callback function to call *before* the `properties` have been applied.",
            "name":"callback",
            "modifiers":{
              "return":[],
              "param":{
                "1":[],
                "function":[]
              },
              "field":{
                "1":[],
                "function":[]
              }
            },
            "description":"\n\n The callback is called with the current client as first argument.\n",
            "type":"rulecomponent",
            "section":"rulecomponent",
            "kind":"rule components",
            "args":"(function)",
            "tags":[],
            "lineno":884
          },{
            "parameter":"field",
            "params":{
              "1":"table",
              "map":{
                "table":""
              }
            },
            "modifiers":{
              "see":[[],[]],
              "return":[],
              "param":{
                "1":[],
                "table":[]
              },
              "field":{
                "1":[],
                "table":[]
              }
            },
            "description":"",
            "tags":{
              "see":[]
            },
            "section":"rulecomponent",
            "inferred":true,
            "subparams":[],
            "summary":"A table whose content will be compared to the target object current properties.",
            "name":"rule",
            "type":"rulecomponent",
            "args":"(table)",
            "kind":"rule components",
            "lineno":891
          },{
            "parameter":"field",
            "params":{
              "1":"table",
              "map":{
                "table":""
              }
            },
            "modifiers":{
              "see":[[],[]],
              "return":[],
              "param":{
                "1":[],
                "table":[]
              },
              "field":{
                "1":[],
                "table":[]
              }
            },
            "description":"\n\n",
            "tags":{
              "see":[]
            },
            "section":"rulecomponent",
            "inferred":true,
            "subparams":[],
            "summary":"Similar to `rule`, but each entry is a table with multiple values.",
            "name":"rule_any",
            "type":"rulecomponent",
            "args":"(table)",
            "kind":"rule components",
            "lineno":899
          },{
            "parameter":"field",
            "params":{
              "1":"table",
              "map":{
                "table":""
              }
            },
            "modifiers":{
              "see":[[],[]],
              "return":[],
              "param":{
                "1":[],
                "table":[]
              },
              "field":{
                "1":[],
                "table":[]
              }
            },
            "description":"",
            "tags":{
              "see":[]
            },
            "section":"rulecomponent",
            "inferred":true,
            "subparams":[],
            "summary":"The negative equivalent of `rule`.",
            "name":"except",
            "type":"rulecomponent",
            "args":"(table)",
            "kind":"rule components",
            "lineno":906
          },{
            "parameter":"field",
            "params":{
              "1":"table",
              "map":{
                "table":""
              }
            },
            "modifiers":{
              "see":[[],[]],
              "return":[],
              "param":{
                "1":[],
                "table":[]
              },
              "field":{
                "1":[],
                "table":[]
              }
            },
            "description":"",
            "tags":{
              "see":[]
            },
            "section":"rulecomponent",
            "inferred":true,
            "subparams":[],
            "summary":"The negative equivalent of `rule_any`.",
            "name":"except_any",
            "type":"rulecomponent",
            "args":"(table)",
            "kind":"rule components",
            "lineno":913
          },{
            "parameter":"field",
            "params":{
              "1":"table",
              "map":{
                "table":""
              }
            },
            "modifiers":{
              "see":[[],[]],
              "return":[],
              "param":{
                "1":[],
                "table":[]
              },
              "field":{
                "1":[],
                "table":[]
              }
            },
            "description":"",
            "tags":{
              "see":[]
            },
            "section":"rulecomponent",
            "inferred":true,
            "subparams":[],
            "summary":"Matches when one of every \\\"category\\\" of components match.",
            "name":"rule_every",
            "type":"rulecomponent",
            "args":"(table)",
            "kind":"rule components",
            "lineno":920
          },{
            "parameter":"field",
            "params":{
              "1":"table",
              "map":{
                "table":""
              }
            },
            "modifiers":{
              "see":[[],[]],
              "return":[],
              "param":{
                "1":[],
                "table":[]
              },
              "field":{
                "1":[],
                "table":[]
              }
            },
            "description":"\n\n The comparison will be made using the lesser (`<`) operator.\n",
            "tags":{
              "see":[]
            },
            "section":"rulecomponent",
            "inferred":true,
            "subparams":[],
            "summary":"A table whose content will be compared to the target object current properties.",
            "name":"rule_lesser",
            "type":"rulecomponent",
            "args":"(table)",
            "kind":"rule components",
            "lineno":929
          },{
            "parameter":"field",
            "params":{
              "1":"table",
              "map":{
                "table":""
              }
            },
            "modifiers":{
              "see":[[],[]],
              "return":[],
              "param":{
                "1":[],
                "table":[]
              },
              "field":{
                "1":[],
                "table":[]
              }
            },
            "description":"\n\n The comparison will be made using the greater (`>`) operator.\n",
            "tags":{
              "see":[]
            },
            "section":"rulecomponent",
            "inferred":true,
            "subparams":[],
            "summary":"A table whose content will be compared to the target object current properties.",
            "name":"rule_greater",
            "type":"rulecomponent",
            "args":"(table)",
            "kind":"rule components",
            "lineno":938
          },{
            "inferred":true,
            "subparams":[],
            "parameter":"field",
            "params":{
              "1":"id",
              "map":{
                "id":""
              }
            },
            "summary":"An identifier for this rule.",
            "name":"id",
            "modifiers":{
              "return":[],
              "param":{
                "1":{
                  "type":"table|string|number|function"
                },
                "id":{
                  "type":"table|string|number|function"
                }
              },
              "field":{
                "1":{
                  "type":"table|string|number|function"
                },
                "id":{
                  "type":"table|string|number|function"
                }
              }
            },
            "description":"\n\n It can be anything. It will be compared with the `==` operator. Strings are\n highly recommended.\n\n Setting an `id` is useful to be able to remove the rule by using its id\n instead of a table reference. Modules can also listen to `rule::appended` and\n modify or disable a rule.\n",
            "type":"rulecomponent",
            "section":"rulecomponent",
            "kind":"rule components",
            "args":"(id)",
            "tags":[],
            "lineno":950
          }],
        "type":"ruleslib",
        "file":"/home/cji/portless/awesome/build/lib/ruled/client.lua",
        "package":"",
        "tags":{
          "author":["Julien Danjou &lt;julien@danjou.info&gt;"],
          "copyright":"2009 Julien Danjou"
        },
        "lineno":293
      },
      "name":""
    }],
  "tags":{
    "see":[],
    "author":["Julien Danjou &lt;julien@danjou.info&gt;"],
    "copyright":"2009 Julien Danjou"
  },
  "summary":"A module to build a set of properties based on a graph of rules.",
  "sections":{
    "by_name":[]
  },
  "name":"gears.matcher",
  "modifiers":{
    "see":[[]],
    "author":[[]],
    "copyright":[]
  },
  "package":"gears",
  "type":"module",
  "description":"\n\n Sources\n =======\n\n This module holds the business logic used by `ruled.client`. It provides an\n object on which one can add sets of rules or, alternatively, functions.\n In this module, the sets of rules or custom functions are called sources.\n\n The sources are used to build a property table. Once all sources are\n evaluated, the `:apply()` method will set the properties on the target\n object.\n\n Sources can have dependencies between them and the property table can only\n be built if the sources graph can be resolved.\n\n Rules\n =====\n\n The `rules` sources themselves are composed, as the name imply, of a set of\n rule. A rule is a table with a `properties` *or* `callbacks` attribute along\n with either `rule` or `rule_any`. It is also possible to add an `except` or\n `except_any` attribute to narrow the scope in which the rule is applied.\n Here's a basic example of a minimal `gears.matcher`.\n\n \n\n\n**Usage example output**:\n\n **Usage example:**\n\n\n \n     local o = {\n         foo    = &#34bar&#34,\n         answer = 42,\n     }\n  \n     -- This rule will match\n     local rule1 = {\n         rule = {\n             answer     = 42,\n             everything = true,\n         },\n         properties = {\n             name = &#34baz&#34,\n         },\n     }\n  \n     -- This rule will **not** match\n     local rule2 = {\n         -- When the rule properties are strings, the Lua\n         --pattern matching is used.\n         rule = {\n             foo = &#34[f]+&#34,\n         },\n         properties = {\n             name = &#34foobar&#34,\n         },\n     }\n  \n     local rules = {\n         rule1,\n         rule2,\n     }\n  \n     local matcher = gears.matcher()\n  \n     local function first_source(self, object, props, callbacks) --luacheck: no unused args\n         -- In this callback, you can add new elements to the props and\n         -- callbacks tables. It is not recommended the modify `object` in\n         -- this callback.\n         if object.answer == 42 then\n             props.is_everything = true\n         end\n     end\n  \n     -- This will add a custom function to add properties to the rules.\n     matcher:add_matching_function(&#34first&#34, first_source, {}, {})\n  \n     -- This will add the `rules` to this matcher.\n     matcher:add_matching_rules(&#34second&#34, rules, {&#34first&#34}, {})\n  \n     -- Some properties cannot be checked with the `==` operator (like those\n     -- with multiple possible types). In that case, it is possible to define\n     -- special comparator function.\n     matcher:add_property_matcher(&#34everything&#34, function(obj, value)\n         return value and obj.answer == 42\n     end)\n  \n     -- The same can be done for the property section.\n     matcher:add_property_setter(&#34multiply_by&#34, function(obj, value)\n         obj.answer = (obj.answer or 1) * value\n     end)\n  \n     -- It is possible to append rules to existing (or new) sources.\n     matcher:append_rule( &#34second&#34, {\n         id   = &#34rule_with_id&#34,\n         rule = {\n             has_elite = true,\n         },\n         properties = {\n             multiply_by = &#341337&#34,\n         },\n     })\n  \n     -- Or remove them.\n     matcher:remove_rule(&#34second&#34, &#34rule_with_id&#34)\n  \n     -- Apply the properties to `o`\n     matcher:apply(o)\n\n This example shows the different matching sections:\n\n \n\n\n \n     local matcher = gears.matcher()\n  \n     matcher:append_rule( &#34my.source&#34, {\n         rule = {\n             my_any_rule = true,\n         },\n         rule_every = {\n             every1 = {1, 42},\n             every2 = {2, 42},\n             every3 = {3, 42},\n         },\n         except = {\n             except1 = 1,\n         },\n         properties = {\n             was_a_match = true,\n         },\n     })\n  \n     local candidate1 = {\n         my_any_rule = true,\n         every1      = 1,\n         every2      = 2,\n         every3      = 3,\n         was_a_match = false,\n     }\n  \n     local candidate2 = {\n         every2      = 2,\n         was_a_match = false,\n     }\n  \n     local candidate3 = {\n         my_any_rule = true,\n         was_a_match = false,\n         every1      = 1,\n         every2      = 2,\n         every3      = 3,\n         except1     = 1,\n     }\n  \n     matcher:apply(candidate1)\n     matcher:apply(candidate2)\n     matcher:apply(candidate3)\n  \n     -- Only candidate1 fits all criteria.\n     assert(candidate1.was_a_match == true )\n     assert(candidate2.was_a_match == false)\n     assert(candidate3.was_a_match == false)\n  \n     -- It is also possible to match number property by range.\n     matcher:append_rule( &#34my.source&#34, {\n         rule_greater = {\n             value = 50,\n         },\n         rule_lesser = {\n             value = 100,\n         },\n         properties = {\n             was_a_match = true,\n         },\n     })\n  \n     local candidate4 = { value = 40 , was_a_match = false }\n     local candidate5 = { value = 75 , was_a_match = false }\n     local candidate6 = { value = 101, was_a_match = false }\n  \n     matcher:apply(candidate4)\n     matcher:apply(candidate5)\n     matcher:apply(candidate6)\n  \n     -- Only candidate5 fits all criteria.\n     assert(candidate4.was_a_match == false)\n     assert(candidate5.was_a_match == true )\n     assert(candidate6.was_a_match == false)\n\n More examples are available in `ruled.client`.\n",
  "file":"/home/cji/portless/awesome/build/lib/gears/matcher.lua",
  "mod_name":"matcher",
  "items":[{
      "parameter":"field",
      "params":{
        "1":"rule",
        "2":"source",
        "3":"content",
        "map":{
          "source":" The matching rules source name.",
          "rule":" The rule.",
          "content":" The matching rules source content.",
          "gears.matcher":" The matcher."
        }
      },
      "modifiers":{
        "see":[[],[]],
        "return":[],
        "param":{
          "1":{
            "type":"table"
          },
          "2":{
            "type":"table"
          },
          "3":{
            "type":"table"
          },
          "4":{
            "type":"table"
          },
          "source":{
            "type":"table"
          },
          "rule":{
            "type":"table"
          },
          "content":{
            "type":"table"
          },
          "gears.matcher":{
            "type":"table"
          }
        },
        "field":{
          "1":{
            "type":"table"
          },
          "2":{
            "type":"table"
          },
          "3":{
            "type":"table"
          },
          "4":{
            "type":"table"
          },
          "source":{
            "type":"table"
          },
          "rule":{
            "type":"table"
          },
          "content":{
            "type":"table"
          },
          "gears.matcher":{
            "type":"table"
          }
        }
      },
      "description":"",
      "tags":{
        "see":[]
      },
      "section":"signal",
      "inferred":true,
      "subparams":{
        "gears":["gears.matcher"]
      },
      "summary":"A rule has been added to a set of matching rules.",
      "name":"rule::appended",
      "type":"signal",
      "args":"(rule, source, content)",
      "kind":"signals",
      "lineno":220
    },{
      "parameter":"field",
      "params":{
        "1":"rule",
        "2":"source",
        "3":"content",
        "map":{
          "source":" The matching rules source name.",
          "rule":" The rule.",
          "content":" The matching rules source content.",
          "gears.matcher":" The matcher."
        }
      },
      "modifiers":{
        "see":[[]],
        "return":[],
        "param":{
          "1":{
            "type":"table"
          },
          "2":{
            "type":"table"
          },
          "3":{
            "type":"table"
          },
          "4":{
            "type":"table"
          },
          "source":{
            "type":"table"
          },
          "rule":{
            "type":"table"
          },
          "content":{
            "type":"table"
          },
          "gears.matcher":{
            "type":"table"
          }
        },
        "field":{
          "1":{
            "type":"table"
          },
          "2":{
            "type":"table"
          },
          "3":{
            "type":"table"
          },
          "4":{
            "type":"table"
          },
          "source":{
            "type":"table"
          },
          "rule":{
            "type":"table"
          },
          "content":{
            "type":"table"
          },
          "gears.matcher":{
            "type":"table"
          }
        }
      },
      "description":"",
      "tags":{
        "see":[]
      },
      "section":"signal",
      "inferred":true,
      "subparams":{
        "gears":["gears.matcher"]
      },
      "summary":"A rule has been removed to a set of matching rules.",
      "name":"rule::removed",
      "type":"signal",
      "args":"(rule, source, content)",
      "kind":"signals",
      "lineno":228
    },{
      "parameter":"field",
      "params":{
        "1":"callback",
        "map":{
          "callback":" The callback.",
          "gears.matcher":" The matcher."
        }
      },
      "modifiers":{
        "see":[[]],
        "return":[],
        "param":{
          "1":{
            "type":"table"
          },
          "2":{
            "type":"function"
          },
          "callback":{
            "type":"function"
          },
          "gears.matcher":{
            "type":"table"
          }
        },
        "field":{
          "1":{
            "type":"table"
          },
          "2":{
            "type":"function"
          },
          "callback":{
            "type":"function"
          },
          "gears.matcher":{
            "type":"table"
          }
        }
      },
      "description":"",
      "tags":{
        "see":[]
      },
      "section":"signal",
      "inferred":true,
      "subparams":{
        "gears":["gears.matcher"]
      },
      "summary":"A matching source function has been added.",
      "name":"matching_function::added",
      "type":"signal",
      "args":"(callback)",
      "kind":"signals",
      "lineno":234
    },{
      "parameter":"field",
      "params":{
        "1":"callback",
        "map":{
          "callback":" The callback.",
          "gears.matcher":" The matcher."
        }
      },
      "modifiers":{
        "see":[[]],
        "return":[],
        "param":{
          "1":{
            "type":"table"
          },
          "2":{
            "type":"function"
          },
          "callback":{
            "type":"function"
          },
          "gears.matcher":{
            "type":"table"
          }
        },
        "field":{
          "1":{
            "type":"table"
          },
          "2":{
            "type":"function"
          },
          "callback":{
            "type":"function"
          },
          "gears.matcher":{
            "type":"table"
          }
        }
      },
      "description":"",
      "tags":{
        "see":[]
      },
      "section":"signal",
      "inferred":true,
      "subparams":{
        "gears":["gears.matcher"]
      },
      "summary":"A matching source table has been added.",
      "name":"matching_rules::added",
      "type":"signal",
      "args":"(callback)",
      "kind":"signals",
      "lineno":240
    },{
      "parameter":"field",
      "params":{
        "map":{
          "gears.matcher":" The matcher."
        }
      },
      "modifiers":{
        "see":[[]],
        "return":[],
        "param":{
          "1":{
            "type":"table"
          },
          "gears.matcher":{
            "type":"table"
          }
        },
        "field":{
          "1":{
            "type":"table"
          },
          "gears.matcher":{
            "type":"table"
          }
        }
      },
      "description":"",
      "tags":{
        "see":[]
      },
      "section":"signal",
      "inferred":true,
      "subparams":{
        "gears":["gears.matcher"]
      },
      "summary":"A matching source function has been removed.",
      "name":"matching_source::removed",
      "type":"signal",
      "args":"()",
      "kind":"signals",
      "lineno":245
    },{
      "inferred":true,
      "subparams":[],
      "parameter":"field",
      "params":{
        "1":"o",
        "2":"entry",
        "map":{
          "o":" The object.",
          "entry":" Rule entry (with keys `rule`, `rule_any`, `except` and/or\n   `except_any`)."
        }
      },
      "summary":"Does a given rule entry match an object?",
      "name":"matches_rule",
      "modifiers":{
        "return":[{
            "type":"boolean"
          }],
        "param":{
          "1":[],
          "2":{
            "type":"table"
          },
          "o":[],
          "entry":{
            "type":"table"
          }
        },
        "field":{
          "1":[],
          "2":{
            "type":"table"
          },
          "o":[],
          "entry":{
            "type":"table"
          }
        }
      },
      "description":"",
      "type":"method",
      "section":"method",
      "kind":"object methods ",
      "args":"(o, entry)",
      "tags":[],
      "lineno":358
    },{
      "inferred":true,
      "subparams":[],
      "parameter":"field",
      "params":{
        "1":"o",
        "2":"rules",
        "map":{
          "o":" The object.",
          "rules":" The rules to check. List with \"rule\", \"rule_any\",\n  \"except\" and \"except_any\" keys. If no rules are provided, all rules\n  registered with a source will be matched."
        }
      },
      "summary":"Get list of matching rules for an object.",
      "name":"matching_rules",
      "modifiers":{
        "return":[],
        "param":{
          "1":[],
          "2":{
            "optchain":"nil",
            "type":"table",
            "opt":"nil"
          },
          "o":[],
          "rules":{
            "optchain":"nil",
            "type":"table",
            "opt":"nil"
          }
        },
        "field":{
          "1":[],
          "2":{
            "optchain":"nil",
            "type":"table",
            "opt":"nil"
          },
          "o":[],
          "rules":{
            "optchain":"nil",
            "type":"table",
            "opt":"nil"
          }
        }
      },
      "description":"\n\n If the `rules` argument is not provided, the rules added with\n `add_matching_rules` will be used.\n",
      "type":"method",
      "section":"method",
      "kind":"object methods ",
      "args":"(o[, rules=nil])",
      "tags":[],
      "lineno":392
    },{
      "inferred":true,
      "subparams":[],
      "parameter":"field",
      "params":{
        "1":"o",
        "2":"rules",
        "map":{
          "o":" The object.",
          "rules":" The rules to check. List of tables with `rule`,\n  `rule_any`, `except` and `except_any` keys."
        }
      },
      "summary":"Check if an object matches a given set of rules.",
      "name":"matches_rules",
      "modifiers":{
        "return":[{
            "type":"boolean"
          }],
        "param":{
          "1":[],
          "2":{
            "type":"table"
          },
          "o":[],
          "rules":{
            "type":"table"
          }
        },
        "field":{
          "1":[],
          "2":{
            "type":"table"
          },
          "o":[],
          "rules":{
            "type":"table"
          }
        }
      },
      "description":"",
      "type":"method",
      "section":"method",
      "kind":"object methods ",
      "args":"(o, rules)",
      "tags":[],
      "lineno":426
    },{
      "parameter":"field",
      "params":{
        "1":"name",
        "2":"f",
        "map":{
          "name":" The property name.",
          "f":" The matching function."
        }
      },
      "modifiers":{
        "field":{
          "1":{
            "type":"string"
          },
          "2":{
            "type":"function"
          },
          "name":{
            "type":"string"
          },
          "f":{
            "type":"function"
          }
        },
        "return":[],
        "param":{
          "1":{
            "type":"string"
          },
          "2":{
            "type":"function"
          },
          "name":{
            "type":"string"
          },
          "f":{
            "type":"function"
          }
        },
        "usage":[[]]
      },
      "description":"\n\n The default matcher uses the `==` operator for all types. It also uses the\n `:match()` method for string and allows pattern matching. If the value is a\n function, then that function is called with the object and the current\n properties to be applied. If the function returns true, the match is\n accepted.\n\n Custom property matcher are useful when objects are compared. This avoids\n having to implement custom metatable for everything.\n\n The `f` function receives 3 arguments:\n\n * The object to match against (anything)\n * The value to compare\n * The property/field name.\n\n It should return `true` if it matches and `false` otherwise.\n",
      "tags":[],
      "section":"method",
      "inferred":true,
      "subparams":[],
      "summary":"Assign a function to match an object property against a value.",
      "name":"add_property_matcher",
      "kind":"object methods ",
      "usage":["-- Manually match the screen in various ways.\nmatcher:add_property_matcher(\"screen\", function(c, value)\n   return c.screen == value\n       or screen[c.screen] == value\n       or c.screen.outputs[value] ~= nil\n       or value == \"any\"\n       or (value == \"primary\" and c.screen == screen.primary)\nend)\n"],
      "args":"(name, f)",
      "type":"method",
      "lineno":466
    },{
      "inferred":true,
      "subparams":[],
      "parameter":"field",
      "params":{
        "1":"name",
        "2":"f",
        "map":{
          "name":" The property name.",
          "f":" The setter function."
        }
      },
      "summary":"Add a special setter for a property.",
      "name":"add_property_setter",
      "modifiers":{
        "return":[],
        "param":{
          "1":{
            "type":"string"
          },
          "2":{
            "type":"function"
          },
          "name":{
            "type":"string"
          },
          "f":{
            "type":"function"
          }
        },
        "field":{
          "1":{
            "type":"string"
          },
          "2":{
            "type":"function"
          },
          "name":{
            "type":"string"
          },
          "f":{
            "type":"function"
          }
        }
      },
      "description":"\n\n This is useful to add more properties to object which only make sense within\n the context of a rule.\n",
      "type":"method",
      "section":"method",
      "kind":"object methods ",
      "args":"(name, f)",
      "tags":[],
      "lineno":482
    },{
      "inferred":true,
      "subparams":[],
      "parameter":"field",
      "params":{
        "1":"name",
        "2":"rules",
        "3":"depends_on",
        "4":"precede",
        "map":{
          "depends_on":" A list of names of sources this source\n  depends on (sources that must be executed *before* `name`).",
          "precede":" A list of names of sources this source has a\n  priority over.",
          "name":" The provider name. It must be unique.",
          "rules":" A set of rules (see how they work at the top of this\n  page)."
        }
      },
      "summary":"Add a set of matching rules.",
      "name":"add_matching_rules",
      "modifiers":{
        "return":[{
            "type":"boolean"
          }],
        "param":{
          "1":{
            "type":"string"
          },
          "2":{
            "type":"table"
          },
          "3":{
            "optchain":"{}",
            "type":"table",
            "opt":"{}"
          },
          "4":{
            "optchain":"{}",
            "type":"table",
            "opt":"{}"
          },
          "depends_on":{
            "optchain":"{}",
            "type":"table",
            "opt":"{}"
          },
          "precede":{
            "optchain":"{}",
            "type":"table",
            "opt":"{}"
          },
          "name":{
            "type":"string"
          },
          "rules":{
            "type":"table"
          }
        },
        "field":{
          "1":{
            "type":"string"
          },
          "2":{
            "type":"table"
          },
          "3":{
            "optchain":"{}",
            "type":"table",
            "opt":"{}"
          },
          "4":{
            "optchain":"{}",
            "type":"table",
            "opt":"{}"
          },
          "depends_on":{
            "optchain":"{}",
            "type":"table",
            "opt":"{}"
          },
          "precede":{
            "optchain":"{}",
            "type":"table",
            "opt":"{}"
          },
          "name":{
            "type":"string"
          },
          "rules":{
            "type":"table"
          }
        }
      },
      "description":"",
      "type":"method",
      "section":"method",
      "kind":"object methods ",
      "args":"(name, rules[, depends_on={}[, precede={}]])",
      "tags":[],
      "lineno":524
    },{
      "inferred":true,
      "subparams":{
        "callback":["callback.self","callback.o","callback.properties","callback.callbacks"]
      },
      "parameter":"field",
      "params":{
        "1":"name",
        "2":"callback",
        "3":"depends_on",
        "4":"precede",
        "map":{
          "callback.callbacks":" A table of all callbacks scheduled to be\n  executed after the main properties are applied.",
          "precede":" A list of names of sources this source has a\n  priority over.",
          "depends_on":" A list of names of sources this source depends on\n  (sources that must be executed *before* `name`).",
          "callback.properties":" The current properties. The callback should\n  add to and overwrite properties in this table.",
          "callback":" The callback that is called to produce properties.",
          "callback.o":" The object.",
          "name":" The provider name. It must be unique.",
          "callback.self":" The matcher object."
        }
      },
      "summary":"Add a matching function.",
      "name":"add_matching_function",
      "modifiers":{
        "return":[{
            "type":"boolean"
          }],
        "param":{
          "1":{
            "type":"string"
          },
          "2":{
            "type":"function"
          },
          "3":{
            "type":"gears.matcher"
          },
          "4":[],
          "5":{
            "type":"table"
          },
          "6":{
            "type":"table"
          },
          "7":{
            "type":"table",
            "opt":"{}"
          },
          "8":{
            "type":"table",
            "opt":"{}"
          },
          "callback.callbacks":{
            "type":"table"
          },
          "precede":{
            "type":"table",
            "opt":"{}"
          },
          "depends_on":{
            "type":"table",
            "opt":"{}"
          },
          "callback.properties":{
            "type":"table"
          },
          "callback":{
            "type":"function"
          },
          "callback.o":[],
          "name":{
            "type":"string"
          },
          "callback.self":{
            "type":"gears.matcher"
          }
        },
        "field":{
          "1":{
            "type":"string"
          },
          "2":{
            "type":"function"
          },
          "3":{
            "type":"gears.matcher"
          },
          "4":[],
          "5":{
            "type":"table"
          },
          "6":{
            "type":"table"
          },
          "7":{
            "type":"table",
            "opt":"{}"
          },
          "8":{
            "type":"table",
            "opt":"{}"
          },
          "callback.callbacks":{
            "type":"table"
          },
          "precede":{
            "type":"table",
            "opt":"{}"
          },
          "depends_on":{
            "type":"table",
            "opt":"{}"
          },
          "callback.properties":{
            "type":"table"
          },
          "callback":{
            "type":"function"
          },
          "callback.o":[],
          "name":{
            "type":"string"
          },
          "callback.self":{
            "type":"gears.matcher"
          }
        }
      },
      "description":"",
      "type":"method",
      "section":"method",
      "kind":"object methods ",
      "args":"(name, callback, depends_on, precede)",
      "tags":[],
      "lineno":552
    },{
      "inferred":true,
      "subparams":[],
      "parameter":"field",
      "params":{
        "1":"name",
        "map":{
          "name":" The source name."
        }
      },
      "summary":"Remove a source.",
      "name":"remove_matching_source",
      "modifiers":{
        "return":[{
            "type":"boolean"
          }],
        "param":{
          "1":{
            "type":"string"
          },
          "name":{
            "type":"string"
          }
        },
        "field":{
          "1":{
            "type":"string"
          },
          "name":{
            "type":"string"
          }
        }
      },
      "description":"\n\n This removes sources added with `add_matching_function` or\n `add_matching_rules`.\n",
      "type":"method",
      "section":"method",
      "kind":"object methods ",
      "args":"(name)",
      "tags":[],
      "lineno":615
    },{
      "inferred":true,
      "subparams":[],
      "parameter":"field",
      "params":{
        "1":"o",
        "map":{
          "o":" The object."
        }
      },
      "summary":"Apply ruled.client.rules to an object.",
      "name":"apply",
      "modifiers":{
        "return":[],
        "param":{
          "1":[],
          "o":[]
        },
        "field":{
          "1":[],
          "o":[]
        }
      },
      "description":"\n\n Calling this will apply all properties provided by the matching functions\n and rules.\n",
      "type":"method",
      "section":"method",
      "kind":"object methods ",
      "args":"(o)",
      "tags":[],
      "lineno":639
    },{
      "inferred":true,
      "subparams":[],
      "parameter":"field",
      "params":{
        "1":"source",
        "2":"rule",
        "map":{
          "source":" The source name.",
          "rule":" A valid rule."
        }
      },
      "summary":"Add a new rule to the default set.",
      "name":"append_rule",
      "modifiers":{
        "return":[],
        "param":{
          "1":{
            "type":"string"
          },
          "2":{
            "type":"table"
          },
          "source":{
            "type":"string"
          },
          "rule":{
            "type":"table"
          }
        },
        "field":{
          "1":{
            "type":"string"
          },
          "2":{
            "type":"table"
          },
          "source":{
            "type":"string"
          },
          "rule":{
            "type":"table"
          }
        }
      },
      "description":"",
      "type":"method",
      "section":"method",
      "kind":"object methods ",
      "args":"(source, rule)",
      "tags":[],
      "lineno":681
    },{
      "inferred":true,
      "subparams":[],
      "parameter":"field",
      "params":{
        "1":"source",
        "2":"rules",
        "map":{
          "source":" The source name.",
          "rules":" A table with rules."
        }
      },
      "summary":"Add a new rules to the default set.",
      "name":"append_rules",
      "modifiers":{
        "return":[],
        "param":{
          "1":{
            "type":"string"
          },
          "2":{
            "type":"table"
          },
          "source":{
            "type":"string"
          },
          "rules":{
            "type":"table"
          }
        },
        "field":{
          "1":{
            "type":"string"
          },
          "2":{
            "type":"table"
          },
          "source":{
            "type":"string"
          },
          "rules":{
            "type":"table"
          }
        }
      },
      "description":"",
      "type":"method",
      "section":"method",
      "kind":"object methods ",
      "args":"(source, rules)",
      "tags":[],
      "lineno":693
    },{
      "inferred":true,
      "subparams":[],
      "parameter":"field",
      "params":{
        "1":"source",
        "2":"rule",
        "map":{
          "source":" The source name.",
          "rule":" An existing rule or its `id`."
        }
      },
      "summary":"Remove a new rule from the default set.",
      "name":"remove_rule",
      "modifiers":{
        "return":[{
            "type":"boolean"
          }],
        "param":{
          "1":{
            "type":"string"
          },
          "2":{
            "type":"string|table"
          },
          "source":{
            "type":"string"
          },
          "rule":{
            "type":"string|table"
          }
        },
        "field":{
          "1":{
            "type":"string"
          },
          "2":{
            "type":"string|table"
          },
          "source":{
            "type":"string"
          },
          "rule":{
            "type":"string|table"
          }
        }
      },
      "description":"",
      "type":"method",
      "section":"method",
      "kind":"object methods ",
      "args":"(source, rule)",
      "tags":[],
      "lineno":704
    },{
      "inferred":true,
      "subparams":[],
      "parameter":"field",
      "params":{
        "map":[]
      },
      "summary":"Create a new rule solver object.",
      "name":"gears.matcher",
      "modifiers":{
        "field":[],
        "return":[[]]
      },
      "description":"",
      "type":"constructorfct",
      "section":"constructorfct",
      "kind":"constructors",
      "args":"()",
      "tags":[],
      "lineno":724
    },{
      "parameter":"field",
      "params":{
        "1":"table",
        "map":{
          "table":""
        }
      },
      "modifiers":{
        "see":[[]],
        "return":[],
        "param":{
          "1":[],
          "table":[]
        },
        "field":{
          "1":[],
          "table":[]
        }
      },
      "description":"",
      "tags":{
        "see":[]
      },
      "section":"rulecomponent",
      "inferred":true,
      "subparams":[],
      "summary":"A table whose content will be used to set the target object properties.",
      "name":"properties",
      "type":"rulecomponent",
      "args":"(table)",
      "kind":"rule components",
      "lineno":753
    },{
      "inferred":true,
      "subparams":[],
      "parameter":"field",
      "params":{
        "1":"function",
        "map":{
          "function":""
        }
      },
      "summary":"A callback function to call *before* the `properties` have been applied.",
      "name":"callback",
      "modifiers":{
        "return":[],
        "param":{
          "1":[],
          "function":[]
        },
        "field":{
          "1":[],
          "function":[]
        }
      },
      "description":"\n\n The callback is called with the current client as first argument.\n",
      "type":"rulecomponent",
      "section":"rulecomponent",
      "kind":"rule components",
      "args":"(function)",
      "tags":[],
      "lineno":763
    },{
      "parameter":"field",
      "params":{
        "1":"table",
        "map":{
          "table":""
        }
      },
      "modifiers":{
        "see":[[],[]],
        "return":[],
        "param":{
          "1":[],
          "table":[]
        },
        "field":{
          "1":[],
          "table":[]
        }
      },
      "description":"",
      "tags":{
        "see":[]
      },
      "section":"rulecomponent",
      "inferred":true,
      "subparams":[],
      "summary":"A table whose content will be compared to the target object current properties.",
      "name":"rule",
      "type":"rulecomponent",
      "args":"(table)",
      "kind":"rule components",
      "lineno":770
    },{
      "parameter":"field",
      "params":{
        "1":"table",
        "map":{
          "table":""
        }
      },
      "modifiers":{
        "see":[[],[]],
        "return":[],
        "param":{
          "1":[],
          "table":[]
        },
        "field":{
          "1":[],
          "table":[]
        }
      },
      "description":"\n\n",
      "tags":{
        "see":[]
      },
      "section":"rulecomponent",
      "inferred":true,
      "subparams":[],
      "summary":"Similar to `rule`, but each entry is a table with multiple values.",
      "name":"rule_any",
      "type":"rulecomponent",
      "args":"(table)",
      "kind":"rule components",
      "lineno":778
    },{
      "parameter":"field",
      "params":{
        "1":"table",
        "map":{
          "table":""
        }
      },
      "modifiers":{
        "see":[[],[]],
        "return":[],
        "param":{
          "1":[],
          "table":[]
        },
        "field":{
          "1":[],
          "table":[]
        }
      },
      "description":"",
      "tags":{
        "see":[]
      },
      "section":"rulecomponent",
      "inferred":true,
      "subparams":[],
      "summary":"The negative equivalent of `rule`.",
      "name":"except",
      "type":"rulecomponent",
      "args":"(table)",
      "kind":"rule components",
      "lineno":785
    },{
      "parameter":"field",
      "params":{
        "1":"table",
        "map":{
          "table":""
        }
      },
      "modifiers":{
        "see":[[],[]],
        "return":[],
        "param":{
          "1":[],
          "table":[]
        },
        "field":{
          "1":[],
          "table":[]
        }
      },
      "description":"",
      "tags":{
        "see":[]
      },
      "section":"rulecomponent",
      "inferred":true,
      "subparams":[],
      "summary":"The negative equivalent of `rule_any`.",
      "name":"except_any",
      "type":"rulecomponent",
      "args":"(table)",
      "kind":"rule components",
      "lineno":792
    },{
      "parameter":"field",
      "params":{
        "1":"table",
        "map":{
          "table":""
        }
      },
      "modifiers":{
        "see":[[],[]],
        "return":[],
        "param":{
          "1":[],
          "table":[]
        },
        "field":{
          "1":[],
          "table":[]
        }
      },
      "description":"",
      "tags":{
        "see":[]
      },
      "section":"rulecomponent",
      "inferred":true,
      "subparams":[],
      "summary":"Matches when one of every \\\"category\\\" of components match.",
      "name":"rule_every",
      "type":"rulecomponent",
      "args":"(table)",
      "kind":"rule components",
      "lineno":799
    },{
      "parameter":"field",
      "params":{
        "1":"table",
        "map":{
          "table":""
        }
      },
      "modifiers":{
        "see":[[],[]],
        "return":[],
        "param":{
          "1":[],
          "table":[]
        },
        "field":{
          "1":[],
          "table":[]
        }
      },
      "description":"\n\n The comparison will be made using the lesser (`<`) operator.\n",
      "tags":{
        "see":[]
      },
      "section":"rulecomponent",
      "inferred":true,
      "subparams":[],
      "summary":"A table whose content will be compared to the target object current properties.",
      "name":"rule_lesser",
      "type":"rulecomponent",
      "args":"(table)",
      "kind":"rule components",
      "lineno":808
    },{
      "parameter":"field",
      "params":{
        "1":"table",
        "map":{
          "table":""
        }
      },
      "modifiers":{
        "see":[[],[]],
        "return":[],
        "param":{
          "1":[],
          "table":[]
        },
        "field":{
          "1":[],
          "table":[]
        }
      },
      "description":"\n\n The comparison will be made using the greater (`>`) operator.\n",
      "tags":{
        "see":[]
      },
      "section":"rulecomponent",
      "inferred":true,
      "subparams":[],
      "summary":"A table whose content will be compared to the target object current properties.",
      "name":"rule_greater",
      "type":"rulecomponent",
      "args":"(table)",
      "kind":"rule components",
      "lineno":817
    },{
      "inferred":true,
      "subparams":[],
      "parameter":"field",
      "params":{
        "1":"id",
        "map":{
          "id":""
        }
      },
      "summary":"An identifier for this rule.",
      "name":"id",
      "modifiers":{
        "return":[],
        "param":{
          "1":{
            "type":"table|string|number|function"
          },
          "id":{
            "type":"table|string|number|function"
          }
        },
        "field":{
          "1":{
            "type":"table|string|number|function"
          },
          "id":{
            "type":"table|string|number|function"
          }
        }
      },
      "description":"\n\n It can be anything. It will be compared with the `==` operator. Strings are\n highly recommended.\n\n Setting an `id` is useful to be able to remove the rule by using its id\n instead of a table reference. Modules can also listen to `rule::appended` and\n modify or disable a rule.\n",
      "type":"rulecomponent",
      "section":"rulecomponent",
      "kind":"rule components",
      "args":"(id)",
      "tags":[],
      "lineno":829
    },{
      "inferred":true,
      "subparams":[],
      "parameter":"field",
      "params":{
        "1":"name",
        "2":"...",
        "map":{
          "name":" The name of the signal.",
          "...":" Extra arguments for the callback functions. Each connected\n   function receives the object as first argument and then any extra\n   arguments that are given to emit_signal()."
        }
      },
      "summary":"Emit a signal.",
      "name":"emit_signal",
      "modifiers":{
        "return":[],
        "baseclass":[[]],
        "param":{
          "1":{
            "type":"string"
          },
          "2":[],
          "name":{
            "type":"string"
          },
          "...":[]
        },
        "field":{
          "1":{
            "type":"string"
          },
          "2":[],
          "name":{
            "type":"string"
          },
          "...":[]
        }
      },
      "description":"",
      "type":"method",
      "section":"method",
      "kind":"object methods ",
      "args":"(name, ...)",
      "tags":{
        "baseclass":["gears.object"]
      },
      "lineno":845
    },{
      "inferred":true,
      "subparams":[],
      "parameter":"field",
      "params":{
        "1":"name",
        "2":"func",
        "map":{
          "name":" The name of the signal.",
          "func":" The callback to call when the signal is emitted."
        }
      },
      "summary":"Connect to a signal.",
      "name":"connect_signal",
      "modifiers":{
        "return":[],
        "baseclass":[[]],
        "param":{
          "1":{
            "type":"string"
          },
          "2":{
            "type":"function"
          },
          "name":{
            "type":"string"
          },
          "func":{
            "type":"function"
          }
        },
        "field":{
          "1":{
            "type":"string"
          },
          "2":{
            "type":"function"
          },
          "name":{
            "type":"string"
          },
          "func":{
            "type":"function"
          }
        }
      },
      "description":"",
      "type":"method",
      "section":"method",
      "kind":"object methods ",
      "args":"(name, func)",
      "tags":{
        "baseclass":["gears.object"]
      },
      "lineno":851
    },{
      "inferred":true,
      "subparams":[],
      "parameter":"field",
      "params":{
        "1":"name",
        "2":"func",
        "map":{
          "name":" The name of the signal.",
          "func":" The callback to call when the signal is emitted."
        }
      },
      "summary":"Connect to a signal weakly.",
      "name":"weak_connect_signal",
      "modifiers":{
        "return":[],
        "baseclass":[[]],
        "param":{
          "1":{
            "type":"string"
          },
          "2":{
            "type":"function"
          },
          "name":{
            "type":"string"
          },
          "func":{
            "type":"function"
          }
        },
        "field":{
          "1":{
            "type":"string"
          },
          "2":{
            "type":"function"
          },
          "name":{
            "type":"string"
          },
          "func":{
            "type":"function"
          }
        }
      },
      "description":"\n\n This allows the callback function to be garbage collected and\n automatically disconnects the signal when that happens.\n\n **Warning:**\n Only use this function if you really, really, really know what you\n are doing.",
      "type":"method",
      "section":"method",
      "kind":"object methods ",
      "args":"(name, func)",
      "tags":{
        "baseclass":["gears.object"]
      },
      "lineno":864
    }],
  "lineno":203
}