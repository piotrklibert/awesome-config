{
  "kind":"documentation",
  "postprocess":<type 'function' is not supported by JSON.>,
  "display_name":"Creating new widget",
  "body":"# Creating new widget\n\nAll widgets have to be generated by the `wibox.widget.base.make_widget` function\nso that the needed signals are added and mouse input handling is set up.\n\nThe returned widget will have a `:buttons` member function that can be used to\nregister a set of mouse button events with the widget.\n\nTo implement your own widget, you can implement some member functions on a\nfreshly-created widget. Note that all of these functions should be deterministic\nin the sense that they will show the same behavior if they are repeatedly called\nwith the same arguments (same width and height). If your widget is updated and\nneeds to change, suitable signals have to be emitted. This will be explained\nlater.\n\nThe first callback is `:fit`. This function is called to select the size of your\nwidget. The arguments to this function are the available space and it should\nreturn its desired size. Note that this function only provides a hint which is\nnot necessarily followed. The widget must also be able to draw itself at\ndifferent sizes than the one requested.\n\n    function widget:fit(context, width, height)\n        -- Find the maximum square available\n        local m = math.min(width, height)\n        return m, m\n    end\n\nThe next callback is `:draw`. As the name suggests, this function is called to\ndraw the widget. The arguments to this function are the context that the widget is\ndrawn in, the Cairo context on which it should be drawn and the widget's size.\nThe Cairo context is set up in such a way that the widget has its top-left corner\nat (0, 0) and its bottom-right corner at (width, height). In other words, no\nspecial transformation needs to be done. Note that during this callback a\nsuitable clip will already be applied to the Cairo context so that this callback\nwill not be able to draw outside of the area that was registered for the widget\nby the layout that placed this widget. You should not call `cr:reset_clip()`, as\nredraws will not be handled correctly in this case.\n\n    function widget:draw(context, cr, width, height)\n        cr:move_to(0, 0)\n        cr:line_to(width, height)\n        cr:move_to(0, height)\n        cr:line_to(width, 0)\n        cr:stroke()\n    end\n\nThere are two signals configured for a widget. When the result that `:fit` would\nreturn changes, the `widget::layout_changed` signal has to be emitted. If this\nactually causes layout changes, the affected areas will be redrawn. The other\nsignal is `widget::redraw_needed`. This signal signals that `:draw` has to be\ncalled to redraw the widget, but it is safe to assume that `:fit` does still\nreturn the same values as before. If in doubt, you can emit both signals to be\nsafe.\n\nIf your widget only needs to draw something to the screen, the above is all that\nis needed. The following callbacks can be used when implementing layouts which\nplace other widgets on the screen.\n\nThe `:layout` callback is used to figure out which other widgets should be drawn\nrelative to this widget. Note that it is allowed to place widgets outside of the\nextents of your own widget, for example at a negative position or at twice the\nsize of this widget. Use this mechanism if your widget needs to draw outside of\nits own extents. If the result of this callback changes,\n`widget::layout_changed` has to be emitted. You can use `:fit_widget` to call\nthe `:fit` callback of other widgets. Never call `:fit` directly!  For example,\nif you want to place another widget `child` inside of your widget, you can do it\nlike this:\n\n    -- For readability\n    local base = wibox.widget.base\n    function widget:layout(width, height)\n        local result = {}\n        table.insert(result, base.place_widget_at(child, width/2, 0, width/2, height)\n        return result\n    end\n\nFinally, if you want to influence how children are drawn, there are four\ncallbacks available that all get similar arguments:\n\n    function widget:before_draw_children(context, cr, width, height)\n    function widget:after_draw_children(context, cr, width, height)\n    function widget:before_draw_child(context, index, child, cr, width, height)\n    function widget:after_draw_child(context, index, child, cr, width, height)\n\nAll of these are called with the same arguments as the `:draw()` method. Please\nnote that a larger clip will be active during these callbacks that also contains\nthe area of all children. These callbacks can be used to influence the way in\nwhich children are drawn, but they should not cause the drawing to cover a\ndifferent area. As an example, these functions can be used to draw children\ntranslucently:\n\n    function widget:before_draw_children(context, cr, width, height)\n        cr:push_group()\n    end\n    function widget:after_draw_children(context, cr, width, height)\n        cr:pop_group_to_source()\n        cr:paint_with_alpha(0.5)\n    end\n\nIn pseudo-code, the call sequence for the drawing callbacks during a redraw\nlooks like this:\n\n    widget:draw(context, cr, width, height)\n    widget:before_draw_children(context, cr, width, height)\n    for child do\n        widget:before_draw_child(context, cr, child_index, child, width, height)\n        cr:save()\n        -- Draw child and all of its children recursively, taking into account the\n        -- position and size given to base.place_widget_at() in :layout().\n        cr:restore()\n        widget:after_draw_child(context, cr, child_index, child, width, height)\n    end\n    widget:after_draw_children(context, cr, width, height)\n\nThe `:set_children()` method gets called recursively when setting a widget with\nthe declarative layout system, therefore the method should be well defined.\nIt should probably hook into the `:add` or `:add_widget` methods or be\noverridden to do nothing.\n",
  "sections":{
    "by_name":[]
  },
  "name":"04-new-widgets.md",
  "modifiers":[],
  "mod_name":"04-new-widgets.md",
  "type":"topic",
  "items":[],
  "file":"/home/cji/portless/awesome/build/docs/04-new-widgets.md",
  "package":"",
  "tags":[],
  "lineno":1
}