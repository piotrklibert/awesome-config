{
  "name":"test-data.lua",
  "postprocess":"<type 'function' is not supported by JSON.>",
  "kind":"examples",
  "file":"/home/cji/portless/Penlight/tests/test-data.lua",
  "tags":[],
  "sections":{
    "by_name":[]
  },
  "items":[],
  "lineno":1,
  "mod_name":"test-data.lua",
  "package":"",
  "modifiers":[],
  "type":"example",
  "body":"local data = require 'pl.data'\nlocal List = require 'pl.List'\nlocal array = require 'pl.array2d'\nlocal func = require 'pl.func'\nlocal seq = require 'pl.seq'\nlocal stringio = require 'pl.stringio'\nlocal open = stringio. open\nlocal asserteq = require 'pl.test' . asserteq\nlocal T = require 'pl.test'. tuple\n\n--[=[\ndat,err = data.read(open [[\n1.0 0.1\n0.2 1.3\n]])\n\nif err then print(err) end\n\nrequire 'pl.pretty'.dump(dat)\nos.exit(0)\n--]=]\n\n-- tab-separated data, explicit column names\nlocal t1f = open [[\nEventID\tMagnitude\tLocationX\tLocationY\tLocationZ\tLocationError\tEventDate\tDataFile\n981124001\t2.0\t18988.4\t10047.1\t4149.7\t33.8\t24/11/1998 11:18:05\t981124DF.AAB\n981125001\t0.8\t19104.0\t9970.4\t5088.7\t3.0\t25/11/1998 05:44:54\t981125DF.AAB\n981127003\t0.5\t19012.5\t9946.9\t3831.2\t46.0\t27/11/1998 17:15:17\t981127DF.AAD\n981127005\t0.6\t18676.4\t10606.2\t3761.9\t4.4\t27/11/1998 17:46:36\t981127DF.AAF\n981127006\t0.2\t19109.9\t9716.5\t3612.0\t11.8\t27/11/1998 19:29:51\t981127DF.AAG\n]]\n\nlocal t1 = data.read (t1f)\n-- column_by_name returns a List\nasserteq(t1:column_by_name 'Magnitude',List{2,0.8,0.5,0.6,0.2})\n-- can use array.column as well\nasserteq(array.column(t1,2),{2,0.8,0.5,0.6,0.2})\n\n-- only numerical columns (deduced from first data row) are converted by default\n-- can look up indices in the list fieldnames.\nlocal EDI = t1.fieldnames:index 'EventDate'\nassert(type(t1[1][EDI]) == 'string')\n\n-- select method returns a sequence, in this case single-valued.\n-- (Note that seq.copy returns a List)\nasserteq(seq(t1:select 'LocationX where Magnitude > 0.5'):copy(),List{18988.4,19104,18676.4})\n\n--[[\n--a common select usage pattern:\nfor event,mag in t1:select 'EventID,Magnitude sort by Magnitude desc' do\n    print(event,mag)\nend\n--]]\n\n-- space-separated, but with last field containing spaces.\nlocal t2f = open [[\nUSER PID %MEM %CPU COMMAND\nsdonovan 2333  0.3 0.1 background --n=2\nroot 2332  0.4  0.2 fred --start=yes\nroot 2338  0.2  0.1 backyard-process\n]]\n\nlocal t2,err = data.read(t2f,{last_field_collect=true})\nif not t2 then return print (err) end\n\n-- the last_field_collect option is useful with space-delimited data where the last\n-- field may contain spaces. Otherwise, a record count mismatch should be an error!\nlocal lt2 = List(t2[2])\nasserteq(lt2:join ',','root,2332,0.4,0.2,fred --start=yes')\n\n-- fieldnames are converted into valid identifiers by substituting _\n-- (we do this to make select queries parseable by Lua)\nasserteq(t2.fieldnames,List{'USER','PID','_MEM','_CPU','COMMAND'})\n\n-- select queries are NOT SQL so remember to use == ! (and no 'between' operator, sorry)\n--s,err = t2:select('_MEM where USER=\"root\"')\n--assert(err == [[[string \"tmp\"]:9: unexpected symbol near '=']])\n\nlocal s = t2:select('_MEM where USER==\"root\"')\nassert(s() == 0.4)\nassert(s() == 0.2)\nassert(s() == nil)\n\n-- CSV, Excel style. Double-quoted fields are allowed, and they may contain commas!\nlocal t3f = open [[\n\"Department Name\",\"Employee ID\",Project,\"Hours Booked\"\nsales,1231,overhead,4\nsales,1255,overhead,3\nengineering,1501,development,5\nengineering,1501,maintenance,3\nengineering,1433,maintenance,10\n]]\n\nlocal t3 = data.read(t3f,{csv=true})\n\n-- although fieldnames are turned in valid Lua identifiers, there is always `original_fieldnames`\nasserteq(t3.fieldnames,List{'Department_Name','Employee_ID','Project','Hours_Booked'})\nasserteq(t3.original_fieldnames,List{'Department Name','Employee ID','Project','Hours Booked'})\n\n-- a common operation is to select using a given list of columns, and each row\n-- on some explicit condition. The select() method can take a table with these\n-- parameters\nlocal keepcols = {'Employee_ID','Hours_Booked'}\n\nlocal q = t3:select { fields = keepcols,\n    where = function(row) return row[1]=='engineering' end\n    }\n\nasserteq(seq.copy2(q),{{1501,5},{1501,3},{1433,10}})\n\n-- another pattern is doing a select to restrict rows & columns, process some\n-- fields and write out the modified rows.\n\nlocal outf = stringio.create()\n\nlocal names = {[1501]='don',[1433]='dilbert'}\n\nt3:write_row (outf,{'Employee','Hours_Booked'})\nq = t3:select_row {fields=keepcols,where=func.Eq(func._1[1],'engineering')}\nfor row in q do\n    row[1] = names[row[1]]\n    t3:write_row(outf,row)\nend\n\nasserteq(outf:value(),\n[[\nEmployee,Hours_Booked\ndon,5\ndon,3\ndilbert,10\n]])\n\n-- data may not always have column headers. When creating a data object\n-- from a two-dimensional array, may specify the fieldnames, as a list or a string.\n-- The delimiter is deduced from the fieldname string, so a string just containing\n-- the delimiter will set it,  and the fieldnames will be empty.\nlocal dat = List()\nlocal row = List.range(1,10)\nfor i = 1,10 do\n    dat:append(row:map('*',i))\nend\ndat = data.new(dat,',')\nlocal out = stringio.create()\ndat:write(out,',')\nasserteq(out:value(), [[\n1,2,3,4,5,6,7,8,9,10\n2,4,6,8,10,12,14,16,18,20\n3,6,9,12,15,18,21,24,27,30\n4,8,12,16,20,24,28,32,36,40\n5,10,15,20,25,30,35,40,45,50\n6,12,18,24,30,36,42,48,54,60\n7,14,21,28,35,42,49,56,63,70\n8,16,24,32,40,48,56,64,72,80\n9,18,27,36,45,54,63,72,81,90\n10,20,30,40,50,60,70,80,90,100\n]])\n\n-- you can always use numerical field indices, AWK-style;\n-- note how the copy_select method gives you a data object instead of an\n-- iterator over the fields\nlocal res = dat:copy_select '$1,$3 where $1 > 5'\nlocal L = List\nasserteq(L(res),L{\n    L{6, 18},\n    L{7,21},\n    L{8,24},\n    L{9,27},\n    L{10,30},\n})\n\n-- the column_by_name method may take a fieldname or an index\nasserteq(dat:column_by_name(2), L{2,4,6,8,10,12,14,16,18,20})\n\n-- the field list may contain expressions or even constants\nlocal q = dat:select '$3,2*$4 where $1 == 8'\nasserteq(T(q()),T(24,64))\n\ndat,err = data.read(open [[\n1.0 0.1\n0.2 1.3\n]])\n\nif err then print(err) end\n\n-- if a method cannot be found, then we look up in array2d\n-- array2d.flatten(t) makes a 1D list out of a 2D array,\n-- and then List.minmax() gets the extrema.\n\nasserteq(T(dat:flatten():minmax()),T(0.1,1.3))\n\nlocal f = open [[\nTime Message\n1266840760 +# EE7C0600006F0D00C00F06010302054000000308010A00002B00407B00\n1266840760 closure data 0.000000 1972 1972 0\n1266840760 ++ 1266840760 EE 1\n1266840760 +# EE7C0600006F0D00C00F06010302054000000408020A00002B00407B00\n1266840764 closure data 0.000000 1972 1972 0\n1266840764 ++ 1266840764 EE 1\n1266840764 +# EE7C0600006F0D00C00F06010302054000000508030A00002B00407B00\n1266840768 duplicate?\n1266840768 +# EE7C0600006F0D00C00F06010302054000000508030A00002B00407B00\n1266840768 closure data 0.000000 1972 1972 0\n]]\n\n-- the `convert` option provides custom converters for each specified column.\n-- Here we convert the timestamps into Date objects and collect everything\n-- else into one field\nlocal Date = require 'pl.Date'\n\nlocal function date_convert (ds)\n    return Date(tonumber(ds))\nend\n\nlocal d = data.read(f,{convert={[1]=date_convert},last_field_collect=true})\n\nasserteq(#d[1],2)\nasserteq(d[2][1]:year(),2010)\n\nd = {{1,2,3},{10,20,30}}\nout = stringio.create()\ndata.write(d,out,{'A','B','C'},',')\nasserteq(out:value(),\n[[\nA,B,C\n1,2,3\n10,20,30\n]])\n\nout = stringio.create()\nd.fieldnames = {'A','B','C'}\ndata.write(d,out)\n\nasserteq(out:value(),\n[[\nA\tB\tC\n1\t2\t3\n10\t20\t30\n]])\n\n\nd = data.read(stringio.open 'One,Two\\n1,\\n,20\\n',{csv=true})\nasserteq(d,{\n    {1,0},{0,20},\n    original_fieldnames={\"One\",\"Two\"},fieldnames={\"One\",\"Two\"},delim=\",\"\n})\n"
}