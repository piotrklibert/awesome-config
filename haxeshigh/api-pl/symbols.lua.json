{
  "name":"symbols.lua",
  "postprocess":"<type 'function' is not supported by JSON.>",
  "kind":"examples",
  "file":"/home/cji/portless/Penlight/examples/symbols.lua",
  "tags":[],
  "sections":{
    "by_name":[]
  },
  "items":[],
  "lineno":1,
  "mod_name":"symbols.lua",
  "package":"",
  "modifiers":[],
  "type":"example",
  "body":"require 'pl'\nutils.import 'pl.func'\nlocal ops = require 'pl.operator'\nlocal List = require 'pl.List'\nlocal append,concat = table.insert,table.concat\nlocal compare,find_if,compare_no_order,imap,reduce,count_map = tablex.compare,tablex.find_if,tablex.compare_no_order,tablex.imap,tablex.reduce,tablex.count_map\nlocal unpack = table.unpack\n\nfunction bindval (self,val)\n    rawset(self,'value',val)\nend\n\nlocal optable = ops.optable\n\nfunction sexpr (e)\n\tif isPE(e) then\n\t\tif e.op ~= 'X' then\n\t\t\tlocal args = tablex.imap(sexpr,e)\n\t\t\treturn '('..e.op..' '..table.concat(args,' ')..')'\n\t\telse\n\t\t\treturn e.repr\n\t\tend\n\telse\n\t\treturn tostring(e)\n\tend\nend\n\n\npsexpr = compose(print,sexpr)\n\n\n\nfunction equals (e1,e2)\n    local p1,p2 = isPE(e1),isPE(e2)\n    if p1 ~= p2 then return false end  -- different kinds of animals!\n    if p1 and p2 then -- both PEs\n        -- operators must be the same\n        if e1.op ~= e2.op then return false end\n        -- PHs are equal if their representations are equal\n        if e1.op == 'X' then return e1.repr == e2.repr\n        -- commutative operators\n        elseif e1.op == '+' or e1.op == '*' then\n            return compare_no_order(e1,e2,equals)\n        else\n            -- arguments must be the same\n            return compare(e1,e2,equals)\n        end\n    else -- fall back on simple equality for non PEs\n        return e1 == e2\n    end\nend\n\n-- run down an unbalanced operator chain (like a+b+c) and return the arguments {a,b,c}\nfunction tcollect (op,e,ls)\n    if isPE(e) and e.op == op then\n        for i = 1,#e do\n            tcollect(op,e[i],ls)\n        end\n    else\n        ls:append(e)\n        return\n    end\nend\n\nfunction rcollect (e)\n    local res = List()\n    tcollect(e.op,e,res)\n    return res\nend\n\n\n-- balance ensures that +/* chains are collected together, operates in-place.\n-- thus (+(+ a b) c) or (+ a (+ b c)) becomes (+ a b c), order immaterial\nfunction balance (e)\n    if isPE(e) and e.op ~= 'X' then\n        local op,args = e.op\n        if op == '+' or op == '*' then\n            args = rcollect(e)\n        else\n            args = imap(balance,e)\n        end\n        for i = 1,#args do\n            e[i] = args[i]\n        end\n    end\n    return e\nend\n\n-- fold constants in an expression\nfunction fold (e)\n    if isPE(e) then\n        if e.op == 'X' then\n            -- there could be _bound values_!\n            local val = rawget(e,'value')\n            return val and val or e\n        else\n            local op = e.op\n            local addmul = op == '*' or op == '+'\n            -- first fold all arguments\n            local args = imap(fold,e)\n            if not addmul and not find_if(args,isPE) then\n                -- no placeholders in these args, we can fold the expression.\n                local opfn = optable[op]\n                if opfn then\n                    return opfn(unpack(args))\n                else\n                    return '?'\n                end\n            elseif addmul then\n                -- enforce a few rules for + and *\n                -- split the args into two classes, PE args and non-PE args.\n                local classes = List.partition(args,isPE)\n                local pe,npe = classes[true],classes[false]\n                if npe then -- there's at least one non PE argument\n                    -- so fold them\n                    if #npe == 1 then npe = npe[1]\n                    else npe = npe:reduce(optable[op])\n                    end\n                    -- if the result is a constant, return it\n                    if not pe then return npe end\n\n                    -- either (* 1 x) => x or (* 1 x y ...) => (* x y ...)\n                    if op == '*' then\n                        if npe == 0 then return 0\n                        elseif npe == 1 then -- identity\n                            if #pe == 1 then return pe[1] else npe = nil end\n                        end\n                    else -- special cases for +\n                        if npe == 0 then -- identity\n                            if #pe == 1 then return pe[1] else npe = nil end\n                        end\n                    end\n                end\n                -- build up the final arguments\n                local res = {}\n                if npe then append(res,npe) end\n                for val,count in pairs(count_map(pe,equals)) do\n                    if count > 1 then\n                        if op == '*' then val = val ^ count\n                        else val = val * count\n                        end\n                    end\n                    append(res,val)\n                end\n                if #res == 1 then return res[1] end\n                return PE{op=op,unpack(res)}\n            elseif op == '^' then\n                if args[2] == 1 then return args[1] end -- identity\n                if args[2] == 0 then return 1 end\n            end\n            return PE{op=op,unpack(args)}\n        end\n    else\n        return e\n    end\nend\n\nfunction expand (e)\n    if isPE(e) and e.op == '*' and isPE(e[2]) and e[2].op == '+' then\n        local a,b = e[1],e[2]\n        return expand(b[1]*a) + expand(b[2]*a)\n    else\n        return e\n    end\nend\n\nfunction isnumber (x)\n    return type(x) == 'number'\nend\n\n-- does this PE contain a reference to x?\nfunction references (e,x)\n    if isPE(e) then\n        if e.op == 'X' then return x.repr == e.repr\n        else\n            return find_if(e,references,x)\n        end\n    else\n        return false\n    end\nend\n\nlocal function muli (args)\n    return PE{op='*',unpack(args)}\nend\n\nlocal function addi (args)\n    return PE{op='+',unpack(args)}\nend\n\nfunction diff (e,x)\n    if isPE(e) and references(e,x) then\n        local op = e.op\n        if op == 'X' then\n            return 1\n        else\n            local a,b = e[1],e[2]\n            if op == '+' then -- differentiation is linear\n                local args = imap(diff,e,x)\n                return balance(addi(args))\n            elseif op == '*' then -- product rule\n                local res,d,ee = {}\n                for i = 1,#e do\n                    d = fold(diff(e[i],x))\n                    if d ~= 0 then\n                        ee = {unpack(e)}\n                        ee[i] = d\n                        append(res,balance(muli(ee)))\n                    end\n                end\n                if #res > 1 then return addi(res)\n                else return res[1] end\n            elseif op == '^' and isnumber(b) then -- power rule\n                return b*x^(b-1)\n            end\n        end\n    else\n        return 0\n    end\nend\n\n\n\n"
}