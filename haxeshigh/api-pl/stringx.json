{
  "kind":"libraries",
  "name":"pl.stringx",
  "modifiers":[],
  "type":"module",
  "description":"\n\n see 3.6.1 of the Python reference.\n If you want to make these available as string methods, then say\n `stringx.import()` to bring them into the standard `string` table.\n\n See @{03-strings.md|the Guide}\n\n Dependencies: `pl.utils`, `pl.types`",
  "file":"/home/cji/portless/Penlight/lua/pl/stringx.lua",
  "summary":"Python-style extended string library.",
  "sections":{
    "1":{
      "name":"predicates",
      "inferred":true,
      "description":"",
      "file":{
        "warning":"<type 'function' is not supported by JSON.>",
        "filename":"/home/cji/portless/Penlight/lua/pl/stringx.lua",
        "items":["<reference cycle>","<reference cycle>",{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":{
                "1":{
                  "type":"string"
                },
                "s":{
                  "type":"string"
                }
              }
            },
            "summary":"does s only contain alphabetic characters?",
            "lineno":55,
            "args":"(s)",
            "section":"String Predicates",
            "name":"isalpha",
            "params":{
              "map":{
                "s":" a string"
              },
              "1":"s"
            },
            "tags":[],
            "kind":"string predicates ",
            "description":"",
            "type":"function",
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":{
                "1":{
                  "type":"string"
                },
                "s":{
                  "type":"string"
                }
              }
            },
            "summary":"does s only contain digits?",
            "lineno":62,
            "args":"(s)",
            "section":"String Predicates",
            "name":"isdigit",
            "params":{
              "map":{
                "s":" a string"
              },
              "1":"s"
            },
            "tags":[],
            "kind":"string predicates ",
            "description":"",
            "type":"function",
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":{
                "1":{
                  "type":"string"
                },
                "s":{
                  "type":"string"
                }
              }
            },
            "summary":"does s only contain alphanumeric characters?",
            "lineno":69,
            "args":"(s)",
            "section":"String Predicates",
            "name":"isalnum",
            "params":{
              "map":{
                "s":" a string"
              },
              "1":"s"
            },
            "tags":[],
            "kind":"string predicates ",
            "description":"",
            "type":"function",
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":{
                "1":{
                  "type":"string"
                },
                "s":{
                  "type":"string"
                }
              }
            },
            "summary":"does s only contain whitespace?",
            "lineno":77,
            "args":"(s)",
            "section":"String Predicates",
            "name":"isspace",
            "params":{
              "map":{
                "s":" a string"
              },
              "1":"s"
            },
            "tags":[],
            "kind":"string predicates ",
            "description":"\n Matches on pattern '%s' so matches space, newline, tabs, etc.",
            "type":"function",
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":{
                "1":{
                  "type":"string"
                },
                "s":{
                  "type":"string"
                }
              }
            },
            "summary":"does s only contain lower case characters?",
            "lineno":84,
            "args":"(s)",
            "section":"String Predicates",
            "name":"islower",
            "params":{
              "map":{
                "s":" a string"
              },
              "1":"s"
            },
            "tags":[],
            "kind":"string predicates ",
            "description":"",
            "type":"function",
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":{
                "1":{
                  "type":"string"
                },
                "s":{
                  "type":"string"
                }
              }
            },
            "summary":"does s only contain upper case characters?",
            "lineno":91,
            "args":"(s)",
            "section":"String Predicates",
            "name":"isupper",
            "params":{
              "map":{
                "s":" a string"
              },
              "1":"s"
            },
            "tags":[],
            "kind":"string predicates ",
            "description":"",
            "type":"function",
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":[],
                "s":{
                  "type":"string"
                },
                "prefix":[]
              }
            },
            "summary":"does s start with prefix or one of prefixes?",
            "lineno":120,
            "args":"(s, prefix)",
            "section":"String Predicates",
            "name":"startswith",
            "params":{
              "1":"s",
              "2":"prefix",
              "map":{
                "s":" a string",
                "prefix":" a string or an array of strings"
              }
            },
            "tags":[],
            "kind":"string predicates ",
            "description":"",
            "type":"function",
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":[],
                "s":{
                  "type":"string"
                },
                "suffix":[]
              }
            },
            "summary":"does s end with suffix or one of suffixes?",
            "lineno":128,
            "args":"(s, suffix)",
            "section":"String Predicates",
            "name":"endswith",
            "params":{
              "1":"s",
              "2":"suffix",
              "map":{
                "s":" a string",
                "suffix":" a string or an array of strings"
              }
            },
            "tags":[],
            "kind":"string predicates ",
            "description":"",
            "type":"function",
            "parameter":"param"
          },{
            "name":"lists",
            "inferred":true,
            "description":"",
            "file":"<reference cycle>",
            "summary":"",
            "tags":[],
            "lineno":136,
            "display_name":"Strings and Lists",
            "type":"section",
            "modifiers":[]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[]],
              "return":[],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":[],
                "s":{
                  "type":"string"
                },
                "seq":[]
              }
            },
            "summary":"concatenate the strings using this string as a delimiter.",
            "lineno":141,
            "args":"(s, seq)",
            "usage":["stringx.join(' ', {1,2,3}) == '1 2 3'\n"],
            "section":"Strings and Lists",
            "name":"join",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"seq",
              "map":{
                "s":" the string",
                "seq":" a table of strings or numbers"
              }
            },
            "tags":[],
            "kind":"strings and lists ",
            "description":"\n Note that the arguments are reversed from `string.concat`.",
            "type":"function"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[[]],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "opt":true,
                  "type":"bool",
                  "optchain":true
                },
                "s":{
                  "type":"string"
                },
                "keep_ends":{
                  "opt":true,
                  "type":"bool",
                  "optchain":true
                }
              }
            },
            "summary":"Split a string into a list of lines.",
            "lineno":154,
            "retgroups":[{
                "1":{
                  "text":"List of lines",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s[, keep_ends])",
            "type":"function",
            "name":"splitlines",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"keep_ends",
              "map":{
                "s":" the string.",
                "keep_ends":" include line ends."
              }
            },
            "tags":[],
            "kind":"strings and lists ",
            "section":"Strings and Lists",
            "description":"\n `\"\\r\"`, `\"\\n\"`, and `\"\\r\\n\"` are considered line ends.\n They are not included in the lines unless `keepends` is passed.\n Terminal line end does not produce an extra line.\n Splitting an empty string results in an empty list.",
            "ret":["List of lines"]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[],[],[]],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "opt":true,
                  "type":"string",
                  "optchain":true
                },
                "3":{
                  "opt":true,
                  "type":"int",
                  "optchain":true
                },
                "re":{
                  "opt":true,
                  "type":"string",
                  "optchain":true
                },
                "n":{
                  "opt":true,
                  "type":"int",
                  "optchain":true
                },
                "s":{
                  "type":"string"
                }
              },
              "return":[[]]
            },
            "summary":"split a string into a list of strings using a delimiter.",
            "lineno":193,
            "retgroups":[{
                "1":{
                  "text":"List",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s[, re[, n]])",
            "usage":["#(stringx.split('one two')) == 2\n","stringx.split('one,two,three', ',') == List{'one','two','three'}\n","stringx.split('one,two,three', ',', 2) == List{'one','two,three'}\n"],
            "type":"function",
            "name":"split",
            "params":{
              "1":"s",
              "2":"re",
              "map":{
                "re":" a delimiter (defaults to whitespace)",
                "n":" maximum number of results",
                "s":" the string"
              },
              "3":"n"
            },
            "tags":[],
            "kind":"strings and lists ",
            "section":"Strings and Lists",
            "description":"",
            "ret":["List"],
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[],[]],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "type":"int"
                },
                "s":{
                  "type":"string"
                },
                "tabsize":{
                  "type":"int"
                }
              },
              "return":[[]]
            },
            "summary":"replace all tabs in s with tabsize spaces.",
            "lineno":216,
            "retgroups":[{
                "1":{
                  "text":"expanded string",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s, tabsize)",
            "usage":["stringx.expandtabs('\\tone,two,three', 4)   == '    one,two,three'\n","stringx.expandtabs('  \\tone,two,three', 4) == '    one,two,three'\n"],
            "type":"function",
            "name":"expandtabs",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"tabsize",
              "map":{
                "s":" the string",
                "tabsize":"[opt=8] number of spaces to expand each tab"
              }
            },
            "tags":[],
            "kind":"strings and lists ",
            "section":"Strings and Lists",
            "description":" If not specified, tabsize defaults to 8.\n Tab stops will be honored.",
            "ret":["expanded string"]
          },{
            "name":"find",
            "inferred":true,
            "description":"",
            "file":"<reference cycle>",
            "summary":"",
            "tags":[],
            "lineno":231,
            "display_name":"Finding and Replacing",
            "type":"section",
            "modifiers":[]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[[]],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "type":"string"
                },
                "3":{
                  "opt":true,
                  "type":"int",
                  "optchain":true
                },
                "4":{
                  "opt":true,
                  "type":"int",
                  "optchain":true
                },
                "first":{
                  "opt":true,
                  "type":"int",
                  "optchain":true
                },
                "sub":{
                  "type":"string"
                },
                "s":{
                  "type":"string"
                },
                "last":{
                  "opt":true,
                  "type":"int",
                  "optchain":true
                }
              }
            },
            "summary":"find index of first instance of sub in s from the left.",
            "lineno":257,
            "retgroups":[{
                "1":{
                  "text":"start index, or nil if not found",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s, sub[, first[, last]])",
            "type":"function",
            "name":"lfind",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"sub",
              "3":"first",
              "4":"last",
              "map":{
                "first":" first index",
                "sub":" substring",
                "s":" the string",
                "last":" last index"
              }
            },
            "tags":[],
            "kind":"finding and replacing ",
            "section":"Finding and Replacing",
            "description":"",
            "ret":["start index, or nil if not found"]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[[]],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "type":"string"
                },
                "3":{
                  "opt":true,
                  "type":"int",
                  "optchain":true
                },
                "4":{
                  "opt":true,
                  "type":"int",
                  "optchain":true
                },
                "first":{
                  "opt":true,
                  "type":"int",
                  "optchain":true
                },
                "sub":{
                  "type":"string"
                },
                "s":{
                  "type":"string"
                },
                "last":{
                  "opt":true,
                  "type":"int",
                  "optchain":true
                }
              }
            },
            "summary":"find index of first instance of sub in s from the right.",
            "lineno":275,
            "retgroups":[{
                "1":{
                  "text":"start index, or nil if not found",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s, sub[, first[, last]])",
            "type":"function",
            "name":"rfind",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"sub",
              "3":"first",
              "4":"last",
              "map":{
                "first":" first index",
                "sub":" substring",
                "s":" the string",
                "last":" last index"
              }
            },
            "tags":[],
            "kind":"finding and replacing ",
            "section":"Finding and Replacing",
            "description":"",
            "ret":["start index, or nil if not found"]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[[]],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "type":"string"
                },
                "3":{
                  "type":"string"
                },
                "4":{
                  "opt":true,
                  "type":"int",
                  "optchain":true
                },
                "n":{
                  "opt":true,
                  "type":"int",
                  "optchain":true
                },
                "old":{
                  "type":"string"
                },
                "s":{
                  "type":"string"
                },
                "new":{
                  "type":"string"
                }
              }
            },
            "summary":"replace up to n instances of old by new in the string s.",
            "lineno":288,
            "retgroups":[{
                "1":{
                  "text":"result string",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s, old, new[, n])",
            "type":"function",
            "name":"replace",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"old",
              "3":"new",
              "4":"n",
              "map":{
                "n":" optional maximum number of substitutions",
                "old":" the target substring",
                "s":" the string",
                "new":" the substitution"
              }
            },
            "tags":[],
            "kind":"finding and replacing ",
            "section":"Finding and Replacing",
            "description":"\n If n is not present, replace all instances.",
            "ret":["result string"]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[]],
              "return":[],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "type":"string"
                },
                "3":{
                  "opt":true,
                  "type":"bool",
                  "optchain":true
                },
                "sub":{
                  "type":"string"
                },
                "s":{
                  "type":"string"
                },
                "allow_overlap":{
                  "opt":true,
                  "type":"bool",
                  "optchain":true
                }
              }
            },
            "summary":"count all instances of substring in string.",
            "lineno":302,
            "args":"(s, sub[, allow_overlap])",
            "usage":["assert(stringx.count('banana', 'ana') == 1)\nassert(stringx.count('banana', 'ana', true) == 2)\n"],
            "section":"Finding and Replacing",
            "name":"count",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"sub",
              "map":{
                "sub":" substring",
                "s":" the string",
                "allow_overlap":" allow matches to overlap"
              },
              "3":"allow_overlap"
            },
            "tags":[],
            "kind":"finding and replacing ",
            "description":"",
            "type":"function"
          },{
            "name":"strip",
            "inferred":true,
            "description":"",
            "file":"<reference cycle>",
            "summary":"",
            "tags":[],
            "lineno":311,
            "display_name":"Stripping and Justifying",
            "type":"section",
            "modifiers":[]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[]],
              "return":[],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "type":"int"
                },
                "3":{
                  "opt":"' '",
                  "type":"string",
                  "optchain":"' '"
                },
                "ch":{
                  "opt":"' '",
                  "type":"string",
                  "optchain":"' '"
                },
                "s":{
                  "type":"string"
                },
                "w":{
                  "type":"int"
                }
              }
            },
            "summary":"left-justify s with width w.",
            "lineno":339,
            "args":"(s, w[, ch=' '])",
            "usage":["stringx.ljust('hello', 10, '*') == '*****hello'\n"],
            "section":"Stripping and Justifying",
            "name":"ljust",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"w",
              "map":{
                "ch":" padding character",
                "s":" the string",
                "w":" width of justification"
              },
              "3":"ch"
            },
            "tags":[],
            "kind":"stripping and justifying ",
            "description":"",
            "type":"function"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[]],
              "return":[],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "type":"int"
                },
                "3":{
                  "opt":"' '",
                  "type":"string",
                  "optchain":"' '"
                },
                "ch":{
                  "opt":"' '",
                  "type":"string",
                  "optchain":"' '"
                },
                "s":{
                  "type":"string"
                },
                "w":{
                  "type":"int"
                }
              }
            },
            "summary":"right-justify s with width w.",
            "lineno":350,
            "args":"(s, w[, ch=' '])",
            "usage":["stringx.rjust('hello', 10, '*') == 'hello*****'\n"],
            "section":"Stripping and Justifying",
            "name":"rjust",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"w",
              "map":{
                "ch":" padding character",
                "s":" the string",
                "w":" width of justification"
              },
              "3":"ch"
            },
            "tags":[],
            "kind":"stripping and justifying ",
            "description":"",
            "type":"function"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[]],
              "return":[],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "type":"int"
                },
                "3":{
                  "opt":"' '",
                  "type":"string",
                  "optchain":"' '"
                },
                "ch":{
                  "opt":"' '",
                  "type":"string",
                  "optchain":"' '"
                },
                "s":{
                  "type":"string"
                },
                "w":{
                  "type":"int"
                }
              }
            },
            "summary":"center-justify s with width w.",
            "lineno":361,
            "args":"(s, w[, ch=' '])",
            "usage":["stringx.center('hello', 10, '*') == '**hello***'\n"],
            "section":"Stripping and Justifying",
            "name":"center",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"w",
              "map":{
                "ch":" padding character",
                "s":" the string",
                "w":" width of justification"
              },
              "3":"ch"
            },
            "tags":[],
            "kind":"stripping and justifying ",
            "description":"",
            "type":"function"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "opt":"'%s'",
                  "type":"string",
                  "optchain":"'%s'"
                },
                "s":{
                  "type":"string"
                },
                "chrs":{
                  "opt":"'%s'",
                  "type":"string",
                  "optchain":"'%s'"
                }
              }
            },
            "summary":"trim any characters on the left of s.",
            "lineno":402,
            "args":"(s[, chrs='%s'])",
            "section":"Stripping and Justifying",
            "name":"lstrip",
            "params":{
              "1":"s",
              "2":"chrs",
              "map":{
                "s":" the string",
                "chrs":" default any whitespace character,\n but can be a string of characters to be trimmed"
              }
            },
            "tags":[],
            "kind":"stripping and justifying ",
            "description":"",
            "type":"function",
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "opt":"'%s'",
                  "type":"string",
                  "optchain":"'%s'"
                },
                "s":{
                  "type":"string"
                },
                "chrs":{
                  "opt":"'%s'",
                  "type":"string",
                  "optchain":"'%s'"
                }
              }
            },
            "summary":"trim any characters on the right of s.",
            "lineno":412,
            "args":"(s[, chrs='%s'])",
            "section":"Stripping and Justifying",
            "name":"rstrip",
            "params":{
              "1":"s",
              "2":"chrs",
              "map":{
                "s":" the string",
                "chrs":" default any whitespace character,\n but can be a string of characters to be trimmed"
              }
            },
            "tags":[],
            "kind":"stripping and justifying ",
            "description":"",
            "type":"function",
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[]],
              "return":[],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "opt":"'%s'",
                  "type":"string",
                  "optchain":"'%s'"
                },
                "s":{
                  "type":"string"
                },
                "chrs":{
                  "opt":"'%s'",
                  "type":"string",
                  "optchain":"'%s'"
                }
              }
            },
            "summary":"trim any characters on both left and right of s.",
            "lineno":422,
            "args":"(s[, chrs='%s'])",
            "usage":["stringx.strip('  --== Hello ==--  ', \"- =\")  --> 'Hello'\n"],
            "section":"Stripping and Justifying",
            "name":"strip",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"chrs",
              "map":{
                "s":" the string",
                "chrs":" default any whitespace character,\n but can be a string of characters to be trimmed"
              }
            },
            "tags":[],
            "kind":"stripping and justifying ",
            "description":"",
            "type":"function"
          },{
            "name":"partitioning",
            "inferred":true,
            "description":"",
            "file":"<reference cycle>",
            "summary":"",
            "tags":[],
            "lineno":430,
            "display_name":"Partitioning Strings",
            "type":"section",
            "modifiers":[]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "opt":"'%s'",
                  "type":"string",
                  "optchain":"'%s'"
                },
                "s":{
                  "type":"string"
                },
                "re":{
                  "opt":"'%s'",
                  "type":"string",
                  "optchain":"'%s'"
                }
              },
              "return":[[]],
              "usage":[[]],
              "see":[[]]
            },
            "summary":"split a string using a pattern.",
            "lineno":436,
            "retgroups":[{
                "1":{
                  "text":"the parts of the string",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s[, re='%s'])",
            "usage":["a,b = line:splitv('=')\n"],
            "type":"function",
            "name":"splitv",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"re",
              "map":{
                "s":" the string",
                "re":" a Lua string pattern (defaults to whitespace)"
              }
            },
            "tags":{
              "see":[]
            },
            "kind":"partitioning strings ",
            "section":"Partitioning Strings",
            "description":" Note that at least one value will be returned!",
            "ret":["the parts of the string"]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[],[]],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "type":"string"
                },
                "s":{
                  "type":"string"
                },
                "ch":{
                  "type":"string"
                }
              },
              "return":[[],[],[]]
            },
            "summary":"partition the string using first occurance of a delimiter",
            "lineno":461,
            "retgroups":[{
                "1":{
                  "text":"part before ch",
                  "type":"",
                  "mods":[]
                },
                "2":{
                  "text":"ch",
                  "type":"",
                  "mods":[]
                },
                "3":{
                  "text":"part after ch",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s, ch)",
            "usage":["{stringx.partition('a,b,c', ','))} == {'a', ',', 'b,c'}\n","{stringx.partition('abc', 'x'))} == {'abc', '', ''}\n"],
            "type":"function",
            "name":"partition",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"ch",
              "map":{
                "s":" the string",
                "ch":" delimiter (match as plain string, no patterns)"
              }
            },
            "tags":[],
            "kind":"partitioning strings ",
            "section":"Partitioning Strings",
            "description":"",
            "ret":["part before ch","ch","part after ch"]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[],[]],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "type":"string"
                },
                "s":{
                  "type":"string"
                },
                "ch":{
                  "type":"string"
                }
              },
              "return":[[],[],[]]
            },
            "summary":"partition the string p using last occurance of a delimiter",
            "lineno":475,
            "retgroups":[{
                "1":{
                  "text":"part before ch",
                  "type":"",
                  "mods":[]
                },
                "2":{
                  "text":"ch",
                  "type":"",
                  "mods":[]
                },
                "3":{
                  "text":"part after ch",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s, ch)",
            "usage":["{stringx.rpartition('a,b,c', ','))} == {'a,b', ',', 'c'}\n","{stringx.rpartition('abc', 'x'))} == {'', '', 'abc'}\n"],
            "type":"function",
            "name":"rpartition",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"ch",
              "map":{
                "s":" the string",
                "ch":" delimiter (match as plain string, no patterns)"
              }
            },
            "tags":[],
            "kind":"partitioning strings ",
            "section":"Partitioning Strings",
            "description":"",
            "ret":["part before ch","ch","part after ch"]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[[]],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "type":"int"
                },
                "s":{
                  "type":"string"
                },
                "idx":{
                  "type":"int"
                }
              }
            },
            "summary":"return the 'character' at the index.",
            "lineno":489,
            "retgroups":[{
                "1":{
                  "text":"a substring of length 1 if successful, empty string otherwise.",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s, idx)",
            "type":"function",
            "name":"at",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"idx",
              "map":{
                "s":" the string",
                "idx":" an index (can be negative)"
              }
            },
            "tags":[],
            "kind":"partitioning strings ",
            "section":"Partitioning Strings",
            "description":"",
            "ret":["a substring of length 1 if successful, empty string otherwise."]
          },{
            "name":"text",
            "inferred":true,
            "description":"",
            "file":"<reference cycle>",
            "summary":"",
            "tags":[],
            "lineno":500,
            "display_name":"Text handling",
            "type":"section",
            "modifiers":[]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[[]],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "type":"integer"
                },
                "3":{
                  "opt":"' '",
                  "type":"string",
                  "optchain":"' '"
                },
                "ch":{
                  "opt":"' '",
                  "type":"string",
                  "optchain":"' '"
                },
                "n":{
                  "type":"integer"
                },
                "s":{
                  "type":"string"
                }
              }
            },
            "summary":"indent a multiline string.",
            "lineno":505,
            "retgroups":[{
                "1":{
                  "text":"indented string",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s, n[, ch=' '])",
            "type":"function",
            "name":"indent",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"n",
              "map":{
                "ch":" the character to use when indenting",
                "n":" the size of the indent",
                "s":" the (multiline) string"
              },
              "3":"ch"
            },
            "tags":[],
            "kind":"text handling ",
            "section":"Text handling",
            "description":"",
            "ret":["indented string"]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[]],
              "param":{
                "1":{
                  "type":"string"
                },
                "s":{
                  "type":"string"
                }
              },
              "return":[[]]
            },
            "summary":"dedent a multiline string by removing any initial indent.",
            "lineno":537,
            "retgroups":[{
                "1":{
                  "text":"a string with initial indent zero.",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s)",
            "usage":["local s = dedent [[\n         One\n\n       Two\n\n     Three\n]]\nassert(s == [[\n    One\n\n  Two\n\nThree\n]])\n"],
            "type":"function",
            "name":"dedent",
            "parameter":"param",
            "params":{
              "map":{
                "s":" the (multiline) string"
              },
              "1":"s"
            },
            "tags":[],
            "kind":"text handling ",
            "section":"Text handling",
            "description":"\n useful when working with [[..]] strings.\n Empty lines are ignored.",
            "ret":["a string with initial indent zero."]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "opt":"70",
                  "type":"integer",
                  "optchain":"70"
                },
                "3":{
                  "opt":"false",
                  "type":"boolean",
                  "optchain":"false"
                },
                "width":{
                  "opt":"70",
                  "type":"integer",
                  "optchain":"70"
                },
                "s":{
                  "type":"string"
                },
                "breaklong":{
                  "opt":"false",
                  "type":"boolean",
                  "optchain":"false"
                }
              },
              "return":[[]],
              "see":[[],[]]
            },
            "summary":"format a paragraph into lines so that they fit into a line width.",
            "lineno":594,
            "retgroups":[{
                "1":{
                  "text":"a list of lines (List object), use `fill` to return a string instead of a `List`.",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s[, width=70[, breaklong=false]])",
            "type":"function",
            "name":"wrap",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"width",
              "map":{
                "width":" the margin width",
                "s":" the string to format",
                "breaklong":" if truthy, words longer than the width given will be forced split."
              },
              "3":"breaklong"
            },
            "tags":{
              "see":[]
            },
            "kind":"text handling ",
            "section":"Text handling",
            "description":"\n It will not break long words by default, so lines can be over the length\n to that extent.",
            "ret":["a list of lines (List object), use `fill` to return a string instead of a `List`."]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "opt":"70",
                  "type":"integer",
                  "optchain":"70"
                },
                "3":{
                  "opt":"false",
                  "type":"boolean",
                  "optchain":"false"
                },
                "width":{
                  "opt":"70",
                  "type":"integer",
                  "optchain":"70"
                },
                "s":{
                  "type":"string"
                },
                "breaklong":{
                  "opt":"false",
                  "type":"boolean",
                  "optchain":"false"
                }
              },
              "return":[[]],
              "see":[[]]
            },
            "summary":"format a paragraph so that it fits into a line width.",
            "lineno":616,
            "retgroups":[{
                "1":{
                  "text":"a string, use `wrap` to return a list of lines instead of a string.",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s[, width=70[, breaklong=false]])",
            "type":"function",
            "name":"fill",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"width",
              "map":{
                "width":" the margin width",
                "s":" the string to format",
                "breaklong":" if truthy, words longer than the width given will be forced split."
              },
              "3":"breaklong"
            },
            "tags":{
              "see":[]
            },
            "kind":"text handling ",
            "section":"Text handling",
            "description":"",
            "ret":["a string, use `wrap` to return a list of lines instead of a string."]
          },{
            "name":"Template",
            "inferred":true,
            "description":"",
            "file":"<reference cycle>",
            "summary":"",
            "tags":[],
            "lineno":624,
            "display_name":"Template",
            "type":"section",
            "modifiers":[]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "param":{
                "1":{
                  "type":"string"
                },
                "tmpl":{
                  "type":"string"
                }
              },
              "return":[{
                  "type":"Template"
                }]
            },
            "summary":"Creates a new Template class.",
            "lineno":662,
            "retgroups":[{
                "1":{
                  "text":"",
                  "type":"Template",
                  "mods":{
                    "type":"Template"
                  }
                },
                "g":0
              }],
            "args":"(tmpl)",
            "section":"Template",
            "name":"Template",
            "params":{
              "map":{
                "tmpl":" the template string"
              },
              "1":"tmpl"
            },
            "tags":[],
            "kind":"template ",
            "description":"\n This is a shortcut to `Template.new(tmpl)`.",
            "type":"function",
            "ret":[""],
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[[]],
              "param":{
                "1":{
                  "type":"table"
                },
                "tbl":{
                  "type":"table"
                }
              }
            },
            "summary":"substitute values into a template, throwing an error.",
            "lineno":674,
            "retgroups":[{
                "1":{
                  "text":"string with place holders substituted",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(tbl)",
            "type":"function",
            "name":"Template:substitute",
            "parameter":"param",
            "params":{
              "map":{
                "tbl":" a table of name-value pairs."
              },
              "1":"tbl"
            },
            "tags":[],
            "kind":"template ",
            "section":"Template",
            "description":"\n This will throw an error if no name is found.",
            "ret":["string with place holders substituted"]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[[]],
              "param":{
                "1":{
                  "type":"table"
                },
                "tbl":{
                  "type":"table"
                }
              }
            },
            "summary":"substitute values into a template.",
            "lineno":683,
            "retgroups":[{
                "1":{
                  "text":"string with place holders substituted",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(tbl)",
            "type":"function",
            "name":"Template:safe_substitute",
            "parameter":"param",
            "params":{
              "map":{
                "tbl":" a table of name-value pairs."
              },
              "1":"tbl"
            },
            "tags":[],
            "kind":"template ",
            "section":"Template",
            "description":"\n This version just passes unknown names through.",
            "ret":["string with place holders substituted"]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[[]],
              "param":{
                "1":{
                  "type":"table"
                },
                "tbl":{
                  "type":"table"
                }
              }
            },
            "summary":"substitute values into a template, preserving indentation.",
            "lineno":695,
            "retgroups":[{
                "1":{
                  "text":"string with place holders substituted",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(tbl)",
            "type":"function",
            "name":"Template:indent_substitute",
            "parameter":"param",
            "params":{
              "map":{
                "tbl":" a table of name-value pairs."
              },
              "1":"tbl"
            },
            "tags":[],
            "kind":"template ",
            "section":"Template",
            "description":" <br>\n If the value is a multiline string _or_ a template, it will insert\n the lines at the correct indentation. <br>\n Furthermore, if a template, then that template will be substituted\n using the same table.",
            "ret":["string with place holders substituted"]
          },{
            "name":"misc",
            "inferred":true,
            "description":"",
            "file":"<reference cycle>",
            "summary":"",
            "tags":[],
            "lineno":742,
            "display_name":"Miscelaneous",
            "type":"section",
            "modifiers":[]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[]],
              "param":{
                "1":{
                  "type":"string"
                },
                "s":{
                  "type":"string"
                }
              },
              "return":[[]]
            },
            "summary":"return an iterator over all lines in a string",
            "lineno":751,
            "retgroups":[{
                "1":{
                  "text":"an iterator",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s)",
            "usage":["local line_no = 1\nfor line in stringx.lines(some_text) do\n  print(line_no, line)\n  line_no = line_no + 1\nend\n"],
            "type":"function",
            "name":"lines",
            "parameter":"param",
            "params":{
              "map":{
                "s":" the string"
              },
              "1":"s"
            },
            "tags":[],
            "kind":"miscelaneous ",
            "section":"Miscelaneous",
            "description":"",
            "ret":["an iterator"]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[]],
              "param":{
                "1":{
                  "type":"string"
                },
                "s":{
                  "type":"string"
                }
              },
              "return":[[]]
            },
            "summary":"inital word letters uppercase ('title case').",
            "lineno":762,
            "retgroups":[{
                "1":{
                  "text":"a string with each word's first letter uppercase",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s)",
            "usage":["stringx.title(\"hello world\") == \"Hello World\")\n"],
            "type":"function",
            "name":"title",
            "parameter":"param",
            "params":{
              "map":{
                "s":" the string"
              },
              "1":"s"
            },
            "tags":[],
            "kind":"miscelaneous ",
            "section":"Miscelaneous",
            "description":"\n Here 'words' mean chunks of non-space characters.",
            "ret":["a string with each word's first letter uppercase"]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[],[],[]],
              "return":[],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "type":"int"
                },
                "3":{
                  "type":"bool"
                },
                "tail":{
                  "type":"bool"
                },
                "s":{
                  "type":"string"
                },
                "w":{
                  "type":"int"
                }
              }
            },
            "summary":"Return a shortened version of a string.",
            "lineno":783,
            "args":"(s, w, tail)",
            "usage":["('1234567890'):shorten(8) == '12345...'\n","('1234567890'):shorten(8, true) == '...67890'\n","('1234567890'):shorten(20) == '1234567890'\n"],
            "section":"Miscelaneous",
            "name":"shorten",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"w",
              "map":{
                "tail":" true if we want to show the end of the string (head otherwise)",
                "s":" the string",
                "w":" the maxinum size allowed"
              },
              "3":"tail"
            },
            "tags":[],
            "kind":"miscelaneous ",
            "description":"\n Fits string within w characters. Removed characters are marked with ellipsis.",
            "type":"function"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[[]],
              "param":{
                "1":[],
                "s":[]
              }
            },
            "summary":"Quote the given string and preserve any control or escape characters, such that reloading the string in Lua returns the same result.",
            "lineno":822,
            "retgroups":[{
                "1":{
                  "text":"The quoted string.",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s)",
            "type":"function",
            "name":"quote_string",
            "parameter":"param",
            "params":{
              "map":{
                "s":" The string to be quoted."
              },
              "1":"s"
            },
            "tags":[],
            "kind":"miscelaneous ",
            "section":"Miscelaneous",
            "description":"",
            "ret":["The quoted string."]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":[],
              "usage":[[]]
            },
            "summary":"Python-style formatting operator.",
            "lineno":873,
            "args":"()",
            "usage":["require 'pl.text'.format_operator()\nlocal out1 = '%s = %5.3f' % {'PI',math.pi}                   --> 'PI = 3.142'\nlocal out2 = '$name = $value' % {name='dog',value='Pluto'}   --> 'dog = Pluto'\n"],
            "section":"Miscelaneous",
            "name":"format_operator",
            "parameter":"param",
            "params":{
              "map":[]
            },
            "tags":[],
            "kind":"miscelaneous ",
            "description":"\n Calling `text.format_operator()` overloads the % operator for strings to give\n Python/Ruby style formated output.\n This is extended to also do template-like substitution for map-like data.\n\n Note this goes further than the original, and will allow these cases:\n\n 1. a single value\n 2. a list of values\n 3. a map of var=value pairs\n 4. a function, as in gsub\n\n For the second two cases, it uses $-variable substituion.\n\n When called, this function will monkey-patch the global `string` metatable by\n adding a `__mod` method.\n\n See <a href=\"http://lua-users.org/wiki/StringInterpolation\">the lua-users wiki</a>\n",
            "type":"function"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "param":[],
              "return":[]
            },
            "summary":"import the stringx functions into the global string (meta)table",
            "lineno":913,
            "args":"()",
            "section":"Miscelaneous",
            "name":"import",
            "params":{
              "map":[]
            },
            "tags":[],
            "kind":"miscelaneous ",
            "description":"",
            "type":"function",
            "parameter":"param"
          }],
        "sections":[],
        "modules":["<reference cycle>"],
        "args":{
          "one":false,
          "module":false,
          "verbose":false,
          "style":"!",
          "template":"!",
          "date":"system",
          "dir":"doc",
          "quiet":false,
          "all":false,
          "ignore":false,
          "colon":false,
          "not_luadoc":false,
          "ext":"html",
          "boilerplate":false,
          "merge":false,
          "filter":"f.filter",
          "package":"/home/cji/portless/Penlight/lua",
          "dump":false,
          "no_args_infer":false,
          "title":"Reference",
          "project":"ldoc",
          "file":"/home/cji/portless/Penlight/lua/pl",
          "format":"discount",
          "simple":false,
          "tags":"none",
          "define":"none",
          "output":"index",
          "unqualified":false,
          "config":"config.ld",
          "fatalwarnings":false,
          "testing":false
        },
        "error":"<type 'function' is not supported by JSON.>",
        "lang":{
          "line_comment":"^%-%-+",
          "start_comment_":"^%-%-%-+",
          "end_comment_":"[^%-]%-%-+[^-]*\n$",
          "extra":[],
          "block_comment":"^%-%-%[=*%[%-+",
          "empty_comment_":"^%-%-%-+%s*$",
          "method_call":":"
        },
        "base":"/home/cji/portless/Penlight/lua"
      },
      "summary":"",
      "tags":[],
      "lineno":53,
      "display_name":"String Predicates",
      "type":"section",
      "modifiers":[]
    },
    "2":{
      "name":"lists",
      "inferred":true,
      "description":"",
      "file":{
        "warning":"<type 'function' is not supported by JSON.>",
        "filename":"/home/cji/portless/Penlight/lua/pl/stringx.lua",
        "items":["<reference cycle>",{
            "name":"predicates",
            "inferred":true,
            "description":"",
            "file":"<reference cycle>",
            "summary":"",
            "tags":[],
            "lineno":53,
            "display_name":"String Predicates",
            "type":"section",
            "modifiers":[]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":{
                "1":{
                  "type":"string"
                },
                "s":{
                  "type":"string"
                }
              }
            },
            "summary":"does s only contain alphabetic characters?",
            "lineno":55,
            "args":"(s)",
            "section":"String Predicates",
            "name":"isalpha",
            "params":{
              "map":{
                "s":" a string"
              },
              "1":"s"
            },
            "tags":[],
            "kind":"string predicates ",
            "description":"",
            "type":"function",
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":{
                "1":{
                  "type":"string"
                },
                "s":{
                  "type":"string"
                }
              }
            },
            "summary":"does s only contain digits?",
            "lineno":62,
            "args":"(s)",
            "section":"String Predicates",
            "name":"isdigit",
            "params":{
              "map":{
                "s":" a string"
              },
              "1":"s"
            },
            "tags":[],
            "kind":"string predicates ",
            "description":"",
            "type":"function",
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":{
                "1":{
                  "type":"string"
                },
                "s":{
                  "type":"string"
                }
              }
            },
            "summary":"does s only contain alphanumeric characters?",
            "lineno":69,
            "args":"(s)",
            "section":"String Predicates",
            "name":"isalnum",
            "params":{
              "map":{
                "s":" a string"
              },
              "1":"s"
            },
            "tags":[],
            "kind":"string predicates ",
            "description":"",
            "type":"function",
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":{
                "1":{
                  "type":"string"
                },
                "s":{
                  "type":"string"
                }
              }
            },
            "summary":"does s only contain whitespace?",
            "lineno":77,
            "args":"(s)",
            "section":"String Predicates",
            "name":"isspace",
            "params":{
              "map":{
                "s":" a string"
              },
              "1":"s"
            },
            "tags":[],
            "kind":"string predicates ",
            "description":"\n Matches on pattern '%s' so matches space, newline, tabs, etc.",
            "type":"function",
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":{
                "1":{
                  "type":"string"
                },
                "s":{
                  "type":"string"
                }
              }
            },
            "summary":"does s only contain lower case characters?",
            "lineno":84,
            "args":"(s)",
            "section":"String Predicates",
            "name":"islower",
            "params":{
              "map":{
                "s":" a string"
              },
              "1":"s"
            },
            "tags":[],
            "kind":"string predicates ",
            "description":"",
            "type":"function",
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":{
                "1":{
                  "type":"string"
                },
                "s":{
                  "type":"string"
                }
              }
            },
            "summary":"does s only contain upper case characters?",
            "lineno":91,
            "args":"(s)",
            "section":"String Predicates",
            "name":"isupper",
            "params":{
              "map":{
                "s":" a string"
              },
              "1":"s"
            },
            "tags":[],
            "kind":"string predicates ",
            "description":"",
            "type":"function",
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":[],
                "s":{
                  "type":"string"
                },
                "prefix":[]
              }
            },
            "summary":"does s start with prefix or one of prefixes?",
            "lineno":120,
            "args":"(s, prefix)",
            "section":"String Predicates",
            "name":"startswith",
            "params":{
              "1":"s",
              "2":"prefix",
              "map":{
                "s":" a string",
                "prefix":" a string or an array of strings"
              }
            },
            "tags":[],
            "kind":"string predicates ",
            "description":"",
            "type":"function",
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":[],
                "s":{
                  "type":"string"
                },
                "suffix":[]
              }
            },
            "summary":"does s end with suffix or one of suffixes?",
            "lineno":128,
            "args":"(s, suffix)",
            "section":"String Predicates",
            "name":"endswith",
            "params":{
              "1":"s",
              "2":"suffix",
              "map":{
                "s":" a string",
                "suffix":" a string or an array of strings"
              }
            },
            "tags":[],
            "kind":"string predicates ",
            "description":"",
            "type":"function",
            "parameter":"param"
          },"<reference cycle>",{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[]],
              "return":[],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":[],
                "s":{
                  "type":"string"
                },
                "seq":[]
              }
            },
            "summary":"concatenate the strings using this string as a delimiter.",
            "lineno":141,
            "args":"(s, seq)",
            "usage":["stringx.join(' ', {1,2,3}) == '1 2 3'\n"],
            "section":"Strings and Lists",
            "name":"join",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"seq",
              "map":{
                "s":" the string",
                "seq":" a table of strings or numbers"
              }
            },
            "tags":[],
            "kind":"strings and lists ",
            "description":"\n Note that the arguments are reversed from `string.concat`.",
            "type":"function"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[[]],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "opt":true,
                  "type":"bool",
                  "optchain":true
                },
                "s":{
                  "type":"string"
                },
                "keep_ends":{
                  "opt":true,
                  "type":"bool",
                  "optchain":true
                }
              }
            },
            "summary":"Split a string into a list of lines.",
            "lineno":154,
            "retgroups":[{
                "1":{
                  "text":"List of lines",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s[, keep_ends])",
            "type":"function",
            "name":"splitlines",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"keep_ends",
              "map":{
                "s":" the string.",
                "keep_ends":" include line ends."
              }
            },
            "tags":[],
            "kind":"strings and lists ",
            "section":"Strings and Lists",
            "description":"\n `\"\\r\"`, `\"\\n\"`, and `\"\\r\\n\"` are considered line ends.\n They are not included in the lines unless `keepends` is passed.\n Terminal line end does not produce an extra line.\n Splitting an empty string results in an empty list.",
            "ret":["List of lines"]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[],[],[]],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "opt":true,
                  "type":"string",
                  "optchain":true
                },
                "3":{
                  "opt":true,
                  "type":"int",
                  "optchain":true
                },
                "re":{
                  "opt":true,
                  "type":"string",
                  "optchain":true
                },
                "n":{
                  "opt":true,
                  "type":"int",
                  "optchain":true
                },
                "s":{
                  "type":"string"
                }
              },
              "return":[[]]
            },
            "summary":"split a string into a list of strings using a delimiter.",
            "lineno":193,
            "retgroups":[{
                "1":{
                  "text":"List",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s[, re[, n]])",
            "usage":["#(stringx.split('one two')) == 2\n","stringx.split('one,two,three', ',') == List{'one','two','three'}\n","stringx.split('one,two,three', ',', 2) == List{'one','two,three'}\n"],
            "type":"function",
            "name":"split",
            "params":{
              "1":"s",
              "2":"re",
              "map":{
                "re":" a delimiter (defaults to whitespace)",
                "n":" maximum number of results",
                "s":" the string"
              },
              "3":"n"
            },
            "tags":[],
            "kind":"strings and lists ",
            "section":"Strings and Lists",
            "description":"",
            "ret":["List"],
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[],[]],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "type":"int"
                },
                "s":{
                  "type":"string"
                },
                "tabsize":{
                  "type":"int"
                }
              },
              "return":[[]]
            },
            "summary":"replace all tabs in s with tabsize spaces.",
            "lineno":216,
            "retgroups":[{
                "1":{
                  "text":"expanded string",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s, tabsize)",
            "usage":["stringx.expandtabs('\\tone,two,three', 4)   == '    one,two,three'\n","stringx.expandtabs('  \\tone,two,three', 4) == '    one,two,three'\n"],
            "type":"function",
            "name":"expandtabs",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"tabsize",
              "map":{
                "s":" the string",
                "tabsize":"[opt=8] number of spaces to expand each tab"
              }
            },
            "tags":[],
            "kind":"strings and lists ",
            "section":"Strings and Lists",
            "description":" If not specified, tabsize defaults to 8.\n Tab stops will be honored.",
            "ret":["expanded string"]
          },{
            "name":"find",
            "inferred":true,
            "description":"",
            "file":"<reference cycle>",
            "summary":"",
            "tags":[],
            "lineno":231,
            "display_name":"Finding and Replacing",
            "type":"section",
            "modifiers":[]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[[]],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "type":"string"
                },
                "3":{
                  "opt":true,
                  "type":"int",
                  "optchain":true
                },
                "4":{
                  "opt":true,
                  "type":"int",
                  "optchain":true
                },
                "first":{
                  "opt":true,
                  "type":"int",
                  "optchain":true
                },
                "sub":{
                  "type":"string"
                },
                "s":{
                  "type":"string"
                },
                "last":{
                  "opt":true,
                  "type":"int",
                  "optchain":true
                }
              }
            },
            "summary":"find index of first instance of sub in s from the left.",
            "lineno":257,
            "retgroups":[{
                "1":{
                  "text":"start index, or nil if not found",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s, sub[, first[, last]])",
            "type":"function",
            "name":"lfind",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"sub",
              "3":"first",
              "4":"last",
              "map":{
                "first":" first index",
                "sub":" substring",
                "s":" the string",
                "last":" last index"
              }
            },
            "tags":[],
            "kind":"finding and replacing ",
            "section":"Finding and Replacing",
            "description":"",
            "ret":["start index, or nil if not found"]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[[]],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "type":"string"
                },
                "3":{
                  "opt":true,
                  "type":"int",
                  "optchain":true
                },
                "4":{
                  "opt":true,
                  "type":"int",
                  "optchain":true
                },
                "first":{
                  "opt":true,
                  "type":"int",
                  "optchain":true
                },
                "sub":{
                  "type":"string"
                },
                "s":{
                  "type":"string"
                },
                "last":{
                  "opt":true,
                  "type":"int",
                  "optchain":true
                }
              }
            },
            "summary":"find index of first instance of sub in s from the right.",
            "lineno":275,
            "retgroups":[{
                "1":{
                  "text":"start index, or nil if not found",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s, sub[, first[, last]])",
            "type":"function",
            "name":"rfind",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"sub",
              "3":"first",
              "4":"last",
              "map":{
                "first":" first index",
                "sub":" substring",
                "s":" the string",
                "last":" last index"
              }
            },
            "tags":[],
            "kind":"finding and replacing ",
            "section":"Finding and Replacing",
            "description":"",
            "ret":["start index, or nil if not found"]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[[]],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "type":"string"
                },
                "3":{
                  "type":"string"
                },
                "4":{
                  "opt":true,
                  "type":"int",
                  "optchain":true
                },
                "n":{
                  "opt":true,
                  "type":"int",
                  "optchain":true
                },
                "old":{
                  "type":"string"
                },
                "s":{
                  "type":"string"
                },
                "new":{
                  "type":"string"
                }
              }
            },
            "summary":"replace up to n instances of old by new in the string s.",
            "lineno":288,
            "retgroups":[{
                "1":{
                  "text":"result string",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s, old, new[, n])",
            "type":"function",
            "name":"replace",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"old",
              "3":"new",
              "4":"n",
              "map":{
                "n":" optional maximum number of substitutions",
                "old":" the target substring",
                "s":" the string",
                "new":" the substitution"
              }
            },
            "tags":[],
            "kind":"finding and replacing ",
            "section":"Finding and Replacing",
            "description":"\n If n is not present, replace all instances.",
            "ret":["result string"]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[]],
              "return":[],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "type":"string"
                },
                "3":{
                  "opt":true,
                  "type":"bool",
                  "optchain":true
                },
                "sub":{
                  "type":"string"
                },
                "s":{
                  "type":"string"
                },
                "allow_overlap":{
                  "opt":true,
                  "type":"bool",
                  "optchain":true
                }
              }
            },
            "summary":"count all instances of substring in string.",
            "lineno":302,
            "args":"(s, sub[, allow_overlap])",
            "usage":["assert(stringx.count('banana', 'ana') == 1)\nassert(stringx.count('banana', 'ana', true) == 2)\n"],
            "section":"Finding and Replacing",
            "name":"count",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"sub",
              "map":{
                "sub":" substring",
                "s":" the string",
                "allow_overlap":" allow matches to overlap"
              },
              "3":"allow_overlap"
            },
            "tags":[],
            "kind":"finding and replacing ",
            "description":"",
            "type":"function"
          },{
            "name":"strip",
            "inferred":true,
            "description":"",
            "file":"<reference cycle>",
            "summary":"",
            "tags":[],
            "lineno":311,
            "display_name":"Stripping and Justifying",
            "type":"section",
            "modifiers":[]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[]],
              "return":[],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "type":"int"
                },
                "3":{
                  "opt":"' '",
                  "type":"string",
                  "optchain":"' '"
                },
                "ch":{
                  "opt":"' '",
                  "type":"string",
                  "optchain":"' '"
                },
                "s":{
                  "type":"string"
                },
                "w":{
                  "type":"int"
                }
              }
            },
            "summary":"left-justify s with width w.",
            "lineno":339,
            "args":"(s, w[, ch=' '])",
            "usage":["stringx.ljust('hello', 10, '*') == '*****hello'\n"],
            "section":"Stripping and Justifying",
            "name":"ljust",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"w",
              "map":{
                "ch":" padding character",
                "s":" the string",
                "w":" width of justification"
              },
              "3":"ch"
            },
            "tags":[],
            "kind":"stripping and justifying ",
            "description":"",
            "type":"function"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[]],
              "return":[],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "type":"int"
                },
                "3":{
                  "opt":"' '",
                  "type":"string",
                  "optchain":"' '"
                },
                "ch":{
                  "opt":"' '",
                  "type":"string",
                  "optchain":"' '"
                },
                "s":{
                  "type":"string"
                },
                "w":{
                  "type":"int"
                }
              }
            },
            "summary":"right-justify s with width w.",
            "lineno":350,
            "args":"(s, w[, ch=' '])",
            "usage":["stringx.rjust('hello', 10, '*') == 'hello*****'\n"],
            "section":"Stripping and Justifying",
            "name":"rjust",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"w",
              "map":{
                "ch":" padding character",
                "s":" the string",
                "w":" width of justification"
              },
              "3":"ch"
            },
            "tags":[],
            "kind":"stripping and justifying ",
            "description":"",
            "type":"function"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[]],
              "return":[],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "type":"int"
                },
                "3":{
                  "opt":"' '",
                  "type":"string",
                  "optchain":"' '"
                },
                "ch":{
                  "opt":"' '",
                  "type":"string",
                  "optchain":"' '"
                },
                "s":{
                  "type":"string"
                },
                "w":{
                  "type":"int"
                }
              }
            },
            "summary":"center-justify s with width w.",
            "lineno":361,
            "args":"(s, w[, ch=' '])",
            "usage":["stringx.center('hello', 10, '*') == '**hello***'\n"],
            "section":"Stripping and Justifying",
            "name":"center",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"w",
              "map":{
                "ch":" padding character",
                "s":" the string",
                "w":" width of justification"
              },
              "3":"ch"
            },
            "tags":[],
            "kind":"stripping and justifying ",
            "description":"",
            "type":"function"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "opt":"'%s'",
                  "type":"string",
                  "optchain":"'%s'"
                },
                "s":{
                  "type":"string"
                },
                "chrs":{
                  "opt":"'%s'",
                  "type":"string",
                  "optchain":"'%s'"
                }
              }
            },
            "summary":"trim any characters on the left of s.",
            "lineno":402,
            "args":"(s[, chrs='%s'])",
            "section":"Stripping and Justifying",
            "name":"lstrip",
            "params":{
              "1":"s",
              "2":"chrs",
              "map":{
                "s":" the string",
                "chrs":" default any whitespace character,\n but can be a string of characters to be trimmed"
              }
            },
            "tags":[],
            "kind":"stripping and justifying ",
            "description":"",
            "type":"function",
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "opt":"'%s'",
                  "type":"string",
                  "optchain":"'%s'"
                },
                "s":{
                  "type":"string"
                },
                "chrs":{
                  "opt":"'%s'",
                  "type":"string",
                  "optchain":"'%s'"
                }
              }
            },
            "summary":"trim any characters on the right of s.",
            "lineno":412,
            "args":"(s[, chrs='%s'])",
            "section":"Stripping and Justifying",
            "name":"rstrip",
            "params":{
              "1":"s",
              "2":"chrs",
              "map":{
                "s":" the string",
                "chrs":" default any whitespace character,\n but can be a string of characters to be trimmed"
              }
            },
            "tags":[],
            "kind":"stripping and justifying ",
            "description":"",
            "type":"function",
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[]],
              "return":[],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "opt":"'%s'",
                  "type":"string",
                  "optchain":"'%s'"
                },
                "s":{
                  "type":"string"
                },
                "chrs":{
                  "opt":"'%s'",
                  "type":"string",
                  "optchain":"'%s'"
                }
              }
            },
            "summary":"trim any characters on both left and right of s.",
            "lineno":422,
            "args":"(s[, chrs='%s'])",
            "usage":["stringx.strip('  --== Hello ==--  ', \"- =\")  --> 'Hello'\n"],
            "section":"Stripping and Justifying",
            "name":"strip",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"chrs",
              "map":{
                "s":" the string",
                "chrs":" default any whitespace character,\n but can be a string of characters to be trimmed"
              }
            },
            "tags":[],
            "kind":"stripping and justifying ",
            "description":"",
            "type":"function"
          },{
            "name":"partitioning",
            "inferred":true,
            "description":"",
            "file":"<reference cycle>",
            "summary":"",
            "tags":[],
            "lineno":430,
            "display_name":"Partitioning Strings",
            "type":"section",
            "modifiers":[]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "opt":"'%s'",
                  "type":"string",
                  "optchain":"'%s'"
                },
                "s":{
                  "type":"string"
                },
                "re":{
                  "opt":"'%s'",
                  "type":"string",
                  "optchain":"'%s'"
                }
              },
              "return":[[]],
              "usage":[[]],
              "see":[[]]
            },
            "summary":"split a string using a pattern.",
            "lineno":436,
            "retgroups":[{
                "1":{
                  "text":"the parts of the string",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s[, re='%s'])",
            "usage":["a,b = line:splitv('=')\n"],
            "type":"function",
            "name":"splitv",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"re",
              "map":{
                "s":" the string",
                "re":" a Lua string pattern (defaults to whitespace)"
              }
            },
            "tags":{
              "see":[]
            },
            "kind":"partitioning strings ",
            "section":"Partitioning Strings",
            "description":" Note that at least one value will be returned!",
            "ret":["the parts of the string"]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[],[]],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "type":"string"
                },
                "s":{
                  "type":"string"
                },
                "ch":{
                  "type":"string"
                }
              },
              "return":[[],[],[]]
            },
            "summary":"partition the string using first occurance of a delimiter",
            "lineno":461,
            "retgroups":[{
                "1":{
                  "text":"part before ch",
                  "type":"",
                  "mods":[]
                },
                "2":{
                  "text":"ch",
                  "type":"",
                  "mods":[]
                },
                "3":{
                  "text":"part after ch",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s, ch)",
            "usage":["{stringx.partition('a,b,c', ','))} == {'a', ',', 'b,c'}\n","{stringx.partition('abc', 'x'))} == {'abc', '', ''}\n"],
            "type":"function",
            "name":"partition",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"ch",
              "map":{
                "s":" the string",
                "ch":" delimiter (match as plain string, no patterns)"
              }
            },
            "tags":[],
            "kind":"partitioning strings ",
            "section":"Partitioning Strings",
            "description":"",
            "ret":["part before ch","ch","part after ch"]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[],[]],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "type":"string"
                },
                "s":{
                  "type":"string"
                },
                "ch":{
                  "type":"string"
                }
              },
              "return":[[],[],[]]
            },
            "summary":"partition the string p using last occurance of a delimiter",
            "lineno":475,
            "retgroups":[{
                "1":{
                  "text":"part before ch",
                  "type":"",
                  "mods":[]
                },
                "2":{
                  "text":"ch",
                  "type":"",
                  "mods":[]
                },
                "3":{
                  "text":"part after ch",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s, ch)",
            "usage":["{stringx.rpartition('a,b,c', ','))} == {'a,b', ',', 'c'}\n","{stringx.rpartition('abc', 'x'))} == {'', '', 'abc'}\n"],
            "type":"function",
            "name":"rpartition",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"ch",
              "map":{
                "s":" the string",
                "ch":" delimiter (match as plain string, no patterns)"
              }
            },
            "tags":[],
            "kind":"partitioning strings ",
            "section":"Partitioning Strings",
            "description":"",
            "ret":["part before ch","ch","part after ch"]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[[]],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "type":"int"
                },
                "s":{
                  "type":"string"
                },
                "idx":{
                  "type":"int"
                }
              }
            },
            "summary":"return the 'character' at the index.",
            "lineno":489,
            "retgroups":[{
                "1":{
                  "text":"a substring of length 1 if successful, empty string otherwise.",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s, idx)",
            "type":"function",
            "name":"at",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"idx",
              "map":{
                "s":" the string",
                "idx":" an index (can be negative)"
              }
            },
            "tags":[],
            "kind":"partitioning strings ",
            "section":"Partitioning Strings",
            "description":"",
            "ret":["a substring of length 1 if successful, empty string otherwise."]
          },{
            "name":"text",
            "inferred":true,
            "description":"",
            "file":"<reference cycle>",
            "summary":"",
            "tags":[],
            "lineno":500,
            "display_name":"Text handling",
            "type":"section",
            "modifiers":[]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[[]],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "type":"integer"
                },
                "3":{
                  "opt":"' '",
                  "type":"string",
                  "optchain":"' '"
                },
                "ch":{
                  "opt":"' '",
                  "type":"string",
                  "optchain":"' '"
                },
                "n":{
                  "type":"integer"
                },
                "s":{
                  "type":"string"
                }
              }
            },
            "summary":"indent a multiline string.",
            "lineno":505,
            "retgroups":[{
                "1":{
                  "text":"indented string",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s, n[, ch=' '])",
            "type":"function",
            "name":"indent",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"n",
              "map":{
                "ch":" the character to use when indenting",
                "n":" the size of the indent",
                "s":" the (multiline) string"
              },
              "3":"ch"
            },
            "tags":[],
            "kind":"text handling ",
            "section":"Text handling",
            "description":"",
            "ret":["indented string"]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[]],
              "param":{
                "1":{
                  "type":"string"
                },
                "s":{
                  "type":"string"
                }
              },
              "return":[[]]
            },
            "summary":"dedent a multiline string by removing any initial indent.",
            "lineno":537,
            "retgroups":[{
                "1":{
                  "text":"a string with initial indent zero.",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s)",
            "usage":["local s = dedent [[\n         One\n\n       Two\n\n     Three\n]]\nassert(s == [[\n    One\n\n  Two\n\nThree\n]])\n"],
            "type":"function",
            "name":"dedent",
            "parameter":"param",
            "params":{
              "map":{
                "s":" the (multiline) string"
              },
              "1":"s"
            },
            "tags":[],
            "kind":"text handling ",
            "section":"Text handling",
            "description":"\n useful when working with [[..]] strings.\n Empty lines are ignored.",
            "ret":["a string with initial indent zero."]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "opt":"70",
                  "type":"integer",
                  "optchain":"70"
                },
                "3":{
                  "opt":"false",
                  "type":"boolean",
                  "optchain":"false"
                },
                "width":{
                  "opt":"70",
                  "type":"integer",
                  "optchain":"70"
                },
                "s":{
                  "type":"string"
                },
                "breaklong":{
                  "opt":"false",
                  "type":"boolean",
                  "optchain":"false"
                }
              },
              "return":[[]],
              "see":[[],[]]
            },
            "summary":"format a paragraph into lines so that they fit into a line width.",
            "lineno":594,
            "retgroups":[{
                "1":{
                  "text":"a list of lines (List object), use `fill` to return a string instead of a `List`.",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s[, width=70[, breaklong=false]])",
            "type":"function",
            "name":"wrap",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"width",
              "map":{
                "width":" the margin width",
                "s":" the string to format",
                "breaklong":" if truthy, words longer than the width given will be forced split."
              },
              "3":"breaklong"
            },
            "tags":{
              "see":[]
            },
            "kind":"text handling ",
            "section":"Text handling",
            "description":"\n It will not break long words by default, so lines can be over the length\n to that extent.",
            "ret":["a list of lines (List object), use `fill` to return a string instead of a `List`."]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "opt":"70",
                  "type":"integer",
                  "optchain":"70"
                },
                "3":{
                  "opt":"false",
                  "type":"boolean",
                  "optchain":"false"
                },
                "width":{
                  "opt":"70",
                  "type":"integer",
                  "optchain":"70"
                },
                "s":{
                  "type":"string"
                },
                "breaklong":{
                  "opt":"false",
                  "type":"boolean",
                  "optchain":"false"
                }
              },
              "return":[[]],
              "see":[[]]
            },
            "summary":"format a paragraph so that it fits into a line width.",
            "lineno":616,
            "retgroups":[{
                "1":{
                  "text":"a string, use `wrap` to return a list of lines instead of a string.",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s[, width=70[, breaklong=false]])",
            "type":"function",
            "name":"fill",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"width",
              "map":{
                "width":" the margin width",
                "s":" the string to format",
                "breaklong":" if truthy, words longer than the width given will be forced split."
              },
              "3":"breaklong"
            },
            "tags":{
              "see":[]
            },
            "kind":"text handling ",
            "section":"Text handling",
            "description":"",
            "ret":["a string, use `wrap` to return a list of lines instead of a string."]
          },{
            "name":"Template",
            "inferred":true,
            "description":"",
            "file":"<reference cycle>",
            "summary":"",
            "tags":[],
            "lineno":624,
            "display_name":"Template",
            "type":"section",
            "modifiers":[]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "param":{
                "1":{
                  "type":"string"
                },
                "tmpl":{
                  "type":"string"
                }
              },
              "return":[{
                  "type":"Template"
                }]
            },
            "summary":"Creates a new Template class.",
            "lineno":662,
            "retgroups":[{
                "1":{
                  "text":"",
                  "type":"Template",
                  "mods":{
                    "type":"Template"
                  }
                },
                "g":0
              }],
            "args":"(tmpl)",
            "section":"Template",
            "name":"Template",
            "params":{
              "map":{
                "tmpl":" the template string"
              },
              "1":"tmpl"
            },
            "tags":[],
            "kind":"template ",
            "description":"\n This is a shortcut to `Template.new(tmpl)`.",
            "type":"function",
            "ret":[""],
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[[]],
              "param":{
                "1":{
                  "type":"table"
                },
                "tbl":{
                  "type":"table"
                }
              }
            },
            "summary":"substitute values into a template, throwing an error.",
            "lineno":674,
            "retgroups":[{
                "1":{
                  "text":"string with place holders substituted",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(tbl)",
            "type":"function",
            "name":"Template:substitute",
            "parameter":"param",
            "params":{
              "map":{
                "tbl":" a table of name-value pairs."
              },
              "1":"tbl"
            },
            "tags":[],
            "kind":"template ",
            "section":"Template",
            "description":"\n This will throw an error if no name is found.",
            "ret":["string with place holders substituted"]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[[]],
              "param":{
                "1":{
                  "type":"table"
                },
                "tbl":{
                  "type":"table"
                }
              }
            },
            "summary":"substitute values into a template.",
            "lineno":683,
            "retgroups":[{
                "1":{
                  "text":"string with place holders substituted",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(tbl)",
            "type":"function",
            "name":"Template:safe_substitute",
            "parameter":"param",
            "params":{
              "map":{
                "tbl":" a table of name-value pairs."
              },
              "1":"tbl"
            },
            "tags":[],
            "kind":"template ",
            "section":"Template",
            "description":"\n This version just passes unknown names through.",
            "ret":["string with place holders substituted"]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[[]],
              "param":{
                "1":{
                  "type":"table"
                },
                "tbl":{
                  "type":"table"
                }
              }
            },
            "summary":"substitute values into a template, preserving indentation.",
            "lineno":695,
            "retgroups":[{
                "1":{
                  "text":"string with place holders substituted",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(tbl)",
            "type":"function",
            "name":"Template:indent_substitute",
            "parameter":"param",
            "params":{
              "map":{
                "tbl":" a table of name-value pairs."
              },
              "1":"tbl"
            },
            "tags":[],
            "kind":"template ",
            "section":"Template",
            "description":" <br>\n If the value is a multiline string _or_ a template, it will insert\n the lines at the correct indentation. <br>\n Furthermore, if a template, then that template will be substituted\n using the same table.",
            "ret":["string with place holders substituted"]
          },{
            "name":"misc",
            "inferred":true,
            "description":"",
            "file":"<reference cycle>",
            "summary":"",
            "tags":[],
            "lineno":742,
            "display_name":"Miscelaneous",
            "type":"section",
            "modifiers":[]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[]],
              "param":{
                "1":{
                  "type":"string"
                },
                "s":{
                  "type":"string"
                }
              },
              "return":[[]]
            },
            "summary":"return an iterator over all lines in a string",
            "lineno":751,
            "retgroups":[{
                "1":{
                  "text":"an iterator",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s)",
            "usage":["local line_no = 1\nfor line in stringx.lines(some_text) do\n  print(line_no, line)\n  line_no = line_no + 1\nend\n"],
            "type":"function",
            "name":"lines",
            "parameter":"param",
            "params":{
              "map":{
                "s":" the string"
              },
              "1":"s"
            },
            "tags":[],
            "kind":"miscelaneous ",
            "section":"Miscelaneous",
            "description":"",
            "ret":["an iterator"]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[]],
              "param":{
                "1":{
                  "type":"string"
                },
                "s":{
                  "type":"string"
                }
              },
              "return":[[]]
            },
            "summary":"inital word letters uppercase ('title case').",
            "lineno":762,
            "retgroups":[{
                "1":{
                  "text":"a string with each word's first letter uppercase",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s)",
            "usage":["stringx.title(\"hello world\") == \"Hello World\")\n"],
            "type":"function",
            "name":"title",
            "parameter":"param",
            "params":{
              "map":{
                "s":" the string"
              },
              "1":"s"
            },
            "tags":[],
            "kind":"miscelaneous ",
            "section":"Miscelaneous",
            "description":"\n Here 'words' mean chunks of non-space characters.",
            "ret":["a string with each word's first letter uppercase"]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[],[],[]],
              "return":[],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "type":"int"
                },
                "3":{
                  "type":"bool"
                },
                "tail":{
                  "type":"bool"
                },
                "s":{
                  "type":"string"
                },
                "w":{
                  "type":"int"
                }
              }
            },
            "summary":"Return a shortened version of a string.",
            "lineno":783,
            "args":"(s, w, tail)",
            "usage":["('1234567890'):shorten(8) == '12345...'\n","('1234567890'):shorten(8, true) == '...67890'\n","('1234567890'):shorten(20) == '1234567890'\n"],
            "section":"Miscelaneous",
            "name":"shorten",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"w",
              "map":{
                "tail":" true if we want to show the end of the string (head otherwise)",
                "s":" the string",
                "w":" the maxinum size allowed"
              },
              "3":"tail"
            },
            "tags":[],
            "kind":"miscelaneous ",
            "description":"\n Fits string within w characters. Removed characters are marked with ellipsis.",
            "type":"function"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[[]],
              "param":{
                "1":[],
                "s":[]
              }
            },
            "summary":"Quote the given string and preserve any control or escape characters, such that reloading the string in Lua returns the same result.",
            "lineno":822,
            "retgroups":[{
                "1":{
                  "text":"The quoted string.",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s)",
            "type":"function",
            "name":"quote_string",
            "parameter":"param",
            "params":{
              "map":{
                "s":" The string to be quoted."
              },
              "1":"s"
            },
            "tags":[],
            "kind":"miscelaneous ",
            "section":"Miscelaneous",
            "description":"",
            "ret":["The quoted string."]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":[],
              "usage":[[]]
            },
            "summary":"Python-style formatting operator.",
            "lineno":873,
            "args":"()",
            "usage":["require 'pl.text'.format_operator()\nlocal out1 = '%s = %5.3f' % {'PI',math.pi}                   --> 'PI = 3.142'\nlocal out2 = '$name = $value' % {name='dog',value='Pluto'}   --> 'dog = Pluto'\n"],
            "section":"Miscelaneous",
            "name":"format_operator",
            "parameter":"param",
            "params":{
              "map":[]
            },
            "tags":[],
            "kind":"miscelaneous ",
            "description":"\n Calling `text.format_operator()` overloads the % operator for strings to give\n Python/Ruby style formated output.\n This is extended to also do template-like substitution for map-like data.\n\n Note this goes further than the original, and will allow these cases:\n\n 1. a single value\n 2. a list of values\n 3. a map of var=value pairs\n 4. a function, as in gsub\n\n For the second two cases, it uses $-variable substituion.\n\n When called, this function will monkey-patch the global `string` metatable by\n adding a `__mod` method.\n\n See <a href=\"http://lua-users.org/wiki/StringInterpolation\">the lua-users wiki</a>\n",
            "type":"function"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "param":[],
              "return":[]
            },
            "summary":"import the stringx functions into the global string (meta)table",
            "lineno":913,
            "args":"()",
            "section":"Miscelaneous",
            "name":"import",
            "params":{
              "map":[]
            },
            "tags":[],
            "kind":"miscelaneous ",
            "description":"",
            "type":"function",
            "parameter":"param"
          }],
        "sections":[],
        "modules":["<reference cycle>"],
        "args":{
          "one":false,
          "module":false,
          "verbose":false,
          "style":"!",
          "template":"!",
          "date":"system",
          "dir":"doc",
          "quiet":false,
          "all":false,
          "ignore":false,
          "colon":false,
          "not_luadoc":false,
          "ext":"html",
          "boilerplate":false,
          "merge":false,
          "filter":"f.filter",
          "package":"/home/cji/portless/Penlight/lua",
          "dump":false,
          "no_args_infer":false,
          "title":"Reference",
          "project":"ldoc",
          "file":"/home/cji/portless/Penlight/lua/pl",
          "format":"discount",
          "simple":false,
          "tags":"none",
          "define":"none",
          "output":"index",
          "unqualified":false,
          "config":"config.ld",
          "fatalwarnings":false,
          "testing":false
        },
        "error":"<type 'function' is not supported by JSON.>",
        "lang":{
          "line_comment":"^%-%-+",
          "start_comment_":"^%-%-%-+",
          "end_comment_":"[^%-]%-%-+[^-]*\n$",
          "extra":[],
          "block_comment":"^%-%-%[=*%[%-+",
          "empty_comment_":"^%-%-%-+%s*$",
          "method_call":":"
        },
        "base":"/home/cji/portless/Penlight/lua"
      },
      "summary":"",
      "tags":[],
      "lineno":136,
      "display_name":"Strings and Lists",
      "type":"section",
      "modifiers":[]
    },
    "3":{
      "name":"find",
      "inferred":true,
      "description":"",
      "file":{
        "warning":"<type 'function' is not supported by JSON.>",
        "filename":"/home/cji/portless/Penlight/lua/pl/stringx.lua",
        "items":["<reference cycle>",{
            "name":"predicates",
            "inferred":true,
            "description":"",
            "file":"<reference cycle>",
            "summary":"",
            "tags":[],
            "lineno":53,
            "display_name":"String Predicates",
            "type":"section",
            "modifiers":[]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":{
                "1":{
                  "type":"string"
                },
                "s":{
                  "type":"string"
                }
              }
            },
            "summary":"does s only contain alphabetic characters?",
            "lineno":55,
            "args":"(s)",
            "section":"String Predicates",
            "name":"isalpha",
            "params":{
              "map":{
                "s":" a string"
              },
              "1":"s"
            },
            "tags":[],
            "kind":"string predicates ",
            "description":"",
            "type":"function",
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":{
                "1":{
                  "type":"string"
                },
                "s":{
                  "type":"string"
                }
              }
            },
            "summary":"does s only contain digits?",
            "lineno":62,
            "args":"(s)",
            "section":"String Predicates",
            "name":"isdigit",
            "params":{
              "map":{
                "s":" a string"
              },
              "1":"s"
            },
            "tags":[],
            "kind":"string predicates ",
            "description":"",
            "type":"function",
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":{
                "1":{
                  "type":"string"
                },
                "s":{
                  "type":"string"
                }
              }
            },
            "summary":"does s only contain alphanumeric characters?",
            "lineno":69,
            "args":"(s)",
            "section":"String Predicates",
            "name":"isalnum",
            "params":{
              "map":{
                "s":" a string"
              },
              "1":"s"
            },
            "tags":[],
            "kind":"string predicates ",
            "description":"",
            "type":"function",
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":{
                "1":{
                  "type":"string"
                },
                "s":{
                  "type":"string"
                }
              }
            },
            "summary":"does s only contain whitespace?",
            "lineno":77,
            "args":"(s)",
            "section":"String Predicates",
            "name":"isspace",
            "params":{
              "map":{
                "s":" a string"
              },
              "1":"s"
            },
            "tags":[],
            "kind":"string predicates ",
            "description":"\n Matches on pattern '%s' so matches space, newline, tabs, etc.",
            "type":"function",
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":{
                "1":{
                  "type":"string"
                },
                "s":{
                  "type":"string"
                }
              }
            },
            "summary":"does s only contain lower case characters?",
            "lineno":84,
            "args":"(s)",
            "section":"String Predicates",
            "name":"islower",
            "params":{
              "map":{
                "s":" a string"
              },
              "1":"s"
            },
            "tags":[],
            "kind":"string predicates ",
            "description":"",
            "type":"function",
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":{
                "1":{
                  "type":"string"
                },
                "s":{
                  "type":"string"
                }
              }
            },
            "summary":"does s only contain upper case characters?",
            "lineno":91,
            "args":"(s)",
            "section":"String Predicates",
            "name":"isupper",
            "params":{
              "map":{
                "s":" a string"
              },
              "1":"s"
            },
            "tags":[],
            "kind":"string predicates ",
            "description":"",
            "type":"function",
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":[],
                "s":{
                  "type":"string"
                },
                "prefix":[]
              }
            },
            "summary":"does s start with prefix or one of prefixes?",
            "lineno":120,
            "args":"(s, prefix)",
            "section":"String Predicates",
            "name":"startswith",
            "params":{
              "1":"s",
              "2":"prefix",
              "map":{
                "s":" a string",
                "prefix":" a string or an array of strings"
              }
            },
            "tags":[],
            "kind":"string predicates ",
            "description":"",
            "type":"function",
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":[],
                "s":{
                  "type":"string"
                },
                "suffix":[]
              }
            },
            "summary":"does s end with suffix or one of suffixes?",
            "lineno":128,
            "args":"(s, suffix)",
            "section":"String Predicates",
            "name":"endswith",
            "params":{
              "1":"s",
              "2":"suffix",
              "map":{
                "s":" a string",
                "suffix":" a string or an array of strings"
              }
            },
            "tags":[],
            "kind":"string predicates ",
            "description":"",
            "type":"function",
            "parameter":"param"
          },{
            "name":"lists",
            "inferred":true,
            "description":"",
            "file":"<reference cycle>",
            "summary":"",
            "tags":[],
            "lineno":136,
            "display_name":"Strings and Lists",
            "type":"section",
            "modifiers":[]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[]],
              "return":[],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":[],
                "s":{
                  "type":"string"
                },
                "seq":[]
              }
            },
            "summary":"concatenate the strings using this string as a delimiter.",
            "lineno":141,
            "args":"(s, seq)",
            "usage":["stringx.join(' ', {1,2,3}) == '1 2 3'\n"],
            "section":"Strings and Lists",
            "name":"join",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"seq",
              "map":{
                "s":" the string",
                "seq":" a table of strings or numbers"
              }
            },
            "tags":[],
            "kind":"strings and lists ",
            "description":"\n Note that the arguments are reversed from `string.concat`.",
            "type":"function"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[[]],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "opt":true,
                  "type":"bool",
                  "optchain":true
                },
                "s":{
                  "type":"string"
                },
                "keep_ends":{
                  "opt":true,
                  "type":"bool",
                  "optchain":true
                }
              }
            },
            "summary":"Split a string into a list of lines.",
            "lineno":154,
            "retgroups":[{
                "1":{
                  "text":"List of lines",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s[, keep_ends])",
            "type":"function",
            "name":"splitlines",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"keep_ends",
              "map":{
                "s":" the string.",
                "keep_ends":" include line ends."
              }
            },
            "tags":[],
            "kind":"strings and lists ",
            "section":"Strings and Lists",
            "description":"\n `\"\\r\"`, `\"\\n\"`, and `\"\\r\\n\"` are considered line ends.\n They are not included in the lines unless `keepends` is passed.\n Terminal line end does not produce an extra line.\n Splitting an empty string results in an empty list.",
            "ret":["List of lines"]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[],[],[]],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "opt":true,
                  "type":"string",
                  "optchain":true
                },
                "3":{
                  "opt":true,
                  "type":"int",
                  "optchain":true
                },
                "re":{
                  "opt":true,
                  "type":"string",
                  "optchain":true
                },
                "n":{
                  "opt":true,
                  "type":"int",
                  "optchain":true
                },
                "s":{
                  "type":"string"
                }
              },
              "return":[[]]
            },
            "summary":"split a string into a list of strings using a delimiter.",
            "lineno":193,
            "retgroups":[{
                "1":{
                  "text":"List",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s[, re[, n]])",
            "usage":["#(stringx.split('one two')) == 2\n","stringx.split('one,two,three', ',') == List{'one','two','three'}\n","stringx.split('one,two,three', ',', 2) == List{'one','two,three'}\n"],
            "type":"function",
            "name":"split",
            "params":{
              "1":"s",
              "2":"re",
              "map":{
                "re":" a delimiter (defaults to whitespace)",
                "n":" maximum number of results",
                "s":" the string"
              },
              "3":"n"
            },
            "tags":[],
            "kind":"strings and lists ",
            "section":"Strings and Lists",
            "description":"",
            "ret":["List"],
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[],[]],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "type":"int"
                },
                "s":{
                  "type":"string"
                },
                "tabsize":{
                  "type":"int"
                }
              },
              "return":[[]]
            },
            "summary":"replace all tabs in s with tabsize spaces.",
            "lineno":216,
            "retgroups":[{
                "1":{
                  "text":"expanded string",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s, tabsize)",
            "usage":["stringx.expandtabs('\\tone,two,three', 4)   == '    one,two,three'\n","stringx.expandtabs('  \\tone,two,three', 4) == '    one,two,three'\n"],
            "type":"function",
            "name":"expandtabs",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"tabsize",
              "map":{
                "s":" the string",
                "tabsize":"[opt=8] number of spaces to expand each tab"
              }
            },
            "tags":[],
            "kind":"strings and lists ",
            "section":"Strings and Lists",
            "description":" If not specified, tabsize defaults to 8.\n Tab stops will be honored.",
            "ret":["expanded string"]
          },"<reference cycle>",{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[[]],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "type":"string"
                },
                "3":{
                  "opt":true,
                  "type":"int",
                  "optchain":true
                },
                "4":{
                  "opt":true,
                  "type":"int",
                  "optchain":true
                },
                "first":{
                  "opt":true,
                  "type":"int",
                  "optchain":true
                },
                "sub":{
                  "type":"string"
                },
                "s":{
                  "type":"string"
                },
                "last":{
                  "opt":true,
                  "type":"int",
                  "optchain":true
                }
              }
            },
            "summary":"find index of first instance of sub in s from the left.",
            "lineno":257,
            "retgroups":[{
                "1":{
                  "text":"start index, or nil if not found",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s, sub[, first[, last]])",
            "type":"function",
            "name":"lfind",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"sub",
              "3":"first",
              "4":"last",
              "map":{
                "first":" first index",
                "sub":" substring",
                "s":" the string",
                "last":" last index"
              }
            },
            "tags":[],
            "kind":"finding and replacing ",
            "section":"Finding and Replacing",
            "description":"",
            "ret":["start index, or nil if not found"]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[[]],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "type":"string"
                },
                "3":{
                  "opt":true,
                  "type":"int",
                  "optchain":true
                },
                "4":{
                  "opt":true,
                  "type":"int",
                  "optchain":true
                },
                "first":{
                  "opt":true,
                  "type":"int",
                  "optchain":true
                },
                "sub":{
                  "type":"string"
                },
                "s":{
                  "type":"string"
                },
                "last":{
                  "opt":true,
                  "type":"int",
                  "optchain":true
                }
              }
            },
            "summary":"find index of first instance of sub in s from the right.",
            "lineno":275,
            "retgroups":[{
                "1":{
                  "text":"start index, or nil if not found",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s, sub[, first[, last]])",
            "type":"function",
            "name":"rfind",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"sub",
              "3":"first",
              "4":"last",
              "map":{
                "first":" first index",
                "sub":" substring",
                "s":" the string",
                "last":" last index"
              }
            },
            "tags":[],
            "kind":"finding and replacing ",
            "section":"Finding and Replacing",
            "description":"",
            "ret":["start index, or nil if not found"]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[[]],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "type":"string"
                },
                "3":{
                  "type":"string"
                },
                "4":{
                  "opt":true,
                  "type":"int",
                  "optchain":true
                },
                "n":{
                  "opt":true,
                  "type":"int",
                  "optchain":true
                },
                "old":{
                  "type":"string"
                },
                "s":{
                  "type":"string"
                },
                "new":{
                  "type":"string"
                }
              }
            },
            "summary":"replace up to n instances of old by new in the string s.",
            "lineno":288,
            "retgroups":[{
                "1":{
                  "text":"result string",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s, old, new[, n])",
            "type":"function",
            "name":"replace",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"old",
              "3":"new",
              "4":"n",
              "map":{
                "n":" optional maximum number of substitutions",
                "old":" the target substring",
                "s":" the string",
                "new":" the substitution"
              }
            },
            "tags":[],
            "kind":"finding and replacing ",
            "section":"Finding and Replacing",
            "description":"\n If n is not present, replace all instances.",
            "ret":["result string"]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[]],
              "return":[],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "type":"string"
                },
                "3":{
                  "opt":true,
                  "type":"bool",
                  "optchain":true
                },
                "sub":{
                  "type":"string"
                },
                "s":{
                  "type":"string"
                },
                "allow_overlap":{
                  "opt":true,
                  "type":"bool",
                  "optchain":true
                }
              }
            },
            "summary":"count all instances of substring in string.",
            "lineno":302,
            "args":"(s, sub[, allow_overlap])",
            "usage":["assert(stringx.count('banana', 'ana') == 1)\nassert(stringx.count('banana', 'ana', true) == 2)\n"],
            "section":"Finding and Replacing",
            "name":"count",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"sub",
              "map":{
                "sub":" substring",
                "s":" the string",
                "allow_overlap":" allow matches to overlap"
              },
              "3":"allow_overlap"
            },
            "tags":[],
            "kind":"finding and replacing ",
            "description":"",
            "type":"function"
          },{
            "name":"strip",
            "inferred":true,
            "description":"",
            "file":"<reference cycle>",
            "summary":"",
            "tags":[],
            "lineno":311,
            "display_name":"Stripping and Justifying",
            "type":"section",
            "modifiers":[]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[]],
              "return":[],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "type":"int"
                },
                "3":{
                  "opt":"' '",
                  "type":"string",
                  "optchain":"' '"
                },
                "ch":{
                  "opt":"' '",
                  "type":"string",
                  "optchain":"' '"
                },
                "s":{
                  "type":"string"
                },
                "w":{
                  "type":"int"
                }
              }
            },
            "summary":"left-justify s with width w.",
            "lineno":339,
            "args":"(s, w[, ch=' '])",
            "usage":["stringx.ljust('hello', 10, '*') == '*****hello'\n"],
            "section":"Stripping and Justifying",
            "name":"ljust",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"w",
              "map":{
                "ch":" padding character",
                "s":" the string",
                "w":" width of justification"
              },
              "3":"ch"
            },
            "tags":[],
            "kind":"stripping and justifying ",
            "description":"",
            "type":"function"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[]],
              "return":[],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "type":"int"
                },
                "3":{
                  "opt":"' '",
                  "type":"string",
                  "optchain":"' '"
                },
                "ch":{
                  "opt":"' '",
                  "type":"string",
                  "optchain":"' '"
                },
                "s":{
                  "type":"string"
                },
                "w":{
                  "type":"int"
                }
              }
            },
            "summary":"right-justify s with width w.",
            "lineno":350,
            "args":"(s, w[, ch=' '])",
            "usage":["stringx.rjust('hello', 10, '*') == 'hello*****'\n"],
            "section":"Stripping and Justifying",
            "name":"rjust",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"w",
              "map":{
                "ch":" padding character",
                "s":" the string",
                "w":" width of justification"
              },
              "3":"ch"
            },
            "tags":[],
            "kind":"stripping and justifying ",
            "description":"",
            "type":"function"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[]],
              "return":[],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "type":"int"
                },
                "3":{
                  "opt":"' '",
                  "type":"string",
                  "optchain":"' '"
                },
                "ch":{
                  "opt":"' '",
                  "type":"string",
                  "optchain":"' '"
                },
                "s":{
                  "type":"string"
                },
                "w":{
                  "type":"int"
                }
              }
            },
            "summary":"center-justify s with width w.",
            "lineno":361,
            "args":"(s, w[, ch=' '])",
            "usage":["stringx.center('hello', 10, '*') == '**hello***'\n"],
            "section":"Stripping and Justifying",
            "name":"center",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"w",
              "map":{
                "ch":" padding character",
                "s":" the string",
                "w":" width of justification"
              },
              "3":"ch"
            },
            "tags":[],
            "kind":"stripping and justifying ",
            "description":"",
            "type":"function"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "opt":"'%s'",
                  "type":"string",
                  "optchain":"'%s'"
                },
                "s":{
                  "type":"string"
                },
                "chrs":{
                  "opt":"'%s'",
                  "type":"string",
                  "optchain":"'%s'"
                }
              }
            },
            "summary":"trim any characters on the left of s.",
            "lineno":402,
            "args":"(s[, chrs='%s'])",
            "section":"Stripping and Justifying",
            "name":"lstrip",
            "params":{
              "1":"s",
              "2":"chrs",
              "map":{
                "s":" the string",
                "chrs":" default any whitespace character,\n but can be a string of characters to be trimmed"
              }
            },
            "tags":[],
            "kind":"stripping and justifying ",
            "description":"",
            "type":"function",
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "opt":"'%s'",
                  "type":"string",
                  "optchain":"'%s'"
                },
                "s":{
                  "type":"string"
                },
                "chrs":{
                  "opt":"'%s'",
                  "type":"string",
                  "optchain":"'%s'"
                }
              }
            },
            "summary":"trim any characters on the right of s.",
            "lineno":412,
            "args":"(s[, chrs='%s'])",
            "section":"Stripping and Justifying",
            "name":"rstrip",
            "params":{
              "1":"s",
              "2":"chrs",
              "map":{
                "s":" the string",
                "chrs":" default any whitespace character,\n but can be a string of characters to be trimmed"
              }
            },
            "tags":[],
            "kind":"stripping and justifying ",
            "description":"",
            "type":"function",
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[]],
              "return":[],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "opt":"'%s'",
                  "type":"string",
                  "optchain":"'%s'"
                },
                "s":{
                  "type":"string"
                },
                "chrs":{
                  "opt":"'%s'",
                  "type":"string",
                  "optchain":"'%s'"
                }
              }
            },
            "summary":"trim any characters on both left and right of s.",
            "lineno":422,
            "args":"(s[, chrs='%s'])",
            "usage":["stringx.strip('  --== Hello ==--  ', \"- =\")  --> 'Hello'\n"],
            "section":"Stripping and Justifying",
            "name":"strip",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"chrs",
              "map":{
                "s":" the string",
                "chrs":" default any whitespace character,\n but can be a string of characters to be trimmed"
              }
            },
            "tags":[],
            "kind":"stripping and justifying ",
            "description":"",
            "type":"function"
          },{
            "name":"partitioning",
            "inferred":true,
            "description":"",
            "file":"<reference cycle>",
            "summary":"",
            "tags":[],
            "lineno":430,
            "display_name":"Partitioning Strings",
            "type":"section",
            "modifiers":[]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "opt":"'%s'",
                  "type":"string",
                  "optchain":"'%s'"
                },
                "s":{
                  "type":"string"
                },
                "re":{
                  "opt":"'%s'",
                  "type":"string",
                  "optchain":"'%s'"
                }
              },
              "return":[[]],
              "usage":[[]],
              "see":[[]]
            },
            "summary":"split a string using a pattern.",
            "lineno":436,
            "retgroups":[{
                "1":{
                  "text":"the parts of the string",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s[, re='%s'])",
            "usage":["a,b = line:splitv('=')\n"],
            "type":"function",
            "name":"splitv",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"re",
              "map":{
                "s":" the string",
                "re":" a Lua string pattern (defaults to whitespace)"
              }
            },
            "tags":{
              "see":[]
            },
            "kind":"partitioning strings ",
            "section":"Partitioning Strings",
            "description":" Note that at least one value will be returned!",
            "ret":["the parts of the string"]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[],[]],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "type":"string"
                },
                "s":{
                  "type":"string"
                },
                "ch":{
                  "type":"string"
                }
              },
              "return":[[],[],[]]
            },
            "summary":"partition the string using first occurance of a delimiter",
            "lineno":461,
            "retgroups":[{
                "1":{
                  "text":"part before ch",
                  "type":"",
                  "mods":[]
                },
                "2":{
                  "text":"ch",
                  "type":"",
                  "mods":[]
                },
                "3":{
                  "text":"part after ch",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s, ch)",
            "usage":["{stringx.partition('a,b,c', ','))} == {'a', ',', 'b,c'}\n","{stringx.partition('abc', 'x'))} == {'abc', '', ''}\n"],
            "type":"function",
            "name":"partition",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"ch",
              "map":{
                "s":" the string",
                "ch":" delimiter (match as plain string, no patterns)"
              }
            },
            "tags":[],
            "kind":"partitioning strings ",
            "section":"Partitioning Strings",
            "description":"",
            "ret":["part before ch","ch","part after ch"]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[],[]],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "type":"string"
                },
                "s":{
                  "type":"string"
                },
                "ch":{
                  "type":"string"
                }
              },
              "return":[[],[],[]]
            },
            "summary":"partition the string p using last occurance of a delimiter",
            "lineno":475,
            "retgroups":[{
                "1":{
                  "text":"part before ch",
                  "type":"",
                  "mods":[]
                },
                "2":{
                  "text":"ch",
                  "type":"",
                  "mods":[]
                },
                "3":{
                  "text":"part after ch",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s, ch)",
            "usage":["{stringx.rpartition('a,b,c', ','))} == {'a,b', ',', 'c'}\n","{stringx.rpartition('abc', 'x'))} == {'', '', 'abc'}\n"],
            "type":"function",
            "name":"rpartition",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"ch",
              "map":{
                "s":" the string",
                "ch":" delimiter (match as plain string, no patterns)"
              }
            },
            "tags":[],
            "kind":"partitioning strings ",
            "section":"Partitioning Strings",
            "description":"",
            "ret":["part before ch","ch","part after ch"]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[[]],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "type":"int"
                },
                "s":{
                  "type":"string"
                },
                "idx":{
                  "type":"int"
                }
              }
            },
            "summary":"return the 'character' at the index.",
            "lineno":489,
            "retgroups":[{
                "1":{
                  "text":"a substring of length 1 if successful, empty string otherwise.",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s, idx)",
            "type":"function",
            "name":"at",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"idx",
              "map":{
                "s":" the string",
                "idx":" an index (can be negative)"
              }
            },
            "tags":[],
            "kind":"partitioning strings ",
            "section":"Partitioning Strings",
            "description":"",
            "ret":["a substring of length 1 if successful, empty string otherwise."]
          },{
            "name":"text",
            "inferred":true,
            "description":"",
            "file":"<reference cycle>",
            "summary":"",
            "tags":[],
            "lineno":500,
            "display_name":"Text handling",
            "type":"section",
            "modifiers":[]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[[]],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "type":"integer"
                },
                "3":{
                  "opt":"' '",
                  "type":"string",
                  "optchain":"' '"
                },
                "ch":{
                  "opt":"' '",
                  "type":"string",
                  "optchain":"' '"
                },
                "n":{
                  "type":"integer"
                },
                "s":{
                  "type":"string"
                }
              }
            },
            "summary":"indent a multiline string.",
            "lineno":505,
            "retgroups":[{
                "1":{
                  "text":"indented string",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s, n[, ch=' '])",
            "type":"function",
            "name":"indent",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"n",
              "map":{
                "ch":" the character to use when indenting",
                "n":" the size of the indent",
                "s":" the (multiline) string"
              },
              "3":"ch"
            },
            "tags":[],
            "kind":"text handling ",
            "section":"Text handling",
            "description":"",
            "ret":["indented string"]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[]],
              "param":{
                "1":{
                  "type":"string"
                },
                "s":{
                  "type":"string"
                }
              },
              "return":[[]]
            },
            "summary":"dedent a multiline string by removing any initial indent.",
            "lineno":537,
            "retgroups":[{
                "1":{
                  "text":"a string with initial indent zero.",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s)",
            "usage":["local s = dedent [[\n         One\n\n       Two\n\n     Three\n]]\nassert(s == [[\n    One\n\n  Two\n\nThree\n]])\n"],
            "type":"function",
            "name":"dedent",
            "parameter":"param",
            "params":{
              "map":{
                "s":" the (multiline) string"
              },
              "1":"s"
            },
            "tags":[],
            "kind":"text handling ",
            "section":"Text handling",
            "description":"\n useful when working with [[..]] strings.\n Empty lines are ignored.",
            "ret":["a string with initial indent zero."]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "opt":"70",
                  "type":"integer",
                  "optchain":"70"
                },
                "3":{
                  "opt":"false",
                  "type":"boolean",
                  "optchain":"false"
                },
                "width":{
                  "opt":"70",
                  "type":"integer",
                  "optchain":"70"
                },
                "s":{
                  "type":"string"
                },
                "breaklong":{
                  "opt":"false",
                  "type":"boolean",
                  "optchain":"false"
                }
              },
              "return":[[]],
              "see":[[],[]]
            },
            "summary":"format a paragraph into lines so that they fit into a line width.",
            "lineno":594,
            "retgroups":[{
                "1":{
                  "text":"a list of lines (List object), use `fill` to return a string instead of a `List`.",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s[, width=70[, breaklong=false]])",
            "type":"function",
            "name":"wrap",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"width",
              "map":{
                "width":" the margin width",
                "s":" the string to format",
                "breaklong":" if truthy, words longer than the width given will be forced split."
              },
              "3":"breaklong"
            },
            "tags":{
              "see":[]
            },
            "kind":"text handling ",
            "section":"Text handling",
            "description":"\n It will not break long words by default, so lines can be over the length\n to that extent.",
            "ret":["a list of lines (List object), use `fill` to return a string instead of a `List`."]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "opt":"70",
                  "type":"integer",
                  "optchain":"70"
                },
                "3":{
                  "opt":"false",
                  "type":"boolean",
                  "optchain":"false"
                },
                "width":{
                  "opt":"70",
                  "type":"integer",
                  "optchain":"70"
                },
                "s":{
                  "type":"string"
                },
                "breaklong":{
                  "opt":"false",
                  "type":"boolean",
                  "optchain":"false"
                }
              },
              "return":[[]],
              "see":[[]]
            },
            "summary":"format a paragraph so that it fits into a line width.",
            "lineno":616,
            "retgroups":[{
                "1":{
                  "text":"a string, use `wrap` to return a list of lines instead of a string.",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s[, width=70[, breaklong=false]])",
            "type":"function",
            "name":"fill",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"width",
              "map":{
                "width":" the margin width",
                "s":" the string to format",
                "breaklong":" if truthy, words longer than the width given will be forced split."
              },
              "3":"breaklong"
            },
            "tags":{
              "see":[]
            },
            "kind":"text handling ",
            "section":"Text handling",
            "description":"",
            "ret":["a string, use `wrap` to return a list of lines instead of a string."]
          },{
            "name":"Template",
            "inferred":true,
            "description":"",
            "file":"<reference cycle>",
            "summary":"",
            "tags":[],
            "lineno":624,
            "display_name":"Template",
            "type":"section",
            "modifiers":[]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "param":{
                "1":{
                  "type":"string"
                },
                "tmpl":{
                  "type":"string"
                }
              },
              "return":[{
                  "type":"Template"
                }]
            },
            "summary":"Creates a new Template class.",
            "lineno":662,
            "retgroups":[{
                "1":{
                  "text":"",
                  "type":"Template",
                  "mods":{
                    "type":"Template"
                  }
                },
                "g":0
              }],
            "args":"(tmpl)",
            "section":"Template",
            "name":"Template",
            "params":{
              "map":{
                "tmpl":" the template string"
              },
              "1":"tmpl"
            },
            "tags":[],
            "kind":"template ",
            "description":"\n This is a shortcut to `Template.new(tmpl)`.",
            "type":"function",
            "ret":[""],
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[[]],
              "param":{
                "1":{
                  "type":"table"
                },
                "tbl":{
                  "type":"table"
                }
              }
            },
            "summary":"substitute values into a template, throwing an error.",
            "lineno":674,
            "retgroups":[{
                "1":{
                  "text":"string with place holders substituted",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(tbl)",
            "type":"function",
            "name":"Template:substitute",
            "parameter":"param",
            "params":{
              "map":{
                "tbl":" a table of name-value pairs."
              },
              "1":"tbl"
            },
            "tags":[],
            "kind":"template ",
            "section":"Template",
            "description":"\n This will throw an error if no name is found.",
            "ret":["string with place holders substituted"]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[[]],
              "param":{
                "1":{
                  "type":"table"
                },
                "tbl":{
                  "type":"table"
                }
              }
            },
            "summary":"substitute values into a template.",
            "lineno":683,
            "retgroups":[{
                "1":{
                  "text":"string with place holders substituted",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(tbl)",
            "type":"function",
            "name":"Template:safe_substitute",
            "parameter":"param",
            "params":{
              "map":{
                "tbl":" a table of name-value pairs."
              },
              "1":"tbl"
            },
            "tags":[],
            "kind":"template ",
            "section":"Template",
            "description":"\n This version just passes unknown names through.",
            "ret":["string with place holders substituted"]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[[]],
              "param":{
                "1":{
                  "type":"table"
                },
                "tbl":{
                  "type":"table"
                }
              }
            },
            "summary":"substitute values into a template, preserving indentation.",
            "lineno":695,
            "retgroups":[{
                "1":{
                  "text":"string with place holders substituted",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(tbl)",
            "type":"function",
            "name":"Template:indent_substitute",
            "parameter":"param",
            "params":{
              "map":{
                "tbl":" a table of name-value pairs."
              },
              "1":"tbl"
            },
            "tags":[],
            "kind":"template ",
            "section":"Template",
            "description":" <br>\n If the value is a multiline string _or_ a template, it will insert\n the lines at the correct indentation. <br>\n Furthermore, if a template, then that template will be substituted\n using the same table.",
            "ret":["string with place holders substituted"]
          },{
            "name":"misc",
            "inferred":true,
            "description":"",
            "file":"<reference cycle>",
            "summary":"",
            "tags":[],
            "lineno":742,
            "display_name":"Miscelaneous",
            "type":"section",
            "modifiers":[]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[]],
              "param":{
                "1":{
                  "type":"string"
                },
                "s":{
                  "type":"string"
                }
              },
              "return":[[]]
            },
            "summary":"return an iterator over all lines in a string",
            "lineno":751,
            "retgroups":[{
                "1":{
                  "text":"an iterator",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s)",
            "usage":["local line_no = 1\nfor line in stringx.lines(some_text) do\n  print(line_no, line)\n  line_no = line_no + 1\nend\n"],
            "type":"function",
            "name":"lines",
            "parameter":"param",
            "params":{
              "map":{
                "s":" the string"
              },
              "1":"s"
            },
            "tags":[],
            "kind":"miscelaneous ",
            "section":"Miscelaneous",
            "description":"",
            "ret":["an iterator"]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[]],
              "param":{
                "1":{
                  "type":"string"
                },
                "s":{
                  "type":"string"
                }
              },
              "return":[[]]
            },
            "summary":"inital word letters uppercase ('title case').",
            "lineno":762,
            "retgroups":[{
                "1":{
                  "text":"a string with each word's first letter uppercase",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s)",
            "usage":["stringx.title(\"hello world\") == \"Hello World\")\n"],
            "type":"function",
            "name":"title",
            "parameter":"param",
            "params":{
              "map":{
                "s":" the string"
              },
              "1":"s"
            },
            "tags":[],
            "kind":"miscelaneous ",
            "section":"Miscelaneous",
            "description":"\n Here 'words' mean chunks of non-space characters.",
            "ret":["a string with each word's first letter uppercase"]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[],[],[]],
              "return":[],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "type":"int"
                },
                "3":{
                  "type":"bool"
                },
                "tail":{
                  "type":"bool"
                },
                "s":{
                  "type":"string"
                },
                "w":{
                  "type":"int"
                }
              }
            },
            "summary":"Return a shortened version of a string.",
            "lineno":783,
            "args":"(s, w, tail)",
            "usage":["('1234567890'):shorten(8) == '12345...'\n","('1234567890'):shorten(8, true) == '...67890'\n","('1234567890'):shorten(20) == '1234567890'\n"],
            "section":"Miscelaneous",
            "name":"shorten",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"w",
              "map":{
                "tail":" true if we want to show the end of the string (head otherwise)",
                "s":" the string",
                "w":" the maxinum size allowed"
              },
              "3":"tail"
            },
            "tags":[],
            "kind":"miscelaneous ",
            "description":"\n Fits string within w characters. Removed characters are marked with ellipsis.",
            "type":"function"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[[]],
              "param":{
                "1":[],
                "s":[]
              }
            },
            "summary":"Quote the given string and preserve any control or escape characters, such that reloading the string in Lua returns the same result.",
            "lineno":822,
            "retgroups":[{
                "1":{
                  "text":"The quoted string.",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s)",
            "type":"function",
            "name":"quote_string",
            "parameter":"param",
            "params":{
              "map":{
                "s":" The string to be quoted."
              },
              "1":"s"
            },
            "tags":[],
            "kind":"miscelaneous ",
            "section":"Miscelaneous",
            "description":"",
            "ret":["The quoted string."]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":[],
              "usage":[[]]
            },
            "summary":"Python-style formatting operator.",
            "lineno":873,
            "args":"()",
            "usage":["require 'pl.text'.format_operator()\nlocal out1 = '%s = %5.3f' % {'PI',math.pi}                   --> 'PI = 3.142'\nlocal out2 = '$name = $value' % {name='dog',value='Pluto'}   --> 'dog = Pluto'\n"],
            "section":"Miscelaneous",
            "name":"format_operator",
            "parameter":"param",
            "params":{
              "map":[]
            },
            "tags":[],
            "kind":"miscelaneous ",
            "description":"\n Calling `text.format_operator()` overloads the % operator for strings to give\n Python/Ruby style formated output.\n This is extended to also do template-like substitution for map-like data.\n\n Note this goes further than the original, and will allow these cases:\n\n 1. a single value\n 2. a list of values\n 3. a map of var=value pairs\n 4. a function, as in gsub\n\n For the second two cases, it uses $-variable substituion.\n\n When called, this function will monkey-patch the global `string` metatable by\n adding a `__mod` method.\n\n See <a href=\"http://lua-users.org/wiki/StringInterpolation\">the lua-users wiki</a>\n",
            "type":"function"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "param":[],
              "return":[]
            },
            "summary":"import the stringx functions into the global string (meta)table",
            "lineno":913,
            "args":"()",
            "section":"Miscelaneous",
            "name":"import",
            "params":{
              "map":[]
            },
            "tags":[],
            "kind":"miscelaneous ",
            "description":"",
            "type":"function",
            "parameter":"param"
          }],
        "sections":[],
        "modules":["<reference cycle>"],
        "args":{
          "one":false,
          "module":false,
          "verbose":false,
          "style":"!",
          "template":"!",
          "date":"system",
          "dir":"doc",
          "quiet":false,
          "all":false,
          "ignore":false,
          "colon":false,
          "not_luadoc":false,
          "ext":"html",
          "boilerplate":false,
          "merge":false,
          "filter":"f.filter",
          "package":"/home/cji/portless/Penlight/lua",
          "dump":false,
          "no_args_infer":false,
          "title":"Reference",
          "project":"ldoc",
          "file":"/home/cji/portless/Penlight/lua/pl",
          "format":"discount",
          "simple":false,
          "tags":"none",
          "define":"none",
          "output":"index",
          "unqualified":false,
          "config":"config.ld",
          "fatalwarnings":false,
          "testing":false
        },
        "error":"<type 'function' is not supported by JSON.>",
        "lang":{
          "line_comment":"^%-%-+",
          "start_comment_":"^%-%-%-+",
          "end_comment_":"[^%-]%-%-+[^-]*\n$",
          "extra":[],
          "block_comment":"^%-%-%[=*%[%-+",
          "empty_comment_":"^%-%-%-+%s*$",
          "method_call":":"
        },
        "base":"/home/cji/portless/Penlight/lua"
      },
      "summary":"",
      "tags":[],
      "lineno":231,
      "display_name":"Finding and Replacing",
      "type":"section",
      "modifiers":[]
    },
    "4":{
      "name":"strip",
      "inferred":true,
      "description":"",
      "file":{
        "warning":"<type 'function' is not supported by JSON.>",
        "filename":"/home/cji/portless/Penlight/lua/pl/stringx.lua",
        "items":["<reference cycle>",{
            "name":"predicates",
            "inferred":true,
            "description":"",
            "file":"<reference cycle>",
            "summary":"",
            "tags":[],
            "lineno":53,
            "display_name":"String Predicates",
            "type":"section",
            "modifiers":[]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":{
                "1":{
                  "type":"string"
                },
                "s":{
                  "type":"string"
                }
              }
            },
            "summary":"does s only contain alphabetic characters?",
            "lineno":55,
            "args":"(s)",
            "section":"String Predicates",
            "name":"isalpha",
            "params":{
              "map":{
                "s":" a string"
              },
              "1":"s"
            },
            "tags":[],
            "kind":"string predicates ",
            "description":"",
            "type":"function",
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":{
                "1":{
                  "type":"string"
                },
                "s":{
                  "type":"string"
                }
              }
            },
            "summary":"does s only contain digits?",
            "lineno":62,
            "args":"(s)",
            "section":"String Predicates",
            "name":"isdigit",
            "params":{
              "map":{
                "s":" a string"
              },
              "1":"s"
            },
            "tags":[],
            "kind":"string predicates ",
            "description":"",
            "type":"function",
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":{
                "1":{
                  "type":"string"
                },
                "s":{
                  "type":"string"
                }
              }
            },
            "summary":"does s only contain alphanumeric characters?",
            "lineno":69,
            "args":"(s)",
            "section":"String Predicates",
            "name":"isalnum",
            "params":{
              "map":{
                "s":" a string"
              },
              "1":"s"
            },
            "tags":[],
            "kind":"string predicates ",
            "description":"",
            "type":"function",
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":{
                "1":{
                  "type":"string"
                },
                "s":{
                  "type":"string"
                }
              }
            },
            "summary":"does s only contain whitespace?",
            "lineno":77,
            "args":"(s)",
            "section":"String Predicates",
            "name":"isspace",
            "params":{
              "map":{
                "s":" a string"
              },
              "1":"s"
            },
            "tags":[],
            "kind":"string predicates ",
            "description":"\n Matches on pattern '%s' so matches space, newline, tabs, etc.",
            "type":"function",
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":{
                "1":{
                  "type":"string"
                },
                "s":{
                  "type":"string"
                }
              }
            },
            "summary":"does s only contain lower case characters?",
            "lineno":84,
            "args":"(s)",
            "section":"String Predicates",
            "name":"islower",
            "params":{
              "map":{
                "s":" a string"
              },
              "1":"s"
            },
            "tags":[],
            "kind":"string predicates ",
            "description":"",
            "type":"function",
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":{
                "1":{
                  "type":"string"
                },
                "s":{
                  "type":"string"
                }
              }
            },
            "summary":"does s only contain upper case characters?",
            "lineno":91,
            "args":"(s)",
            "section":"String Predicates",
            "name":"isupper",
            "params":{
              "map":{
                "s":" a string"
              },
              "1":"s"
            },
            "tags":[],
            "kind":"string predicates ",
            "description":"",
            "type":"function",
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":[],
                "s":{
                  "type":"string"
                },
                "prefix":[]
              }
            },
            "summary":"does s start with prefix or one of prefixes?",
            "lineno":120,
            "args":"(s, prefix)",
            "section":"String Predicates",
            "name":"startswith",
            "params":{
              "1":"s",
              "2":"prefix",
              "map":{
                "s":" a string",
                "prefix":" a string or an array of strings"
              }
            },
            "tags":[],
            "kind":"string predicates ",
            "description":"",
            "type":"function",
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":[],
                "s":{
                  "type":"string"
                },
                "suffix":[]
              }
            },
            "summary":"does s end with suffix or one of suffixes?",
            "lineno":128,
            "args":"(s, suffix)",
            "section":"String Predicates",
            "name":"endswith",
            "params":{
              "1":"s",
              "2":"suffix",
              "map":{
                "s":" a string",
                "suffix":" a string or an array of strings"
              }
            },
            "tags":[],
            "kind":"string predicates ",
            "description":"",
            "type":"function",
            "parameter":"param"
          },{
            "name":"lists",
            "inferred":true,
            "description":"",
            "file":"<reference cycle>",
            "summary":"",
            "tags":[],
            "lineno":136,
            "display_name":"Strings and Lists",
            "type":"section",
            "modifiers":[]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[]],
              "return":[],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":[],
                "s":{
                  "type":"string"
                },
                "seq":[]
              }
            },
            "summary":"concatenate the strings using this string as a delimiter.",
            "lineno":141,
            "args":"(s, seq)",
            "usage":["stringx.join(' ', {1,2,3}) == '1 2 3'\n"],
            "section":"Strings and Lists",
            "name":"join",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"seq",
              "map":{
                "s":" the string",
                "seq":" a table of strings or numbers"
              }
            },
            "tags":[],
            "kind":"strings and lists ",
            "description":"\n Note that the arguments are reversed from `string.concat`.",
            "type":"function"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[[]],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "opt":true,
                  "type":"bool",
                  "optchain":true
                },
                "s":{
                  "type":"string"
                },
                "keep_ends":{
                  "opt":true,
                  "type":"bool",
                  "optchain":true
                }
              }
            },
            "summary":"Split a string into a list of lines.",
            "lineno":154,
            "retgroups":[{
                "1":{
                  "text":"List of lines",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s[, keep_ends])",
            "type":"function",
            "name":"splitlines",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"keep_ends",
              "map":{
                "s":" the string.",
                "keep_ends":" include line ends."
              }
            },
            "tags":[],
            "kind":"strings and lists ",
            "section":"Strings and Lists",
            "description":"\n `\"\\r\"`, `\"\\n\"`, and `\"\\r\\n\"` are considered line ends.\n They are not included in the lines unless `keepends` is passed.\n Terminal line end does not produce an extra line.\n Splitting an empty string results in an empty list.",
            "ret":["List of lines"]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[],[],[]],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "opt":true,
                  "type":"string",
                  "optchain":true
                },
                "3":{
                  "opt":true,
                  "type":"int",
                  "optchain":true
                },
                "re":{
                  "opt":true,
                  "type":"string",
                  "optchain":true
                },
                "n":{
                  "opt":true,
                  "type":"int",
                  "optchain":true
                },
                "s":{
                  "type":"string"
                }
              },
              "return":[[]]
            },
            "summary":"split a string into a list of strings using a delimiter.",
            "lineno":193,
            "retgroups":[{
                "1":{
                  "text":"List",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s[, re[, n]])",
            "usage":["#(stringx.split('one two')) == 2\n","stringx.split('one,two,three', ',') == List{'one','two','three'}\n","stringx.split('one,two,three', ',', 2) == List{'one','two,three'}\n"],
            "type":"function",
            "name":"split",
            "params":{
              "1":"s",
              "2":"re",
              "map":{
                "re":" a delimiter (defaults to whitespace)",
                "n":" maximum number of results",
                "s":" the string"
              },
              "3":"n"
            },
            "tags":[],
            "kind":"strings and lists ",
            "section":"Strings and Lists",
            "description":"",
            "ret":["List"],
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[],[]],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "type":"int"
                },
                "s":{
                  "type":"string"
                },
                "tabsize":{
                  "type":"int"
                }
              },
              "return":[[]]
            },
            "summary":"replace all tabs in s with tabsize spaces.",
            "lineno":216,
            "retgroups":[{
                "1":{
                  "text":"expanded string",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s, tabsize)",
            "usage":["stringx.expandtabs('\\tone,two,three', 4)   == '    one,two,three'\n","stringx.expandtabs('  \\tone,two,three', 4) == '    one,two,three'\n"],
            "type":"function",
            "name":"expandtabs",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"tabsize",
              "map":{
                "s":" the string",
                "tabsize":"[opt=8] number of spaces to expand each tab"
              }
            },
            "tags":[],
            "kind":"strings and lists ",
            "section":"Strings and Lists",
            "description":" If not specified, tabsize defaults to 8.\n Tab stops will be honored.",
            "ret":["expanded string"]
          },{
            "name":"find",
            "inferred":true,
            "description":"",
            "file":"<reference cycle>",
            "summary":"",
            "tags":[],
            "lineno":231,
            "display_name":"Finding and Replacing",
            "type":"section",
            "modifiers":[]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[[]],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "type":"string"
                },
                "3":{
                  "opt":true,
                  "type":"int",
                  "optchain":true
                },
                "4":{
                  "opt":true,
                  "type":"int",
                  "optchain":true
                },
                "first":{
                  "opt":true,
                  "type":"int",
                  "optchain":true
                },
                "sub":{
                  "type":"string"
                },
                "s":{
                  "type":"string"
                },
                "last":{
                  "opt":true,
                  "type":"int",
                  "optchain":true
                }
              }
            },
            "summary":"find index of first instance of sub in s from the left.",
            "lineno":257,
            "retgroups":[{
                "1":{
                  "text":"start index, or nil if not found",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s, sub[, first[, last]])",
            "type":"function",
            "name":"lfind",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"sub",
              "3":"first",
              "4":"last",
              "map":{
                "first":" first index",
                "sub":" substring",
                "s":" the string",
                "last":" last index"
              }
            },
            "tags":[],
            "kind":"finding and replacing ",
            "section":"Finding and Replacing",
            "description":"",
            "ret":["start index, or nil if not found"]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[[]],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "type":"string"
                },
                "3":{
                  "opt":true,
                  "type":"int",
                  "optchain":true
                },
                "4":{
                  "opt":true,
                  "type":"int",
                  "optchain":true
                },
                "first":{
                  "opt":true,
                  "type":"int",
                  "optchain":true
                },
                "sub":{
                  "type":"string"
                },
                "s":{
                  "type":"string"
                },
                "last":{
                  "opt":true,
                  "type":"int",
                  "optchain":true
                }
              }
            },
            "summary":"find index of first instance of sub in s from the right.",
            "lineno":275,
            "retgroups":[{
                "1":{
                  "text":"start index, or nil if not found",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s, sub[, first[, last]])",
            "type":"function",
            "name":"rfind",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"sub",
              "3":"first",
              "4":"last",
              "map":{
                "first":" first index",
                "sub":" substring",
                "s":" the string",
                "last":" last index"
              }
            },
            "tags":[],
            "kind":"finding and replacing ",
            "section":"Finding and Replacing",
            "description":"",
            "ret":["start index, or nil if not found"]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[[]],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "type":"string"
                },
                "3":{
                  "type":"string"
                },
                "4":{
                  "opt":true,
                  "type":"int",
                  "optchain":true
                },
                "n":{
                  "opt":true,
                  "type":"int",
                  "optchain":true
                },
                "old":{
                  "type":"string"
                },
                "s":{
                  "type":"string"
                },
                "new":{
                  "type":"string"
                }
              }
            },
            "summary":"replace up to n instances of old by new in the string s.",
            "lineno":288,
            "retgroups":[{
                "1":{
                  "text":"result string",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s, old, new[, n])",
            "type":"function",
            "name":"replace",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"old",
              "3":"new",
              "4":"n",
              "map":{
                "n":" optional maximum number of substitutions",
                "old":" the target substring",
                "s":" the string",
                "new":" the substitution"
              }
            },
            "tags":[],
            "kind":"finding and replacing ",
            "section":"Finding and Replacing",
            "description":"\n If n is not present, replace all instances.",
            "ret":["result string"]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[]],
              "return":[],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "type":"string"
                },
                "3":{
                  "opt":true,
                  "type":"bool",
                  "optchain":true
                },
                "sub":{
                  "type":"string"
                },
                "s":{
                  "type":"string"
                },
                "allow_overlap":{
                  "opt":true,
                  "type":"bool",
                  "optchain":true
                }
              }
            },
            "summary":"count all instances of substring in string.",
            "lineno":302,
            "args":"(s, sub[, allow_overlap])",
            "usage":["assert(stringx.count('banana', 'ana') == 1)\nassert(stringx.count('banana', 'ana', true) == 2)\n"],
            "section":"Finding and Replacing",
            "name":"count",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"sub",
              "map":{
                "sub":" substring",
                "s":" the string",
                "allow_overlap":" allow matches to overlap"
              },
              "3":"allow_overlap"
            },
            "tags":[],
            "kind":"finding and replacing ",
            "description":"",
            "type":"function"
          },"<reference cycle>",{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[]],
              "return":[],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "type":"int"
                },
                "3":{
                  "opt":"' '",
                  "type":"string",
                  "optchain":"' '"
                },
                "ch":{
                  "opt":"' '",
                  "type":"string",
                  "optchain":"' '"
                },
                "s":{
                  "type":"string"
                },
                "w":{
                  "type":"int"
                }
              }
            },
            "summary":"left-justify s with width w.",
            "lineno":339,
            "args":"(s, w[, ch=' '])",
            "usage":["stringx.ljust('hello', 10, '*') == '*****hello'\n"],
            "section":"Stripping and Justifying",
            "name":"ljust",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"w",
              "map":{
                "ch":" padding character",
                "s":" the string",
                "w":" width of justification"
              },
              "3":"ch"
            },
            "tags":[],
            "kind":"stripping and justifying ",
            "description":"",
            "type":"function"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[]],
              "return":[],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "type":"int"
                },
                "3":{
                  "opt":"' '",
                  "type":"string",
                  "optchain":"' '"
                },
                "ch":{
                  "opt":"' '",
                  "type":"string",
                  "optchain":"' '"
                },
                "s":{
                  "type":"string"
                },
                "w":{
                  "type":"int"
                }
              }
            },
            "summary":"right-justify s with width w.",
            "lineno":350,
            "args":"(s, w[, ch=' '])",
            "usage":["stringx.rjust('hello', 10, '*') == 'hello*****'\n"],
            "section":"Stripping and Justifying",
            "name":"rjust",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"w",
              "map":{
                "ch":" padding character",
                "s":" the string",
                "w":" width of justification"
              },
              "3":"ch"
            },
            "tags":[],
            "kind":"stripping and justifying ",
            "description":"",
            "type":"function"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[]],
              "return":[],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "type":"int"
                },
                "3":{
                  "opt":"' '",
                  "type":"string",
                  "optchain":"' '"
                },
                "ch":{
                  "opt":"' '",
                  "type":"string",
                  "optchain":"' '"
                },
                "s":{
                  "type":"string"
                },
                "w":{
                  "type":"int"
                }
              }
            },
            "summary":"center-justify s with width w.",
            "lineno":361,
            "args":"(s, w[, ch=' '])",
            "usage":["stringx.center('hello', 10, '*') == '**hello***'\n"],
            "section":"Stripping and Justifying",
            "name":"center",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"w",
              "map":{
                "ch":" padding character",
                "s":" the string",
                "w":" width of justification"
              },
              "3":"ch"
            },
            "tags":[],
            "kind":"stripping and justifying ",
            "description":"",
            "type":"function"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "opt":"'%s'",
                  "type":"string",
                  "optchain":"'%s'"
                },
                "s":{
                  "type":"string"
                },
                "chrs":{
                  "opt":"'%s'",
                  "type":"string",
                  "optchain":"'%s'"
                }
              }
            },
            "summary":"trim any characters on the left of s.",
            "lineno":402,
            "args":"(s[, chrs='%s'])",
            "section":"Stripping and Justifying",
            "name":"lstrip",
            "params":{
              "1":"s",
              "2":"chrs",
              "map":{
                "s":" the string",
                "chrs":" default any whitespace character,\n but can be a string of characters to be trimmed"
              }
            },
            "tags":[],
            "kind":"stripping and justifying ",
            "description":"",
            "type":"function",
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "opt":"'%s'",
                  "type":"string",
                  "optchain":"'%s'"
                },
                "s":{
                  "type":"string"
                },
                "chrs":{
                  "opt":"'%s'",
                  "type":"string",
                  "optchain":"'%s'"
                }
              }
            },
            "summary":"trim any characters on the right of s.",
            "lineno":412,
            "args":"(s[, chrs='%s'])",
            "section":"Stripping and Justifying",
            "name":"rstrip",
            "params":{
              "1":"s",
              "2":"chrs",
              "map":{
                "s":" the string",
                "chrs":" default any whitespace character,\n but can be a string of characters to be trimmed"
              }
            },
            "tags":[],
            "kind":"stripping and justifying ",
            "description":"",
            "type":"function",
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[]],
              "return":[],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "opt":"'%s'",
                  "type":"string",
                  "optchain":"'%s'"
                },
                "s":{
                  "type":"string"
                },
                "chrs":{
                  "opt":"'%s'",
                  "type":"string",
                  "optchain":"'%s'"
                }
              }
            },
            "summary":"trim any characters on both left and right of s.",
            "lineno":422,
            "args":"(s[, chrs='%s'])",
            "usage":["stringx.strip('  --== Hello ==--  ', \"- =\")  --> 'Hello'\n"],
            "section":"Stripping and Justifying",
            "name":"strip",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"chrs",
              "map":{
                "s":" the string",
                "chrs":" default any whitespace character,\n but can be a string of characters to be trimmed"
              }
            },
            "tags":[],
            "kind":"stripping and justifying ",
            "description":"",
            "type":"function"
          },{
            "name":"partitioning",
            "inferred":true,
            "description":"",
            "file":"<reference cycle>",
            "summary":"",
            "tags":[],
            "lineno":430,
            "display_name":"Partitioning Strings",
            "type":"section",
            "modifiers":[]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "opt":"'%s'",
                  "type":"string",
                  "optchain":"'%s'"
                },
                "s":{
                  "type":"string"
                },
                "re":{
                  "opt":"'%s'",
                  "type":"string",
                  "optchain":"'%s'"
                }
              },
              "return":[[]],
              "usage":[[]],
              "see":[[]]
            },
            "summary":"split a string using a pattern.",
            "lineno":436,
            "retgroups":[{
                "1":{
                  "text":"the parts of the string",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s[, re='%s'])",
            "usage":["a,b = line:splitv('=')\n"],
            "type":"function",
            "name":"splitv",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"re",
              "map":{
                "s":" the string",
                "re":" a Lua string pattern (defaults to whitespace)"
              }
            },
            "tags":{
              "see":[]
            },
            "kind":"partitioning strings ",
            "section":"Partitioning Strings",
            "description":" Note that at least one value will be returned!",
            "ret":["the parts of the string"]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[],[]],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "type":"string"
                },
                "s":{
                  "type":"string"
                },
                "ch":{
                  "type":"string"
                }
              },
              "return":[[],[],[]]
            },
            "summary":"partition the string using first occurance of a delimiter",
            "lineno":461,
            "retgroups":[{
                "1":{
                  "text":"part before ch",
                  "type":"",
                  "mods":[]
                },
                "2":{
                  "text":"ch",
                  "type":"",
                  "mods":[]
                },
                "3":{
                  "text":"part after ch",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s, ch)",
            "usage":["{stringx.partition('a,b,c', ','))} == {'a', ',', 'b,c'}\n","{stringx.partition('abc', 'x'))} == {'abc', '', ''}\n"],
            "type":"function",
            "name":"partition",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"ch",
              "map":{
                "s":" the string",
                "ch":" delimiter (match as plain string, no patterns)"
              }
            },
            "tags":[],
            "kind":"partitioning strings ",
            "section":"Partitioning Strings",
            "description":"",
            "ret":["part before ch","ch","part after ch"]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[],[]],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "type":"string"
                },
                "s":{
                  "type":"string"
                },
                "ch":{
                  "type":"string"
                }
              },
              "return":[[],[],[]]
            },
            "summary":"partition the string p using last occurance of a delimiter",
            "lineno":475,
            "retgroups":[{
                "1":{
                  "text":"part before ch",
                  "type":"",
                  "mods":[]
                },
                "2":{
                  "text":"ch",
                  "type":"",
                  "mods":[]
                },
                "3":{
                  "text":"part after ch",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s, ch)",
            "usage":["{stringx.rpartition('a,b,c', ','))} == {'a,b', ',', 'c'}\n","{stringx.rpartition('abc', 'x'))} == {'', '', 'abc'}\n"],
            "type":"function",
            "name":"rpartition",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"ch",
              "map":{
                "s":" the string",
                "ch":" delimiter (match as plain string, no patterns)"
              }
            },
            "tags":[],
            "kind":"partitioning strings ",
            "section":"Partitioning Strings",
            "description":"",
            "ret":["part before ch","ch","part after ch"]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[[]],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "type":"int"
                },
                "s":{
                  "type":"string"
                },
                "idx":{
                  "type":"int"
                }
              }
            },
            "summary":"return the 'character' at the index.",
            "lineno":489,
            "retgroups":[{
                "1":{
                  "text":"a substring of length 1 if successful, empty string otherwise.",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s, idx)",
            "type":"function",
            "name":"at",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"idx",
              "map":{
                "s":" the string",
                "idx":" an index (can be negative)"
              }
            },
            "tags":[],
            "kind":"partitioning strings ",
            "section":"Partitioning Strings",
            "description":"",
            "ret":["a substring of length 1 if successful, empty string otherwise."]
          },{
            "name":"text",
            "inferred":true,
            "description":"",
            "file":"<reference cycle>",
            "summary":"",
            "tags":[],
            "lineno":500,
            "display_name":"Text handling",
            "type":"section",
            "modifiers":[]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[[]],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "type":"integer"
                },
                "3":{
                  "opt":"' '",
                  "type":"string",
                  "optchain":"' '"
                },
                "ch":{
                  "opt":"' '",
                  "type":"string",
                  "optchain":"' '"
                },
                "n":{
                  "type":"integer"
                },
                "s":{
                  "type":"string"
                }
              }
            },
            "summary":"indent a multiline string.",
            "lineno":505,
            "retgroups":[{
                "1":{
                  "text":"indented string",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s, n[, ch=' '])",
            "type":"function",
            "name":"indent",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"n",
              "map":{
                "ch":" the character to use when indenting",
                "n":" the size of the indent",
                "s":" the (multiline) string"
              },
              "3":"ch"
            },
            "tags":[],
            "kind":"text handling ",
            "section":"Text handling",
            "description":"",
            "ret":["indented string"]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[]],
              "param":{
                "1":{
                  "type":"string"
                },
                "s":{
                  "type":"string"
                }
              },
              "return":[[]]
            },
            "summary":"dedent a multiline string by removing any initial indent.",
            "lineno":537,
            "retgroups":[{
                "1":{
                  "text":"a string with initial indent zero.",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s)",
            "usage":["local s = dedent [[\n         One\n\n       Two\n\n     Three\n]]\nassert(s == [[\n    One\n\n  Two\n\nThree\n]])\n"],
            "type":"function",
            "name":"dedent",
            "parameter":"param",
            "params":{
              "map":{
                "s":" the (multiline) string"
              },
              "1":"s"
            },
            "tags":[],
            "kind":"text handling ",
            "section":"Text handling",
            "description":"\n useful when working with [[..]] strings.\n Empty lines are ignored.",
            "ret":["a string with initial indent zero."]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "opt":"70",
                  "type":"integer",
                  "optchain":"70"
                },
                "3":{
                  "opt":"false",
                  "type":"boolean",
                  "optchain":"false"
                },
                "width":{
                  "opt":"70",
                  "type":"integer",
                  "optchain":"70"
                },
                "s":{
                  "type":"string"
                },
                "breaklong":{
                  "opt":"false",
                  "type":"boolean",
                  "optchain":"false"
                }
              },
              "return":[[]],
              "see":[[],[]]
            },
            "summary":"format a paragraph into lines so that they fit into a line width.",
            "lineno":594,
            "retgroups":[{
                "1":{
                  "text":"a list of lines (List object), use `fill` to return a string instead of a `List`.",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s[, width=70[, breaklong=false]])",
            "type":"function",
            "name":"wrap",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"width",
              "map":{
                "width":" the margin width",
                "s":" the string to format",
                "breaklong":" if truthy, words longer than the width given will be forced split."
              },
              "3":"breaklong"
            },
            "tags":{
              "see":[]
            },
            "kind":"text handling ",
            "section":"Text handling",
            "description":"\n It will not break long words by default, so lines can be over the length\n to that extent.",
            "ret":["a list of lines (List object), use `fill` to return a string instead of a `List`."]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "opt":"70",
                  "type":"integer",
                  "optchain":"70"
                },
                "3":{
                  "opt":"false",
                  "type":"boolean",
                  "optchain":"false"
                },
                "width":{
                  "opt":"70",
                  "type":"integer",
                  "optchain":"70"
                },
                "s":{
                  "type":"string"
                },
                "breaklong":{
                  "opt":"false",
                  "type":"boolean",
                  "optchain":"false"
                }
              },
              "return":[[]],
              "see":[[]]
            },
            "summary":"format a paragraph so that it fits into a line width.",
            "lineno":616,
            "retgroups":[{
                "1":{
                  "text":"a string, use `wrap` to return a list of lines instead of a string.",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s[, width=70[, breaklong=false]])",
            "type":"function",
            "name":"fill",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"width",
              "map":{
                "width":" the margin width",
                "s":" the string to format",
                "breaklong":" if truthy, words longer than the width given will be forced split."
              },
              "3":"breaklong"
            },
            "tags":{
              "see":[]
            },
            "kind":"text handling ",
            "section":"Text handling",
            "description":"",
            "ret":["a string, use `wrap` to return a list of lines instead of a string."]
          },{
            "name":"Template",
            "inferred":true,
            "description":"",
            "file":"<reference cycle>",
            "summary":"",
            "tags":[],
            "lineno":624,
            "display_name":"Template",
            "type":"section",
            "modifiers":[]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "param":{
                "1":{
                  "type":"string"
                },
                "tmpl":{
                  "type":"string"
                }
              },
              "return":[{
                  "type":"Template"
                }]
            },
            "summary":"Creates a new Template class.",
            "lineno":662,
            "retgroups":[{
                "1":{
                  "text":"",
                  "type":"Template",
                  "mods":{
                    "type":"Template"
                  }
                },
                "g":0
              }],
            "args":"(tmpl)",
            "section":"Template",
            "name":"Template",
            "params":{
              "map":{
                "tmpl":" the template string"
              },
              "1":"tmpl"
            },
            "tags":[],
            "kind":"template ",
            "description":"\n This is a shortcut to `Template.new(tmpl)`.",
            "type":"function",
            "ret":[""],
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[[]],
              "param":{
                "1":{
                  "type":"table"
                },
                "tbl":{
                  "type":"table"
                }
              }
            },
            "summary":"substitute values into a template, throwing an error.",
            "lineno":674,
            "retgroups":[{
                "1":{
                  "text":"string with place holders substituted",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(tbl)",
            "type":"function",
            "name":"Template:substitute",
            "parameter":"param",
            "params":{
              "map":{
                "tbl":" a table of name-value pairs."
              },
              "1":"tbl"
            },
            "tags":[],
            "kind":"template ",
            "section":"Template",
            "description":"\n This will throw an error if no name is found.",
            "ret":["string with place holders substituted"]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[[]],
              "param":{
                "1":{
                  "type":"table"
                },
                "tbl":{
                  "type":"table"
                }
              }
            },
            "summary":"substitute values into a template.",
            "lineno":683,
            "retgroups":[{
                "1":{
                  "text":"string with place holders substituted",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(tbl)",
            "type":"function",
            "name":"Template:safe_substitute",
            "parameter":"param",
            "params":{
              "map":{
                "tbl":" a table of name-value pairs."
              },
              "1":"tbl"
            },
            "tags":[],
            "kind":"template ",
            "section":"Template",
            "description":"\n This version just passes unknown names through.",
            "ret":["string with place holders substituted"]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[[]],
              "param":{
                "1":{
                  "type":"table"
                },
                "tbl":{
                  "type":"table"
                }
              }
            },
            "summary":"substitute values into a template, preserving indentation.",
            "lineno":695,
            "retgroups":[{
                "1":{
                  "text":"string with place holders substituted",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(tbl)",
            "type":"function",
            "name":"Template:indent_substitute",
            "parameter":"param",
            "params":{
              "map":{
                "tbl":" a table of name-value pairs."
              },
              "1":"tbl"
            },
            "tags":[],
            "kind":"template ",
            "section":"Template",
            "description":" <br>\n If the value is a multiline string _or_ a template, it will insert\n the lines at the correct indentation. <br>\n Furthermore, if a template, then that template will be substituted\n using the same table.",
            "ret":["string with place holders substituted"]
          },{
            "name":"misc",
            "inferred":true,
            "description":"",
            "file":"<reference cycle>",
            "summary":"",
            "tags":[],
            "lineno":742,
            "display_name":"Miscelaneous",
            "type":"section",
            "modifiers":[]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[]],
              "param":{
                "1":{
                  "type":"string"
                },
                "s":{
                  "type":"string"
                }
              },
              "return":[[]]
            },
            "summary":"return an iterator over all lines in a string",
            "lineno":751,
            "retgroups":[{
                "1":{
                  "text":"an iterator",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s)",
            "usage":["local line_no = 1\nfor line in stringx.lines(some_text) do\n  print(line_no, line)\n  line_no = line_no + 1\nend\n"],
            "type":"function",
            "name":"lines",
            "parameter":"param",
            "params":{
              "map":{
                "s":" the string"
              },
              "1":"s"
            },
            "tags":[],
            "kind":"miscelaneous ",
            "section":"Miscelaneous",
            "description":"",
            "ret":["an iterator"]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[]],
              "param":{
                "1":{
                  "type":"string"
                },
                "s":{
                  "type":"string"
                }
              },
              "return":[[]]
            },
            "summary":"inital word letters uppercase ('title case').",
            "lineno":762,
            "retgroups":[{
                "1":{
                  "text":"a string with each word's first letter uppercase",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s)",
            "usage":["stringx.title(\"hello world\") == \"Hello World\")\n"],
            "type":"function",
            "name":"title",
            "parameter":"param",
            "params":{
              "map":{
                "s":" the string"
              },
              "1":"s"
            },
            "tags":[],
            "kind":"miscelaneous ",
            "section":"Miscelaneous",
            "description":"\n Here 'words' mean chunks of non-space characters.",
            "ret":["a string with each word's first letter uppercase"]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[],[],[]],
              "return":[],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "type":"int"
                },
                "3":{
                  "type":"bool"
                },
                "tail":{
                  "type":"bool"
                },
                "s":{
                  "type":"string"
                },
                "w":{
                  "type":"int"
                }
              }
            },
            "summary":"Return a shortened version of a string.",
            "lineno":783,
            "args":"(s, w, tail)",
            "usage":["('1234567890'):shorten(8) == '12345...'\n","('1234567890'):shorten(8, true) == '...67890'\n","('1234567890'):shorten(20) == '1234567890'\n"],
            "section":"Miscelaneous",
            "name":"shorten",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"w",
              "map":{
                "tail":" true if we want to show the end of the string (head otherwise)",
                "s":" the string",
                "w":" the maxinum size allowed"
              },
              "3":"tail"
            },
            "tags":[],
            "kind":"miscelaneous ",
            "description":"\n Fits string within w characters. Removed characters are marked with ellipsis.",
            "type":"function"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[[]],
              "param":{
                "1":[],
                "s":[]
              }
            },
            "summary":"Quote the given string and preserve any control or escape characters, such that reloading the string in Lua returns the same result.",
            "lineno":822,
            "retgroups":[{
                "1":{
                  "text":"The quoted string.",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s)",
            "type":"function",
            "name":"quote_string",
            "parameter":"param",
            "params":{
              "map":{
                "s":" The string to be quoted."
              },
              "1":"s"
            },
            "tags":[],
            "kind":"miscelaneous ",
            "section":"Miscelaneous",
            "description":"",
            "ret":["The quoted string."]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":[],
              "usage":[[]]
            },
            "summary":"Python-style formatting operator.",
            "lineno":873,
            "args":"()",
            "usage":["require 'pl.text'.format_operator()\nlocal out1 = '%s = %5.3f' % {'PI',math.pi}                   --> 'PI = 3.142'\nlocal out2 = '$name = $value' % {name='dog',value='Pluto'}   --> 'dog = Pluto'\n"],
            "section":"Miscelaneous",
            "name":"format_operator",
            "parameter":"param",
            "params":{
              "map":[]
            },
            "tags":[],
            "kind":"miscelaneous ",
            "description":"\n Calling `text.format_operator()` overloads the % operator for strings to give\n Python/Ruby style formated output.\n This is extended to also do template-like substitution for map-like data.\n\n Note this goes further than the original, and will allow these cases:\n\n 1. a single value\n 2. a list of values\n 3. a map of var=value pairs\n 4. a function, as in gsub\n\n For the second two cases, it uses $-variable substituion.\n\n When called, this function will monkey-patch the global `string` metatable by\n adding a `__mod` method.\n\n See <a href=\"http://lua-users.org/wiki/StringInterpolation\">the lua-users wiki</a>\n",
            "type":"function"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "param":[],
              "return":[]
            },
            "summary":"import the stringx functions into the global string (meta)table",
            "lineno":913,
            "args":"()",
            "section":"Miscelaneous",
            "name":"import",
            "params":{
              "map":[]
            },
            "tags":[],
            "kind":"miscelaneous ",
            "description":"",
            "type":"function",
            "parameter":"param"
          }],
        "sections":[],
        "modules":["<reference cycle>"],
        "args":{
          "one":false,
          "module":false,
          "verbose":false,
          "style":"!",
          "template":"!",
          "date":"system",
          "dir":"doc",
          "quiet":false,
          "all":false,
          "ignore":false,
          "colon":false,
          "not_luadoc":false,
          "ext":"html",
          "boilerplate":false,
          "merge":false,
          "filter":"f.filter",
          "package":"/home/cji/portless/Penlight/lua",
          "dump":false,
          "no_args_infer":false,
          "title":"Reference",
          "project":"ldoc",
          "file":"/home/cji/portless/Penlight/lua/pl",
          "format":"discount",
          "simple":false,
          "tags":"none",
          "define":"none",
          "output":"index",
          "unqualified":false,
          "config":"config.ld",
          "fatalwarnings":false,
          "testing":false
        },
        "error":"<type 'function' is not supported by JSON.>",
        "lang":{
          "line_comment":"^%-%-+",
          "start_comment_":"^%-%-%-+",
          "end_comment_":"[^%-]%-%-+[^-]*\n$",
          "extra":[],
          "block_comment":"^%-%-%[=*%[%-+",
          "empty_comment_":"^%-%-%-+%s*$",
          "method_call":":"
        },
        "base":"/home/cji/portless/Penlight/lua"
      },
      "summary":"",
      "tags":[],
      "lineno":311,
      "display_name":"Stripping and Justifying",
      "type":"section",
      "modifiers":[]
    },
    "5":{
      "name":"partitioning",
      "inferred":true,
      "description":"",
      "file":{
        "warning":"<type 'function' is not supported by JSON.>",
        "filename":"/home/cji/portless/Penlight/lua/pl/stringx.lua",
        "items":["<reference cycle>",{
            "name":"predicates",
            "inferred":true,
            "description":"",
            "file":"<reference cycle>",
            "summary":"",
            "tags":[],
            "lineno":53,
            "display_name":"String Predicates",
            "type":"section",
            "modifiers":[]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":{
                "1":{
                  "type":"string"
                },
                "s":{
                  "type":"string"
                }
              }
            },
            "summary":"does s only contain alphabetic characters?",
            "lineno":55,
            "args":"(s)",
            "section":"String Predicates",
            "name":"isalpha",
            "params":{
              "map":{
                "s":" a string"
              },
              "1":"s"
            },
            "tags":[],
            "kind":"string predicates ",
            "description":"",
            "type":"function",
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":{
                "1":{
                  "type":"string"
                },
                "s":{
                  "type":"string"
                }
              }
            },
            "summary":"does s only contain digits?",
            "lineno":62,
            "args":"(s)",
            "section":"String Predicates",
            "name":"isdigit",
            "params":{
              "map":{
                "s":" a string"
              },
              "1":"s"
            },
            "tags":[],
            "kind":"string predicates ",
            "description":"",
            "type":"function",
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":{
                "1":{
                  "type":"string"
                },
                "s":{
                  "type":"string"
                }
              }
            },
            "summary":"does s only contain alphanumeric characters?",
            "lineno":69,
            "args":"(s)",
            "section":"String Predicates",
            "name":"isalnum",
            "params":{
              "map":{
                "s":" a string"
              },
              "1":"s"
            },
            "tags":[],
            "kind":"string predicates ",
            "description":"",
            "type":"function",
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":{
                "1":{
                  "type":"string"
                },
                "s":{
                  "type":"string"
                }
              }
            },
            "summary":"does s only contain whitespace?",
            "lineno":77,
            "args":"(s)",
            "section":"String Predicates",
            "name":"isspace",
            "params":{
              "map":{
                "s":" a string"
              },
              "1":"s"
            },
            "tags":[],
            "kind":"string predicates ",
            "description":"\n Matches on pattern '%s' so matches space, newline, tabs, etc.",
            "type":"function",
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":{
                "1":{
                  "type":"string"
                },
                "s":{
                  "type":"string"
                }
              }
            },
            "summary":"does s only contain lower case characters?",
            "lineno":84,
            "args":"(s)",
            "section":"String Predicates",
            "name":"islower",
            "params":{
              "map":{
                "s":" a string"
              },
              "1":"s"
            },
            "tags":[],
            "kind":"string predicates ",
            "description":"",
            "type":"function",
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":{
                "1":{
                  "type":"string"
                },
                "s":{
                  "type":"string"
                }
              }
            },
            "summary":"does s only contain upper case characters?",
            "lineno":91,
            "args":"(s)",
            "section":"String Predicates",
            "name":"isupper",
            "params":{
              "map":{
                "s":" a string"
              },
              "1":"s"
            },
            "tags":[],
            "kind":"string predicates ",
            "description":"",
            "type":"function",
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":[],
                "s":{
                  "type":"string"
                },
                "prefix":[]
              }
            },
            "summary":"does s start with prefix or one of prefixes?",
            "lineno":120,
            "args":"(s, prefix)",
            "section":"String Predicates",
            "name":"startswith",
            "params":{
              "1":"s",
              "2":"prefix",
              "map":{
                "s":" a string",
                "prefix":" a string or an array of strings"
              }
            },
            "tags":[],
            "kind":"string predicates ",
            "description":"",
            "type":"function",
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":[],
                "s":{
                  "type":"string"
                },
                "suffix":[]
              }
            },
            "summary":"does s end with suffix or one of suffixes?",
            "lineno":128,
            "args":"(s, suffix)",
            "section":"String Predicates",
            "name":"endswith",
            "params":{
              "1":"s",
              "2":"suffix",
              "map":{
                "s":" a string",
                "suffix":" a string or an array of strings"
              }
            },
            "tags":[],
            "kind":"string predicates ",
            "description":"",
            "type":"function",
            "parameter":"param"
          },{
            "name":"lists",
            "inferred":true,
            "description":"",
            "file":"<reference cycle>",
            "summary":"",
            "tags":[],
            "lineno":136,
            "display_name":"Strings and Lists",
            "type":"section",
            "modifiers":[]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[]],
              "return":[],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":[],
                "s":{
                  "type":"string"
                },
                "seq":[]
              }
            },
            "summary":"concatenate the strings using this string as a delimiter.",
            "lineno":141,
            "args":"(s, seq)",
            "usage":["stringx.join(' ', {1,2,3}) == '1 2 3'\n"],
            "section":"Strings and Lists",
            "name":"join",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"seq",
              "map":{
                "s":" the string",
                "seq":" a table of strings or numbers"
              }
            },
            "tags":[],
            "kind":"strings and lists ",
            "description":"\n Note that the arguments are reversed from `string.concat`.",
            "type":"function"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[[]],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "opt":true,
                  "type":"bool",
                  "optchain":true
                },
                "s":{
                  "type":"string"
                },
                "keep_ends":{
                  "opt":true,
                  "type":"bool",
                  "optchain":true
                }
              }
            },
            "summary":"Split a string into a list of lines.",
            "lineno":154,
            "retgroups":[{
                "1":{
                  "text":"List of lines",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s[, keep_ends])",
            "type":"function",
            "name":"splitlines",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"keep_ends",
              "map":{
                "s":" the string.",
                "keep_ends":" include line ends."
              }
            },
            "tags":[],
            "kind":"strings and lists ",
            "section":"Strings and Lists",
            "description":"\n `\"\\r\"`, `\"\\n\"`, and `\"\\r\\n\"` are considered line ends.\n They are not included in the lines unless `keepends` is passed.\n Terminal line end does not produce an extra line.\n Splitting an empty string results in an empty list.",
            "ret":["List of lines"]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[],[],[]],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "opt":true,
                  "type":"string",
                  "optchain":true
                },
                "3":{
                  "opt":true,
                  "type":"int",
                  "optchain":true
                },
                "re":{
                  "opt":true,
                  "type":"string",
                  "optchain":true
                },
                "n":{
                  "opt":true,
                  "type":"int",
                  "optchain":true
                },
                "s":{
                  "type":"string"
                }
              },
              "return":[[]]
            },
            "summary":"split a string into a list of strings using a delimiter.",
            "lineno":193,
            "retgroups":[{
                "1":{
                  "text":"List",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s[, re[, n]])",
            "usage":["#(stringx.split('one two')) == 2\n","stringx.split('one,two,three', ',') == List{'one','two','three'}\n","stringx.split('one,two,three', ',', 2) == List{'one','two,three'}\n"],
            "type":"function",
            "name":"split",
            "params":{
              "1":"s",
              "2":"re",
              "map":{
                "re":" a delimiter (defaults to whitespace)",
                "n":" maximum number of results",
                "s":" the string"
              },
              "3":"n"
            },
            "tags":[],
            "kind":"strings and lists ",
            "section":"Strings and Lists",
            "description":"",
            "ret":["List"],
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[],[]],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "type":"int"
                },
                "s":{
                  "type":"string"
                },
                "tabsize":{
                  "type":"int"
                }
              },
              "return":[[]]
            },
            "summary":"replace all tabs in s with tabsize spaces.",
            "lineno":216,
            "retgroups":[{
                "1":{
                  "text":"expanded string",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s, tabsize)",
            "usage":["stringx.expandtabs('\\tone,two,three', 4)   == '    one,two,three'\n","stringx.expandtabs('  \\tone,two,three', 4) == '    one,two,three'\n"],
            "type":"function",
            "name":"expandtabs",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"tabsize",
              "map":{
                "s":" the string",
                "tabsize":"[opt=8] number of spaces to expand each tab"
              }
            },
            "tags":[],
            "kind":"strings and lists ",
            "section":"Strings and Lists",
            "description":" If not specified, tabsize defaults to 8.\n Tab stops will be honored.",
            "ret":["expanded string"]
          },{
            "name":"find",
            "inferred":true,
            "description":"",
            "file":"<reference cycle>",
            "summary":"",
            "tags":[],
            "lineno":231,
            "display_name":"Finding and Replacing",
            "type":"section",
            "modifiers":[]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[[]],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "type":"string"
                },
                "3":{
                  "opt":true,
                  "type":"int",
                  "optchain":true
                },
                "4":{
                  "opt":true,
                  "type":"int",
                  "optchain":true
                },
                "first":{
                  "opt":true,
                  "type":"int",
                  "optchain":true
                },
                "sub":{
                  "type":"string"
                },
                "s":{
                  "type":"string"
                },
                "last":{
                  "opt":true,
                  "type":"int",
                  "optchain":true
                }
              }
            },
            "summary":"find index of first instance of sub in s from the left.",
            "lineno":257,
            "retgroups":[{
                "1":{
                  "text":"start index, or nil if not found",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s, sub[, first[, last]])",
            "type":"function",
            "name":"lfind",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"sub",
              "3":"first",
              "4":"last",
              "map":{
                "first":" first index",
                "sub":" substring",
                "s":" the string",
                "last":" last index"
              }
            },
            "tags":[],
            "kind":"finding and replacing ",
            "section":"Finding and Replacing",
            "description":"",
            "ret":["start index, or nil if not found"]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[[]],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "type":"string"
                },
                "3":{
                  "opt":true,
                  "type":"int",
                  "optchain":true
                },
                "4":{
                  "opt":true,
                  "type":"int",
                  "optchain":true
                },
                "first":{
                  "opt":true,
                  "type":"int",
                  "optchain":true
                },
                "sub":{
                  "type":"string"
                },
                "s":{
                  "type":"string"
                },
                "last":{
                  "opt":true,
                  "type":"int",
                  "optchain":true
                }
              }
            },
            "summary":"find index of first instance of sub in s from the right.",
            "lineno":275,
            "retgroups":[{
                "1":{
                  "text":"start index, or nil if not found",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s, sub[, first[, last]])",
            "type":"function",
            "name":"rfind",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"sub",
              "3":"first",
              "4":"last",
              "map":{
                "first":" first index",
                "sub":" substring",
                "s":" the string",
                "last":" last index"
              }
            },
            "tags":[],
            "kind":"finding and replacing ",
            "section":"Finding and Replacing",
            "description":"",
            "ret":["start index, or nil if not found"]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[[]],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "type":"string"
                },
                "3":{
                  "type":"string"
                },
                "4":{
                  "opt":true,
                  "type":"int",
                  "optchain":true
                },
                "n":{
                  "opt":true,
                  "type":"int",
                  "optchain":true
                },
                "old":{
                  "type":"string"
                },
                "s":{
                  "type":"string"
                },
                "new":{
                  "type":"string"
                }
              }
            },
            "summary":"replace up to n instances of old by new in the string s.",
            "lineno":288,
            "retgroups":[{
                "1":{
                  "text":"result string",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s, old, new[, n])",
            "type":"function",
            "name":"replace",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"old",
              "3":"new",
              "4":"n",
              "map":{
                "n":" optional maximum number of substitutions",
                "old":" the target substring",
                "s":" the string",
                "new":" the substitution"
              }
            },
            "tags":[],
            "kind":"finding and replacing ",
            "section":"Finding and Replacing",
            "description":"\n If n is not present, replace all instances.",
            "ret":["result string"]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[]],
              "return":[],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "type":"string"
                },
                "3":{
                  "opt":true,
                  "type":"bool",
                  "optchain":true
                },
                "sub":{
                  "type":"string"
                },
                "s":{
                  "type":"string"
                },
                "allow_overlap":{
                  "opt":true,
                  "type":"bool",
                  "optchain":true
                }
              }
            },
            "summary":"count all instances of substring in string.",
            "lineno":302,
            "args":"(s, sub[, allow_overlap])",
            "usage":["assert(stringx.count('banana', 'ana') == 1)\nassert(stringx.count('banana', 'ana', true) == 2)\n"],
            "section":"Finding and Replacing",
            "name":"count",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"sub",
              "map":{
                "sub":" substring",
                "s":" the string",
                "allow_overlap":" allow matches to overlap"
              },
              "3":"allow_overlap"
            },
            "tags":[],
            "kind":"finding and replacing ",
            "description":"",
            "type":"function"
          },{
            "name":"strip",
            "inferred":true,
            "description":"",
            "file":"<reference cycle>",
            "summary":"",
            "tags":[],
            "lineno":311,
            "display_name":"Stripping and Justifying",
            "type":"section",
            "modifiers":[]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[]],
              "return":[],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "type":"int"
                },
                "3":{
                  "opt":"' '",
                  "type":"string",
                  "optchain":"' '"
                },
                "ch":{
                  "opt":"' '",
                  "type":"string",
                  "optchain":"' '"
                },
                "s":{
                  "type":"string"
                },
                "w":{
                  "type":"int"
                }
              }
            },
            "summary":"left-justify s with width w.",
            "lineno":339,
            "args":"(s, w[, ch=' '])",
            "usage":["stringx.ljust('hello', 10, '*') == '*****hello'\n"],
            "section":"Stripping and Justifying",
            "name":"ljust",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"w",
              "map":{
                "ch":" padding character",
                "s":" the string",
                "w":" width of justification"
              },
              "3":"ch"
            },
            "tags":[],
            "kind":"stripping and justifying ",
            "description":"",
            "type":"function"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[]],
              "return":[],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "type":"int"
                },
                "3":{
                  "opt":"' '",
                  "type":"string",
                  "optchain":"' '"
                },
                "ch":{
                  "opt":"' '",
                  "type":"string",
                  "optchain":"' '"
                },
                "s":{
                  "type":"string"
                },
                "w":{
                  "type":"int"
                }
              }
            },
            "summary":"right-justify s with width w.",
            "lineno":350,
            "args":"(s, w[, ch=' '])",
            "usage":["stringx.rjust('hello', 10, '*') == 'hello*****'\n"],
            "section":"Stripping and Justifying",
            "name":"rjust",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"w",
              "map":{
                "ch":" padding character",
                "s":" the string",
                "w":" width of justification"
              },
              "3":"ch"
            },
            "tags":[],
            "kind":"stripping and justifying ",
            "description":"",
            "type":"function"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[]],
              "return":[],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "type":"int"
                },
                "3":{
                  "opt":"' '",
                  "type":"string",
                  "optchain":"' '"
                },
                "ch":{
                  "opt":"' '",
                  "type":"string",
                  "optchain":"' '"
                },
                "s":{
                  "type":"string"
                },
                "w":{
                  "type":"int"
                }
              }
            },
            "summary":"center-justify s with width w.",
            "lineno":361,
            "args":"(s, w[, ch=' '])",
            "usage":["stringx.center('hello', 10, '*') == '**hello***'\n"],
            "section":"Stripping and Justifying",
            "name":"center",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"w",
              "map":{
                "ch":" padding character",
                "s":" the string",
                "w":" width of justification"
              },
              "3":"ch"
            },
            "tags":[],
            "kind":"stripping and justifying ",
            "description":"",
            "type":"function"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "opt":"'%s'",
                  "type":"string",
                  "optchain":"'%s'"
                },
                "s":{
                  "type":"string"
                },
                "chrs":{
                  "opt":"'%s'",
                  "type":"string",
                  "optchain":"'%s'"
                }
              }
            },
            "summary":"trim any characters on the left of s.",
            "lineno":402,
            "args":"(s[, chrs='%s'])",
            "section":"Stripping and Justifying",
            "name":"lstrip",
            "params":{
              "1":"s",
              "2":"chrs",
              "map":{
                "s":" the string",
                "chrs":" default any whitespace character,\n but can be a string of characters to be trimmed"
              }
            },
            "tags":[],
            "kind":"stripping and justifying ",
            "description":"",
            "type":"function",
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "opt":"'%s'",
                  "type":"string",
                  "optchain":"'%s'"
                },
                "s":{
                  "type":"string"
                },
                "chrs":{
                  "opt":"'%s'",
                  "type":"string",
                  "optchain":"'%s'"
                }
              }
            },
            "summary":"trim any characters on the right of s.",
            "lineno":412,
            "args":"(s[, chrs='%s'])",
            "section":"Stripping and Justifying",
            "name":"rstrip",
            "params":{
              "1":"s",
              "2":"chrs",
              "map":{
                "s":" the string",
                "chrs":" default any whitespace character,\n but can be a string of characters to be trimmed"
              }
            },
            "tags":[],
            "kind":"stripping and justifying ",
            "description":"",
            "type":"function",
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[]],
              "return":[],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "opt":"'%s'",
                  "type":"string",
                  "optchain":"'%s'"
                },
                "s":{
                  "type":"string"
                },
                "chrs":{
                  "opt":"'%s'",
                  "type":"string",
                  "optchain":"'%s'"
                }
              }
            },
            "summary":"trim any characters on both left and right of s.",
            "lineno":422,
            "args":"(s[, chrs='%s'])",
            "usage":["stringx.strip('  --== Hello ==--  ', \"- =\")  --> 'Hello'\n"],
            "section":"Stripping and Justifying",
            "name":"strip",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"chrs",
              "map":{
                "s":" the string",
                "chrs":" default any whitespace character,\n but can be a string of characters to be trimmed"
              }
            },
            "tags":[],
            "kind":"stripping and justifying ",
            "description":"",
            "type":"function"
          },"<reference cycle>",{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "opt":"'%s'",
                  "type":"string",
                  "optchain":"'%s'"
                },
                "s":{
                  "type":"string"
                },
                "re":{
                  "opt":"'%s'",
                  "type":"string",
                  "optchain":"'%s'"
                }
              },
              "return":[[]],
              "usage":[[]],
              "see":[[]]
            },
            "summary":"split a string using a pattern.",
            "lineno":436,
            "retgroups":[{
                "1":{
                  "text":"the parts of the string",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s[, re='%s'])",
            "usage":["a,b = line:splitv('=')\n"],
            "type":"function",
            "name":"splitv",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"re",
              "map":{
                "s":" the string",
                "re":" a Lua string pattern (defaults to whitespace)"
              }
            },
            "tags":{
              "see":[]
            },
            "kind":"partitioning strings ",
            "section":"Partitioning Strings",
            "description":" Note that at least one value will be returned!",
            "ret":["the parts of the string"]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[],[]],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "type":"string"
                },
                "s":{
                  "type":"string"
                },
                "ch":{
                  "type":"string"
                }
              },
              "return":[[],[],[]]
            },
            "summary":"partition the string using first occurance of a delimiter",
            "lineno":461,
            "retgroups":[{
                "1":{
                  "text":"part before ch",
                  "type":"",
                  "mods":[]
                },
                "2":{
                  "text":"ch",
                  "type":"",
                  "mods":[]
                },
                "3":{
                  "text":"part after ch",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s, ch)",
            "usage":["{stringx.partition('a,b,c', ','))} == {'a', ',', 'b,c'}\n","{stringx.partition('abc', 'x'))} == {'abc', '', ''}\n"],
            "type":"function",
            "name":"partition",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"ch",
              "map":{
                "s":" the string",
                "ch":" delimiter (match as plain string, no patterns)"
              }
            },
            "tags":[],
            "kind":"partitioning strings ",
            "section":"Partitioning Strings",
            "description":"",
            "ret":["part before ch","ch","part after ch"]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[],[]],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "type":"string"
                },
                "s":{
                  "type":"string"
                },
                "ch":{
                  "type":"string"
                }
              },
              "return":[[],[],[]]
            },
            "summary":"partition the string p using last occurance of a delimiter",
            "lineno":475,
            "retgroups":[{
                "1":{
                  "text":"part before ch",
                  "type":"",
                  "mods":[]
                },
                "2":{
                  "text":"ch",
                  "type":"",
                  "mods":[]
                },
                "3":{
                  "text":"part after ch",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s, ch)",
            "usage":["{stringx.rpartition('a,b,c', ','))} == {'a,b', ',', 'c'}\n","{stringx.rpartition('abc', 'x'))} == {'', '', 'abc'}\n"],
            "type":"function",
            "name":"rpartition",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"ch",
              "map":{
                "s":" the string",
                "ch":" delimiter (match as plain string, no patterns)"
              }
            },
            "tags":[],
            "kind":"partitioning strings ",
            "section":"Partitioning Strings",
            "description":"",
            "ret":["part before ch","ch","part after ch"]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[[]],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "type":"int"
                },
                "s":{
                  "type":"string"
                },
                "idx":{
                  "type":"int"
                }
              }
            },
            "summary":"return the 'character' at the index.",
            "lineno":489,
            "retgroups":[{
                "1":{
                  "text":"a substring of length 1 if successful, empty string otherwise.",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s, idx)",
            "type":"function",
            "name":"at",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"idx",
              "map":{
                "s":" the string",
                "idx":" an index (can be negative)"
              }
            },
            "tags":[],
            "kind":"partitioning strings ",
            "section":"Partitioning Strings",
            "description":"",
            "ret":["a substring of length 1 if successful, empty string otherwise."]
          },{
            "name":"text",
            "inferred":true,
            "description":"",
            "file":"<reference cycle>",
            "summary":"",
            "tags":[],
            "lineno":500,
            "display_name":"Text handling",
            "type":"section",
            "modifiers":[]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[[]],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "type":"integer"
                },
                "3":{
                  "opt":"' '",
                  "type":"string",
                  "optchain":"' '"
                },
                "ch":{
                  "opt":"' '",
                  "type":"string",
                  "optchain":"' '"
                },
                "n":{
                  "type":"integer"
                },
                "s":{
                  "type":"string"
                }
              }
            },
            "summary":"indent a multiline string.",
            "lineno":505,
            "retgroups":[{
                "1":{
                  "text":"indented string",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s, n[, ch=' '])",
            "type":"function",
            "name":"indent",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"n",
              "map":{
                "ch":" the character to use when indenting",
                "n":" the size of the indent",
                "s":" the (multiline) string"
              },
              "3":"ch"
            },
            "tags":[],
            "kind":"text handling ",
            "section":"Text handling",
            "description":"",
            "ret":["indented string"]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[]],
              "param":{
                "1":{
                  "type":"string"
                },
                "s":{
                  "type":"string"
                }
              },
              "return":[[]]
            },
            "summary":"dedent a multiline string by removing any initial indent.",
            "lineno":537,
            "retgroups":[{
                "1":{
                  "text":"a string with initial indent zero.",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s)",
            "usage":["local s = dedent [[\n         One\n\n       Two\n\n     Three\n]]\nassert(s == [[\n    One\n\n  Two\n\nThree\n]])\n"],
            "type":"function",
            "name":"dedent",
            "parameter":"param",
            "params":{
              "map":{
                "s":" the (multiline) string"
              },
              "1":"s"
            },
            "tags":[],
            "kind":"text handling ",
            "section":"Text handling",
            "description":"\n useful when working with [[..]] strings.\n Empty lines are ignored.",
            "ret":["a string with initial indent zero."]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "opt":"70",
                  "type":"integer",
                  "optchain":"70"
                },
                "3":{
                  "opt":"false",
                  "type":"boolean",
                  "optchain":"false"
                },
                "width":{
                  "opt":"70",
                  "type":"integer",
                  "optchain":"70"
                },
                "s":{
                  "type":"string"
                },
                "breaklong":{
                  "opt":"false",
                  "type":"boolean",
                  "optchain":"false"
                }
              },
              "return":[[]],
              "see":[[],[]]
            },
            "summary":"format a paragraph into lines so that they fit into a line width.",
            "lineno":594,
            "retgroups":[{
                "1":{
                  "text":"a list of lines (List object), use `fill` to return a string instead of a `List`.",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s[, width=70[, breaklong=false]])",
            "type":"function",
            "name":"wrap",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"width",
              "map":{
                "width":" the margin width",
                "s":" the string to format",
                "breaklong":" if truthy, words longer than the width given will be forced split."
              },
              "3":"breaklong"
            },
            "tags":{
              "see":[]
            },
            "kind":"text handling ",
            "section":"Text handling",
            "description":"\n It will not break long words by default, so lines can be over the length\n to that extent.",
            "ret":["a list of lines (List object), use `fill` to return a string instead of a `List`."]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "opt":"70",
                  "type":"integer",
                  "optchain":"70"
                },
                "3":{
                  "opt":"false",
                  "type":"boolean",
                  "optchain":"false"
                },
                "width":{
                  "opt":"70",
                  "type":"integer",
                  "optchain":"70"
                },
                "s":{
                  "type":"string"
                },
                "breaklong":{
                  "opt":"false",
                  "type":"boolean",
                  "optchain":"false"
                }
              },
              "return":[[]],
              "see":[[]]
            },
            "summary":"format a paragraph so that it fits into a line width.",
            "lineno":616,
            "retgroups":[{
                "1":{
                  "text":"a string, use `wrap` to return a list of lines instead of a string.",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s[, width=70[, breaklong=false]])",
            "type":"function",
            "name":"fill",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"width",
              "map":{
                "width":" the margin width",
                "s":" the string to format",
                "breaklong":" if truthy, words longer than the width given will be forced split."
              },
              "3":"breaklong"
            },
            "tags":{
              "see":[]
            },
            "kind":"text handling ",
            "section":"Text handling",
            "description":"",
            "ret":["a string, use `wrap` to return a list of lines instead of a string."]
          },{
            "name":"Template",
            "inferred":true,
            "description":"",
            "file":"<reference cycle>",
            "summary":"",
            "tags":[],
            "lineno":624,
            "display_name":"Template",
            "type":"section",
            "modifiers":[]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "param":{
                "1":{
                  "type":"string"
                },
                "tmpl":{
                  "type":"string"
                }
              },
              "return":[{
                  "type":"Template"
                }]
            },
            "summary":"Creates a new Template class.",
            "lineno":662,
            "retgroups":[{
                "1":{
                  "text":"",
                  "type":"Template",
                  "mods":{
                    "type":"Template"
                  }
                },
                "g":0
              }],
            "args":"(tmpl)",
            "section":"Template",
            "name":"Template",
            "params":{
              "map":{
                "tmpl":" the template string"
              },
              "1":"tmpl"
            },
            "tags":[],
            "kind":"template ",
            "description":"\n This is a shortcut to `Template.new(tmpl)`.",
            "type":"function",
            "ret":[""],
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[[]],
              "param":{
                "1":{
                  "type":"table"
                },
                "tbl":{
                  "type":"table"
                }
              }
            },
            "summary":"substitute values into a template, throwing an error.",
            "lineno":674,
            "retgroups":[{
                "1":{
                  "text":"string with place holders substituted",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(tbl)",
            "type":"function",
            "name":"Template:substitute",
            "parameter":"param",
            "params":{
              "map":{
                "tbl":" a table of name-value pairs."
              },
              "1":"tbl"
            },
            "tags":[],
            "kind":"template ",
            "section":"Template",
            "description":"\n This will throw an error if no name is found.",
            "ret":["string with place holders substituted"]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[[]],
              "param":{
                "1":{
                  "type":"table"
                },
                "tbl":{
                  "type":"table"
                }
              }
            },
            "summary":"substitute values into a template.",
            "lineno":683,
            "retgroups":[{
                "1":{
                  "text":"string with place holders substituted",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(tbl)",
            "type":"function",
            "name":"Template:safe_substitute",
            "parameter":"param",
            "params":{
              "map":{
                "tbl":" a table of name-value pairs."
              },
              "1":"tbl"
            },
            "tags":[],
            "kind":"template ",
            "section":"Template",
            "description":"\n This version just passes unknown names through.",
            "ret":["string with place holders substituted"]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[[]],
              "param":{
                "1":{
                  "type":"table"
                },
                "tbl":{
                  "type":"table"
                }
              }
            },
            "summary":"substitute values into a template, preserving indentation.",
            "lineno":695,
            "retgroups":[{
                "1":{
                  "text":"string with place holders substituted",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(tbl)",
            "type":"function",
            "name":"Template:indent_substitute",
            "parameter":"param",
            "params":{
              "map":{
                "tbl":" a table of name-value pairs."
              },
              "1":"tbl"
            },
            "tags":[],
            "kind":"template ",
            "section":"Template",
            "description":" <br>\n If the value is a multiline string _or_ a template, it will insert\n the lines at the correct indentation. <br>\n Furthermore, if a template, then that template will be substituted\n using the same table.",
            "ret":["string with place holders substituted"]
          },{
            "name":"misc",
            "inferred":true,
            "description":"",
            "file":"<reference cycle>",
            "summary":"",
            "tags":[],
            "lineno":742,
            "display_name":"Miscelaneous",
            "type":"section",
            "modifiers":[]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[]],
              "param":{
                "1":{
                  "type":"string"
                },
                "s":{
                  "type":"string"
                }
              },
              "return":[[]]
            },
            "summary":"return an iterator over all lines in a string",
            "lineno":751,
            "retgroups":[{
                "1":{
                  "text":"an iterator",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s)",
            "usage":["local line_no = 1\nfor line in stringx.lines(some_text) do\n  print(line_no, line)\n  line_no = line_no + 1\nend\n"],
            "type":"function",
            "name":"lines",
            "parameter":"param",
            "params":{
              "map":{
                "s":" the string"
              },
              "1":"s"
            },
            "tags":[],
            "kind":"miscelaneous ",
            "section":"Miscelaneous",
            "description":"",
            "ret":["an iterator"]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[]],
              "param":{
                "1":{
                  "type":"string"
                },
                "s":{
                  "type":"string"
                }
              },
              "return":[[]]
            },
            "summary":"inital word letters uppercase ('title case').",
            "lineno":762,
            "retgroups":[{
                "1":{
                  "text":"a string with each word's first letter uppercase",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s)",
            "usage":["stringx.title(\"hello world\") == \"Hello World\")\n"],
            "type":"function",
            "name":"title",
            "parameter":"param",
            "params":{
              "map":{
                "s":" the string"
              },
              "1":"s"
            },
            "tags":[],
            "kind":"miscelaneous ",
            "section":"Miscelaneous",
            "description":"\n Here 'words' mean chunks of non-space characters.",
            "ret":["a string with each word's first letter uppercase"]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[],[],[]],
              "return":[],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "type":"int"
                },
                "3":{
                  "type":"bool"
                },
                "tail":{
                  "type":"bool"
                },
                "s":{
                  "type":"string"
                },
                "w":{
                  "type":"int"
                }
              }
            },
            "summary":"Return a shortened version of a string.",
            "lineno":783,
            "args":"(s, w, tail)",
            "usage":["('1234567890'):shorten(8) == '12345...'\n","('1234567890'):shorten(8, true) == '...67890'\n","('1234567890'):shorten(20) == '1234567890'\n"],
            "section":"Miscelaneous",
            "name":"shorten",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"w",
              "map":{
                "tail":" true if we want to show the end of the string (head otherwise)",
                "s":" the string",
                "w":" the maxinum size allowed"
              },
              "3":"tail"
            },
            "tags":[],
            "kind":"miscelaneous ",
            "description":"\n Fits string within w characters. Removed characters are marked with ellipsis.",
            "type":"function"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[[]],
              "param":{
                "1":[],
                "s":[]
              }
            },
            "summary":"Quote the given string and preserve any control or escape characters, such that reloading the string in Lua returns the same result.",
            "lineno":822,
            "retgroups":[{
                "1":{
                  "text":"The quoted string.",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s)",
            "type":"function",
            "name":"quote_string",
            "parameter":"param",
            "params":{
              "map":{
                "s":" The string to be quoted."
              },
              "1":"s"
            },
            "tags":[],
            "kind":"miscelaneous ",
            "section":"Miscelaneous",
            "description":"",
            "ret":["The quoted string."]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":[],
              "usage":[[]]
            },
            "summary":"Python-style formatting operator.",
            "lineno":873,
            "args":"()",
            "usage":["require 'pl.text'.format_operator()\nlocal out1 = '%s = %5.3f' % {'PI',math.pi}                   --> 'PI = 3.142'\nlocal out2 = '$name = $value' % {name='dog',value='Pluto'}   --> 'dog = Pluto'\n"],
            "section":"Miscelaneous",
            "name":"format_operator",
            "parameter":"param",
            "params":{
              "map":[]
            },
            "tags":[],
            "kind":"miscelaneous ",
            "description":"\n Calling `text.format_operator()` overloads the % operator for strings to give\n Python/Ruby style formated output.\n This is extended to also do template-like substitution for map-like data.\n\n Note this goes further than the original, and will allow these cases:\n\n 1. a single value\n 2. a list of values\n 3. a map of var=value pairs\n 4. a function, as in gsub\n\n For the second two cases, it uses $-variable substituion.\n\n When called, this function will monkey-patch the global `string` metatable by\n adding a `__mod` method.\n\n See <a href=\"http://lua-users.org/wiki/StringInterpolation\">the lua-users wiki</a>\n",
            "type":"function"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "param":[],
              "return":[]
            },
            "summary":"import the stringx functions into the global string (meta)table",
            "lineno":913,
            "args":"()",
            "section":"Miscelaneous",
            "name":"import",
            "params":{
              "map":[]
            },
            "tags":[],
            "kind":"miscelaneous ",
            "description":"",
            "type":"function",
            "parameter":"param"
          }],
        "sections":[],
        "modules":["<reference cycle>"],
        "args":{
          "one":false,
          "module":false,
          "verbose":false,
          "style":"!",
          "template":"!",
          "date":"system",
          "dir":"doc",
          "quiet":false,
          "all":false,
          "ignore":false,
          "colon":false,
          "not_luadoc":false,
          "ext":"html",
          "boilerplate":false,
          "merge":false,
          "filter":"f.filter",
          "package":"/home/cji/portless/Penlight/lua",
          "dump":false,
          "no_args_infer":false,
          "title":"Reference",
          "project":"ldoc",
          "file":"/home/cji/portless/Penlight/lua/pl",
          "format":"discount",
          "simple":false,
          "tags":"none",
          "define":"none",
          "output":"index",
          "unqualified":false,
          "config":"config.ld",
          "fatalwarnings":false,
          "testing":false
        },
        "error":"<type 'function' is not supported by JSON.>",
        "lang":{
          "line_comment":"^%-%-+",
          "start_comment_":"^%-%-%-+",
          "end_comment_":"[^%-]%-%-+[^-]*\n$",
          "extra":[],
          "block_comment":"^%-%-%[=*%[%-+",
          "empty_comment_":"^%-%-%-+%s*$",
          "method_call":":"
        },
        "base":"/home/cji/portless/Penlight/lua"
      },
      "summary":"",
      "tags":[],
      "lineno":430,
      "display_name":"Partitioning Strings",
      "type":"section",
      "modifiers":[]
    },
    "6":{
      "name":"text",
      "inferred":true,
      "description":"",
      "file":{
        "warning":"<type 'function' is not supported by JSON.>",
        "filename":"/home/cji/portless/Penlight/lua/pl/stringx.lua",
        "items":["<reference cycle>",{
            "name":"predicates",
            "inferred":true,
            "description":"",
            "file":"<reference cycle>",
            "summary":"",
            "tags":[],
            "lineno":53,
            "display_name":"String Predicates",
            "type":"section",
            "modifiers":[]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":{
                "1":{
                  "type":"string"
                },
                "s":{
                  "type":"string"
                }
              }
            },
            "summary":"does s only contain alphabetic characters?",
            "lineno":55,
            "args":"(s)",
            "section":"String Predicates",
            "name":"isalpha",
            "params":{
              "map":{
                "s":" a string"
              },
              "1":"s"
            },
            "tags":[],
            "kind":"string predicates ",
            "description":"",
            "type":"function",
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":{
                "1":{
                  "type":"string"
                },
                "s":{
                  "type":"string"
                }
              }
            },
            "summary":"does s only contain digits?",
            "lineno":62,
            "args":"(s)",
            "section":"String Predicates",
            "name":"isdigit",
            "params":{
              "map":{
                "s":" a string"
              },
              "1":"s"
            },
            "tags":[],
            "kind":"string predicates ",
            "description":"",
            "type":"function",
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":{
                "1":{
                  "type":"string"
                },
                "s":{
                  "type":"string"
                }
              }
            },
            "summary":"does s only contain alphanumeric characters?",
            "lineno":69,
            "args":"(s)",
            "section":"String Predicates",
            "name":"isalnum",
            "params":{
              "map":{
                "s":" a string"
              },
              "1":"s"
            },
            "tags":[],
            "kind":"string predicates ",
            "description":"",
            "type":"function",
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":{
                "1":{
                  "type":"string"
                },
                "s":{
                  "type":"string"
                }
              }
            },
            "summary":"does s only contain whitespace?",
            "lineno":77,
            "args":"(s)",
            "section":"String Predicates",
            "name":"isspace",
            "params":{
              "map":{
                "s":" a string"
              },
              "1":"s"
            },
            "tags":[],
            "kind":"string predicates ",
            "description":"\n Matches on pattern '%s' so matches space, newline, tabs, etc.",
            "type":"function",
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":{
                "1":{
                  "type":"string"
                },
                "s":{
                  "type":"string"
                }
              }
            },
            "summary":"does s only contain lower case characters?",
            "lineno":84,
            "args":"(s)",
            "section":"String Predicates",
            "name":"islower",
            "params":{
              "map":{
                "s":" a string"
              },
              "1":"s"
            },
            "tags":[],
            "kind":"string predicates ",
            "description":"",
            "type":"function",
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":{
                "1":{
                  "type":"string"
                },
                "s":{
                  "type":"string"
                }
              }
            },
            "summary":"does s only contain upper case characters?",
            "lineno":91,
            "args":"(s)",
            "section":"String Predicates",
            "name":"isupper",
            "params":{
              "map":{
                "s":" a string"
              },
              "1":"s"
            },
            "tags":[],
            "kind":"string predicates ",
            "description":"",
            "type":"function",
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":[],
                "s":{
                  "type":"string"
                },
                "prefix":[]
              }
            },
            "summary":"does s start with prefix or one of prefixes?",
            "lineno":120,
            "args":"(s, prefix)",
            "section":"String Predicates",
            "name":"startswith",
            "params":{
              "1":"s",
              "2":"prefix",
              "map":{
                "s":" a string",
                "prefix":" a string or an array of strings"
              }
            },
            "tags":[],
            "kind":"string predicates ",
            "description":"",
            "type":"function",
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":[],
                "s":{
                  "type":"string"
                },
                "suffix":[]
              }
            },
            "summary":"does s end with suffix or one of suffixes?",
            "lineno":128,
            "args":"(s, suffix)",
            "section":"String Predicates",
            "name":"endswith",
            "params":{
              "1":"s",
              "2":"suffix",
              "map":{
                "s":" a string",
                "suffix":" a string or an array of strings"
              }
            },
            "tags":[],
            "kind":"string predicates ",
            "description":"",
            "type":"function",
            "parameter":"param"
          },{
            "name":"lists",
            "inferred":true,
            "description":"",
            "file":"<reference cycle>",
            "summary":"",
            "tags":[],
            "lineno":136,
            "display_name":"Strings and Lists",
            "type":"section",
            "modifiers":[]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[]],
              "return":[],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":[],
                "s":{
                  "type":"string"
                },
                "seq":[]
              }
            },
            "summary":"concatenate the strings using this string as a delimiter.",
            "lineno":141,
            "args":"(s, seq)",
            "usage":["stringx.join(' ', {1,2,3}) == '1 2 3'\n"],
            "section":"Strings and Lists",
            "name":"join",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"seq",
              "map":{
                "s":" the string",
                "seq":" a table of strings or numbers"
              }
            },
            "tags":[],
            "kind":"strings and lists ",
            "description":"\n Note that the arguments are reversed from `string.concat`.",
            "type":"function"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[[]],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "opt":true,
                  "type":"bool",
                  "optchain":true
                },
                "s":{
                  "type":"string"
                },
                "keep_ends":{
                  "opt":true,
                  "type":"bool",
                  "optchain":true
                }
              }
            },
            "summary":"Split a string into a list of lines.",
            "lineno":154,
            "retgroups":[{
                "1":{
                  "text":"List of lines",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s[, keep_ends])",
            "type":"function",
            "name":"splitlines",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"keep_ends",
              "map":{
                "s":" the string.",
                "keep_ends":" include line ends."
              }
            },
            "tags":[],
            "kind":"strings and lists ",
            "section":"Strings and Lists",
            "description":"\n `\"\\r\"`, `\"\\n\"`, and `\"\\r\\n\"` are considered line ends.\n They are not included in the lines unless `keepends` is passed.\n Terminal line end does not produce an extra line.\n Splitting an empty string results in an empty list.",
            "ret":["List of lines"]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[],[],[]],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "opt":true,
                  "type":"string",
                  "optchain":true
                },
                "3":{
                  "opt":true,
                  "type":"int",
                  "optchain":true
                },
                "re":{
                  "opt":true,
                  "type":"string",
                  "optchain":true
                },
                "n":{
                  "opt":true,
                  "type":"int",
                  "optchain":true
                },
                "s":{
                  "type":"string"
                }
              },
              "return":[[]]
            },
            "summary":"split a string into a list of strings using a delimiter.",
            "lineno":193,
            "retgroups":[{
                "1":{
                  "text":"List",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s[, re[, n]])",
            "usage":["#(stringx.split('one two')) == 2\n","stringx.split('one,two,three', ',') == List{'one','two','three'}\n","stringx.split('one,two,three', ',', 2) == List{'one','two,three'}\n"],
            "type":"function",
            "name":"split",
            "params":{
              "1":"s",
              "2":"re",
              "map":{
                "re":" a delimiter (defaults to whitespace)",
                "n":" maximum number of results",
                "s":" the string"
              },
              "3":"n"
            },
            "tags":[],
            "kind":"strings and lists ",
            "section":"Strings and Lists",
            "description":"",
            "ret":["List"],
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[],[]],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "type":"int"
                },
                "s":{
                  "type":"string"
                },
                "tabsize":{
                  "type":"int"
                }
              },
              "return":[[]]
            },
            "summary":"replace all tabs in s with tabsize spaces.",
            "lineno":216,
            "retgroups":[{
                "1":{
                  "text":"expanded string",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s, tabsize)",
            "usage":["stringx.expandtabs('\\tone,two,three', 4)   == '    one,two,three'\n","stringx.expandtabs('  \\tone,two,three', 4) == '    one,two,three'\n"],
            "type":"function",
            "name":"expandtabs",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"tabsize",
              "map":{
                "s":" the string",
                "tabsize":"[opt=8] number of spaces to expand each tab"
              }
            },
            "tags":[],
            "kind":"strings and lists ",
            "section":"Strings and Lists",
            "description":" If not specified, tabsize defaults to 8.\n Tab stops will be honored.",
            "ret":["expanded string"]
          },{
            "name":"find",
            "inferred":true,
            "description":"",
            "file":"<reference cycle>",
            "summary":"",
            "tags":[],
            "lineno":231,
            "display_name":"Finding and Replacing",
            "type":"section",
            "modifiers":[]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[[]],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "type":"string"
                },
                "3":{
                  "opt":true,
                  "type":"int",
                  "optchain":true
                },
                "4":{
                  "opt":true,
                  "type":"int",
                  "optchain":true
                },
                "first":{
                  "opt":true,
                  "type":"int",
                  "optchain":true
                },
                "sub":{
                  "type":"string"
                },
                "s":{
                  "type":"string"
                },
                "last":{
                  "opt":true,
                  "type":"int",
                  "optchain":true
                }
              }
            },
            "summary":"find index of first instance of sub in s from the left.",
            "lineno":257,
            "retgroups":[{
                "1":{
                  "text":"start index, or nil if not found",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s, sub[, first[, last]])",
            "type":"function",
            "name":"lfind",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"sub",
              "3":"first",
              "4":"last",
              "map":{
                "first":" first index",
                "sub":" substring",
                "s":" the string",
                "last":" last index"
              }
            },
            "tags":[],
            "kind":"finding and replacing ",
            "section":"Finding and Replacing",
            "description":"",
            "ret":["start index, or nil if not found"]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[[]],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "type":"string"
                },
                "3":{
                  "opt":true,
                  "type":"int",
                  "optchain":true
                },
                "4":{
                  "opt":true,
                  "type":"int",
                  "optchain":true
                },
                "first":{
                  "opt":true,
                  "type":"int",
                  "optchain":true
                },
                "sub":{
                  "type":"string"
                },
                "s":{
                  "type":"string"
                },
                "last":{
                  "opt":true,
                  "type":"int",
                  "optchain":true
                }
              }
            },
            "summary":"find index of first instance of sub in s from the right.",
            "lineno":275,
            "retgroups":[{
                "1":{
                  "text":"start index, or nil if not found",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s, sub[, first[, last]])",
            "type":"function",
            "name":"rfind",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"sub",
              "3":"first",
              "4":"last",
              "map":{
                "first":" first index",
                "sub":" substring",
                "s":" the string",
                "last":" last index"
              }
            },
            "tags":[],
            "kind":"finding and replacing ",
            "section":"Finding and Replacing",
            "description":"",
            "ret":["start index, or nil if not found"]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[[]],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "type":"string"
                },
                "3":{
                  "type":"string"
                },
                "4":{
                  "opt":true,
                  "type":"int",
                  "optchain":true
                },
                "n":{
                  "opt":true,
                  "type":"int",
                  "optchain":true
                },
                "old":{
                  "type":"string"
                },
                "s":{
                  "type":"string"
                },
                "new":{
                  "type":"string"
                }
              }
            },
            "summary":"replace up to n instances of old by new in the string s.",
            "lineno":288,
            "retgroups":[{
                "1":{
                  "text":"result string",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s, old, new[, n])",
            "type":"function",
            "name":"replace",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"old",
              "3":"new",
              "4":"n",
              "map":{
                "n":" optional maximum number of substitutions",
                "old":" the target substring",
                "s":" the string",
                "new":" the substitution"
              }
            },
            "tags":[],
            "kind":"finding and replacing ",
            "section":"Finding and Replacing",
            "description":"\n If n is not present, replace all instances.",
            "ret":["result string"]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[]],
              "return":[],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "type":"string"
                },
                "3":{
                  "opt":true,
                  "type":"bool",
                  "optchain":true
                },
                "sub":{
                  "type":"string"
                },
                "s":{
                  "type":"string"
                },
                "allow_overlap":{
                  "opt":true,
                  "type":"bool",
                  "optchain":true
                }
              }
            },
            "summary":"count all instances of substring in string.",
            "lineno":302,
            "args":"(s, sub[, allow_overlap])",
            "usage":["assert(stringx.count('banana', 'ana') == 1)\nassert(stringx.count('banana', 'ana', true) == 2)\n"],
            "section":"Finding and Replacing",
            "name":"count",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"sub",
              "map":{
                "sub":" substring",
                "s":" the string",
                "allow_overlap":" allow matches to overlap"
              },
              "3":"allow_overlap"
            },
            "tags":[],
            "kind":"finding and replacing ",
            "description":"",
            "type":"function"
          },{
            "name":"strip",
            "inferred":true,
            "description":"",
            "file":"<reference cycle>",
            "summary":"",
            "tags":[],
            "lineno":311,
            "display_name":"Stripping and Justifying",
            "type":"section",
            "modifiers":[]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[]],
              "return":[],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "type":"int"
                },
                "3":{
                  "opt":"' '",
                  "type":"string",
                  "optchain":"' '"
                },
                "ch":{
                  "opt":"' '",
                  "type":"string",
                  "optchain":"' '"
                },
                "s":{
                  "type":"string"
                },
                "w":{
                  "type":"int"
                }
              }
            },
            "summary":"left-justify s with width w.",
            "lineno":339,
            "args":"(s, w[, ch=' '])",
            "usage":["stringx.ljust('hello', 10, '*') == '*****hello'\n"],
            "section":"Stripping and Justifying",
            "name":"ljust",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"w",
              "map":{
                "ch":" padding character",
                "s":" the string",
                "w":" width of justification"
              },
              "3":"ch"
            },
            "tags":[],
            "kind":"stripping and justifying ",
            "description":"",
            "type":"function"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[]],
              "return":[],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "type":"int"
                },
                "3":{
                  "opt":"' '",
                  "type":"string",
                  "optchain":"' '"
                },
                "ch":{
                  "opt":"' '",
                  "type":"string",
                  "optchain":"' '"
                },
                "s":{
                  "type":"string"
                },
                "w":{
                  "type":"int"
                }
              }
            },
            "summary":"right-justify s with width w.",
            "lineno":350,
            "args":"(s, w[, ch=' '])",
            "usage":["stringx.rjust('hello', 10, '*') == 'hello*****'\n"],
            "section":"Stripping and Justifying",
            "name":"rjust",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"w",
              "map":{
                "ch":" padding character",
                "s":" the string",
                "w":" width of justification"
              },
              "3":"ch"
            },
            "tags":[],
            "kind":"stripping and justifying ",
            "description":"",
            "type":"function"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[]],
              "return":[],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "type":"int"
                },
                "3":{
                  "opt":"' '",
                  "type":"string",
                  "optchain":"' '"
                },
                "ch":{
                  "opt":"' '",
                  "type":"string",
                  "optchain":"' '"
                },
                "s":{
                  "type":"string"
                },
                "w":{
                  "type":"int"
                }
              }
            },
            "summary":"center-justify s with width w.",
            "lineno":361,
            "args":"(s, w[, ch=' '])",
            "usage":["stringx.center('hello', 10, '*') == '**hello***'\n"],
            "section":"Stripping and Justifying",
            "name":"center",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"w",
              "map":{
                "ch":" padding character",
                "s":" the string",
                "w":" width of justification"
              },
              "3":"ch"
            },
            "tags":[],
            "kind":"stripping and justifying ",
            "description":"",
            "type":"function"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "opt":"'%s'",
                  "type":"string",
                  "optchain":"'%s'"
                },
                "s":{
                  "type":"string"
                },
                "chrs":{
                  "opt":"'%s'",
                  "type":"string",
                  "optchain":"'%s'"
                }
              }
            },
            "summary":"trim any characters on the left of s.",
            "lineno":402,
            "args":"(s[, chrs='%s'])",
            "section":"Stripping and Justifying",
            "name":"lstrip",
            "params":{
              "1":"s",
              "2":"chrs",
              "map":{
                "s":" the string",
                "chrs":" default any whitespace character,\n but can be a string of characters to be trimmed"
              }
            },
            "tags":[],
            "kind":"stripping and justifying ",
            "description":"",
            "type":"function",
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "opt":"'%s'",
                  "type":"string",
                  "optchain":"'%s'"
                },
                "s":{
                  "type":"string"
                },
                "chrs":{
                  "opt":"'%s'",
                  "type":"string",
                  "optchain":"'%s'"
                }
              }
            },
            "summary":"trim any characters on the right of s.",
            "lineno":412,
            "args":"(s[, chrs='%s'])",
            "section":"Stripping and Justifying",
            "name":"rstrip",
            "params":{
              "1":"s",
              "2":"chrs",
              "map":{
                "s":" the string",
                "chrs":" default any whitespace character,\n but can be a string of characters to be trimmed"
              }
            },
            "tags":[],
            "kind":"stripping and justifying ",
            "description":"",
            "type":"function",
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[]],
              "return":[],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "opt":"'%s'",
                  "type":"string",
                  "optchain":"'%s'"
                },
                "s":{
                  "type":"string"
                },
                "chrs":{
                  "opt":"'%s'",
                  "type":"string",
                  "optchain":"'%s'"
                }
              }
            },
            "summary":"trim any characters on both left and right of s.",
            "lineno":422,
            "args":"(s[, chrs='%s'])",
            "usage":["stringx.strip('  --== Hello ==--  ', \"- =\")  --> 'Hello'\n"],
            "section":"Stripping and Justifying",
            "name":"strip",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"chrs",
              "map":{
                "s":" the string",
                "chrs":" default any whitespace character,\n but can be a string of characters to be trimmed"
              }
            },
            "tags":[],
            "kind":"stripping and justifying ",
            "description":"",
            "type":"function"
          },{
            "name":"partitioning",
            "inferred":true,
            "description":"",
            "file":"<reference cycle>",
            "summary":"",
            "tags":[],
            "lineno":430,
            "display_name":"Partitioning Strings",
            "type":"section",
            "modifiers":[]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "opt":"'%s'",
                  "type":"string",
                  "optchain":"'%s'"
                },
                "s":{
                  "type":"string"
                },
                "re":{
                  "opt":"'%s'",
                  "type":"string",
                  "optchain":"'%s'"
                }
              },
              "return":[[]],
              "usage":[[]],
              "see":[[]]
            },
            "summary":"split a string using a pattern.",
            "lineno":436,
            "retgroups":[{
                "1":{
                  "text":"the parts of the string",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s[, re='%s'])",
            "usage":["a,b = line:splitv('=')\n"],
            "type":"function",
            "name":"splitv",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"re",
              "map":{
                "s":" the string",
                "re":" a Lua string pattern (defaults to whitespace)"
              }
            },
            "tags":{
              "see":[]
            },
            "kind":"partitioning strings ",
            "section":"Partitioning Strings",
            "description":" Note that at least one value will be returned!",
            "ret":["the parts of the string"]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[],[]],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "type":"string"
                },
                "s":{
                  "type":"string"
                },
                "ch":{
                  "type":"string"
                }
              },
              "return":[[],[],[]]
            },
            "summary":"partition the string using first occurance of a delimiter",
            "lineno":461,
            "retgroups":[{
                "1":{
                  "text":"part before ch",
                  "type":"",
                  "mods":[]
                },
                "2":{
                  "text":"ch",
                  "type":"",
                  "mods":[]
                },
                "3":{
                  "text":"part after ch",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s, ch)",
            "usage":["{stringx.partition('a,b,c', ','))} == {'a', ',', 'b,c'}\n","{stringx.partition('abc', 'x'))} == {'abc', '', ''}\n"],
            "type":"function",
            "name":"partition",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"ch",
              "map":{
                "s":" the string",
                "ch":" delimiter (match as plain string, no patterns)"
              }
            },
            "tags":[],
            "kind":"partitioning strings ",
            "section":"Partitioning Strings",
            "description":"",
            "ret":["part before ch","ch","part after ch"]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[],[]],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "type":"string"
                },
                "s":{
                  "type":"string"
                },
                "ch":{
                  "type":"string"
                }
              },
              "return":[[],[],[]]
            },
            "summary":"partition the string p using last occurance of a delimiter",
            "lineno":475,
            "retgroups":[{
                "1":{
                  "text":"part before ch",
                  "type":"",
                  "mods":[]
                },
                "2":{
                  "text":"ch",
                  "type":"",
                  "mods":[]
                },
                "3":{
                  "text":"part after ch",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s, ch)",
            "usage":["{stringx.rpartition('a,b,c', ','))} == {'a,b', ',', 'c'}\n","{stringx.rpartition('abc', 'x'))} == {'', '', 'abc'}\n"],
            "type":"function",
            "name":"rpartition",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"ch",
              "map":{
                "s":" the string",
                "ch":" delimiter (match as plain string, no patterns)"
              }
            },
            "tags":[],
            "kind":"partitioning strings ",
            "section":"Partitioning Strings",
            "description":"",
            "ret":["part before ch","ch","part after ch"]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[[]],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "type":"int"
                },
                "s":{
                  "type":"string"
                },
                "idx":{
                  "type":"int"
                }
              }
            },
            "summary":"return the 'character' at the index.",
            "lineno":489,
            "retgroups":[{
                "1":{
                  "text":"a substring of length 1 if successful, empty string otherwise.",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s, idx)",
            "type":"function",
            "name":"at",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"idx",
              "map":{
                "s":" the string",
                "idx":" an index (can be negative)"
              }
            },
            "tags":[],
            "kind":"partitioning strings ",
            "section":"Partitioning Strings",
            "description":"",
            "ret":["a substring of length 1 if successful, empty string otherwise."]
          },"<reference cycle>",{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[[]],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "type":"integer"
                },
                "3":{
                  "opt":"' '",
                  "type":"string",
                  "optchain":"' '"
                },
                "ch":{
                  "opt":"' '",
                  "type":"string",
                  "optchain":"' '"
                },
                "n":{
                  "type":"integer"
                },
                "s":{
                  "type":"string"
                }
              }
            },
            "summary":"indent a multiline string.",
            "lineno":505,
            "retgroups":[{
                "1":{
                  "text":"indented string",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s, n[, ch=' '])",
            "type":"function",
            "name":"indent",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"n",
              "map":{
                "ch":" the character to use when indenting",
                "n":" the size of the indent",
                "s":" the (multiline) string"
              },
              "3":"ch"
            },
            "tags":[],
            "kind":"text handling ",
            "section":"Text handling",
            "description":"",
            "ret":["indented string"]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[]],
              "param":{
                "1":{
                  "type":"string"
                },
                "s":{
                  "type":"string"
                }
              },
              "return":[[]]
            },
            "summary":"dedent a multiline string by removing any initial indent.",
            "lineno":537,
            "retgroups":[{
                "1":{
                  "text":"a string with initial indent zero.",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s)",
            "usage":["local s = dedent [[\n         One\n\n       Two\n\n     Three\n]]\nassert(s == [[\n    One\n\n  Two\n\nThree\n]])\n"],
            "type":"function",
            "name":"dedent",
            "parameter":"param",
            "params":{
              "map":{
                "s":" the (multiline) string"
              },
              "1":"s"
            },
            "tags":[],
            "kind":"text handling ",
            "section":"Text handling",
            "description":"\n useful when working with [[..]] strings.\n Empty lines are ignored.",
            "ret":["a string with initial indent zero."]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "opt":"70",
                  "type":"integer",
                  "optchain":"70"
                },
                "3":{
                  "opt":"false",
                  "type":"boolean",
                  "optchain":"false"
                },
                "width":{
                  "opt":"70",
                  "type":"integer",
                  "optchain":"70"
                },
                "s":{
                  "type":"string"
                },
                "breaklong":{
                  "opt":"false",
                  "type":"boolean",
                  "optchain":"false"
                }
              },
              "return":[[]],
              "see":[[],[]]
            },
            "summary":"format a paragraph into lines so that they fit into a line width.",
            "lineno":594,
            "retgroups":[{
                "1":{
                  "text":"a list of lines (List object), use `fill` to return a string instead of a `List`.",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s[, width=70[, breaklong=false]])",
            "type":"function",
            "name":"wrap",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"width",
              "map":{
                "width":" the margin width",
                "s":" the string to format",
                "breaklong":" if truthy, words longer than the width given will be forced split."
              },
              "3":"breaklong"
            },
            "tags":{
              "see":[]
            },
            "kind":"text handling ",
            "section":"Text handling",
            "description":"\n It will not break long words by default, so lines can be over the length\n to that extent.",
            "ret":["a list of lines (List object), use `fill` to return a string instead of a `List`."]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "opt":"70",
                  "type":"integer",
                  "optchain":"70"
                },
                "3":{
                  "opt":"false",
                  "type":"boolean",
                  "optchain":"false"
                },
                "width":{
                  "opt":"70",
                  "type":"integer",
                  "optchain":"70"
                },
                "s":{
                  "type":"string"
                },
                "breaklong":{
                  "opt":"false",
                  "type":"boolean",
                  "optchain":"false"
                }
              },
              "return":[[]],
              "see":[[]]
            },
            "summary":"format a paragraph so that it fits into a line width.",
            "lineno":616,
            "retgroups":[{
                "1":{
                  "text":"a string, use `wrap` to return a list of lines instead of a string.",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s[, width=70[, breaklong=false]])",
            "type":"function",
            "name":"fill",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"width",
              "map":{
                "width":" the margin width",
                "s":" the string to format",
                "breaklong":" if truthy, words longer than the width given will be forced split."
              },
              "3":"breaklong"
            },
            "tags":{
              "see":[]
            },
            "kind":"text handling ",
            "section":"Text handling",
            "description":"",
            "ret":["a string, use `wrap` to return a list of lines instead of a string."]
          },{
            "name":"Template",
            "inferred":true,
            "description":"",
            "file":"<reference cycle>",
            "summary":"",
            "tags":[],
            "lineno":624,
            "display_name":"Template",
            "type":"section",
            "modifiers":[]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "param":{
                "1":{
                  "type":"string"
                },
                "tmpl":{
                  "type":"string"
                }
              },
              "return":[{
                  "type":"Template"
                }]
            },
            "summary":"Creates a new Template class.",
            "lineno":662,
            "retgroups":[{
                "1":{
                  "text":"",
                  "type":"Template",
                  "mods":{
                    "type":"Template"
                  }
                },
                "g":0
              }],
            "args":"(tmpl)",
            "section":"Template",
            "name":"Template",
            "params":{
              "map":{
                "tmpl":" the template string"
              },
              "1":"tmpl"
            },
            "tags":[],
            "kind":"template ",
            "description":"\n This is a shortcut to `Template.new(tmpl)`.",
            "type":"function",
            "ret":[""],
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[[]],
              "param":{
                "1":{
                  "type":"table"
                },
                "tbl":{
                  "type":"table"
                }
              }
            },
            "summary":"substitute values into a template, throwing an error.",
            "lineno":674,
            "retgroups":[{
                "1":{
                  "text":"string with place holders substituted",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(tbl)",
            "type":"function",
            "name":"Template:substitute",
            "parameter":"param",
            "params":{
              "map":{
                "tbl":" a table of name-value pairs."
              },
              "1":"tbl"
            },
            "tags":[],
            "kind":"template ",
            "section":"Template",
            "description":"\n This will throw an error if no name is found.",
            "ret":["string with place holders substituted"]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[[]],
              "param":{
                "1":{
                  "type":"table"
                },
                "tbl":{
                  "type":"table"
                }
              }
            },
            "summary":"substitute values into a template.",
            "lineno":683,
            "retgroups":[{
                "1":{
                  "text":"string with place holders substituted",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(tbl)",
            "type":"function",
            "name":"Template:safe_substitute",
            "parameter":"param",
            "params":{
              "map":{
                "tbl":" a table of name-value pairs."
              },
              "1":"tbl"
            },
            "tags":[],
            "kind":"template ",
            "section":"Template",
            "description":"\n This version just passes unknown names through.",
            "ret":["string with place holders substituted"]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[[]],
              "param":{
                "1":{
                  "type":"table"
                },
                "tbl":{
                  "type":"table"
                }
              }
            },
            "summary":"substitute values into a template, preserving indentation.",
            "lineno":695,
            "retgroups":[{
                "1":{
                  "text":"string with place holders substituted",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(tbl)",
            "type":"function",
            "name":"Template:indent_substitute",
            "parameter":"param",
            "params":{
              "map":{
                "tbl":" a table of name-value pairs."
              },
              "1":"tbl"
            },
            "tags":[],
            "kind":"template ",
            "section":"Template",
            "description":" <br>\n If the value is a multiline string _or_ a template, it will insert\n the lines at the correct indentation. <br>\n Furthermore, if a template, then that template will be substituted\n using the same table.",
            "ret":["string with place holders substituted"]
          },{
            "name":"misc",
            "inferred":true,
            "description":"",
            "file":"<reference cycle>",
            "summary":"",
            "tags":[],
            "lineno":742,
            "display_name":"Miscelaneous",
            "type":"section",
            "modifiers":[]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[]],
              "param":{
                "1":{
                  "type":"string"
                },
                "s":{
                  "type":"string"
                }
              },
              "return":[[]]
            },
            "summary":"return an iterator over all lines in a string",
            "lineno":751,
            "retgroups":[{
                "1":{
                  "text":"an iterator",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s)",
            "usage":["local line_no = 1\nfor line in stringx.lines(some_text) do\n  print(line_no, line)\n  line_no = line_no + 1\nend\n"],
            "type":"function",
            "name":"lines",
            "parameter":"param",
            "params":{
              "map":{
                "s":" the string"
              },
              "1":"s"
            },
            "tags":[],
            "kind":"miscelaneous ",
            "section":"Miscelaneous",
            "description":"",
            "ret":["an iterator"]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[]],
              "param":{
                "1":{
                  "type":"string"
                },
                "s":{
                  "type":"string"
                }
              },
              "return":[[]]
            },
            "summary":"inital word letters uppercase ('title case').",
            "lineno":762,
            "retgroups":[{
                "1":{
                  "text":"a string with each word's first letter uppercase",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s)",
            "usage":["stringx.title(\"hello world\") == \"Hello World\")\n"],
            "type":"function",
            "name":"title",
            "parameter":"param",
            "params":{
              "map":{
                "s":" the string"
              },
              "1":"s"
            },
            "tags":[],
            "kind":"miscelaneous ",
            "section":"Miscelaneous",
            "description":"\n Here 'words' mean chunks of non-space characters.",
            "ret":["a string with each word's first letter uppercase"]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[],[],[]],
              "return":[],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "type":"int"
                },
                "3":{
                  "type":"bool"
                },
                "tail":{
                  "type":"bool"
                },
                "s":{
                  "type":"string"
                },
                "w":{
                  "type":"int"
                }
              }
            },
            "summary":"Return a shortened version of a string.",
            "lineno":783,
            "args":"(s, w, tail)",
            "usage":["('1234567890'):shorten(8) == '12345...'\n","('1234567890'):shorten(8, true) == '...67890'\n","('1234567890'):shorten(20) == '1234567890'\n"],
            "section":"Miscelaneous",
            "name":"shorten",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"w",
              "map":{
                "tail":" true if we want to show the end of the string (head otherwise)",
                "s":" the string",
                "w":" the maxinum size allowed"
              },
              "3":"tail"
            },
            "tags":[],
            "kind":"miscelaneous ",
            "description":"\n Fits string within w characters. Removed characters are marked with ellipsis.",
            "type":"function"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[[]],
              "param":{
                "1":[],
                "s":[]
              }
            },
            "summary":"Quote the given string and preserve any control or escape characters, such that reloading the string in Lua returns the same result.",
            "lineno":822,
            "retgroups":[{
                "1":{
                  "text":"The quoted string.",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s)",
            "type":"function",
            "name":"quote_string",
            "parameter":"param",
            "params":{
              "map":{
                "s":" The string to be quoted."
              },
              "1":"s"
            },
            "tags":[],
            "kind":"miscelaneous ",
            "section":"Miscelaneous",
            "description":"",
            "ret":["The quoted string."]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":[],
              "usage":[[]]
            },
            "summary":"Python-style formatting operator.",
            "lineno":873,
            "args":"()",
            "usage":["require 'pl.text'.format_operator()\nlocal out1 = '%s = %5.3f' % {'PI',math.pi}                   --> 'PI = 3.142'\nlocal out2 = '$name = $value' % {name='dog',value='Pluto'}   --> 'dog = Pluto'\n"],
            "section":"Miscelaneous",
            "name":"format_operator",
            "parameter":"param",
            "params":{
              "map":[]
            },
            "tags":[],
            "kind":"miscelaneous ",
            "description":"\n Calling `text.format_operator()` overloads the % operator for strings to give\n Python/Ruby style formated output.\n This is extended to also do template-like substitution for map-like data.\n\n Note this goes further than the original, and will allow these cases:\n\n 1. a single value\n 2. a list of values\n 3. a map of var=value pairs\n 4. a function, as in gsub\n\n For the second two cases, it uses $-variable substituion.\n\n When called, this function will monkey-patch the global `string` metatable by\n adding a `__mod` method.\n\n See <a href=\"http://lua-users.org/wiki/StringInterpolation\">the lua-users wiki</a>\n",
            "type":"function"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "param":[],
              "return":[]
            },
            "summary":"import the stringx functions into the global string (meta)table",
            "lineno":913,
            "args":"()",
            "section":"Miscelaneous",
            "name":"import",
            "params":{
              "map":[]
            },
            "tags":[],
            "kind":"miscelaneous ",
            "description":"",
            "type":"function",
            "parameter":"param"
          }],
        "sections":[],
        "modules":["<reference cycle>"],
        "args":{
          "one":false,
          "module":false,
          "verbose":false,
          "style":"!",
          "template":"!",
          "date":"system",
          "dir":"doc",
          "quiet":false,
          "all":false,
          "ignore":false,
          "colon":false,
          "not_luadoc":false,
          "ext":"html",
          "boilerplate":false,
          "merge":false,
          "filter":"f.filter",
          "package":"/home/cji/portless/Penlight/lua",
          "dump":false,
          "no_args_infer":false,
          "title":"Reference",
          "project":"ldoc",
          "file":"/home/cji/portless/Penlight/lua/pl",
          "format":"discount",
          "simple":false,
          "tags":"none",
          "define":"none",
          "output":"index",
          "unqualified":false,
          "config":"config.ld",
          "fatalwarnings":false,
          "testing":false
        },
        "error":"<type 'function' is not supported by JSON.>",
        "lang":{
          "line_comment":"^%-%-+",
          "start_comment_":"^%-%-%-+",
          "end_comment_":"[^%-]%-%-+[^-]*\n$",
          "extra":[],
          "block_comment":"^%-%-%[=*%[%-+",
          "empty_comment_":"^%-%-%-+%s*$",
          "method_call":":"
        },
        "base":"/home/cji/portless/Penlight/lua"
      },
      "summary":"",
      "tags":[],
      "lineno":500,
      "display_name":"Text handling",
      "type":"section",
      "modifiers":[]
    },
    "7":{
      "name":"Template",
      "inferred":true,
      "description":"",
      "file":{
        "warning":"<type 'function' is not supported by JSON.>",
        "filename":"/home/cji/portless/Penlight/lua/pl/stringx.lua",
        "items":["<reference cycle>",{
            "name":"predicates",
            "inferred":true,
            "description":"",
            "file":"<reference cycle>",
            "summary":"",
            "tags":[],
            "lineno":53,
            "display_name":"String Predicates",
            "type":"section",
            "modifiers":[]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":{
                "1":{
                  "type":"string"
                },
                "s":{
                  "type":"string"
                }
              }
            },
            "summary":"does s only contain alphabetic characters?",
            "lineno":55,
            "args":"(s)",
            "section":"String Predicates",
            "name":"isalpha",
            "params":{
              "map":{
                "s":" a string"
              },
              "1":"s"
            },
            "tags":[],
            "kind":"string predicates ",
            "description":"",
            "type":"function",
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":{
                "1":{
                  "type":"string"
                },
                "s":{
                  "type":"string"
                }
              }
            },
            "summary":"does s only contain digits?",
            "lineno":62,
            "args":"(s)",
            "section":"String Predicates",
            "name":"isdigit",
            "params":{
              "map":{
                "s":" a string"
              },
              "1":"s"
            },
            "tags":[],
            "kind":"string predicates ",
            "description":"",
            "type":"function",
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":{
                "1":{
                  "type":"string"
                },
                "s":{
                  "type":"string"
                }
              }
            },
            "summary":"does s only contain alphanumeric characters?",
            "lineno":69,
            "args":"(s)",
            "section":"String Predicates",
            "name":"isalnum",
            "params":{
              "map":{
                "s":" a string"
              },
              "1":"s"
            },
            "tags":[],
            "kind":"string predicates ",
            "description":"",
            "type":"function",
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":{
                "1":{
                  "type":"string"
                },
                "s":{
                  "type":"string"
                }
              }
            },
            "summary":"does s only contain whitespace?",
            "lineno":77,
            "args":"(s)",
            "section":"String Predicates",
            "name":"isspace",
            "params":{
              "map":{
                "s":" a string"
              },
              "1":"s"
            },
            "tags":[],
            "kind":"string predicates ",
            "description":"\n Matches on pattern '%s' so matches space, newline, tabs, etc.",
            "type":"function",
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":{
                "1":{
                  "type":"string"
                },
                "s":{
                  "type":"string"
                }
              }
            },
            "summary":"does s only contain lower case characters?",
            "lineno":84,
            "args":"(s)",
            "section":"String Predicates",
            "name":"islower",
            "params":{
              "map":{
                "s":" a string"
              },
              "1":"s"
            },
            "tags":[],
            "kind":"string predicates ",
            "description":"",
            "type":"function",
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":{
                "1":{
                  "type":"string"
                },
                "s":{
                  "type":"string"
                }
              }
            },
            "summary":"does s only contain upper case characters?",
            "lineno":91,
            "args":"(s)",
            "section":"String Predicates",
            "name":"isupper",
            "params":{
              "map":{
                "s":" a string"
              },
              "1":"s"
            },
            "tags":[],
            "kind":"string predicates ",
            "description":"",
            "type":"function",
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":[],
                "s":{
                  "type":"string"
                },
                "prefix":[]
              }
            },
            "summary":"does s start with prefix or one of prefixes?",
            "lineno":120,
            "args":"(s, prefix)",
            "section":"String Predicates",
            "name":"startswith",
            "params":{
              "1":"s",
              "2":"prefix",
              "map":{
                "s":" a string",
                "prefix":" a string or an array of strings"
              }
            },
            "tags":[],
            "kind":"string predicates ",
            "description":"",
            "type":"function",
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":[],
                "s":{
                  "type":"string"
                },
                "suffix":[]
              }
            },
            "summary":"does s end with suffix or one of suffixes?",
            "lineno":128,
            "args":"(s, suffix)",
            "section":"String Predicates",
            "name":"endswith",
            "params":{
              "1":"s",
              "2":"suffix",
              "map":{
                "s":" a string",
                "suffix":" a string or an array of strings"
              }
            },
            "tags":[],
            "kind":"string predicates ",
            "description":"",
            "type":"function",
            "parameter":"param"
          },{
            "name":"lists",
            "inferred":true,
            "description":"",
            "file":"<reference cycle>",
            "summary":"",
            "tags":[],
            "lineno":136,
            "display_name":"Strings and Lists",
            "type":"section",
            "modifiers":[]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[]],
              "return":[],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":[],
                "s":{
                  "type":"string"
                },
                "seq":[]
              }
            },
            "summary":"concatenate the strings using this string as a delimiter.",
            "lineno":141,
            "args":"(s, seq)",
            "usage":["stringx.join(' ', {1,2,3}) == '1 2 3'\n"],
            "section":"Strings and Lists",
            "name":"join",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"seq",
              "map":{
                "s":" the string",
                "seq":" a table of strings or numbers"
              }
            },
            "tags":[],
            "kind":"strings and lists ",
            "description":"\n Note that the arguments are reversed from `string.concat`.",
            "type":"function"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[[]],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "opt":true,
                  "type":"bool",
                  "optchain":true
                },
                "s":{
                  "type":"string"
                },
                "keep_ends":{
                  "opt":true,
                  "type":"bool",
                  "optchain":true
                }
              }
            },
            "summary":"Split a string into a list of lines.",
            "lineno":154,
            "retgroups":[{
                "1":{
                  "text":"List of lines",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s[, keep_ends])",
            "type":"function",
            "name":"splitlines",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"keep_ends",
              "map":{
                "s":" the string.",
                "keep_ends":" include line ends."
              }
            },
            "tags":[],
            "kind":"strings and lists ",
            "section":"Strings and Lists",
            "description":"\n `\"\\r\"`, `\"\\n\"`, and `\"\\r\\n\"` are considered line ends.\n They are not included in the lines unless `keepends` is passed.\n Terminal line end does not produce an extra line.\n Splitting an empty string results in an empty list.",
            "ret":["List of lines"]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[],[],[]],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "opt":true,
                  "type":"string",
                  "optchain":true
                },
                "3":{
                  "opt":true,
                  "type":"int",
                  "optchain":true
                },
                "re":{
                  "opt":true,
                  "type":"string",
                  "optchain":true
                },
                "n":{
                  "opt":true,
                  "type":"int",
                  "optchain":true
                },
                "s":{
                  "type":"string"
                }
              },
              "return":[[]]
            },
            "summary":"split a string into a list of strings using a delimiter.",
            "lineno":193,
            "retgroups":[{
                "1":{
                  "text":"List",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s[, re[, n]])",
            "usage":["#(stringx.split('one two')) == 2\n","stringx.split('one,two,three', ',') == List{'one','two','three'}\n","stringx.split('one,two,three', ',', 2) == List{'one','two,three'}\n"],
            "type":"function",
            "name":"split",
            "params":{
              "1":"s",
              "2":"re",
              "map":{
                "re":" a delimiter (defaults to whitespace)",
                "n":" maximum number of results",
                "s":" the string"
              },
              "3":"n"
            },
            "tags":[],
            "kind":"strings and lists ",
            "section":"Strings and Lists",
            "description":"",
            "ret":["List"],
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[],[]],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "type":"int"
                },
                "s":{
                  "type":"string"
                },
                "tabsize":{
                  "type":"int"
                }
              },
              "return":[[]]
            },
            "summary":"replace all tabs in s with tabsize spaces.",
            "lineno":216,
            "retgroups":[{
                "1":{
                  "text":"expanded string",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s, tabsize)",
            "usage":["stringx.expandtabs('\\tone,two,three', 4)   == '    one,two,three'\n","stringx.expandtabs('  \\tone,two,three', 4) == '    one,two,three'\n"],
            "type":"function",
            "name":"expandtabs",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"tabsize",
              "map":{
                "s":" the string",
                "tabsize":"[opt=8] number of spaces to expand each tab"
              }
            },
            "tags":[],
            "kind":"strings and lists ",
            "section":"Strings and Lists",
            "description":" If not specified, tabsize defaults to 8.\n Tab stops will be honored.",
            "ret":["expanded string"]
          },{
            "name":"find",
            "inferred":true,
            "description":"",
            "file":"<reference cycle>",
            "summary":"",
            "tags":[],
            "lineno":231,
            "display_name":"Finding and Replacing",
            "type":"section",
            "modifiers":[]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[[]],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "type":"string"
                },
                "3":{
                  "opt":true,
                  "type":"int",
                  "optchain":true
                },
                "4":{
                  "opt":true,
                  "type":"int",
                  "optchain":true
                },
                "first":{
                  "opt":true,
                  "type":"int",
                  "optchain":true
                },
                "sub":{
                  "type":"string"
                },
                "s":{
                  "type":"string"
                },
                "last":{
                  "opt":true,
                  "type":"int",
                  "optchain":true
                }
              }
            },
            "summary":"find index of first instance of sub in s from the left.",
            "lineno":257,
            "retgroups":[{
                "1":{
                  "text":"start index, or nil if not found",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s, sub[, first[, last]])",
            "type":"function",
            "name":"lfind",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"sub",
              "3":"first",
              "4":"last",
              "map":{
                "first":" first index",
                "sub":" substring",
                "s":" the string",
                "last":" last index"
              }
            },
            "tags":[],
            "kind":"finding and replacing ",
            "section":"Finding and Replacing",
            "description":"",
            "ret":["start index, or nil if not found"]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[[]],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "type":"string"
                },
                "3":{
                  "opt":true,
                  "type":"int",
                  "optchain":true
                },
                "4":{
                  "opt":true,
                  "type":"int",
                  "optchain":true
                },
                "first":{
                  "opt":true,
                  "type":"int",
                  "optchain":true
                },
                "sub":{
                  "type":"string"
                },
                "s":{
                  "type":"string"
                },
                "last":{
                  "opt":true,
                  "type":"int",
                  "optchain":true
                }
              }
            },
            "summary":"find index of first instance of sub in s from the right.",
            "lineno":275,
            "retgroups":[{
                "1":{
                  "text":"start index, or nil if not found",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s, sub[, first[, last]])",
            "type":"function",
            "name":"rfind",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"sub",
              "3":"first",
              "4":"last",
              "map":{
                "first":" first index",
                "sub":" substring",
                "s":" the string",
                "last":" last index"
              }
            },
            "tags":[],
            "kind":"finding and replacing ",
            "section":"Finding and Replacing",
            "description":"",
            "ret":["start index, or nil if not found"]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[[]],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "type":"string"
                },
                "3":{
                  "type":"string"
                },
                "4":{
                  "opt":true,
                  "type":"int",
                  "optchain":true
                },
                "n":{
                  "opt":true,
                  "type":"int",
                  "optchain":true
                },
                "old":{
                  "type":"string"
                },
                "s":{
                  "type":"string"
                },
                "new":{
                  "type":"string"
                }
              }
            },
            "summary":"replace up to n instances of old by new in the string s.",
            "lineno":288,
            "retgroups":[{
                "1":{
                  "text":"result string",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s, old, new[, n])",
            "type":"function",
            "name":"replace",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"old",
              "3":"new",
              "4":"n",
              "map":{
                "n":" optional maximum number of substitutions",
                "old":" the target substring",
                "s":" the string",
                "new":" the substitution"
              }
            },
            "tags":[],
            "kind":"finding and replacing ",
            "section":"Finding and Replacing",
            "description":"\n If n is not present, replace all instances.",
            "ret":["result string"]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[]],
              "return":[],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "type":"string"
                },
                "3":{
                  "opt":true,
                  "type":"bool",
                  "optchain":true
                },
                "sub":{
                  "type":"string"
                },
                "s":{
                  "type":"string"
                },
                "allow_overlap":{
                  "opt":true,
                  "type":"bool",
                  "optchain":true
                }
              }
            },
            "summary":"count all instances of substring in string.",
            "lineno":302,
            "args":"(s, sub[, allow_overlap])",
            "usage":["assert(stringx.count('banana', 'ana') == 1)\nassert(stringx.count('banana', 'ana', true) == 2)\n"],
            "section":"Finding and Replacing",
            "name":"count",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"sub",
              "map":{
                "sub":" substring",
                "s":" the string",
                "allow_overlap":" allow matches to overlap"
              },
              "3":"allow_overlap"
            },
            "tags":[],
            "kind":"finding and replacing ",
            "description":"",
            "type":"function"
          },{
            "name":"strip",
            "inferred":true,
            "description":"",
            "file":"<reference cycle>",
            "summary":"",
            "tags":[],
            "lineno":311,
            "display_name":"Stripping and Justifying",
            "type":"section",
            "modifiers":[]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[]],
              "return":[],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "type":"int"
                },
                "3":{
                  "opt":"' '",
                  "type":"string",
                  "optchain":"' '"
                },
                "ch":{
                  "opt":"' '",
                  "type":"string",
                  "optchain":"' '"
                },
                "s":{
                  "type":"string"
                },
                "w":{
                  "type":"int"
                }
              }
            },
            "summary":"left-justify s with width w.",
            "lineno":339,
            "args":"(s, w[, ch=' '])",
            "usage":["stringx.ljust('hello', 10, '*') == '*****hello'\n"],
            "section":"Stripping and Justifying",
            "name":"ljust",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"w",
              "map":{
                "ch":" padding character",
                "s":" the string",
                "w":" width of justification"
              },
              "3":"ch"
            },
            "tags":[],
            "kind":"stripping and justifying ",
            "description":"",
            "type":"function"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[]],
              "return":[],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "type":"int"
                },
                "3":{
                  "opt":"' '",
                  "type":"string",
                  "optchain":"' '"
                },
                "ch":{
                  "opt":"' '",
                  "type":"string",
                  "optchain":"' '"
                },
                "s":{
                  "type":"string"
                },
                "w":{
                  "type":"int"
                }
              }
            },
            "summary":"right-justify s with width w.",
            "lineno":350,
            "args":"(s, w[, ch=' '])",
            "usage":["stringx.rjust('hello', 10, '*') == 'hello*****'\n"],
            "section":"Stripping and Justifying",
            "name":"rjust",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"w",
              "map":{
                "ch":" padding character",
                "s":" the string",
                "w":" width of justification"
              },
              "3":"ch"
            },
            "tags":[],
            "kind":"stripping and justifying ",
            "description":"",
            "type":"function"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[]],
              "return":[],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "type":"int"
                },
                "3":{
                  "opt":"' '",
                  "type":"string",
                  "optchain":"' '"
                },
                "ch":{
                  "opt":"' '",
                  "type":"string",
                  "optchain":"' '"
                },
                "s":{
                  "type":"string"
                },
                "w":{
                  "type":"int"
                }
              }
            },
            "summary":"center-justify s with width w.",
            "lineno":361,
            "args":"(s, w[, ch=' '])",
            "usage":["stringx.center('hello', 10, '*') == '**hello***'\n"],
            "section":"Stripping and Justifying",
            "name":"center",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"w",
              "map":{
                "ch":" padding character",
                "s":" the string",
                "w":" width of justification"
              },
              "3":"ch"
            },
            "tags":[],
            "kind":"stripping and justifying ",
            "description":"",
            "type":"function"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "opt":"'%s'",
                  "type":"string",
                  "optchain":"'%s'"
                },
                "s":{
                  "type":"string"
                },
                "chrs":{
                  "opt":"'%s'",
                  "type":"string",
                  "optchain":"'%s'"
                }
              }
            },
            "summary":"trim any characters on the left of s.",
            "lineno":402,
            "args":"(s[, chrs='%s'])",
            "section":"Stripping and Justifying",
            "name":"lstrip",
            "params":{
              "1":"s",
              "2":"chrs",
              "map":{
                "s":" the string",
                "chrs":" default any whitespace character,\n but can be a string of characters to be trimmed"
              }
            },
            "tags":[],
            "kind":"stripping and justifying ",
            "description":"",
            "type":"function",
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "opt":"'%s'",
                  "type":"string",
                  "optchain":"'%s'"
                },
                "s":{
                  "type":"string"
                },
                "chrs":{
                  "opt":"'%s'",
                  "type":"string",
                  "optchain":"'%s'"
                }
              }
            },
            "summary":"trim any characters on the right of s.",
            "lineno":412,
            "args":"(s[, chrs='%s'])",
            "section":"Stripping and Justifying",
            "name":"rstrip",
            "params":{
              "1":"s",
              "2":"chrs",
              "map":{
                "s":" the string",
                "chrs":" default any whitespace character,\n but can be a string of characters to be trimmed"
              }
            },
            "tags":[],
            "kind":"stripping and justifying ",
            "description":"",
            "type":"function",
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[]],
              "return":[],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "opt":"'%s'",
                  "type":"string",
                  "optchain":"'%s'"
                },
                "s":{
                  "type":"string"
                },
                "chrs":{
                  "opt":"'%s'",
                  "type":"string",
                  "optchain":"'%s'"
                }
              }
            },
            "summary":"trim any characters on both left and right of s.",
            "lineno":422,
            "args":"(s[, chrs='%s'])",
            "usage":["stringx.strip('  --== Hello ==--  ', \"- =\")  --> 'Hello'\n"],
            "section":"Stripping and Justifying",
            "name":"strip",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"chrs",
              "map":{
                "s":" the string",
                "chrs":" default any whitespace character,\n but can be a string of characters to be trimmed"
              }
            },
            "tags":[],
            "kind":"stripping and justifying ",
            "description":"",
            "type":"function"
          },{
            "name":"partitioning",
            "inferred":true,
            "description":"",
            "file":"<reference cycle>",
            "summary":"",
            "tags":[],
            "lineno":430,
            "display_name":"Partitioning Strings",
            "type":"section",
            "modifiers":[]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "opt":"'%s'",
                  "type":"string",
                  "optchain":"'%s'"
                },
                "s":{
                  "type":"string"
                },
                "re":{
                  "opt":"'%s'",
                  "type":"string",
                  "optchain":"'%s'"
                }
              },
              "return":[[]],
              "usage":[[]],
              "see":[[]]
            },
            "summary":"split a string using a pattern.",
            "lineno":436,
            "retgroups":[{
                "1":{
                  "text":"the parts of the string",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s[, re='%s'])",
            "usage":["a,b = line:splitv('=')\n"],
            "type":"function",
            "name":"splitv",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"re",
              "map":{
                "s":" the string",
                "re":" a Lua string pattern (defaults to whitespace)"
              }
            },
            "tags":{
              "see":[]
            },
            "kind":"partitioning strings ",
            "section":"Partitioning Strings",
            "description":" Note that at least one value will be returned!",
            "ret":["the parts of the string"]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[],[]],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "type":"string"
                },
                "s":{
                  "type":"string"
                },
                "ch":{
                  "type":"string"
                }
              },
              "return":[[],[],[]]
            },
            "summary":"partition the string using first occurance of a delimiter",
            "lineno":461,
            "retgroups":[{
                "1":{
                  "text":"part before ch",
                  "type":"",
                  "mods":[]
                },
                "2":{
                  "text":"ch",
                  "type":"",
                  "mods":[]
                },
                "3":{
                  "text":"part after ch",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s, ch)",
            "usage":["{stringx.partition('a,b,c', ','))} == {'a', ',', 'b,c'}\n","{stringx.partition('abc', 'x'))} == {'abc', '', ''}\n"],
            "type":"function",
            "name":"partition",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"ch",
              "map":{
                "s":" the string",
                "ch":" delimiter (match as plain string, no patterns)"
              }
            },
            "tags":[],
            "kind":"partitioning strings ",
            "section":"Partitioning Strings",
            "description":"",
            "ret":["part before ch","ch","part after ch"]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[],[]],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "type":"string"
                },
                "s":{
                  "type":"string"
                },
                "ch":{
                  "type":"string"
                }
              },
              "return":[[],[],[]]
            },
            "summary":"partition the string p using last occurance of a delimiter",
            "lineno":475,
            "retgroups":[{
                "1":{
                  "text":"part before ch",
                  "type":"",
                  "mods":[]
                },
                "2":{
                  "text":"ch",
                  "type":"",
                  "mods":[]
                },
                "3":{
                  "text":"part after ch",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s, ch)",
            "usage":["{stringx.rpartition('a,b,c', ','))} == {'a,b', ',', 'c'}\n","{stringx.rpartition('abc', 'x'))} == {'', '', 'abc'}\n"],
            "type":"function",
            "name":"rpartition",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"ch",
              "map":{
                "s":" the string",
                "ch":" delimiter (match as plain string, no patterns)"
              }
            },
            "tags":[],
            "kind":"partitioning strings ",
            "section":"Partitioning Strings",
            "description":"",
            "ret":["part before ch","ch","part after ch"]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[[]],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "type":"int"
                },
                "s":{
                  "type":"string"
                },
                "idx":{
                  "type":"int"
                }
              }
            },
            "summary":"return the 'character' at the index.",
            "lineno":489,
            "retgroups":[{
                "1":{
                  "text":"a substring of length 1 if successful, empty string otherwise.",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s, idx)",
            "type":"function",
            "name":"at",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"idx",
              "map":{
                "s":" the string",
                "idx":" an index (can be negative)"
              }
            },
            "tags":[],
            "kind":"partitioning strings ",
            "section":"Partitioning Strings",
            "description":"",
            "ret":["a substring of length 1 if successful, empty string otherwise."]
          },{
            "name":"text",
            "inferred":true,
            "description":"",
            "file":"<reference cycle>",
            "summary":"",
            "tags":[],
            "lineno":500,
            "display_name":"Text handling",
            "type":"section",
            "modifiers":[]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[[]],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "type":"integer"
                },
                "3":{
                  "opt":"' '",
                  "type":"string",
                  "optchain":"' '"
                },
                "ch":{
                  "opt":"' '",
                  "type":"string",
                  "optchain":"' '"
                },
                "n":{
                  "type":"integer"
                },
                "s":{
                  "type":"string"
                }
              }
            },
            "summary":"indent a multiline string.",
            "lineno":505,
            "retgroups":[{
                "1":{
                  "text":"indented string",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s, n[, ch=' '])",
            "type":"function",
            "name":"indent",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"n",
              "map":{
                "ch":" the character to use when indenting",
                "n":" the size of the indent",
                "s":" the (multiline) string"
              },
              "3":"ch"
            },
            "tags":[],
            "kind":"text handling ",
            "section":"Text handling",
            "description":"",
            "ret":["indented string"]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[]],
              "param":{
                "1":{
                  "type":"string"
                },
                "s":{
                  "type":"string"
                }
              },
              "return":[[]]
            },
            "summary":"dedent a multiline string by removing any initial indent.",
            "lineno":537,
            "retgroups":[{
                "1":{
                  "text":"a string with initial indent zero.",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s)",
            "usage":["local s = dedent [[\n         One\n\n       Two\n\n     Three\n]]\nassert(s == [[\n    One\n\n  Two\n\nThree\n]])\n"],
            "type":"function",
            "name":"dedent",
            "parameter":"param",
            "params":{
              "map":{
                "s":" the (multiline) string"
              },
              "1":"s"
            },
            "tags":[],
            "kind":"text handling ",
            "section":"Text handling",
            "description":"\n useful when working with [[..]] strings.\n Empty lines are ignored.",
            "ret":["a string with initial indent zero."]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "opt":"70",
                  "type":"integer",
                  "optchain":"70"
                },
                "3":{
                  "opt":"false",
                  "type":"boolean",
                  "optchain":"false"
                },
                "width":{
                  "opt":"70",
                  "type":"integer",
                  "optchain":"70"
                },
                "s":{
                  "type":"string"
                },
                "breaklong":{
                  "opt":"false",
                  "type":"boolean",
                  "optchain":"false"
                }
              },
              "return":[[]],
              "see":[[],[]]
            },
            "summary":"format a paragraph into lines so that they fit into a line width.",
            "lineno":594,
            "retgroups":[{
                "1":{
                  "text":"a list of lines (List object), use `fill` to return a string instead of a `List`.",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s[, width=70[, breaklong=false]])",
            "type":"function",
            "name":"wrap",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"width",
              "map":{
                "width":" the margin width",
                "s":" the string to format",
                "breaklong":" if truthy, words longer than the width given will be forced split."
              },
              "3":"breaklong"
            },
            "tags":{
              "see":[]
            },
            "kind":"text handling ",
            "section":"Text handling",
            "description":"\n It will not break long words by default, so lines can be over the length\n to that extent.",
            "ret":["a list of lines (List object), use `fill` to return a string instead of a `List`."]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "opt":"70",
                  "type":"integer",
                  "optchain":"70"
                },
                "3":{
                  "opt":"false",
                  "type":"boolean",
                  "optchain":"false"
                },
                "width":{
                  "opt":"70",
                  "type":"integer",
                  "optchain":"70"
                },
                "s":{
                  "type":"string"
                },
                "breaklong":{
                  "opt":"false",
                  "type":"boolean",
                  "optchain":"false"
                }
              },
              "return":[[]],
              "see":[[]]
            },
            "summary":"format a paragraph so that it fits into a line width.",
            "lineno":616,
            "retgroups":[{
                "1":{
                  "text":"a string, use `wrap` to return a list of lines instead of a string.",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s[, width=70[, breaklong=false]])",
            "type":"function",
            "name":"fill",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"width",
              "map":{
                "width":" the margin width",
                "s":" the string to format",
                "breaklong":" if truthy, words longer than the width given will be forced split."
              },
              "3":"breaklong"
            },
            "tags":{
              "see":[]
            },
            "kind":"text handling ",
            "section":"Text handling",
            "description":"",
            "ret":["a string, use `wrap` to return a list of lines instead of a string."]
          },"<reference cycle>",{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "param":{
                "1":{
                  "type":"string"
                },
                "tmpl":{
                  "type":"string"
                }
              },
              "return":[{
                  "type":"Template"
                }]
            },
            "summary":"Creates a new Template class.",
            "lineno":662,
            "retgroups":[{
                "1":{
                  "text":"",
                  "type":"Template",
                  "mods":{
                    "type":"Template"
                  }
                },
                "g":0
              }],
            "args":"(tmpl)",
            "section":"Template",
            "name":"Template",
            "params":{
              "map":{
                "tmpl":" the template string"
              },
              "1":"tmpl"
            },
            "tags":[],
            "kind":"template ",
            "description":"\n This is a shortcut to `Template.new(tmpl)`.",
            "type":"function",
            "ret":[""],
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[[]],
              "param":{
                "1":{
                  "type":"table"
                },
                "tbl":{
                  "type":"table"
                }
              }
            },
            "summary":"substitute values into a template, throwing an error.",
            "lineno":674,
            "retgroups":[{
                "1":{
                  "text":"string with place holders substituted",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(tbl)",
            "type":"function",
            "name":"Template:substitute",
            "parameter":"param",
            "params":{
              "map":{
                "tbl":" a table of name-value pairs."
              },
              "1":"tbl"
            },
            "tags":[],
            "kind":"template ",
            "section":"Template",
            "description":"\n This will throw an error if no name is found.",
            "ret":["string with place holders substituted"]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[[]],
              "param":{
                "1":{
                  "type":"table"
                },
                "tbl":{
                  "type":"table"
                }
              }
            },
            "summary":"substitute values into a template.",
            "lineno":683,
            "retgroups":[{
                "1":{
                  "text":"string with place holders substituted",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(tbl)",
            "type":"function",
            "name":"Template:safe_substitute",
            "parameter":"param",
            "params":{
              "map":{
                "tbl":" a table of name-value pairs."
              },
              "1":"tbl"
            },
            "tags":[],
            "kind":"template ",
            "section":"Template",
            "description":"\n This version just passes unknown names through.",
            "ret":["string with place holders substituted"]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[[]],
              "param":{
                "1":{
                  "type":"table"
                },
                "tbl":{
                  "type":"table"
                }
              }
            },
            "summary":"substitute values into a template, preserving indentation.",
            "lineno":695,
            "retgroups":[{
                "1":{
                  "text":"string with place holders substituted",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(tbl)",
            "type":"function",
            "name":"Template:indent_substitute",
            "parameter":"param",
            "params":{
              "map":{
                "tbl":" a table of name-value pairs."
              },
              "1":"tbl"
            },
            "tags":[],
            "kind":"template ",
            "section":"Template",
            "description":" <br>\n If the value is a multiline string _or_ a template, it will insert\n the lines at the correct indentation. <br>\n Furthermore, if a template, then that template will be substituted\n using the same table.",
            "ret":["string with place holders substituted"]
          },{
            "name":"misc",
            "inferred":true,
            "description":"",
            "file":"<reference cycle>",
            "summary":"",
            "tags":[],
            "lineno":742,
            "display_name":"Miscelaneous",
            "type":"section",
            "modifiers":[]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[]],
              "param":{
                "1":{
                  "type":"string"
                },
                "s":{
                  "type":"string"
                }
              },
              "return":[[]]
            },
            "summary":"return an iterator over all lines in a string",
            "lineno":751,
            "retgroups":[{
                "1":{
                  "text":"an iterator",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s)",
            "usage":["local line_no = 1\nfor line in stringx.lines(some_text) do\n  print(line_no, line)\n  line_no = line_no + 1\nend\n"],
            "type":"function",
            "name":"lines",
            "parameter":"param",
            "params":{
              "map":{
                "s":" the string"
              },
              "1":"s"
            },
            "tags":[],
            "kind":"miscelaneous ",
            "section":"Miscelaneous",
            "description":"",
            "ret":["an iterator"]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[]],
              "param":{
                "1":{
                  "type":"string"
                },
                "s":{
                  "type":"string"
                }
              },
              "return":[[]]
            },
            "summary":"inital word letters uppercase ('title case').",
            "lineno":762,
            "retgroups":[{
                "1":{
                  "text":"a string with each word's first letter uppercase",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s)",
            "usage":["stringx.title(\"hello world\") == \"Hello World\")\n"],
            "type":"function",
            "name":"title",
            "parameter":"param",
            "params":{
              "map":{
                "s":" the string"
              },
              "1":"s"
            },
            "tags":[],
            "kind":"miscelaneous ",
            "section":"Miscelaneous",
            "description":"\n Here 'words' mean chunks of non-space characters.",
            "ret":["a string with each word's first letter uppercase"]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[],[],[]],
              "return":[],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "type":"int"
                },
                "3":{
                  "type":"bool"
                },
                "tail":{
                  "type":"bool"
                },
                "s":{
                  "type":"string"
                },
                "w":{
                  "type":"int"
                }
              }
            },
            "summary":"Return a shortened version of a string.",
            "lineno":783,
            "args":"(s, w, tail)",
            "usage":["('1234567890'):shorten(8) == '12345...'\n","('1234567890'):shorten(8, true) == '...67890'\n","('1234567890'):shorten(20) == '1234567890'\n"],
            "section":"Miscelaneous",
            "name":"shorten",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"w",
              "map":{
                "tail":" true if we want to show the end of the string (head otherwise)",
                "s":" the string",
                "w":" the maxinum size allowed"
              },
              "3":"tail"
            },
            "tags":[],
            "kind":"miscelaneous ",
            "description":"\n Fits string within w characters. Removed characters are marked with ellipsis.",
            "type":"function"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[[]],
              "param":{
                "1":[],
                "s":[]
              }
            },
            "summary":"Quote the given string and preserve any control or escape characters, such that reloading the string in Lua returns the same result.",
            "lineno":822,
            "retgroups":[{
                "1":{
                  "text":"The quoted string.",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s)",
            "type":"function",
            "name":"quote_string",
            "parameter":"param",
            "params":{
              "map":{
                "s":" The string to be quoted."
              },
              "1":"s"
            },
            "tags":[],
            "kind":"miscelaneous ",
            "section":"Miscelaneous",
            "description":"",
            "ret":["The quoted string."]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":[],
              "usage":[[]]
            },
            "summary":"Python-style formatting operator.",
            "lineno":873,
            "args":"()",
            "usage":["require 'pl.text'.format_operator()\nlocal out1 = '%s = %5.3f' % {'PI',math.pi}                   --> 'PI = 3.142'\nlocal out2 = '$name = $value' % {name='dog',value='Pluto'}   --> 'dog = Pluto'\n"],
            "section":"Miscelaneous",
            "name":"format_operator",
            "parameter":"param",
            "params":{
              "map":[]
            },
            "tags":[],
            "kind":"miscelaneous ",
            "description":"\n Calling `text.format_operator()` overloads the % operator for strings to give\n Python/Ruby style formated output.\n This is extended to also do template-like substitution for map-like data.\n\n Note this goes further than the original, and will allow these cases:\n\n 1. a single value\n 2. a list of values\n 3. a map of var=value pairs\n 4. a function, as in gsub\n\n For the second two cases, it uses $-variable substituion.\n\n When called, this function will monkey-patch the global `string` metatable by\n adding a `__mod` method.\n\n See <a href=\"http://lua-users.org/wiki/StringInterpolation\">the lua-users wiki</a>\n",
            "type":"function"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "param":[],
              "return":[]
            },
            "summary":"import the stringx functions into the global string (meta)table",
            "lineno":913,
            "args":"()",
            "section":"Miscelaneous",
            "name":"import",
            "params":{
              "map":[]
            },
            "tags":[],
            "kind":"miscelaneous ",
            "description":"",
            "type":"function",
            "parameter":"param"
          }],
        "sections":[],
        "modules":["<reference cycle>"],
        "args":{
          "one":false,
          "module":false,
          "verbose":false,
          "style":"!",
          "template":"!",
          "date":"system",
          "dir":"doc",
          "quiet":false,
          "all":false,
          "ignore":false,
          "colon":false,
          "not_luadoc":false,
          "ext":"html",
          "boilerplate":false,
          "merge":false,
          "filter":"f.filter",
          "package":"/home/cji/portless/Penlight/lua",
          "dump":false,
          "no_args_infer":false,
          "title":"Reference",
          "project":"ldoc",
          "file":"/home/cji/portless/Penlight/lua/pl",
          "format":"discount",
          "simple":false,
          "tags":"none",
          "define":"none",
          "output":"index",
          "unqualified":false,
          "config":"config.ld",
          "fatalwarnings":false,
          "testing":false
        },
        "error":"<type 'function' is not supported by JSON.>",
        "lang":{
          "line_comment":"^%-%-+",
          "start_comment_":"^%-%-%-+",
          "end_comment_":"[^%-]%-%-+[^-]*\n$",
          "extra":[],
          "block_comment":"^%-%-%[=*%[%-+",
          "empty_comment_":"^%-%-%-+%s*$",
          "method_call":":"
        },
        "base":"/home/cji/portless/Penlight/lua"
      },
      "summary":"",
      "tags":[],
      "lineno":624,
      "display_name":"Template",
      "type":"section",
      "modifiers":[]
    },
    "8":{
      "name":"misc",
      "inferred":true,
      "description":"",
      "file":{
        "warning":"<type 'function' is not supported by JSON.>",
        "filename":"/home/cji/portless/Penlight/lua/pl/stringx.lua",
        "items":["<reference cycle>",{
            "name":"predicates",
            "inferred":true,
            "description":"",
            "file":"<reference cycle>",
            "summary":"",
            "tags":[],
            "lineno":53,
            "display_name":"String Predicates",
            "type":"section",
            "modifiers":[]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":{
                "1":{
                  "type":"string"
                },
                "s":{
                  "type":"string"
                }
              }
            },
            "summary":"does s only contain alphabetic characters?",
            "lineno":55,
            "args":"(s)",
            "section":"String Predicates",
            "name":"isalpha",
            "params":{
              "map":{
                "s":" a string"
              },
              "1":"s"
            },
            "tags":[],
            "kind":"string predicates ",
            "description":"",
            "type":"function",
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":{
                "1":{
                  "type":"string"
                },
                "s":{
                  "type":"string"
                }
              }
            },
            "summary":"does s only contain digits?",
            "lineno":62,
            "args":"(s)",
            "section":"String Predicates",
            "name":"isdigit",
            "params":{
              "map":{
                "s":" a string"
              },
              "1":"s"
            },
            "tags":[],
            "kind":"string predicates ",
            "description":"",
            "type":"function",
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":{
                "1":{
                  "type":"string"
                },
                "s":{
                  "type":"string"
                }
              }
            },
            "summary":"does s only contain alphanumeric characters?",
            "lineno":69,
            "args":"(s)",
            "section":"String Predicates",
            "name":"isalnum",
            "params":{
              "map":{
                "s":" a string"
              },
              "1":"s"
            },
            "tags":[],
            "kind":"string predicates ",
            "description":"",
            "type":"function",
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":{
                "1":{
                  "type":"string"
                },
                "s":{
                  "type":"string"
                }
              }
            },
            "summary":"does s only contain whitespace?",
            "lineno":77,
            "args":"(s)",
            "section":"String Predicates",
            "name":"isspace",
            "params":{
              "map":{
                "s":" a string"
              },
              "1":"s"
            },
            "tags":[],
            "kind":"string predicates ",
            "description":"\n Matches on pattern '%s' so matches space, newline, tabs, etc.",
            "type":"function",
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":{
                "1":{
                  "type":"string"
                },
                "s":{
                  "type":"string"
                }
              }
            },
            "summary":"does s only contain lower case characters?",
            "lineno":84,
            "args":"(s)",
            "section":"String Predicates",
            "name":"islower",
            "params":{
              "map":{
                "s":" a string"
              },
              "1":"s"
            },
            "tags":[],
            "kind":"string predicates ",
            "description":"",
            "type":"function",
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":{
                "1":{
                  "type":"string"
                },
                "s":{
                  "type":"string"
                }
              }
            },
            "summary":"does s only contain upper case characters?",
            "lineno":91,
            "args":"(s)",
            "section":"String Predicates",
            "name":"isupper",
            "params":{
              "map":{
                "s":" a string"
              },
              "1":"s"
            },
            "tags":[],
            "kind":"string predicates ",
            "description":"",
            "type":"function",
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":[],
                "s":{
                  "type":"string"
                },
                "prefix":[]
              }
            },
            "summary":"does s start with prefix or one of prefixes?",
            "lineno":120,
            "args":"(s, prefix)",
            "section":"String Predicates",
            "name":"startswith",
            "params":{
              "1":"s",
              "2":"prefix",
              "map":{
                "s":" a string",
                "prefix":" a string or an array of strings"
              }
            },
            "tags":[],
            "kind":"string predicates ",
            "description":"",
            "type":"function",
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":[],
                "s":{
                  "type":"string"
                },
                "suffix":[]
              }
            },
            "summary":"does s end with suffix or one of suffixes?",
            "lineno":128,
            "args":"(s, suffix)",
            "section":"String Predicates",
            "name":"endswith",
            "params":{
              "1":"s",
              "2":"suffix",
              "map":{
                "s":" a string",
                "suffix":" a string or an array of strings"
              }
            },
            "tags":[],
            "kind":"string predicates ",
            "description":"",
            "type":"function",
            "parameter":"param"
          },{
            "name":"lists",
            "inferred":true,
            "description":"",
            "file":"<reference cycle>",
            "summary":"",
            "tags":[],
            "lineno":136,
            "display_name":"Strings and Lists",
            "type":"section",
            "modifiers":[]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[]],
              "return":[],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":[],
                "s":{
                  "type":"string"
                },
                "seq":[]
              }
            },
            "summary":"concatenate the strings using this string as a delimiter.",
            "lineno":141,
            "args":"(s, seq)",
            "usage":["stringx.join(' ', {1,2,3}) == '1 2 3'\n"],
            "section":"Strings and Lists",
            "name":"join",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"seq",
              "map":{
                "s":" the string",
                "seq":" a table of strings or numbers"
              }
            },
            "tags":[],
            "kind":"strings and lists ",
            "description":"\n Note that the arguments are reversed from `string.concat`.",
            "type":"function"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[[]],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "opt":true,
                  "type":"bool",
                  "optchain":true
                },
                "s":{
                  "type":"string"
                },
                "keep_ends":{
                  "opt":true,
                  "type":"bool",
                  "optchain":true
                }
              }
            },
            "summary":"Split a string into a list of lines.",
            "lineno":154,
            "retgroups":[{
                "1":{
                  "text":"List of lines",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s[, keep_ends])",
            "type":"function",
            "name":"splitlines",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"keep_ends",
              "map":{
                "s":" the string.",
                "keep_ends":" include line ends."
              }
            },
            "tags":[],
            "kind":"strings and lists ",
            "section":"Strings and Lists",
            "description":"\n `\"\\r\"`, `\"\\n\"`, and `\"\\r\\n\"` are considered line ends.\n They are not included in the lines unless `keepends` is passed.\n Terminal line end does not produce an extra line.\n Splitting an empty string results in an empty list.",
            "ret":["List of lines"]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[],[],[]],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "opt":true,
                  "type":"string",
                  "optchain":true
                },
                "3":{
                  "opt":true,
                  "type":"int",
                  "optchain":true
                },
                "re":{
                  "opt":true,
                  "type":"string",
                  "optchain":true
                },
                "n":{
                  "opt":true,
                  "type":"int",
                  "optchain":true
                },
                "s":{
                  "type":"string"
                }
              },
              "return":[[]]
            },
            "summary":"split a string into a list of strings using a delimiter.",
            "lineno":193,
            "retgroups":[{
                "1":{
                  "text":"List",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s[, re[, n]])",
            "usage":["#(stringx.split('one two')) == 2\n","stringx.split('one,two,three', ',') == List{'one','two','three'}\n","stringx.split('one,two,three', ',', 2) == List{'one','two,three'}\n"],
            "type":"function",
            "name":"split",
            "params":{
              "1":"s",
              "2":"re",
              "map":{
                "re":" a delimiter (defaults to whitespace)",
                "n":" maximum number of results",
                "s":" the string"
              },
              "3":"n"
            },
            "tags":[],
            "kind":"strings and lists ",
            "section":"Strings and Lists",
            "description":"",
            "ret":["List"],
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[],[]],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "type":"int"
                },
                "s":{
                  "type":"string"
                },
                "tabsize":{
                  "type":"int"
                }
              },
              "return":[[]]
            },
            "summary":"replace all tabs in s with tabsize spaces.",
            "lineno":216,
            "retgroups":[{
                "1":{
                  "text":"expanded string",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s, tabsize)",
            "usage":["stringx.expandtabs('\\tone,two,three', 4)   == '    one,two,three'\n","stringx.expandtabs('  \\tone,two,three', 4) == '    one,two,three'\n"],
            "type":"function",
            "name":"expandtabs",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"tabsize",
              "map":{
                "s":" the string",
                "tabsize":"[opt=8] number of spaces to expand each tab"
              }
            },
            "tags":[],
            "kind":"strings and lists ",
            "section":"Strings and Lists",
            "description":" If not specified, tabsize defaults to 8.\n Tab stops will be honored.",
            "ret":["expanded string"]
          },{
            "name":"find",
            "inferred":true,
            "description":"",
            "file":"<reference cycle>",
            "summary":"",
            "tags":[],
            "lineno":231,
            "display_name":"Finding and Replacing",
            "type":"section",
            "modifiers":[]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[[]],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "type":"string"
                },
                "3":{
                  "opt":true,
                  "type":"int",
                  "optchain":true
                },
                "4":{
                  "opt":true,
                  "type":"int",
                  "optchain":true
                },
                "first":{
                  "opt":true,
                  "type":"int",
                  "optchain":true
                },
                "sub":{
                  "type":"string"
                },
                "s":{
                  "type":"string"
                },
                "last":{
                  "opt":true,
                  "type":"int",
                  "optchain":true
                }
              }
            },
            "summary":"find index of first instance of sub in s from the left.",
            "lineno":257,
            "retgroups":[{
                "1":{
                  "text":"start index, or nil if not found",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s, sub[, first[, last]])",
            "type":"function",
            "name":"lfind",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"sub",
              "3":"first",
              "4":"last",
              "map":{
                "first":" first index",
                "sub":" substring",
                "s":" the string",
                "last":" last index"
              }
            },
            "tags":[],
            "kind":"finding and replacing ",
            "section":"Finding and Replacing",
            "description":"",
            "ret":["start index, or nil if not found"]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[[]],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "type":"string"
                },
                "3":{
                  "opt":true,
                  "type":"int",
                  "optchain":true
                },
                "4":{
                  "opt":true,
                  "type":"int",
                  "optchain":true
                },
                "first":{
                  "opt":true,
                  "type":"int",
                  "optchain":true
                },
                "sub":{
                  "type":"string"
                },
                "s":{
                  "type":"string"
                },
                "last":{
                  "opt":true,
                  "type":"int",
                  "optchain":true
                }
              }
            },
            "summary":"find index of first instance of sub in s from the right.",
            "lineno":275,
            "retgroups":[{
                "1":{
                  "text":"start index, or nil if not found",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s, sub[, first[, last]])",
            "type":"function",
            "name":"rfind",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"sub",
              "3":"first",
              "4":"last",
              "map":{
                "first":" first index",
                "sub":" substring",
                "s":" the string",
                "last":" last index"
              }
            },
            "tags":[],
            "kind":"finding and replacing ",
            "section":"Finding and Replacing",
            "description":"",
            "ret":["start index, or nil if not found"]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[[]],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "type":"string"
                },
                "3":{
                  "type":"string"
                },
                "4":{
                  "opt":true,
                  "type":"int",
                  "optchain":true
                },
                "n":{
                  "opt":true,
                  "type":"int",
                  "optchain":true
                },
                "old":{
                  "type":"string"
                },
                "s":{
                  "type":"string"
                },
                "new":{
                  "type":"string"
                }
              }
            },
            "summary":"replace up to n instances of old by new in the string s.",
            "lineno":288,
            "retgroups":[{
                "1":{
                  "text":"result string",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s, old, new[, n])",
            "type":"function",
            "name":"replace",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"old",
              "3":"new",
              "4":"n",
              "map":{
                "n":" optional maximum number of substitutions",
                "old":" the target substring",
                "s":" the string",
                "new":" the substitution"
              }
            },
            "tags":[],
            "kind":"finding and replacing ",
            "section":"Finding and Replacing",
            "description":"\n If n is not present, replace all instances.",
            "ret":["result string"]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[]],
              "return":[],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "type":"string"
                },
                "3":{
                  "opt":true,
                  "type":"bool",
                  "optchain":true
                },
                "sub":{
                  "type":"string"
                },
                "s":{
                  "type":"string"
                },
                "allow_overlap":{
                  "opt":true,
                  "type":"bool",
                  "optchain":true
                }
              }
            },
            "summary":"count all instances of substring in string.",
            "lineno":302,
            "args":"(s, sub[, allow_overlap])",
            "usage":["assert(stringx.count('banana', 'ana') == 1)\nassert(stringx.count('banana', 'ana', true) == 2)\n"],
            "section":"Finding and Replacing",
            "name":"count",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"sub",
              "map":{
                "sub":" substring",
                "s":" the string",
                "allow_overlap":" allow matches to overlap"
              },
              "3":"allow_overlap"
            },
            "tags":[],
            "kind":"finding and replacing ",
            "description":"",
            "type":"function"
          },{
            "name":"strip",
            "inferred":true,
            "description":"",
            "file":"<reference cycle>",
            "summary":"",
            "tags":[],
            "lineno":311,
            "display_name":"Stripping and Justifying",
            "type":"section",
            "modifiers":[]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[]],
              "return":[],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "type":"int"
                },
                "3":{
                  "opt":"' '",
                  "type":"string",
                  "optchain":"' '"
                },
                "ch":{
                  "opt":"' '",
                  "type":"string",
                  "optchain":"' '"
                },
                "s":{
                  "type":"string"
                },
                "w":{
                  "type":"int"
                }
              }
            },
            "summary":"left-justify s with width w.",
            "lineno":339,
            "args":"(s, w[, ch=' '])",
            "usage":["stringx.ljust('hello', 10, '*') == '*****hello'\n"],
            "section":"Stripping and Justifying",
            "name":"ljust",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"w",
              "map":{
                "ch":" padding character",
                "s":" the string",
                "w":" width of justification"
              },
              "3":"ch"
            },
            "tags":[],
            "kind":"stripping and justifying ",
            "description":"",
            "type":"function"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[]],
              "return":[],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "type":"int"
                },
                "3":{
                  "opt":"' '",
                  "type":"string",
                  "optchain":"' '"
                },
                "ch":{
                  "opt":"' '",
                  "type":"string",
                  "optchain":"' '"
                },
                "s":{
                  "type":"string"
                },
                "w":{
                  "type":"int"
                }
              }
            },
            "summary":"right-justify s with width w.",
            "lineno":350,
            "args":"(s, w[, ch=' '])",
            "usage":["stringx.rjust('hello', 10, '*') == 'hello*****'\n"],
            "section":"Stripping and Justifying",
            "name":"rjust",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"w",
              "map":{
                "ch":" padding character",
                "s":" the string",
                "w":" width of justification"
              },
              "3":"ch"
            },
            "tags":[],
            "kind":"stripping and justifying ",
            "description":"",
            "type":"function"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[]],
              "return":[],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "type":"int"
                },
                "3":{
                  "opt":"' '",
                  "type":"string",
                  "optchain":"' '"
                },
                "ch":{
                  "opt":"' '",
                  "type":"string",
                  "optchain":"' '"
                },
                "s":{
                  "type":"string"
                },
                "w":{
                  "type":"int"
                }
              }
            },
            "summary":"center-justify s with width w.",
            "lineno":361,
            "args":"(s, w[, ch=' '])",
            "usage":["stringx.center('hello', 10, '*') == '**hello***'\n"],
            "section":"Stripping and Justifying",
            "name":"center",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"w",
              "map":{
                "ch":" padding character",
                "s":" the string",
                "w":" width of justification"
              },
              "3":"ch"
            },
            "tags":[],
            "kind":"stripping and justifying ",
            "description":"",
            "type":"function"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "opt":"'%s'",
                  "type":"string",
                  "optchain":"'%s'"
                },
                "s":{
                  "type":"string"
                },
                "chrs":{
                  "opt":"'%s'",
                  "type":"string",
                  "optchain":"'%s'"
                }
              }
            },
            "summary":"trim any characters on the left of s.",
            "lineno":402,
            "args":"(s[, chrs='%s'])",
            "section":"Stripping and Justifying",
            "name":"lstrip",
            "params":{
              "1":"s",
              "2":"chrs",
              "map":{
                "s":" the string",
                "chrs":" default any whitespace character,\n but can be a string of characters to be trimmed"
              }
            },
            "tags":[],
            "kind":"stripping and justifying ",
            "description":"",
            "type":"function",
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "opt":"'%s'",
                  "type":"string",
                  "optchain":"'%s'"
                },
                "s":{
                  "type":"string"
                },
                "chrs":{
                  "opt":"'%s'",
                  "type":"string",
                  "optchain":"'%s'"
                }
              }
            },
            "summary":"trim any characters on the right of s.",
            "lineno":412,
            "args":"(s[, chrs='%s'])",
            "section":"Stripping and Justifying",
            "name":"rstrip",
            "params":{
              "1":"s",
              "2":"chrs",
              "map":{
                "s":" the string",
                "chrs":" default any whitespace character,\n but can be a string of characters to be trimmed"
              }
            },
            "tags":[],
            "kind":"stripping and justifying ",
            "description":"",
            "type":"function",
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[]],
              "return":[],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "opt":"'%s'",
                  "type":"string",
                  "optchain":"'%s'"
                },
                "s":{
                  "type":"string"
                },
                "chrs":{
                  "opt":"'%s'",
                  "type":"string",
                  "optchain":"'%s'"
                }
              }
            },
            "summary":"trim any characters on both left and right of s.",
            "lineno":422,
            "args":"(s[, chrs='%s'])",
            "usage":["stringx.strip('  --== Hello ==--  ', \"- =\")  --> 'Hello'\n"],
            "section":"Stripping and Justifying",
            "name":"strip",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"chrs",
              "map":{
                "s":" the string",
                "chrs":" default any whitespace character,\n but can be a string of characters to be trimmed"
              }
            },
            "tags":[],
            "kind":"stripping and justifying ",
            "description":"",
            "type":"function"
          },{
            "name":"partitioning",
            "inferred":true,
            "description":"",
            "file":"<reference cycle>",
            "summary":"",
            "tags":[],
            "lineno":430,
            "display_name":"Partitioning Strings",
            "type":"section",
            "modifiers":[]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "opt":"'%s'",
                  "type":"string",
                  "optchain":"'%s'"
                },
                "s":{
                  "type":"string"
                },
                "re":{
                  "opt":"'%s'",
                  "type":"string",
                  "optchain":"'%s'"
                }
              },
              "return":[[]],
              "usage":[[]],
              "see":[[]]
            },
            "summary":"split a string using a pattern.",
            "lineno":436,
            "retgroups":[{
                "1":{
                  "text":"the parts of the string",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s[, re='%s'])",
            "usage":["a,b = line:splitv('=')\n"],
            "type":"function",
            "name":"splitv",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"re",
              "map":{
                "s":" the string",
                "re":" a Lua string pattern (defaults to whitespace)"
              }
            },
            "tags":{
              "see":[]
            },
            "kind":"partitioning strings ",
            "section":"Partitioning Strings",
            "description":" Note that at least one value will be returned!",
            "ret":["the parts of the string"]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[],[]],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "type":"string"
                },
                "s":{
                  "type":"string"
                },
                "ch":{
                  "type":"string"
                }
              },
              "return":[[],[],[]]
            },
            "summary":"partition the string using first occurance of a delimiter",
            "lineno":461,
            "retgroups":[{
                "1":{
                  "text":"part before ch",
                  "type":"",
                  "mods":[]
                },
                "2":{
                  "text":"ch",
                  "type":"",
                  "mods":[]
                },
                "3":{
                  "text":"part after ch",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s, ch)",
            "usage":["{stringx.partition('a,b,c', ','))} == {'a', ',', 'b,c'}\n","{stringx.partition('abc', 'x'))} == {'abc', '', ''}\n"],
            "type":"function",
            "name":"partition",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"ch",
              "map":{
                "s":" the string",
                "ch":" delimiter (match as plain string, no patterns)"
              }
            },
            "tags":[],
            "kind":"partitioning strings ",
            "section":"Partitioning Strings",
            "description":"",
            "ret":["part before ch","ch","part after ch"]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[],[]],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "type":"string"
                },
                "s":{
                  "type":"string"
                },
                "ch":{
                  "type":"string"
                }
              },
              "return":[[],[],[]]
            },
            "summary":"partition the string p using last occurance of a delimiter",
            "lineno":475,
            "retgroups":[{
                "1":{
                  "text":"part before ch",
                  "type":"",
                  "mods":[]
                },
                "2":{
                  "text":"ch",
                  "type":"",
                  "mods":[]
                },
                "3":{
                  "text":"part after ch",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s, ch)",
            "usage":["{stringx.rpartition('a,b,c', ','))} == {'a,b', ',', 'c'}\n","{stringx.rpartition('abc', 'x'))} == {'', '', 'abc'}\n"],
            "type":"function",
            "name":"rpartition",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"ch",
              "map":{
                "s":" the string",
                "ch":" delimiter (match as plain string, no patterns)"
              }
            },
            "tags":[],
            "kind":"partitioning strings ",
            "section":"Partitioning Strings",
            "description":"",
            "ret":["part before ch","ch","part after ch"]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[[]],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "type":"int"
                },
                "s":{
                  "type":"string"
                },
                "idx":{
                  "type":"int"
                }
              }
            },
            "summary":"return the 'character' at the index.",
            "lineno":489,
            "retgroups":[{
                "1":{
                  "text":"a substring of length 1 if successful, empty string otherwise.",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s, idx)",
            "type":"function",
            "name":"at",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"idx",
              "map":{
                "s":" the string",
                "idx":" an index (can be negative)"
              }
            },
            "tags":[],
            "kind":"partitioning strings ",
            "section":"Partitioning Strings",
            "description":"",
            "ret":["a substring of length 1 if successful, empty string otherwise."]
          },{
            "name":"text",
            "inferred":true,
            "description":"",
            "file":"<reference cycle>",
            "summary":"",
            "tags":[],
            "lineno":500,
            "display_name":"Text handling",
            "type":"section",
            "modifiers":[]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[[]],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "type":"integer"
                },
                "3":{
                  "opt":"' '",
                  "type":"string",
                  "optchain":"' '"
                },
                "ch":{
                  "opt":"' '",
                  "type":"string",
                  "optchain":"' '"
                },
                "n":{
                  "type":"integer"
                },
                "s":{
                  "type":"string"
                }
              }
            },
            "summary":"indent a multiline string.",
            "lineno":505,
            "retgroups":[{
                "1":{
                  "text":"indented string",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s, n[, ch=' '])",
            "type":"function",
            "name":"indent",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"n",
              "map":{
                "ch":" the character to use when indenting",
                "n":" the size of the indent",
                "s":" the (multiline) string"
              },
              "3":"ch"
            },
            "tags":[],
            "kind":"text handling ",
            "section":"Text handling",
            "description":"",
            "ret":["indented string"]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[]],
              "param":{
                "1":{
                  "type":"string"
                },
                "s":{
                  "type":"string"
                }
              },
              "return":[[]]
            },
            "summary":"dedent a multiline string by removing any initial indent.",
            "lineno":537,
            "retgroups":[{
                "1":{
                  "text":"a string with initial indent zero.",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s)",
            "usage":["local s = dedent [[\n         One\n\n       Two\n\n     Three\n]]\nassert(s == [[\n    One\n\n  Two\n\nThree\n]])\n"],
            "type":"function",
            "name":"dedent",
            "parameter":"param",
            "params":{
              "map":{
                "s":" the (multiline) string"
              },
              "1":"s"
            },
            "tags":[],
            "kind":"text handling ",
            "section":"Text handling",
            "description":"\n useful when working with [[..]] strings.\n Empty lines are ignored.",
            "ret":["a string with initial indent zero."]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "opt":"70",
                  "type":"integer",
                  "optchain":"70"
                },
                "3":{
                  "opt":"false",
                  "type":"boolean",
                  "optchain":"false"
                },
                "width":{
                  "opt":"70",
                  "type":"integer",
                  "optchain":"70"
                },
                "s":{
                  "type":"string"
                },
                "breaklong":{
                  "opt":"false",
                  "type":"boolean",
                  "optchain":"false"
                }
              },
              "return":[[]],
              "see":[[],[]]
            },
            "summary":"format a paragraph into lines so that they fit into a line width.",
            "lineno":594,
            "retgroups":[{
                "1":{
                  "text":"a list of lines (List object), use `fill` to return a string instead of a `List`.",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s[, width=70[, breaklong=false]])",
            "type":"function",
            "name":"wrap",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"width",
              "map":{
                "width":" the margin width",
                "s":" the string to format",
                "breaklong":" if truthy, words longer than the width given will be forced split."
              },
              "3":"breaklong"
            },
            "tags":{
              "see":[]
            },
            "kind":"text handling ",
            "section":"Text handling",
            "description":"\n It will not break long words by default, so lines can be over the length\n to that extent.",
            "ret":["a list of lines (List object), use `fill` to return a string instead of a `List`."]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "opt":"70",
                  "type":"integer",
                  "optchain":"70"
                },
                "3":{
                  "opt":"false",
                  "type":"boolean",
                  "optchain":"false"
                },
                "width":{
                  "opt":"70",
                  "type":"integer",
                  "optchain":"70"
                },
                "s":{
                  "type":"string"
                },
                "breaklong":{
                  "opt":"false",
                  "type":"boolean",
                  "optchain":"false"
                }
              },
              "return":[[]],
              "see":[[]]
            },
            "summary":"format a paragraph so that it fits into a line width.",
            "lineno":616,
            "retgroups":[{
                "1":{
                  "text":"a string, use `wrap` to return a list of lines instead of a string.",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s[, width=70[, breaklong=false]])",
            "type":"function",
            "name":"fill",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"width",
              "map":{
                "width":" the margin width",
                "s":" the string to format",
                "breaklong":" if truthy, words longer than the width given will be forced split."
              },
              "3":"breaklong"
            },
            "tags":{
              "see":[]
            },
            "kind":"text handling ",
            "section":"Text handling",
            "description":"",
            "ret":["a string, use `wrap` to return a list of lines instead of a string."]
          },{
            "name":"Template",
            "inferred":true,
            "description":"",
            "file":"<reference cycle>",
            "summary":"",
            "tags":[],
            "lineno":624,
            "display_name":"Template",
            "type":"section",
            "modifiers":[]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "param":{
                "1":{
                  "type":"string"
                },
                "tmpl":{
                  "type":"string"
                }
              },
              "return":[{
                  "type":"Template"
                }]
            },
            "summary":"Creates a new Template class.",
            "lineno":662,
            "retgroups":[{
                "1":{
                  "text":"",
                  "type":"Template",
                  "mods":{
                    "type":"Template"
                  }
                },
                "g":0
              }],
            "args":"(tmpl)",
            "section":"Template",
            "name":"Template",
            "params":{
              "map":{
                "tmpl":" the template string"
              },
              "1":"tmpl"
            },
            "tags":[],
            "kind":"template ",
            "description":"\n This is a shortcut to `Template.new(tmpl)`.",
            "type":"function",
            "ret":[""],
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[[]],
              "param":{
                "1":{
                  "type":"table"
                },
                "tbl":{
                  "type":"table"
                }
              }
            },
            "summary":"substitute values into a template, throwing an error.",
            "lineno":674,
            "retgroups":[{
                "1":{
                  "text":"string with place holders substituted",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(tbl)",
            "type":"function",
            "name":"Template:substitute",
            "parameter":"param",
            "params":{
              "map":{
                "tbl":" a table of name-value pairs."
              },
              "1":"tbl"
            },
            "tags":[],
            "kind":"template ",
            "section":"Template",
            "description":"\n This will throw an error if no name is found.",
            "ret":["string with place holders substituted"]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[[]],
              "param":{
                "1":{
                  "type":"table"
                },
                "tbl":{
                  "type":"table"
                }
              }
            },
            "summary":"substitute values into a template.",
            "lineno":683,
            "retgroups":[{
                "1":{
                  "text":"string with place holders substituted",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(tbl)",
            "type":"function",
            "name":"Template:safe_substitute",
            "parameter":"param",
            "params":{
              "map":{
                "tbl":" a table of name-value pairs."
              },
              "1":"tbl"
            },
            "tags":[],
            "kind":"template ",
            "section":"Template",
            "description":"\n This version just passes unknown names through.",
            "ret":["string with place holders substituted"]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[[]],
              "param":{
                "1":{
                  "type":"table"
                },
                "tbl":{
                  "type":"table"
                }
              }
            },
            "summary":"substitute values into a template, preserving indentation.",
            "lineno":695,
            "retgroups":[{
                "1":{
                  "text":"string with place holders substituted",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(tbl)",
            "type":"function",
            "name":"Template:indent_substitute",
            "parameter":"param",
            "params":{
              "map":{
                "tbl":" a table of name-value pairs."
              },
              "1":"tbl"
            },
            "tags":[],
            "kind":"template ",
            "section":"Template",
            "description":" <br>\n If the value is a multiline string _or_ a template, it will insert\n the lines at the correct indentation. <br>\n Furthermore, if a template, then that template will be substituted\n using the same table.",
            "ret":["string with place holders substituted"]
          },"<reference cycle>",{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[]],
              "param":{
                "1":{
                  "type":"string"
                },
                "s":{
                  "type":"string"
                }
              },
              "return":[[]]
            },
            "summary":"return an iterator over all lines in a string",
            "lineno":751,
            "retgroups":[{
                "1":{
                  "text":"an iterator",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s)",
            "usage":["local line_no = 1\nfor line in stringx.lines(some_text) do\n  print(line_no, line)\n  line_no = line_no + 1\nend\n"],
            "type":"function",
            "name":"lines",
            "parameter":"param",
            "params":{
              "map":{
                "s":" the string"
              },
              "1":"s"
            },
            "tags":[],
            "kind":"miscelaneous ",
            "section":"Miscelaneous",
            "description":"",
            "ret":["an iterator"]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[]],
              "param":{
                "1":{
                  "type":"string"
                },
                "s":{
                  "type":"string"
                }
              },
              "return":[[]]
            },
            "summary":"inital word letters uppercase ('title case').",
            "lineno":762,
            "retgroups":[{
                "1":{
                  "text":"a string with each word's first letter uppercase",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s)",
            "usage":["stringx.title(\"hello world\") == \"Hello World\")\n"],
            "type":"function",
            "name":"title",
            "parameter":"param",
            "params":{
              "map":{
                "s":" the string"
              },
              "1":"s"
            },
            "tags":[],
            "kind":"miscelaneous ",
            "section":"Miscelaneous",
            "description":"\n Here 'words' mean chunks of non-space characters.",
            "ret":["a string with each word's first letter uppercase"]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[],[],[]],
              "return":[],
              "param":{
                "1":{
                  "type":"string"
                },
                "2":{
                  "type":"int"
                },
                "3":{
                  "type":"bool"
                },
                "tail":{
                  "type":"bool"
                },
                "s":{
                  "type":"string"
                },
                "w":{
                  "type":"int"
                }
              }
            },
            "summary":"Return a shortened version of a string.",
            "lineno":783,
            "args":"(s, w, tail)",
            "usage":["('1234567890'):shorten(8) == '12345...'\n","('1234567890'):shorten(8, true) == '...67890'\n","('1234567890'):shorten(20) == '1234567890'\n"],
            "section":"Miscelaneous",
            "name":"shorten",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"w",
              "map":{
                "tail":" true if we want to show the end of the string (head otherwise)",
                "s":" the string",
                "w":" the maxinum size allowed"
              },
              "3":"tail"
            },
            "tags":[],
            "kind":"miscelaneous ",
            "description":"\n Fits string within w characters. Removed characters are marked with ellipsis.",
            "type":"function"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[[]],
              "param":{
                "1":[],
                "s":[]
              }
            },
            "summary":"Quote the given string and preserve any control or escape characters, such that reloading the string in Lua returns the same result.",
            "lineno":822,
            "retgroups":[{
                "1":{
                  "text":"The quoted string.",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s)",
            "type":"function",
            "name":"quote_string",
            "parameter":"param",
            "params":{
              "map":{
                "s":" The string to be quoted."
              },
              "1":"s"
            },
            "tags":[],
            "kind":"miscelaneous ",
            "section":"Miscelaneous",
            "description":"",
            "ret":["The quoted string."]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":[],
              "usage":[[]]
            },
            "summary":"Python-style formatting operator.",
            "lineno":873,
            "args":"()",
            "usage":["require 'pl.text'.format_operator()\nlocal out1 = '%s = %5.3f' % {'PI',math.pi}                   --> 'PI = 3.142'\nlocal out2 = '$name = $value' % {name='dog',value='Pluto'}   --> 'dog = Pluto'\n"],
            "section":"Miscelaneous",
            "name":"format_operator",
            "parameter":"param",
            "params":{
              "map":[]
            },
            "tags":[],
            "kind":"miscelaneous ",
            "description":"\n Calling `text.format_operator()` overloads the % operator for strings to give\n Python/Ruby style formated output.\n This is extended to also do template-like substitution for map-like data.\n\n Note this goes further than the original, and will allow these cases:\n\n 1. a single value\n 2. a list of values\n 3. a map of var=value pairs\n 4. a function, as in gsub\n\n For the second two cases, it uses $-variable substituion.\n\n When called, this function will monkey-patch the global `string` metatable by\n adding a `__mod` method.\n\n See <a href=\"http://lua-users.org/wiki/StringInterpolation\">the lua-users wiki</a>\n",
            "type":"function"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "param":[],
              "return":[]
            },
            "summary":"import the stringx functions into the global string (meta)table",
            "lineno":913,
            "args":"()",
            "section":"Miscelaneous",
            "name":"import",
            "params":{
              "map":[]
            },
            "tags":[],
            "kind":"miscelaneous ",
            "description":"",
            "type":"function",
            "parameter":"param"
          }],
        "sections":[],
        "modules":["<reference cycle>"],
        "args":{
          "one":false,
          "module":false,
          "verbose":false,
          "style":"!",
          "template":"!",
          "date":"system",
          "dir":"doc",
          "quiet":false,
          "all":false,
          "ignore":false,
          "colon":false,
          "not_luadoc":false,
          "ext":"html",
          "boilerplate":false,
          "merge":false,
          "filter":"f.filter",
          "package":"/home/cji/portless/Penlight/lua",
          "dump":false,
          "no_args_infer":false,
          "title":"Reference",
          "project":"ldoc",
          "file":"/home/cji/portless/Penlight/lua/pl",
          "format":"discount",
          "simple":false,
          "tags":"none",
          "define":"none",
          "output":"index",
          "unqualified":false,
          "config":"config.ld",
          "fatalwarnings":false,
          "testing":false
        },
        "error":"<type 'function' is not supported by JSON.>",
        "lang":{
          "line_comment":"^%-%-+",
          "start_comment_":"^%-%-%-+",
          "end_comment_":"[^%-]%-%-+[^-]*\n$",
          "extra":[],
          "block_comment":"^%-%-%[=*%[%-+",
          "empty_comment_":"^%-%-%-+%s*$",
          "method_call":":"
        },
        "base":"/home/cji/portless/Penlight/lua"
      },
      "summary":"",
      "tags":[],
      "lineno":742,
      "display_name":"Miscelaneous",
      "type":"section",
      "modifiers":[]
    },
    "by_name":{
      "Template":{
        "name":"Template",
        "inferred":true,
        "description":"",
        "file":{
          "warning":"<type 'function' is not supported by JSON.>",
          "filename":"/home/cji/portless/Penlight/lua/pl/stringx.lua",
          "items":["<reference cycle>",{
              "name":"predicates",
              "inferred":true,
              "description":"",
              "file":"<reference cycle>",
              "summary":"",
              "tags":[],
              "lineno":53,
              "display_name":"String Predicates",
              "type":"section",
              "modifiers":[]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "s":{
                    "type":"string"
                  }
                }
              },
              "summary":"does s only contain alphabetic characters?",
              "lineno":55,
              "args":"(s)",
              "section":"String Predicates",
              "name":"isalpha",
              "params":{
                "map":{
                  "s":" a string"
                },
                "1":"s"
              },
              "tags":[],
              "kind":"string predicates ",
              "description":"",
              "type":"function",
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "s":{
                    "type":"string"
                  }
                }
              },
              "summary":"does s only contain digits?",
              "lineno":62,
              "args":"(s)",
              "section":"String Predicates",
              "name":"isdigit",
              "params":{
                "map":{
                  "s":" a string"
                },
                "1":"s"
              },
              "tags":[],
              "kind":"string predicates ",
              "description":"",
              "type":"function",
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "s":{
                    "type":"string"
                  }
                }
              },
              "summary":"does s only contain alphanumeric characters?",
              "lineno":69,
              "args":"(s)",
              "section":"String Predicates",
              "name":"isalnum",
              "params":{
                "map":{
                  "s":" a string"
                },
                "1":"s"
              },
              "tags":[],
              "kind":"string predicates ",
              "description":"",
              "type":"function",
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "s":{
                    "type":"string"
                  }
                }
              },
              "summary":"does s only contain whitespace?",
              "lineno":77,
              "args":"(s)",
              "section":"String Predicates",
              "name":"isspace",
              "params":{
                "map":{
                  "s":" a string"
                },
                "1":"s"
              },
              "tags":[],
              "kind":"string predicates ",
              "description":"\n Matches on pattern '%s' so matches space, newline, tabs, etc.",
              "type":"function",
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "s":{
                    "type":"string"
                  }
                }
              },
              "summary":"does s only contain lower case characters?",
              "lineno":84,
              "args":"(s)",
              "section":"String Predicates",
              "name":"islower",
              "params":{
                "map":{
                  "s":" a string"
                },
                "1":"s"
              },
              "tags":[],
              "kind":"string predicates ",
              "description":"",
              "type":"function",
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "s":{
                    "type":"string"
                  }
                }
              },
              "summary":"does s only contain upper case characters?",
              "lineno":91,
              "args":"(s)",
              "section":"String Predicates",
              "name":"isupper",
              "params":{
                "map":{
                  "s":" a string"
                },
                "1":"s"
              },
              "tags":[],
              "kind":"string predicates ",
              "description":"",
              "type":"function",
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":[],
                  "s":{
                    "type":"string"
                  },
                  "prefix":[]
                }
              },
              "summary":"does s start with prefix or one of prefixes?",
              "lineno":120,
              "args":"(s, prefix)",
              "section":"String Predicates",
              "name":"startswith",
              "params":{
                "1":"s",
                "2":"prefix",
                "map":{
                  "s":" a string",
                  "prefix":" a string or an array of strings"
                }
              },
              "tags":[],
              "kind":"string predicates ",
              "description":"",
              "type":"function",
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":[],
                  "s":{
                    "type":"string"
                  },
                  "suffix":[]
                }
              },
              "summary":"does s end with suffix or one of suffixes?",
              "lineno":128,
              "args":"(s, suffix)",
              "section":"String Predicates",
              "name":"endswith",
              "params":{
                "1":"s",
                "2":"suffix",
                "map":{
                  "s":" a string",
                  "suffix":" a string or an array of strings"
                }
              },
              "tags":[],
              "kind":"string predicates ",
              "description":"",
              "type":"function",
              "parameter":"param"
            },{
              "name":"lists",
              "inferred":true,
              "description":"",
              "file":"<reference cycle>",
              "summary":"",
              "tags":[],
              "lineno":136,
              "display_name":"Strings and Lists",
              "type":"section",
              "modifiers":[]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[]],
                "return":[],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":[],
                  "s":{
                    "type":"string"
                  },
                  "seq":[]
                }
              },
              "summary":"concatenate the strings using this string as a delimiter.",
              "lineno":141,
              "args":"(s, seq)",
              "usage":["stringx.join(' ', {1,2,3}) == '1 2 3'\n"],
              "section":"Strings and Lists",
              "name":"join",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"seq",
                "map":{
                  "s":" the string",
                  "seq":" a table of strings or numbers"
                }
              },
              "tags":[],
              "kind":"strings and lists ",
              "description":"\n Note that the arguments are reversed from `string.concat`.",
              "type":"function"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[[]],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "opt":true,
                    "type":"bool",
                    "optchain":true
                  },
                  "s":{
                    "type":"string"
                  },
                  "keep_ends":{
                    "opt":true,
                    "type":"bool",
                    "optchain":true
                  }
                }
              },
              "summary":"Split a string into a list of lines.",
              "lineno":154,
              "retgroups":[{
                  "1":{
                    "text":"List of lines",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s[, keep_ends])",
              "type":"function",
              "name":"splitlines",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"keep_ends",
                "map":{
                  "s":" the string.",
                  "keep_ends":" include line ends."
                }
              },
              "tags":[],
              "kind":"strings and lists ",
              "section":"Strings and Lists",
              "description":"\n `\"\\r\"`, `\"\\n\"`, and `\"\\r\\n\"` are considered line ends.\n They are not included in the lines unless `keepends` is passed.\n Terminal line end does not produce an extra line.\n Splitting an empty string results in an empty list.",
              "ret":["List of lines"]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[],[],[]],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "opt":true,
                    "type":"string",
                    "optchain":true
                  },
                  "3":{
                    "opt":true,
                    "type":"int",
                    "optchain":true
                  },
                  "re":{
                    "opt":true,
                    "type":"string",
                    "optchain":true
                  },
                  "n":{
                    "opt":true,
                    "type":"int",
                    "optchain":true
                  },
                  "s":{
                    "type":"string"
                  }
                },
                "return":[[]]
              },
              "summary":"split a string into a list of strings using a delimiter.",
              "lineno":193,
              "retgroups":[{
                  "1":{
                    "text":"List",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s[, re[, n]])",
              "usage":["#(stringx.split('one two')) == 2\n","stringx.split('one,two,three', ',') == List{'one','two','three'}\n","stringx.split('one,two,three', ',', 2) == List{'one','two,three'}\n"],
              "type":"function",
              "name":"split",
              "params":{
                "1":"s",
                "2":"re",
                "map":{
                  "re":" a delimiter (defaults to whitespace)",
                  "n":" maximum number of results",
                  "s":" the string"
                },
                "3":"n"
              },
              "tags":[],
              "kind":"strings and lists ",
              "section":"Strings and Lists",
              "description":"",
              "ret":["List"],
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[],[]],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "type":"int"
                  },
                  "s":{
                    "type":"string"
                  },
                  "tabsize":{
                    "type":"int"
                  }
                },
                "return":[[]]
              },
              "summary":"replace all tabs in s with tabsize spaces.",
              "lineno":216,
              "retgroups":[{
                  "1":{
                    "text":"expanded string",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s, tabsize)",
              "usage":["stringx.expandtabs('\\tone,two,three', 4)   == '    one,two,three'\n","stringx.expandtabs('  \\tone,two,three', 4) == '    one,two,three'\n"],
              "type":"function",
              "name":"expandtabs",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"tabsize",
                "map":{
                  "s":" the string",
                  "tabsize":"[opt=8] number of spaces to expand each tab"
                }
              },
              "tags":[],
              "kind":"strings and lists ",
              "section":"Strings and Lists",
              "description":" If not specified, tabsize defaults to 8.\n Tab stops will be honored.",
              "ret":["expanded string"]
            },{
              "name":"find",
              "inferred":true,
              "description":"",
              "file":"<reference cycle>",
              "summary":"",
              "tags":[],
              "lineno":231,
              "display_name":"Finding and Replacing",
              "type":"section",
              "modifiers":[]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[[]],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "type":"string"
                  },
                  "3":{
                    "opt":true,
                    "type":"int",
                    "optchain":true
                  },
                  "4":{
                    "opt":true,
                    "type":"int",
                    "optchain":true
                  },
                  "first":{
                    "opt":true,
                    "type":"int",
                    "optchain":true
                  },
                  "sub":{
                    "type":"string"
                  },
                  "s":{
                    "type":"string"
                  },
                  "last":{
                    "opt":true,
                    "type":"int",
                    "optchain":true
                  }
                }
              },
              "summary":"find index of first instance of sub in s from the left.",
              "lineno":257,
              "retgroups":[{
                  "1":{
                    "text":"start index, or nil if not found",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s, sub[, first[, last]])",
              "type":"function",
              "name":"lfind",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"sub",
                "3":"first",
                "4":"last",
                "map":{
                  "first":" first index",
                  "sub":" substring",
                  "s":" the string",
                  "last":" last index"
                }
              },
              "tags":[],
              "kind":"finding and replacing ",
              "section":"Finding and Replacing",
              "description":"",
              "ret":["start index, or nil if not found"]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[[]],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "type":"string"
                  },
                  "3":{
                    "opt":true,
                    "type":"int",
                    "optchain":true
                  },
                  "4":{
                    "opt":true,
                    "type":"int",
                    "optchain":true
                  },
                  "first":{
                    "opt":true,
                    "type":"int",
                    "optchain":true
                  },
                  "sub":{
                    "type":"string"
                  },
                  "s":{
                    "type":"string"
                  },
                  "last":{
                    "opt":true,
                    "type":"int",
                    "optchain":true
                  }
                }
              },
              "summary":"find index of first instance of sub in s from the right.",
              "lineno":275,
              "retgroups":[{
                  "1":{
                    "text":"start index, or nil if not found",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s, sub[, first[, last]])",
              "type":"function",
              "name":"rfind",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"sub",
                "3":"first",
                "4":"last",
                "map":{
                  "first":" first index",
                  "sub":" substring",
                  "s":" the string",
                  "last":" last index"
                }
              },
              "tags":[],
              "kind":"finding and replacing ",
              "section":"Finding and Replacing",
              "description":"",
              "ret":["start index, or nil if not found"]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[[]],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "type":"string"
                  },
                  "3":{
                    "type":"string"
                  },
                  "4":{
                    "opt":true,
                    "type":"int",
                    "optchain":true
                  },
                  "n":{
                    "opt":true,
                    "type":"int",
                    "optchain":true
                  },
                  "old":{
                    "type":"string"
                  },
                  "s":{
                    "type":"string"
                  },
                  "new":{
                    "type":"string"
                  }
                }
              },
              "summary":"replace up to n instances of old by new in the string s.",
              "lineno":288,
              "retgroups":[{
                  "1":{
                    "text":"result string",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s, old, new[, n])",
              "type":"function",
              "name":"replace",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"old",
                "3":"new",
                "4":"n",
                "map":{
                  "n":" optional maximum number of substitutions",
                  "old":" the target substring",
                  "s":" the string",
                  "new":" the substitution"
                }
              },
              "tags":[],
              "kind":"finding and replacing ",
              "section":"Finding and Replacing",
              "description":"\n If n is not present, replace all instances.",
              "ret":["result string"]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[]],
                "return":[],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "type":"string"
                  },
                  "3":{
                    "opt":true,
                    "type":"bool",
                    "optchain":true
                  },
                  "sub":{
                    "type":"string"
                  },
                  "s":{
                    "type":"string"
                  },
                  "allow_overlap":{
                    "opt":true,
                    "type":"bool",
                    "optchain":true
                  }
                }
              },
              "summary":"count all instances of substring in string.",
              "lineno":302,
              "args":"(s, sub[, allow_overlap])",
              "usage":["assert(stringx.count('banana', 'ana') == 1)\nassert(stringx.count('banana', 'ana', true) == 2)\n"],
              "section":"Finding and Replacing",
              "name":"count",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"sub",
                "map":{
                  "sub":" substring",
                  "s":" the string",
                  "allow_overlap":" allow matches to overlap"
                },
                "3":"allow_overlap"
              },
              "tags":[],
              "kind":"finding and replacing ",
              "description":"",
              "type":"function"
            },{
              "name":"strip",
              "inferred":true,
              "description":"",
              "file":"<reference cycle>",
              "summary":"",
              "tags":[],
              "lineno":311,
              "display_name":"Stripping and Justifying",
              "type":"section",
              "modifiers":[]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[]],
                "return":[],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "type":"int"
                  },
                  "3":{
                    "opt":"' '",
                    "type":"string",
                    "optchain":"' '"
                  },
                  "ch":{
                    "opt":"' '",
                    "type":"string",
                    "optchain":"' '"
                  },
                  "s":{
                    "type":"string"
                  },
                  "w":{
                    "type":"int"
                  }
                }
              },
              "summary":"left-justify s with width w.",
              "lineno":339,
              "args":"(s, w[, ch=' '])",
              "usage":["stringx.ljust('hello', 10, '*') == '*****hello'\n"],
              "section":"Stripping and Justifying",
              "name":"ljust",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"w",
                "map":{
                  "ch":" padding character",
                  "s":" the string",
                  "w":" width of justification"
                },
                "3":"ch"
              },
              "tags":[],
              "kind":"stripping and justifying ",
              "description":"",
              "type":"function"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[]],
                "return":[],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "type":"int"
                  },
                  "3":{
                    "opt":"' '",
                    "type":"string",
                    "optchain":"' '"
                  },
                  "ch":{
                    "opt":"' '",
                    "type":"string",
                    "optchain":"' '"
                  },
                  "s":{
                    "type":"string"
                  },
                  "w":{
                    "type":"int"
                  }
                }
              },
              "summary":"right-justify s with width w.",
              "lineno":350,
              "args":"(s, w[, ch=' '])",
              "usage":["stringx.rjust('hello', 10, '*') == 'hello*****'\n"],
              "section":"Stripping and Justifying",
              "name":"rjust",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"w",
                "map":{
                  "ch":" padding character",
                  "s":" the string",
                  "w":" width of justification"
                },
                "3":"ch"
              },
              "tags":[],
              "kind":"stripping and justifying ",
              "description":"",
              "type":"function"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[]],
                "return":[],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "type":"int"
                  },
                  "3":{
                    "opt":"' '",
                    "type":"string",
                    "optchain":"' '"
                  },
                  "ch":{
                    "opt":"' '",
                    "type":"string",
                    "optchain":"' '"
                  },
                  "s":{
                    "type":"string"
                  },
                  "w":{
                    "type":"int"
                  }
                }
              },
              "summary":"center-justify s with width w.",
              "lineno":361,
              "args":"(s, w[, ch=' '])",
              "usage":["stringx.center('hello', 10, '*') == '**hello***'\n"],
              "section":"Stripping and Justifying",
              "name":"center",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"w",
                "map":{
                  "ch":" padding character",
                  "s":" the string",
                  "w":" width of justification"
                },
                "3":"ch"
              },
              "tags":[],
              "kind":"stripping and justifying ",
              "description":"",
              "type":"function"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "opt":"'%s'",
                    "type":"string",
                    "optchain":"'%s'"
                  },
                  "s":{
                    "type":"string"
                  },
                  "chrs":{
                    "opt":"'%s'",
                    "type":"string",
                    "optchain":"'%s'"
                  }
                }
              },
              "summary":"trim any characters on the left of s.",
              "lineno":402,
              "args":"(s[, chrs='%s'])",
              "section":"Stripping and Justifying",
              "name":"lstrip",
              "params":{
                "1":"s",
                "2":"chrs",
                "map":{
                  "s":" the string",
                  "chrs":" default any whitespace character,\n but can be a string of characters to be trimmed"
                }
              },
              "tags":[],
              "kind":"stripping and justifying ",
              "description":"",
              "type":"function",
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "opt":"'%s'",
                    "type":"string",
                    "optchain":"'%s'"
                  },
                  "s":{
                    "type":"string"
                  },
                  "chrs":{
                    "opt":"'%s'",
                    "type":"string",
                    "optchain":"'%s'"
                  }
                }
              },
              "summary":"trim any characters on the right of s.",
              "lineno":412,
              "args":"(s[, chrs='%s'])",
              "section":"Stripping and Justifying",
              "name":"rstrip",
              "params":{
                "1":"s",
                "2":"chrs",
                "map":{
                  "s":" the string",
                  "chrs":" default any whitespace character,\n but can be a string of characters to be trimmed"
                }
              },
              "tags":[],
              "kind":"stripping and justifying ",
              "description":"",
              "type":"function",
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[]],
                "return":[],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "opt":"'%s'",
                    "type":"string",
                    "optchain":"'%s'"
                  },
                  "s":{
                    "type":"string"
                  },
                  "chrs":{
                    "opt":"'%s'",
                    "type":"string",
                    "optchain":"'%s'"
                  }
                }
              },
              "summary":"trim any characters on both left and right of s.",
              "lineno":422,
              "args":"(s[, chrs='%s'])",
              "usage":["stringx.strip('  --== Hello ==--  ', \"- =\")  --> 'Hello'\n"],
              "section":"Stripping and Justifying",
              "name":"strip",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"chrs",
                "map":{
                  "s":" the string",
                  "chrs":" default any whitespace character,\n but can be a string of characters to be trimmed"
                }
              },
              "tags":[],
              "kind":"stripping and justifying ",
              "description":"",
              "type":"function"
            },{
              "name":"partitioning",
              "inferred":true,
              "description":"",
              "file":"<reference cycle>",
              "summary":"",
              "tags":[],
              "lineno":430,
              "display_name":"Partitioning Strings",
              "type":"section",
              "modifiers":[]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "opt":"'%s'",
                    "type":"string",
                    "optchain":"'%s'"
                  },
                  "s":{
                    "type":"string"
                  },
                  "re":{
                    "opt":"'%s'",
                    "type":"string",
                    "optchain":"'%s'"
                  }
                },
                "return":[[]],
                "usage":[[]],
                "see":[[]]
              },
              "summary":"split a string using a pattern.",
              "lineno":436,
              "retgroups":[{
                  "1":{
                    "text":"the parts of the string",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s[, re='%s'])",
              "usage":["a,b = line:splitv('=')\n"],
              "type":"function",
              "name":"splitv",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"re",
                "map":{
                  "s":" the string",
                  "re":" a Lua string pattern (defaults to whitespace)"
                }
              },
              "tags":{
                "see":[]
              },
              "kind":"partitioning strings ",
              "section":"Partitioning Strings",
              "description":" Note that at least one value will be returned!",
              "ret":["the parts of the string"]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[],[]],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "type":"string"
                  },
                  "s":{
                    "type":"string"
                  },
                  "ch":{
                    "type":"string"
                  }
                },
                "return":[[],[],[]]
              },
              "summary":"partition the string using first occurance of a delimiter",
              "lineno":461,
              "retgroups":[{
                  "1":{
                    "text":"part before ch",
                    "type":"",
                    "mods":[]
                  },
                  "2":{
                    "text":"ch",
                    "type":"",
                    "mods":[]
                  },
                  "3":{
                    "text":"part after ch",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s, ch)",
              "usage":["{stringx.partition('a,b,c', ','))} == {'a', ',', 'b,c'}\n","{stringx.partition('abc', 'x'))} == {'abc', '', ''}\n"],
              "type":"function",
              "name":"partition",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"ch",
                "map":{
                  "s":" the string",
                  "ch":" delimiter (match as plain string, no patterns)"
                }
              },
              "tags":[],
              "kind":"partitioning strings ",
              "section":"Partitioning Strings",
              "description":"",
              "ret":["part before ch","ch","part after ch"]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[],[]],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "type":"string"
                  },
                  "s":{
                    "type":"string"
                  },
                  "ch":{
                    "type":"string"
                  }
                },
                "return":[[],[],[]]
              },
              "summary":"partition the string p using last occurance of a delimiter",
              "lineno":475,
              "retgroups":[{
                  "1":{
                    "text":"part before ch",
                    "type":"",
                    "mods":[]
                  },
                  "2":{
                    "text":"ch",
                    "type":"",
                    "mods":[]
                  },
                  "3":{
                    "text":"part after ch",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s, ch)",
              "usage":["{stringx.rpartition('a,b,c', ','))} == {'a,b', ',', 'c'}\n","{stringx.rpartition('abc', 'x'))} == {'', '', 'abc'}\n"],
              "type":"function",
              "name":"rpartition",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"ch",
                "map":{
                  "s":" the string",
                  "ch":" delimiter (match as plain string, no patterns)"
                }
              },
              "tags":[],
              "kind":"partitioning strings ",
              "section":"Partitioning Strings",
              "description":"",
              "ret":["part before ch","ch","part after ch"]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[[]],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "type":"int"
                  },
                  "s":{
                    "type":"string"
                  },
                  "idx":{
                    "type":"int"
                  }
                }
              },
              "summary":"return the 'character' at the index.",
              "lineno":489,
              "retgroups":[{
                  "1":{
                    "text":"a substring of length 1 if successful, empty string otherwise.",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s, idx)",
              "type":"function",
              "name":"at",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"idx",
                "map":{
                  "s":" the string",
                  "idx":" an index (can be negative)"
                }
              },
              "tags":[],
              "kind":"partitioning strings ",
              "section":"Partitioning Strings",
              "description":"",
              "ret":["a substring of length 1 if successful, empty string otherwise."]
            },{
              "name":"text",
              "inferred":true,
              "description":"",
              "file":"<reference cycle>",
              "summary":"",
              "tags":[],
              "lineno":500,
              "display_name":"Text handling",
              "type":"section",
              "modifiers":[]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[[]],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "type":"integer"
                  },
                  "3":{
                    "opt":"' '",
                    "type":"string",
                    "optchain":"' '"
                  },
                  "ch":{
                    "opt":"' '",
                    "type":"string",
                    "optchain":"' '"
                  },
                  "n":{
                    "type":"integer"
                  },
                  "s":{
                    "type":"string"
                  }
                }
              },
              "summary":"indent a multiline string.",
              "lineno":505,
              "retgroups":[{
                  "1":{
                    "text":"indented string",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s, n[, ch=' '])",
              "type":"function",
              "name":"indent",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"n",
                "map":{
                  "ch":" the character to use when indenting",
                  "n":" the size of the indent",
                  "s":" the (multiline) string"
                },
                "3":"ch"
              },
              "tags":[],
              "kind":"text handling ",
              "section":"Text handling",
              "description":"",
              "ret":["indented string"]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[]],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "s":{
                    "type":"string"
                  }
                },
                "return":[[]]
              },
              "summary":"dedent a multiline string by removing any initial indent.",
              "lineno":537,
              "retgroups":[{
                  "1":{
                    "text":"a string with initial indent zero.",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s)",
              "usage":["local s = dedent [[\n         One\n\n       Two\n\n     Three\n]]\nassert(s == [[\n    One\n\n  Two\n\nThree\n]])\n"],
              "type":"function",
              "name":"dedent",
              "parameter":"param",
              "params":{
                "map":{
                  "s":" the (multiline) string"
                },
                "1":"s"
              },
              "tags":[],
              "kind":"text handling ",
              "section":"Text handling",
              "description":"\n useful when working with [[..]] strings.\n Empty lines are ignored.",
              "ret":["a string with initial indent zero."]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "opt":"70",
                    "type":"integer",
                    "optchain":"70"
                  },
                  "3":{
                    "opt":"false",
                    "type":"boolean",
                    "optchain":"false"
                  },
                  "width":{
                    "opt":"70",
                    "type":"integer",
                    "optchain":"70"
                  },
                  "s":{
                    "type":"string"
                  },
                  "breaklong":{
                    "opt":"false",
                    "type":"boolean",
                    "optchain":"false"
                  }
                },
                "return":[[]],
                "see":[[],[]]
              },
              "summary":"format a paragraph into lines so that they fit into a line width.",
              "lineno":594,
              "retgroups":[{
                  "1":{
                    "text":"a list of lines (List object), use `fill` to return a string instead of a `List`.",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s[, width=70[, breaklong=false]])",
              "type":"function",
              "name":"wrap",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"width",
                "map":{
                  "width":" the margin width",
                  "s":" the string to format",
                  "breaklong":" if truthy, words longer than the width given will be forced split."
                },
                "3":"breaklong"
              },
              "tags":{
                "see":[]
              },
              "kind":"text handling ",
              "section":"Text handling",
              "description":"\n It will not break long words by default, so lines can be over the length\n to that extent.",
              "ret":["a list of lines (List object), use `fill` to return a string instead of a `List`."]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "opt":"70",
                    "type":"integer",
                    "optchain":"70"
                  },
                  "3":{
                    "opt":"false",
                    "type":"boolean",
                    "optchain":"false"
                  },
                  "width":{
                    "opt":"70",
                    "type":"integer",
                    "optchain":"70"
                  },
                  "s":{
                    "type":"string"
                  },
                  "breaklong":{
                    "opt":"false",
                    "type":"boolean",
                    "optchain":"false"
                  }
                },
                "return":[[]],
                "see":[[]]
              },
              "summary":"format a paragraph so that it fits into a line width.",
              "lineno":616,
              "retgroups":[{
                  "1":{
                    "text":"a string, use `wrap` to return a list of lines instead of a string.",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s[, width=70[, breaklong=false]])",
              "type":"function",
              "name":"fill",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"width",
                "map":{
                  "width":" the margin width",
                  "s":" the string to format",
                  "breaklong":" if truthy, words longer than the width given will be forced split."
                },
                "3":"breaklong"
              },
              "tags":{
                "see":[]
              },
              "kind":"text handling ",
              "section":"Text handling",
              "description":"",
              "ret":["a string, use `wrap` to return a list of lines instead of a string."]
            },"<reference cycle>",{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "tmpl":{
                    "type":"string"
                  }
                },
                "return":[{
                    "type":"Template"
                  }]
              },
              "summary":"Creates a new Template class.",
              "lineno":662,
              "retgroups":[{
                  "1":{
                    "text":"",
                    "type":"Template",
                    "mods":{
                      "type":"Template"
                    }
                  },
                  "g":0
                }],
              "args":"(tmpl)",
              "section":"Template",
              "name":"Template",
              "params":{
                "map":{
                  "tmpl":" the template string"
                },
                "1":"tmpl"
              },
              "tags":[],
              "kind":"template ",
              "description":"\n This is a shortcut to `Template.new(tmpl)`.",
              "type":"function",
              "ret":[""],
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[[]],
                "param":{
                  "1":{
                    "type":"table"
                  },
                  "tbl":{
                    "type":"table"
                  }
                }
              },
              "summary":"substitute values into a template, throwing an error.",
              "lineno":674,
              "retgroups":[{
                  "1":{
                    "text":"string with place holders substituted",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(tbl)",
              "type":"function",
              "name":"Template:substitute",
              "parameter":"param",
              "params":{
                "map":{
                  "tbl":" a table of name-value pairs."
                },
                "1":"tbl"
              },
              "tags":[],
              "kind":"template ",
              "section":"Template",
              "description":"\n This will throw an error if no name is found.",
              "ret":["string with place holders substituted"]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[[]],
                "param":{
                  "1":{
                    "type":"table"
                  },
                  "tbl":{
                    "type":"table"
                  }
                }
              },
              "summary":"substitute values into a template.",
              "lineno":683,
              "retgroups":[{
                  "1":{
                    "text":"string with place holders substituted",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(tbl)",
              "type":"function",
              "name":"Template:safe_substitute",
              "parameter":"param",
              "params":{
                "map":{
                  "tbl":" a table of name-value pairs."
                },
                "1":"tbl"
              },
              "tags":[],
              "kind":"template ",
              "section":"Template",
              "description":"\n This version just passes unknown names through.",
              "ret":["string with place holders substituted"]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[[]],
                "param":{
                  "1":{
                    "type":"table"
                  },
                  "tbl":{
                    "type":"table"
                  }
                }
              },
              "summary":"substitute values into a template, preserving indentation.",
              "lineno":695,
              "retgroups":[{
                  "1":{
                    "text":"string with place holders substituted",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(tbl)",
              "type":"function",
              "name":"Template:indent_substitute",
              "parameter":"param",
              "params":{
                "map":{
                  "tbl":" a table of name-value pairs."
                },
                "1":"tbl"
              },
              "tags":[],
              "kind":"template ",
              "section":"Template",
              "description":" <br>\n If the value is a multiline string _or_ a template, it will insert\n the lines at the correct indentation. <br>\n Furthermore, if a template, then that template will be substituted\n using the same table.",
              "ret":["string with place holders substituted"]
            },{
              "name":"misc",
              "inferred":true,
              "description":"",
              "file":"<reference cycle>",
              "summary":"",
              "tags":[],
              "lineno":742,
              "display_name":"Miscelaneous",
              "type":"section",
              "modifiers":[]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[]],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "s":{
                    "type":"string"
                  }
                },
                "return":[[]]
              },
              "summary":"return an iterator over all lines in a string",
              "lineno":751,
              "retgroups":[{
                  "1":{
                    "text":"an iterator",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s)",
              "usage":["local line_no = 1\nfor line in stringx.lines(some_text) do\n  print(line_no, line)\n  line_no = line_no + 1\nend\n"],
              "type":"function",
              "name":"lines",
              "parameter":"param",
              "params":{
                "map":{
                  "s":" the string"
                },
                "1":"s"
              },
              "tags":[],
              "kind":"miscelaneous ",
              "section":"Miscelaneous",
              "description":"",
              "ret":["an iterator"]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[]],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "s":{
                    "type":"string"
                  }
                },
                "return":[[]]
              },
              "summary":"inital word letters uppercase ('title case').",
              "lineno":762,
              "retgroups":[{
                  "1":{
                    "text":"a string with each word's first letter uppercase",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s)",
              "usage":["stringx.title(\"hello world\") == \"Hello World\")\n"],
              "type":"function",
              "name":"title",
              "parameter":"param",
              "params":{
                "map":{
                  "s":" the string"
                },
                "1":"s"
              },
              "tags":[],
              "kind":"miscelaneous ",
              "section":"Miscelaneous",
              "description":"\n Here 'words' mean chunks of non-space characters.",
              "ret":["a string with each word's first letter uppercase"]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[],[],[]],
                "return":[],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "type":"int"
                  },
                  "3":{
                    "type":"bool"
                  },
                  "tail":{
                    "type":"bool"
                  },
                  "s":{
                    "type":"string"
                  },
                  "w":{
                    "type":"int"
                  }
                }
              },
              "summary":"Return a shortened version of a string.",
              "lineno":783,
              "args":"(s, w, tail)",
              "usage":["('1234567890'):shorten(8) == '12345...'\n","('1234567890'):shorten(8, true) == '...67890'\n","('1234567890'):shorten(20) == '1234567890'\n"],
              "section":"Miscelaneous",
              "name":"shorten",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"w",
                "map":{
                  "tail":" true if we want to show the end of the string (head otherwise)",
                  "s":" the string",
                  "w":" the maxinum size allowed"
                },
                "3":"tail"
              },
              "tags":[],
              "kind":"miscelaneous ",
              "description":"\n Fits string within w characters. Removed characters are marked with ellipsis.",
              "type":"function"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[[]],
                "param":{
                  "1":[],
                  "s":[]
                }
              },
              "summary":"Quote the given string and preserve any control or escape characters, such that reloading the string in Lua returns the same result.",
              "lineno":822,
              "retgroups":[{
                  "1":{
                    "text":"The quoted string.",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s)",
              "type":"function",
              "name":"quote_string",
              "parameter":"param",
              "params":{
                "map":{
                  "s":" The string to be quoted."
                },
                "1":"s"
              },
              "tags":[],
              "kind":"miscelaneous ",
              "section":"Miscelaneous",
              "description":"",
              "ret":["The quoted string."]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":[],
                "usage":[[]]
              },
              "summary":"Python-style formatting operator.",
              "lineno":873,
              "args":"()",
              "usage":["require 'pl.text'.format_operator()\nlocal out1 = '%s = %5.3f' % {'PI',math.pi}                   --> 'PI = 3.142'\nlocal out2 = '$name = $value' % {name='dog',value='Pluto'}   --> 'dog = Pluto'\n"],
              "section":"Miscelaneous",
              "name":"format_operator",
              "parameter":"param",
              "params":{
                "map":[]
              },
              "tags":[],
              "kind":"miscelaneous ",
              "description":"\n Calling `text.format_operator()` overloads the % operator for strings to give\n Python/Ruby style formated output.\n This is extended to also do template-like substitution for map-like data.\n\n Note this goes further than the original, and will allow these cases:\n\n 1. a single value\n 2. a list of values\n 3. a map of var=value pairs\n 4. a function, as in gsub\n\n For the second two cases, it uses $-variable substituion.\n\n When called, this function will monkey-patch the global `string` metatable by\n adding a `__mod` method.\n\n See <a href=\"http://lua-users.org/wiki/StringInterpolation\">the lua-users wiki</a>\n",
              "type":"function"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "param":[],
                "return":[]
              },
              "summary":"import the stringx functions into the global string (meta)table",
              "lineno":913,
              "args":"()",
              "section":"Miscelaneous",
              "name":"import",
              "params":{
                "map":[]
              },
              "tags":[],
              "kind":"miscelaneous ",
              "description":"",
              "type":"function",
              "parameter":"param"
            }],
          "sections":[],
          "modules":["<reference cycle>"],
          "args":{
            "one":false,
            "module":false,
            "verbose":false,
            "style":"!",
            "template":"!",
            "date":"system",
            "dir":"doc",
            "quiet":false,
            "all":false,
            "ignore":false,
            "colon":false,
            "not_luadoc":false,
            "ext":"html",
            "boilerplate":false,
            "merge":false,
            "filter":"f.filter",
            "package":"/home/cji/portless/Penlight/lua",
            "dump":false,
            "no_args_infer":false,
            "title":"Reference",
            "project":"ldoc",
            "file":"/home/cji/portless/Penlight/lua/pl",
            "format":"discount",
            "simple":false,
            "tags":"none",
            "define":"none",
            "output":"index",
            "unqualified":false,
            "config":"config.ld",
            "fatalwarnings":false,
            "testing":false
          },
          "error":"<type 'function' is not supported by JSON.>",
          "lang":{
            "line_comment":"^%-%-+",
            "start_comment_":"^%-%-%-+",
            "end_comment_":"[^%-]%-%-+[^-]*\n$",
            "extra":[],
            "block_comment":"^%-%-%[=*%[%-+",
            "empty_comment_":"^%-%-%-+%s*$",
            "method_call":":"
          },
          "base":"/home/cji/portless/Penlight/lua"
        },
        "summary":"",
        "tags":[],
        "lineno":624,
        "display_name":"Template",
        "type":"section",
        "modifiers":[]
      },
      "Stripping_and_Justifying":{
        "name":"strip",
        "inferred":true,
        "description":"",
        "file":{
          "warning":"<type 'function' is not supported by JSON.>",
          "filename":"/home/cji/portless/Penlight/lua/pl/stringx.lua",
          "items":["<reference cycle>",{
              "name":"predicates",
              "inferred":true,
              "description":"",
              "file":"<reference cycle>",
              "summary":"",
              "tags":[],
              "lineno":53,
              "display_name":"String Predicates",
              "type":"section",
              "modifiers":[]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "s":{
                    "type":"string"
                  }
                }
              },
              "summary":"does s only contain alphabetic characters?",
              "lineno":55,
              "args":"(s)",
              "section":"String Predicates",
              "name":"isalpha",
              "params":{
                "map":{
                  "s":" a string"
                },
                "1":"s"
              },
              "tags":[],
              "kind":"string predicates ",
              "description":"",
              "type":"function",
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "s":{
                    "type":"string"
                  }
                }
              },
              "summary":"does s only contain digits?",
              "lineno":62,
              "args":"(s)",
              "section":"String Predicates",
              "name":"isdigit",
              "params":{
                "map":{
                  "s":" a string"
                },
                "1":"s"
              },
              "tags":[],
              "kind":"string predicates ",
              "description":"",
              "type":"function",
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "s":{
                    "type":"string"
                  }
                }
              },
              "summary":"does s only contain alphanumeric characters?",
              "lineno":69,
              "args":"(s)",
              "section":"String Predicates",
              "name":"isalnum",
              "params":{
                "map":{
                  "s":" a string"
                },
                "1":"s"
              },
              "tags":[],
              "kind":"string predicates ",
              "description":"",
              "type":"function",
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "s":{
                    "type":"string"
                  }
                }
              },
              "summary":"does s only contain whitespace?",
              "lineno":77,
              "args":"(s)",
              "section":"String Predicates",
              "name":"isspace",
              "params":{
                "map":{
                  "s":" a string"
                },
                "1":"s"
              },
              "tags":[],
              "kind":"string predicates ",
              "description":"\n Matches on pattern '%s' so matches space, newline, tabs, etc.",
              "type":"function",
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "s":{
                    "type":"string"
                  }
                }
              },
              "summary":"does s only contain lower case characters?",
              "lineno":84,
              "args":"(s)",
              "section":"String Predicates",
              "name":"islower",
              "params":{
                "map":{
                  "s":" a string"
                },
                "1":"s"
              },
              "tags":[],
              "kind":"string predicates ",
              "description":"",
              "type":"function",
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "s":{
                    "type":"string"
                  }
                }
              },
              "summary":"does s only contain upper case characters?",
              "lineno":91,
              "args":"(s)",
              "section":"String Predicates",
              "name":"isupper",
              "params":{
                "map":{
                  "s":" a string"
                },
                "1":"s"
              },
              "tags":[],
              "kind":"string predicates ",
              "description":"",
              "type":"function",
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":[],
                  "s":{
                    "type":"string"
                  },
                  "prefix":[]
                }
              },
              "summary":"does s start with prefix or one of prefixes?",
              "lineno":120,
              "args":"(s, prefix)",
              "section":"String Predicates",
              "name":"startswith",
              "params":{
                "1":"s",
                "2":"prefix",
                "map":{
                  "s":" a string",
                  "prefix":" a string or an array of strings"
                }
              },
              "tags":[],
              "kind":"string predicates ",
              "description":"",
              "type":"function",
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":[],
                  "s":{
                    "type":"string"
                  },
                  "suffix":[]
                }
              },
              "summary":"does s end with suffix or one of suffixes?",
              "lineno":128,
              "args":"(s, suffix)",
              "section":"String Predicates",
              "name":"endswith",
              "params":{
                "1":"s",
                "2":"suffix",
                "map":{
                  "s":" a string",
                  "suffix":" a string or an array of strings"
                }
              },
              "tags":[],
              "kind":"string predicates ",
              "description":"",
              "type":"function",
              "parameter":"param"
            },{
              "name":"lists",
              "inferred":true,
              "description":"",
              "file":"<reference cycle>",
              "summary":"",
              "tags":[],
              "lineno":136,
              "display_name":"Strings and Lists",
              "type":"section",
              "modifiers":[]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[]],
                "return":[],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":[],
                  "s":{
                    "type":"string"
                  },
                  "seq":[]
                }
              },
              "summary":"concatenate the strings using this string as a delimiter.",
              "lineno":141,
              "args":"(s, seq)",
              "usage":["stringx.join(' ', {1,2,3}) == '1 2 3'\n"],
              "section":"Strings and Lists",
              "name":"join",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"seq",
                "map":{
                  "s":" the string",
                  "seq":" a table of strings or numbers"
                }
              },
              "tags":[],
              "kind":"strings and lists ",
              "description":"\n Note that the arguments are reversed from `string.concat`.",
              "type":"function"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[[]],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "opt":true,
                    "type":"bool",
                    "optchain":true
                  },
                  "s":{
                    "type":"string"
                  },
                  "keep_ends":{
                    "opt":true,
                    "type":"bool",
                    "optchain":true
                  }
                }
              },
              "summary":"Split a string into a list of lines.",
              "lineno":154,
              "retgroups":[{
                  "1":{
                    "text":"List of lines",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s[, keep_ends])",
              "type":"function",
              "name":"splitlines",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"keep_ends",
                "map":{
                  "s":" the string.",
                  "keep_ends":" include line ends."
                }
              },
              "tags":[],
              "kind":"strings and lists ",
              "section":"Strings and Lists",
              "description":"\n `\"\\r\"`, `\"\\n\"`, and `\"\\r\\n\"` are considered line ends.\n They are not included in the lines unless `keepends` is passed.\n Terminal line end does not produce an extra line.\n Splitting an empty string results in an empty list.",
              "ret":["List of lines"]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[],[],[]],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "opt":true,
                    "type":"string",
                    "optchain":true
                  },
                  "3":{
                    "opt":true,
                    "type":"int",
                    "optchain":true
                  },
                  "re":{
                    "opt":true,
                    "type":"string",
                    "optchain":true
                  },
                  "n":{
                    "opt":true,
                    "type":"int",
                    "optchain":true
                  },
                  "s":{
                    "type":"string"
                  }
                },
                "return":[[]]
              },
              "summary":"split a string into a list of strings using a delimiter.",
              "lineno":193,
              "retgroups":[{
                  "1":{
                    "text":"List",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s[, re[, n]])",
              "usage":["#(stringx.split('one two')) == 2\n","stringx.split('one,two,three', ',') == List{'one','two','three'}\n","stringx.split('one,two,three', ',', 2) == List{'one','two,three'}\n"],
              "type":"function",
              "name":"split",
              "params":{
                "1":"s",
                "2":"re",
                "map":{
                  "re":" a delimiter (defaults to whitespace)",
                  "n":" maximum number of results",
                  "s":" the string"
                },
                "3":"n"
              },
              "tags":[],
              "kind":"strings and lists ",
              "section":"Strings and Lists",
              "description":"",
              "ret":["List"],
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[],[]],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "type":"int"
                  },
                  "s":{
                    "type":"string"
                  },
                  "tabsize":{
                    "type":"int"
                  }
                },
                "return":[[]]
              },
              "summary":"replace all tabs in s with tabsize spaces.",
              "lineno":216,
              "retgroups":[{
                  "1":{
                    "text":"expanded string",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s, tabsize)",
              "usage":["stringx.expandtabs('\\tone,two,three', 4)   == '    one,two,three'\n","stringx.expandtabs('  \\tone,two,three', 4) == '    one,two,three'\n"],
              "type":"function",
              "name":"expandtabs",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"tabsize",
                "map":{
                  "s":" the string",
                  "tabsize":"[opt=8] number of spaces to expand each tab"
                }
              },
              "tags":[],
              "kind":"strings and lists ",
              "section":"Strings and Lists",
              "description":" If not specified, tabsize defaults to 8.\n Tab stops will be honored.",
              "ret":["expanded string"]
            },{
              "name":"find",
              "inferred":true,
              "description":"",
              "file":"<reference cycle>",
              "summary":"",
              "tags":[],
              "lineno":231,
              "display_name":"Finding and Replacing",
              "type":"section",
              "modifiers":[]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[[]],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "type":"string"
                  },
                  "3":{
                    "opt":true,
                    "type":"int",
                    "optchain":true
                  },
                  "4":{
                    "opt":true,
                    "type":"int",
                    "optchain":true
                  },
                  "first":{
                    "opt":true,
                    "type":"int",
                    "optchain":true
                  },
                  "sub":{
                    "type":"string"
                  },
                  "s":{
                    "type":"string"
                  },
                  "last":{
                    "opt":true,
                    "type":"int",
                    "optchain":true
                  }
                }
              },
              "summary":"find index of first instance of sub in s from the left.",
              "lineno":257,
              "retgroups":[{
                  "1":{
                    "text":"start index, or nil if not found",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s, sub[, first[, last]])",
              "type":"function",
              "name":"lfind",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"sub",
                "3":"first",
                "4":"last",
                "map":{
                  "first":" first index",
                  "sub":" substring",
                  "s":" the string",
                  "last":" last index"
                }
              },
              "tags":[],
              "kind":"finding and replacing ",
              "section":"Finding and Replacing",
              "description":"",
              "ret":["start index, or nil if not found"]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[[]],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "type":"string"
                  },
                  "3":{
                    "opt":true,
                    "type":"int",
                    "optchain":true
                  },
                  "4":{
                    "opt":true,
                    "type":"int",
                    "optchain":true
                  },
                  "first":{
                    "opt":true,
                    "type":"int",
                    "optchain":true
                  },
                  "sub":{
                    "type":"string"
                  },
                  "s":{
                    "type":"string"
                  },
                  "last":{
                    "opt":true,
                    "type":"int",
                    "optchain":true
                  }
                }
              },
              "summary":"find index of first instance of sub in s from the right.",
              "lineno":275,
              "retgroups":[{
                  "1":{
                    "text":"start index, or nil if not found",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s, sub[, first[, last]])",
              "type":"function",
              "name":"rfind",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"sub",
                "3":"first",
                "4":"last",
                "map":{
                  "first":" first index",
                  "sub":" substring",
                  "s":" the string",
                  "last":" last index"
                }
              },
              "tags":[],
              "kind":"finding and replacing ",
              "section":"Finding and Replacing",
              "description":"",
              "ret":["start index, or nil if not found"]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[[]],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "type":"string"
                  },
                  "3":{
                    "type":"string"
                  },
                  "4":{
                    "opt":true,
                    "type":"int",
                    "optchain":true
                  },
                  "n":{
                    "opt":true,
                    "type":"int",
                    "optchain":true
                  },
                  "old":{
                    "type":"string"
                  },
                  "s":{
                    "type":"string"
                  },
                  "new":{
                    "type":"string"
                  }
                }
              },
              "summary":"replace up to n instances of old by new in the string s.",
              "lineno":288,
              "retgroups":[{
                  "1":{
                    "text":"result string",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s, old, new[, n])",
              "type":"function",
              "name":"replace",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"old",
                "3":"new",
                "4":"n",
                "map":{
                  "n":" optional maximum number of substitutions",
                  "old":" the target substring",
                  "s":" the string",
                  "new":" the substitution"
                }
              },
              "tags":[],
              "kind":"finding and replacing ",
              "section":"Finding and Replacing",
              "description":"\n If n is not present, replace all instances.",
              "ret":["result string"]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[]],
                "return":[],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "type":"string"
                  },
                  "3":{
                    "opt":true,
                    "type":"bool",
                    "optchain":true
                  },
                  "sub":{
                    "type":"string"
                  },
                  "s":{
                    "type":"string"
                  },
                  "allow_overlap":{
                    "opt":true,
                    "type":"bool",
                    "optchain":true
                  }
                }
              },
              "summary":"count all instances of substring in string.",
              "lineno":302,
              "args":"(s, sub[, allow_overlap])",
              "usage":["assert(stringx.count('banana', 'ana') == 1)\nassert(stringx.count('banana', 'ana', true) == 2)\n"],
              "section":"Finding and Replacing",
              "name":"count",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"sub",
                "map":{
                  "sub":" substring",
                  "s":" the string",
                  "allow_overlap":" allow matches to overlap"
                },
                "3":"allow_overlap"
              },
              "tags":[],
              "kind":"finding and replacing ",
              "description":"",
              "type":"function"
            },"<reference cycle>",{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[]],
                "return":[],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "type":"int"
                  },
                  "3":{
                    "opt":"' '",
                    "type":"string",
                    "optchain":"' '"
                  },
                  "ch":{
                    "opt":"' '",
                    "type":"string",
                    "optchain":"' '"
                  },
                  "s":{
                    "type":"string"
                  },
                  "w":{
                    "type":"int"
                  }
                }
              },
              "summary":"left-justify s with width w.",
              "lineno":339,
              "args":"(s, w[, ch=' '])",
              "usage":["stringx.ljust('hello', 10, '*') == '*****hello'\n"],
              "section":"Stripping and Justifying",
              "name":"ljust",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"w",
                "map":{
                  "ch":" padding character",
                  "s":" the string",
                  "w":" width of justification"
                },
                "3":"ch"
              },
              "tags":[],
              "kind":"stripping and justifying ",
              "description":"",
              "type":"function"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[]],
                "return":[],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "type":"int"
                  },
                  "3":{
                    "opt":"' '",
                    "type":"string",
                    "optchain":"' '"
                  },
                  "ch":{
                    "opt":"' '",
                    "type":"string",
                    "optchain":"' '"
                  },
                  "s":{
                    "type":"string"
                  },
                  "w":{
                    "type":"int"
                  }
                }
              },
              "summary":"right-justify s with width w.",
              "lineno":350,
              "args":"(s, w[, ch=' '])",
              "usage":["stringx.rjust('hello', 10, '*') == 'hello*****'\n"],
              "section":"Stripping and Justifying",
              "name":"rjust",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"w",
                "map":{
                  "ch":" padding character",
                  "s":" the string",
                  "w":" width of justification"
                },
                "3":"ch"
              },
              "tags":[],
              "kind":"stripping and justifying ",
              "description":"",
              "type":"function"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[]],
                "return":[],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "type":"int"
                  },
                  "3":{
                    "opt":"' '",
                    "type":"string",
                    "optchain":"' '"
                  },
                  "ch":{
                    "opt":"' '",
                    "type":"string",
                    "optchain":"' '"
                  },
                  "s":{
                    "type":"string"
                  },
                  "w":{
                    "type":"int"
                  }
                }
              },
              "summary":"center-justify s with width w.",
              "lineno":361,
              "args":"(s, w[, ch=' '])",
              "usage":["stringx.center('hello', 10, '*') == '**hello***'\n"],
              "section":"Stripping and Justifying",
              "name":"center",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"w",
                "map":{
                  "ch":" padding character",
                  "s":" the string",
                  "w":" width of justification"
                },
                "3":"ch"
              },
              "tags":[],
              "kind":"stripping and justifying ",
              "description":"",
              "type":"function"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "opt":"'%s'",
                    "type":"string",
                    "optchain":"'%s'"
                  },
                  "s":{
                    "type":"string"
                  },
                  "chrs":{
                    "opt":"'%s'",
                    "type":"string",
                    "optchain":"'%s'"
                  }
                }
              },
              "summary":"trim any characters on the left of s.",
              "lineno":402,
              "args":"(s[, chrs='%s'])",
              "section":"Stripping and Justifying",
              "name":"lstrip",
              "params":{
                "1":"s",
                "2":"chrs",
                "map":{
                  "s":" the string",
                  "chrs":" default any whitespace character,\n but can be a string of characters to be trimmed"
                }
              },
              "tags":[],
              "kind":"stripping and justifying ",
              "description":"",
              "type":"function",
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "opt":"'%s'",
                    "type":"string",
                    "optchain":"'%s'"
                  },
                  "s":{
                    "type":"string"
                  },
                  "chrs":{
                    "opt":"'%s'",
                    "type":"string",
                    "optchain":"'%s'"
                  }
                }
              },
              "summary":"trim any characters on the right of s.",
              "lineno":412,
              "args":"(s[, chrs='%s'])",
              "section":"Stripping and Justifying",
              "name":"rstrip",
              "params":{
                "1":"s",
                "2":"chrs",
                "map":{
                  "s":" the string",
                  "chrs":" default any whitespace character,\n but can be a string of characters to be trimmed"
                }
              },
              "tags":[],
              "kind":"stripping and justifying ",
              "description":"",
              "type":"function",
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[]],
                "return":[],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "opt":"'%s'",
                    "type":"string",
                    "optchain":"'%s'"
                  },
                  "s":{
                    "type":"string"
                  },
                  "chrs":{
                    "opt":"'%s'",
                    "type":"string",
                    "optchain":"'%s'"
                  }
                }
              },
              "summary":"trim any characters on both left and right of s.",
              "lineno":422,
              "args":"(s[, chrs='%s'])",
              "usage":["stringx.strip('  --== Hello ==--  ', \"- =\")  --> 'Hello'\n"],
              "section":"Stripping and Justifying",
              "name":"strip",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"chrs",
                "map":{
                  "s":" the string",
                  "chrs":" default any whitespace character,\n but can be a string of characters to be trimmed"
                }
              },
              "tags":[],
              "kind":"stripping and justifying ",
              "description":"",
              "type":"function"
            },{
              "name":"partitioning",
              "inferred":true,
              "description":"",
              "file":"<reference cycle>",
              "summary":"",
              "tags":[],
              "lineno":430,
              "display_name":"Partitioning Strings",
              "type":"section",
              "modifiers":[]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "opt":"'%s'",
                    "type":"string",
                    "optchain":"'%s'"
                  },
                  "s":{
                    "type":"string"
                  },
                  "re":{
                    "opt":"'%s'",
                    "type":"string",
                    "optchain":"'%s'"
                  }
                },
                "return":[[]],
                "usage":[[]],
                "see":[[]]
              },
              "summary":"split a string using a pattern.",
              "lineno":436,
              "retgroups":[{
                  "1":{
                    "text":"the parts of the string",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s[, re='%s'])",
              "usage":["a,b = line:splitv('=')\n"],
              "type":"function",
              "name":"splitv",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"re",
                "map":{
                  "s":" the string",
                  "re":" a Lua string pattern (defaults to whitespace)"
                }
              },
              "tags":{
                "see":[]
              },
              "kind":"partitioning strings ",
              "section":"Partitioning Strings",
              "description":" Note that at least one value will be returned!",
              "ret":["the parts of the string"]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[],[]],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "type":"string"
                  },
                  "s":{
                    "type":"string"
                  },
                  "ch":{
                    "type":"string"
                  }
                },
                "return":[[],[],[]]
              },
              "summary":"partition the string using first occurance of a delimiter",
              "lineno":461,
              "retgroups":[{
                  "1":{
                    "text":"part before ch",
                    "type":"",
                    "mods":[]
                  },
                  "2":{
                    "text":"ch",
                    "type":"",
                    "mods":[]
                  },
                  "3":{
                    "text":"part after ch",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s, ch)",
              "usage":["{stringx.partition('a,b,c', ','))} == {'a', ',', 'b,c'}\n","{stringx.partition('abc', 'x'))} == {'abc', '', ''}\n"],
              "type":"function",
              "name":"partition",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"ch",
                "map":{
                  "s":" the string",
                  "ch":" delimiter (match as plain string, no patterns)"
                }
              },
              "tags":[],
              "kind":"partitioning strings ",
              "section":"Partitioning Strings",
              "description":"",
              "ret":["part before ch","ch","part after ch"]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[],[]],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "type":"string"
                  },
                  "s":{
                    "type":"string"
                  },
                  "ch":{
                    "type":"string"
                  }
                },
                "return":[[],[],[]]
              },
              "summary":"partition the string p using last occurance of a delimiter",
              "lineno":475,
              "retgroups":[{
                  "1":{
                    "text":"part before ch",
                    "type":"",
                    "mods":[]
                  },
                  "2":{
                    "text":"ch",
                    "type":"",
                    "mods":[]
                  },
                  "3":{
                    "text":"part after ch",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s, ch)",
              "usage":["{stringx.rpartition('a,b,c', ','))} == {'a,b', ',', 'c'}\n","{stringx.rpartition('abc', 'x'))} == {'', '', 'abc'}\n"],
              "type":"function",
              "name":"rpartition",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"ch",
                "map":{
                  "s":" the string",
                  "ch":" delimiter (match as plain string, no patterns)"
                }
              },
              "tags":[],
              "kind":"partitioning strings ",
              "section":"Partitioning Strings",
              "description":"",
              "ret":["part before ch","ch","part after ch"]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[[]],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "type":"int"
                  },
                  "s":{
                    "type":"string"
                  },
                  "idx":{
                    "type":"int"
                  }
                }
              },
              "summary":"return the 'character' at the index.",
              "lineno":489,
              "retgroups":[{
                  "1":{
                    "text":"a substring of length 1 if successful, empty string otherwise.",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s, idx)",
              "type":"function",
              "name":"at",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"idx",
                "map":{
                  "s":" the string",
                  "idx":" an index (can be negative)"
                }
              },
              "tags":[],
              "kind":"partitioning strings ",
              "section":"Partitioning Strings",
              "description":"",
              "ret":["a substring of length 1 if successful, empty string otherwise."]
            },{
              "name":"text",
              "inferred":true,
              "description":"",
              "file":"<reference cycle>",
              "summary":"",
              "tags":[],
              "lineno":500,
              "display_name":"Text handling",
              "type":"section",
              "modifiers":[]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[[]],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "type":"integer"
                  },
                  "3":{
                    "opt":"' '",
                    "type":"string",
                    "optchain":"' '"
                  },
                  "ch":{
                    "opt":"' '",
                    "type":"string",
                    "optchain":"' '"
                  },
                  "n":{
                    "type":"integer"
                  },
                  "s":{
                    "type":"string"
                  }
                }
              },
              "summary":"indent a multiline string.",
              "lineno":505,
              "retgroups":[{
                  "1":{
                    "text":"indented string",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s, n[, ch=' '])",
              "type":"function",
              "name":"indent",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"n",
                "map":{
                  "ch":" the character to use when indenting",
                  "n":" the size of the indent",
                  "s":" the (multiline) string"
                },
                "3":"ch"
              },
              "tags":[],
              "kind":"text handling ",
              "section":"Text handling",
              "description":"",
              "ret":["indented string"]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[]],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "s":{
                    "type":"string"
                  }
                },
                "return":[[]]
              },
              "summary":"dedent a multiline string by removing any initial indent.",
              "lineno":537,
              "retgroups":[{
                  "1":{
                    "text":"a string with initial indent zero.",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s)",
              "usage":["local s = dedent [[\n         One\n\n       Two\n\n     Three\n]]\nassert(s == [[\n    One\n\n  Two\n\nThree\n]])\n"],
              "type":"function",
              "name":"dedent",
              "parameter":"param",
              "params":{
                "map":{
                  "s":" the (multiline) string"
                },
                "1":"s"
              },
              "tags":[],
              "kind":"text handling ",
              "section":"Text handling",
              "description":"\n useful when working with [[..]] strings.\n Empty lines are ignored.",
              "ret":["a string with initial indent zero."]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "opt":"70",
                    "type":"integer",
                    "optchain":"70"
                  },
                  "3":{
                    "opt":"false",
                    "type":"boolean",
                    "optchain":"false"
                  },
                  "width":{
                    "opt":"70",
                    "type":"integer",
                    "optchain":"70"
                  },
                  "s":{
                    "type":"string"
                  },
                  "breaklong":{
                    "opt":"false",
                    "type":"boolean",
                    "optchain":"false"
                  }
                },
                "return":[[]],
                "see":[[],[]]
              },
              "summary":"format a paragraph into lines so that they fit into a line width.",
              "lineno":594,
              "retgroups":[{
                  "1":{
                    "text":"a list of lines (List object), use `fill` to return a string instead of a `List`.",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s[, width=70[, breaklong=false]])",
              "type":"function",
              "name":"wrap",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"width",
                "map":{
                  "width":" the margin width",
                  "s":" the string to format",
                  "breaklong":" if truthy, words longer than the width given will be forced split."
                },
                "3":"breaklong"
              },
              "tags":{
                "see":[]
              },
              "kind":"text handling ",
              "section":"Text handling",
              "description":"\n It will not break long words by default, so lines can be over the length\n to that extent.",
              "ret":["a list of lines (List object), use `fill` to return a string instead of a `List`."]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "opt":"70",
                    "type":"integer",
                    "optchain":"70"
                  },
                  "3":{
                    "opt":"false",
                    "type":"boolean",
                    "optchain":"false"
                  },
                  "width":{
                    "opt":"70",
                    "type":"integer",
                    "optchain":"70"
                  },
                  "s":{
                    "type":"string"
                  },
                  "breaklong":{
                    "opt":"false",
                    "type":"boolean",
                    "optchain":"false"
                  }
                },
                "return":[[]],
                "see":[[]]
              },
              "summary":"format a paragraph so that it fits into a line width.",
              "lineno":616,
              "retgroups":[{
                  "1":{
                    "text":"a string, use `wrap` to return a list of lines instead of a string.",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s[, width=70[, breaklong=false]])",
              "type":"function",
              "name":"fill",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"width",
                "map":{
                  "width":" the margin width",
                  "s":" the string to format",
                  "breaklong":" if truthy, words longer than the width given will be forced split."
                },
                "3":"breaklong"
              },
              "tags":{
                "see":[]
              },
              "kind":"text handling ",
              "section":"Text handling",
              "description":"",
              "ret":["a string, use `wrap` to return a list of lines instead of a string."]
            },{
              "name":"Template",
              "inferred":true,
              "description":"",
              "file":"<reference cycle>",
              "summary":"",
              "tags":[],
              "lineno":624,
              "display_name":"Template",
              "type":"section",
              "modifiers":[]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "tmpl":{
                    "type":"string"
                  }
                },
                "return":[{
                    "type":"Template"
                  }]
              },
              "summary":"Creates a new Template class.",
              "lineno":662,
              "retgroups":[{
                  "1":{
                    "text":"",
                    "type":"Template",
                    "mods":{
                      "type":"Template"
                    }
                  },
                  "g":0
                }],
              "args":"(tmpl)",
              "section":"Template",
              "name":"Template",
              "params":{
                "map":{
                  "tmpl":" the template string"
                },
                "1":"tmpl"
              },
              "tags":[],
              "kind":"template ",
              "description":"\n This is a shortcut to `Template.new(tmpl)`.",
              "type":"function",
              "ret":[""],
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[[]],
                "param":{
                  "1":{
                    "type":"table"
                  },
                  "tbl":{
                    "type":"table"
                  }
                }
              },
              "summary":"substitute values into a template, throwing an error.",
              "lineno":674,
              "retgroups":[{
                  "1":{
                    "text":"string with place holders substituted",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(tbl)",
              "type":"function",
              "name":"Template:substitute",
              "parameter":"param",
              "params":{
                "map":{
                  "tbl":" a table of name-value pairs."
                },
                "1":"tbl"
              },
              "tags":[],
              "kind":"template ",
              "section":"Template",
              "description":"\n This will throw an error if no name is found.",
              "ret":["string with place holders substituted"]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[[]],
                "param":{
                  "1":{
                    "type":"table"
                  },
                  "tbl":{
                    "type":"table"
                  }
                }
              },
              "summary":"substitute values into a template.",
              "lineno":683,
              "retgroups":[{
                  "1":{
                    "text":"string with place holders substituted",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(tbl)",
              "type":"function",
              "name":"Template:safe_substitute",
              "parameter":"param",
              "params":{
                "map":{
                  "tbl":" a table of name-value pairs."
                },
                "1":"tbl"
              },
              "tags":[],
              "kind":"template ",
              "section":"Template",
              "description":"\n This version just passes unknown names through.",
              "ret":["string with place holders substituted"]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[[]],
                "param":{
                  "1":{
                    "type":"table"
                  },
                  "tbl":{
                    "type":"table"
                  }
                }
              },
              "summary":"substitute values into a template, preserving indentation.",
              "lineno":695,
              "retgroups":[{
                  "1":{
                    "text":"string with place holders substituted",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(tbl)",
              "type":"function",
              "name":"Template:indent_substitute",
              "parameter":"param",
              "params":{
                "map":{
                  "tbl":" a table of name-value pairs."
                },
                "1":"tbl"
              },
              "tags":[],
              "kind":"template ",
              "section":"Template",
              "description":" <br>\n If the value is a multiline string _or_ a template, it will insert\n the lines at the correct indentation. <br>\n Furthermore, if a template, then that template will be substituted\n using the same table.",
              "ret":["string with place holders substituted"]
            },{
              "name":"misc",
              "inferred":true,
              "description":"",
              "file":"<reference cycle>",
              "summary":"",
              "tags":[],
              "lineno":742,
              "display_name":"Miscelaneous",
              "type":"section",
              "modifiers":[]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[]],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "s":{
                    "type":"string"
                  }
                },
                "return":[[]]
              },
              "summary":"return an iterator over all lines in a string",
              "lineno":751,
              "retgroups":[{
                  "1":{
                    "text":"an iterator",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s)",
              "usage":["local line_no = 1\nfor line in stringx.lines(some_text) do\n  print(line_no, line)\n  line_no = line_no + 1\nend\n"],
              "type":"function",
              "name":"lines",
              "parameter":"param",
              "params":{
                "map":{
                  "s":" the string"
                },
                "1":"s"
              },
              "tags":[],
              "kind":"miscelaneous ",
              "section":"Miscelaneous",
              "description":"",
              "ret":["an iterator"]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[]],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "s":{
                    "type":"string"
                  }
                },
                "return":[[]]
              },
              "summary":"inital word letters uppercase ('title case').",
              "lineno":762,
              "retgroups":[{
                  "1":{
                    "text":"a string with each word's first letter uppercase",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s)",
              "usage":["stringx.title(\"hello world\") == \"Hello World\")\n"],
              "type":"function",
              "name":"title",
              "parameter":"param",
              "params":{
                "map":{
                  "s":" the string"
                },
                "1":"s"
              },
              "tags":[],
              "kind":"miscelaneous ",
              "section":"Miscelaneous",
              "description":"\n Here 'words' mean chunks of non-space characters.",
              "ret":["a string with each word's first letter uppercase"]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[],[],[]],
                "return":[],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "type":"int"
                  },
                  "3":{
                    "type":"bool"
                  },
                  "tail":{
                    "type":"bool"
                  },
                  "s":{
                    "type":"string"
                  },
                  "w":{
                    "type":"int"
                  }
                }
              },
              "summary":"Return a shortened version of a string.",
              "lineno":783,
              "args":"(s, w, tail)",
              "usage":["('1234567890'):shorten(8) == '12345...'\n","('1234567890'):shorten(8, true) == '...67890'\n","('1234567890'):shorten(20) == '1234567890'\n"],
              "section":"Miscelaneous",
              "name":"shorten",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"w",
                "map":{
                  "tail":" true if we want to show the end of the string (head otherwise)",
                  "s":" the string",
                  "w":" the maxinum size allowed"
                },
                "3":"tail"
              },
              "tags":[],
              "kind":"miscelaneous ",
              "description":"\n Fits string within w characters. Removed characters are marked with ellipsis.",
              "type":"function"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[[]],
                "param":{
                  "1":[],
                  "s":[]
                }
              },
              "summary":"Quote the given string and preserve any control or escape characters, such that reloading the string in Lua returns the same result.",
              "lineno":822,
              "retgroups":[{
                  "1":{
                    "text":"The quoted string.",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s)",
              "type":"function",
              "name":"quote_string",
              "parameter":"param",
              "params":{
                "map":{
                  "s":" The string to be quoted."
                },
                "1":"s"
              },
              "tags":[],
              "kind":"miscelaneous ",
              "section":"Miscelaneous",
              "description":"",
              "ret":["The quoted string."]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":[],
                "usage":[[]]
              },
              "summary":"Python-style formatting operator.",
              "lineno":873,
              "args":"()",
              "usage":["require 'pl.text'.format_operator()\nlocal out1 = '%s = %5.3f' % {'PI',math.pi}                   --> 'PI = 3.142'\nlocal out2 = '$name = $value' % {name='dog',value='Pluto'}   --> 'dog = Pluto'\n"],
              "section":"Miscelaneous",
              "name":"format_operator",
              "parameter":"param",
              "params":{
                "map":[]
              },
              "tags":[],
              "kind":"miscelaneous ",
              "description":"\n Calling `text.format_operator()` overloads the % operator for strings to give\n Python/Ruby style formated output.\n This is extended to also do template-like substitution for map-like data.\n\n Note this goes further than the original, and will allow these cases:\n\n 1. a single value\n 2. a list of values\n 3. a map of var=value pairs\n 4. a function, as in gsub\n\n For the second two cases, it uses $-variable substituion.\n\n When called, this function will monkey-patch the global `string` metatable by\n adding a `__mod` method.\n\n See <a href=\"http://lua-users.org/wiki/StringInterpolation\">the lua-users wiki</a>\n",
              "type":"function"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "param":[],
                "return":[]
              },
              "summary":"import the stringx functions into the global string (meta)table",
              "lineno":913,
              "args":"()",
              "section":"Miscelaneous",
              "name":"import",
              "params":{
                "map":[]
              },
              "tags":[],
              "kind":"miscelaneous ",
              "description":"",
              "type":"function",
              "parameter":"param"
            }],
          "sections":[],
          "modules":["<reference cycle>"],
          "args":{
            "one":false,
            "module":false,
            "verbose":false,
            "style":"!",
            "template":"!",
            "date":"system",
            "dir":"doc",
            "quiet":false,
            "all":false,
            "ignore":false,
            "colon":false,
            "not_luadoc":false,
            "ext":"html",
            "boilerplate":false,
            "merge":false,
            "filter":"f.filter",
            "package":"/home/cji/portless/Penlight/lua",
            "dump":false,
            "no_args_infer":false,
            "title":"Reference",
            "project":"ldoc",
            "file":"/home/cji/portless/Penlight/lua/pl",
            "format":"discount",
            "simple":false,
            "tags":"none",
            "define":"none",
            "output":"index",
            "unqualified":false,
            "config":"config.ld",
            "fatalwarnings":false,
            "testing":false
          },
          "error":"<type 'function' is not supported by JSON.>",
          "lang":{
            "line_comment":"^%-%-+",
            "start_comment_":"^%-%-%-+",
            "end_comment_":"[^%-]%-%-+[^-]*\n$",
            "extra":[],
            "block_comment":"^%-%-%[=*%[%-+",
            "empty_comment_":"^%-%-%-+%s*$",
            "method_call":":"
          },
          "base":"/home/cji/portless/Penlight/lua"
        },
        "summary":"",
        "tags":[],
        "lineno":311,
        "display_name":"Stripping and Justifying",
        "type":"section",
        "modifiers":[]
      },
      "Miscelaneous":{
        "name":"misc",
        "inferred":true,
        "description":"",
        "file":{
          "warning":"<type 'function' is not supported by JSON.>",
          "filename":"/home/cji/portless/Penlight/lua/pl/stringx.lua",
          "items":["<reference cycle>",{
              "name":"predicates",
              "inferred":true,
              "description":"",
              "file":"<reference cycle>",
              "summary":"",
              "tags":[],
              "lineno":53,
              "display_name":"String Predicates",
              "type":"section",
              "modifiers":[]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "s":{
                    "type":"string"
                  }
                }
              },
              "summary":"does s only contain alphabetic characters?",
              "lineno":55,
              "args":"(s)",
              "section":"String Predicates",
              "name":"isalpha",
              "params":{
                "map":{
                  "s":" a string"
                },
                "1":"s"
              },
              "tags":[],
              "kind":"string predicates ",
              "description":"",
              "type":"function",
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "s":{
                    "type":"string"
                  }
                }
              },
              "summary":"does s only contain digits?",
              "lineno":62,
              "args":"(s)",
              "section":"String Predicates",
              "name":"isdigit",
              "params":{
                "map":{
                  "s":" a string"
                },
                "1":"s"
              },
              "tags":[],
              "kind":"string predicates ",
              "description":"",
              "type":"function",
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "s":{
                    "type":"string"
                  }
                }
              },
              "summary":"does s only contain alphanumeric characters?",
              "lineno":69,
              "args":"(s)",
              "section":"String Predicates",
              "name":"isalnum",
              "params":{
                "map":{
                  "s":" a string"
                },
                "1":"s"
              },
              "tags":[],
              "kind":"string predicates ",
              "description":"",
              "type":"function",
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "s":{
                    "type":"string"
                  }
                }
              },
              "summary":"does s only contain whitespace?",
              "lineno":77,
              "args":"(s)",
              "section":"String Predicates",
              "name":"isspace",
              "params":{
                "map":{
                  "s":" a string"
                },
                "1":"s"
              },
              "tags":[],
              "kind":"string predicates ",
              "description":"\n Matches on pattern '%s' so matches space, newline, tabs, etc.",
              "type":"function",
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "s":{
                    "type":"string"
                  }
                }
              },
              "summary":"does s only contain lower case characters?",
              "lineno":84,
              "args":"(s)",
              "section":"String Predicates",
              "name":"islower",
              "params":{
                "map":{
                  "s":" a string"
                },
                "1":"s"
              },
              "tags":[],
              "kind":"string predicates ",
              "description":"",
              "type":"function",
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "s":{
                    "type":"string"
                  }
                }
              },
              "summary":"does s only contain upper case characters?",
              "lineno":91,
              "args":"(s)",
              "section":"String Predicates",
              "name":"isupper",
              "params":{
                "map":{
                  "s":" a string"
                },
                "1":"s"
              },
              "tags":[],
              "kind":"string predicates ",
              "description":"",
              "type":"function",
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":[],
                  "s":{
                    "type":"string"
                  },
                  "prefix":[]
                }
              },
              "summary":"does s start with prefix or one of prefixes?",
              "lineno":120,
              "args":"(s, prefix)",
              "section":"String Predicates",
              "name":"startswith",
              "params":{
                "1":"s",
                "2":"prefix",
                "map":{
                  "s":" a string",
                  "prefix":" a string or an array of strings"
                }
              },
              "tags":[],
              "kind":"string predicates ",
              "description":"",
              "type":"function",
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":[],
                  "s":{
                    "type":"string"
                  },
                  "suffix":[]
                }
              },
              "summary":"does s end with suffix or one of suffixes?",
              "lineno":128,
              "args":"(s, suffix)",
              "section":"String Predicates",
              "name":"endswith",
              "params":{
                "1":"s",
                "2":"suffix",
                "map":{
                  "s":" a string",
                  "suffix":" a string or an array of strings"
                }
              },
              "tags":[],
              "kind":"string predicates ",
              "description":"",
              "type":"function",
              "parameter":"param"
            },{
              "name":"lists",
              "inferred":true,
              "description":"",
              "file":"<reference cycle>",
              "summary":"",
              "tags":[],
              "lineno":136,
              "display_name":"Strings and Lists",
              "type":"section",
              "modifiers":[]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[]],
                "return":[],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":[],
                  "s":{
                    "type":"string"
                  },
                  "seq":[]
                }
              },
              "summary":"concatenate the strings using this string as a delimiter.",
              "lineno":141,
              "args":"(s, seq)",
              "usage":["stringx.join(' ', {1,2,3}) == '1 2 3'\n"],
              "section":"Strings and Lists",
              "name":"join",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"seq",
                "map":{
                  "s":" the string",
                  "seq":" a table of strings or numbers"
                }
              },
              "tags":[],
              "kind":"strings and lists ",
              "description":"\n Note that the arguments are reversed from `string.concat`.",
              "type":"function"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[[]],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "opt":true,
                    "type":"bool",
                    "optchain":true
                  },
                  "s":{
                    "type":"string"
                  },
                  "keep_ends":{
                    "opt":true,
                    "type":"bool",
                    "optchain":true
                  }
                }
              },
              "summary":"Split a string into a list of lines.",
              "lineno":154,
              "retgroups":[{
                  "1":{
                    "text":"List of lines",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s[, keep_ends])",
              "type":"function",
              "name":"splitlines",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"keep_ends",
                "map":{
                  "s":" the string.",
                  "keep_ends":" include line ends."
                }
              },
              "tags":[],
              "kind":"strings and lists ",
              "section":"Strings and Lists",
              "description":"\n `\"\\r\"`, `\"\\n\"`, and `\"\\r\\n\"` are considered line ends.\n They are not included in the lines unless `keepends` is passed.\n Terminal line end does not produce an extra line.\n Splitting an empty string results in an empty list.",
              "ret":["List of lines"]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[],[],[]],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "opt":true,
                    "type":"string",
                    "optchain":true
                  },
                  "3":{
                    "opt":true,
                    "type":"int",
                    "optchain":true
                  },
                  "re":{
                    "opt":true,
                    "type":"string",
                    "optchain":true
                  },
                  "n":{
                    "opt":true,
                    "type":"int",
                    "optchain":true
                  },
                  "s":{
                    "type":"string"
                  }
                },
                "return":[[]]
              },
              "summary":"split a string into a list of strings using a delimiter.",
              "lineno":193,
              "retgroups":[{
                  "1":{
                    "text":"List",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s[, re[, n]])",
              "usage":["#(stringx.split('one two')) == 2\n","stringx.split('one,two,three', ',') == List{'one','two','three'}\n","stringx.split('one,two,three', ',', 2) == List{'one','two,three'}\n"],
              "type":"function",
              "name":"split",
              "params":{
                "1":"s",
                "2":"re",
                "map":{
                  "re":" a delimiter (defaults to whitespace)",
                  "n":" maximum number of results",
                  "s":" the string"
                },
                "3":"n"
              },
              "tags":[],
              "kind":"strings and lists ",
              "section":"Strings and Lists",
              "description":"",
              "ret":["List"],
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[],[]],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "type":"int"
                  },
                  "s":{
                    "type":"string"
                  },
                  "tabsize":{
                    "type":"int"
                  }
                },
                "return":[[]]
              },
              "summary":"replace all tabs in s with tabsize spaces.",
              "lineno":216,
              "retgroups":[{
                  "1":{
                    "text":"expanded string",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s, tabsize)",
              "usage":["stringx.expandtabs('\\tone,two,three', 4)   == '    one,two,three'\n","stringx.expandtabs('  \\tone,two,three', 4) == '    one,two,three'\n"],
              "type":"function",
              "name":"expandtabs",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"tabsize",
                "map":{
                  "s":" the string",
                  "tabsize":"[opt=8] number of spaces to expand each tab"
                }
              },
              "tags":[],
              "kind":"strings and lists ",
              "section":"Strings and Lists",
              "description":" If not specified, tabsize defaults to 8.\n Tab stops will be honored.",
              "ret":["expanded string"]
            },{
              "name":"find",
              "inferred":true,
              "description":"",
              "file":"<reference cycle>",
              "summary":"",
              "tags":[],
              "lineno":231,
              "display_name":"Finding and Replacing",
              "type":"section",
              "modifiers":[]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[[]],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "type":"string"
                  },
                  "3":{
                    "opt":true,
                    "type":"int",
                    "optchain":true
                  },
                  "4":{
                    "opt":true,
                    "type":"int",
                    "optchain":true
                  },
                  "first":{
                    "opt":true,
                    "type":"int",
                    "optchain":true
                  },
                  "sub":{
                    "type":"string"
                  },
                  "s":{
                    "type":"string"
                  },
                  "last":{
                    "opt":true,
                    "type":"int",
                    "optchain":true
                  }
                }
              },
              "summary":"find index of first instance of sub in s from the left.",
              "lineno":257,
              "retgroups":[{
                  "1":{
                    "text":"start index, or nil if not found",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s, sub[, first[, last]])",
              "type":"function",
              "name":"lfind",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"sub",
                "3":"first",
                "4":"last",
                "map":{
                  "first":" first index",
                  "sub":" substring",
                  "s":" the string",
                  "last":" last index"
                }
              },
              "tags":[],
              "kind":"finding and replacing ",
              "section":"Finding and Replacing",
              "description":"",
              "ret":["start index, or nil if not found"]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[[]],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "type":"string"
                  },
                  "3":{
                    "opt":true,
                    "type":"int",
                    "optchain":true
                  },
                  "4":{
                    "opt":true,
                    "type":"int",
                    "optchain":true
                  },
                  "first":{
                    "opt":true,
                    "type":"int",
                    "optchain":true
                  },
                  "sub":{
                    "type":"string"
                  },
                  "s":{
                    "type":"string"
                  },
                  "last":{
                    "opt":true,
                    "type":"int",
                    "optchain":true
                  }
                }
              },
              "summary":"find index of first instance of sub in s from the right.",
              "lineno":275,
              "retgroups":[{
                  "1":{
                    "text":"start index, or nil if not found",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s, sub[, first[, last]])",
              "type":"function",
              "name":"rfind",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"sub",
                "3":"first",
                "4":"last",
                "map":{
                  "first":" first index",
                  "sub":" substring",
                  "s":" the string",
                  "last":" last index"
                }
              },
              "tags":[],
              "kind":"finding and replacing ",
              "section":"Finding and Replacing",
              "description":"",
              "ret":["start index, or nil if not found"]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[[]],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "type":"string"
                  },
                  "3":{
                    "type":"string"
                  },
                  "4":{
                    "opt":true,
                    "type":"int",
                    "optchain":true
                  },
                  "n":{
                    "opt":true,
                    "type":"int",
                    "optchain":true
                  },
                  "old":{
                    "type":"string"
                  },
                  "s":{
                    "type":"string"
                  },
                  "new":{
                    "type":"string"
                  }
                }
              },
              "summary":"replace up to n instances of old by new in the string s.",
              "lineno":288,
              "retgroups":[{
                  "1":{
                    "text":"result string",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s, old, new[, n])",
              "type":"function",
              "name":"replace",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"old",
                "3":"new",
                "4":"n",
                "map":{
                  "n":" optional maximum number of substitutions",
                  "old":" the target substring",
                  "s":" the string",
                  "new":" the substitution"
                }
              },
              "tags":[],
              "kind":"finding and replacing ",
              "section":"Finding and Replacing",
              "description":"\n If n is not present, replace all instances.",
              "ret":["result string"]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[]],
                "return":[],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "type":"string"
                  },
                  "3":{
                    "opt":true,
                    "type":"bool",
                    "optchain":true
                  },
                  "sub":{
                    "type":"string"
                  },
                  "s":{
                    "type":"string"
                  },
                  "allow_overlap":{
                    "opt":true,
                    "type":"bool",
                    "optchain":true
                  }
                }
              },
              "summary":"count all instances of substring in string.",
              "lineno":302,
              "args":"(s, sub[, allow_overlap])",
              "usage":["assert(stringx.count('banana', 'ana') == 1)\nassert(stringx.count('banana', 'ana', true) == 2)\n"],
              "section":"Finding and Replacing",
              "name":"count",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"sub",
                "map":{
                  "sub":" substring",
                  "s":" the string",
                  "allow_overlap":" allow matches to overlap"
                },
                "3":"allow_overlap"
              },
              "tags":[],
              "kind":"finding and replacing ",
              "description":"",
              "type":"function"
            },{
              "name":"strip",
              "inferred":true,
              "description":"",
              "file":"<reference cycle>",
              "summary":"",
              "tags":[],
              "lineno":311,
              "display_name":"Stripping and Justifying",
              "type":"section",
              "modifiers":[]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[]],
                "return":[],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "type":"int"
                  },
                  "3":{
                    "opt":"' '",
                    "type":"string",
                    "optchain":"' '"
                  },
                  "ch":{
                    "opt":"' '",
                    "type":"string",
                    "optchain":"' '"
                  },
                  "s":{
                    "type":"string"
                  },
                  "w":{
                    "type":"int"
                  }
                }
              },
              "summary":"left-justify s with width w.",
              "lineno":339,
              "args":"(s, w[, ch=' '])",
              "usage":["stringx.ljust('hello', 10, '*') == '*****hello'\n"],
              "section":"Stripping and Justifying",
              "name":"ljust",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"w",
                "map":{
                  "ch":" padding character",
                  "s":" the string",
                  "w":" width of justification"
                },
                "3":"ch"
              },
              "tags":[],
              "kind":"stripping and justifying ",
              "description":"",
              "type":"function"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[]],
                "return":[],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "type":"int"
                  },
                  "3":{
                    "opt":"' '",
                    "type":"string",
                    "optchain":"' '"
                  },
                  "ch":{
                    "opt":"' '",
                    "type":"string",
                    "optchain":"' '"
                  },
                  "s":{
                    "type":"string"
                  },
                  "w":{
                    "type":"int"
                  }
                }
              },
              "summary":"right-justify s with width w.",
              "lineno":350,
              "args":"(s, w[, ch=' '])",
              "usage":["stringx.rjust('hello', 10, '*') == 'hello*****'\n"],
              "section":"Stripping and Justifying",
              "name":"rjust",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"w",
                "map":{
                  "ch":" padding character",
                  "s":" the string",
                  "w":" width of justification"
                },
                "3":"ch"
              },
              "tags":[],
              "kind":"stripping and justifying ",
              "description":"",
              "type":"function"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[]],
                "return":[],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "type":"int"
                  },
                  "3":{
                    "opt":"' '",
                    "type":"string",
                    "optchain":"' '"
                  },
                  "ch":{
                    "opt":"' '",
                    "type":"string",
                    "optchain":"' '"
                  },
                  "s":{
                    "type":"string"
                  },
                  "w":{
                    "type":"int"
                  }
                }
              },
              "summary":"center-justify s with width w.",
              "lineno":361,
              "args":"(s, w[, ch=' '])",
              "usage":["stringx.center('hello', 10, '*') == '**hello***'\n"],
              "section":"Stripping and Justifying",
              "name":"center",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"w",
                "map":{
                  "ch":" padding character",
                  "s":" the string",
                  "w":" width of justification"
                },
                "3":"ch"
              },
              "tags":[],
              "kind":"stripping and justifying ",
              "description":"",
              "type":"function"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "opt":"'%s'",
                    "type":"string",
                    "optchain":"'%s'"
                  },
                  "s":{
                    "type":"string"
                  },
                  "chrs":{
                    "opt":"'%s'",
                    "type":"string",
                    "optchain":"'%s'"
                  }
                }
              },
              "summary":"trim any characters on the left of s.",
              "lineno":402,
              "args":"(s[, chrs='%s'])",
              "section":"Stripping and Justifying",
              "name":"lstrip",
              "params":{
                "1":"s",
                "2":"chrs",
                "map":{
                  "s":" the string",
                  "chrs":" default any whitespace character,\n but can be a string of characters to be trimmed"
                }
              },
              "tags":[],
              "kind":"stripping and justifying ",
              "description":"",
              "type":"function",
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "opt":"'%s'",
                    "type":"string",
                    "optchain":"'%s'"
                  },
                  "s":{
                    "type":"string"
                  },
                  "chrs":{
                    "opt":"'%s'",
                    "type":"string",
                    "optchain":"'%s'"
                  }
                }
              },
              "summary":"trim any characters on the right of s.",
              "lineno":412,
              "args":"(s[, chrs='%s'])",
              "section":"Stripping and Justifying",
              "name":"rstrip",
              "params":{
                "1":"s",
                "2":"chrs",
                "map":{
                  "s":" the string",
                  "chrs":" default any whitespace character,\n but can be a string of characters to be trimmed"
                }
              },
              "tags":[],
              "kind":"stripping and justifying ",
              "description":"",
              "type":"function",
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[]],
                "return":[],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "opt":"'%s'",
                    "type":"string",
                    "optchain":"'%s'"
                  },
                  "s":{
                    "type":"string"
                  },
                  "chrs":{
                    "opt":"'%s'",
                    "type":"string",
                    "optchain":"'%s'"
                  }
                }
              },
              "summary":"trim any characters on both left and right of s.",
              "lineno":422,
              "args":"(s[, chrs='%s'])",
              "usage":["stringx.strip('  --== Hello ==--  ', \"- =\")  --> 'Hello'\n"],
              "section":"Stripping and Justifying",
              "name":"strip",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"chrs",
                "map":{
                  "s":" the string",
                  "chrs":" default any whitespace character,\n but can be a string of characters to be trimmed"
                }
              },
              "tags":[],
              "kind":"stripping and justifying ",
              "description":"",
              "type":"function"
            },{
              "name":"partitioning",
              "inferred":true,
              "description":"",
              "file":"<reference cycle>",
              "summary":"",
              "tags":[],
              "lineno":430,
              "display_name":"Partitioning Strings",
              "type":"section",
              "modifiers":[]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "opt":"'%s'",
                    "type":"string",
                    "optchain":"'%s'"
                  },
                  "s":{
                    "type":"string"
                  },
                  "re":{
                    "opt":"'%s'",
                    "type":"string",
                    "optchain":"'%s'"
                  }
                },
                "return":[[]],
                "usage":[[]],
                "see":[[]]
              },
              "summary":"split a string using a pattern.",
              "lineno":436,
              "retgroups":[{
                  "1":{
                    "text":"the parts of the string",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s[, re='%s'])",
              "usage":["a,b = line:splitv('=')\n"],
              "type":"function",
              "name":"splitv",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"re",
                "map":{
                  "s":" the string",
                  "re":" a Lua string pattern (defaults to whitespace)"
                }
              },
              "tags":{
                "see":[]
              },
              "kind":"partitioning strings ",
              "section":"Partitioning Strings",
              "description":" Note that at least one value will be returned!",
              "ret":["the parts of the string"]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[],[]],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "type":"string"
                  },
                  "s":{
                    "type":"string"
                  },
                  "ch":{
                    "type":"string"
                  }
                },
                "return":[[],[],[]]
              },
              "summary":"partition the string using first occurance of a delimiter",
              "lineno":461,
              "retgroups":[{
                  "1":{
                    "text":"part before ch",
                    "type":"",
                    "mods":[]
                  },
                  "2":{
                    "text":"ch",
                    "type":"",
                    "mods":[]
                  },
                  "3":{
                    "text":"part after ch",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s, ch)",
              "usage":["{stringx.partition('a,b,c', ','))} == {'a', ',', 'b,c'}\n","{stringx.partition('abc', 'x'))} == {'abc', '', ''}\n"],
              "type":"function",
              "name":"partition",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"ch",
                "map":{
                  "s":" the string",
                  "ch":" delimiter (match as plain string, no patterns)"
                }
              },
              "tags":[],
              "kind":"partitioning strings ",
              "section":"Partitioning Strings",
              "description":"",
              "ret":["part before ch","ch","part after ch"]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[],[]],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "type":"string"
                  },
                  "s":{
                    "type":"string"
                  },
                  "ch":{
                    "type":"string"
                  }
                },
                "return":[[],[],[]]
              },
              "summary":"partition the string p using last occurance of a delimiter",
              "lineno":475,
              "retgroups":[{
                  "1":{
                    "text":"part before ch",
                    "type":"",
                    "mods":[]
                  },
                  "2":{
                    "text":"ch",
                    "type":"",
                    "mods":[]
                  },
                  "3":{
                    "text":"part after ch",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s, ch)",
              "usage":["{stringx.rpartition('a,b,c', ','))} == {'a,b', ',', 'c'}\n","{stringx.rpartition('abc', 'x'))} == {'', '', 'abc'}\n"],
              "type":"function",
              "name":"rpartition",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"ch",
                "map":{
                  "s":" the string",
                  "ch":" delimiter (match as plain string, no patterns)"
                }
              },
              "tags":[],
              "kind":"partitioning strings ",
              "section":"Partitioning Strings",
              "description":"",
              "ret":["part before ch","ch","part after ch"]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[[]],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "type":"int"
                  },
                  "s":{
                    "type":"string"
                  },
                  "idx":{
                    "type":"int"
                  }
                }
              },
              "summary":"return the 'character' at the index.",
              "lineno":489,
              "retgroups":[{
                  "1":{
                    "text":"a substring of length 1 if successful, empty string otherwise.",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s, idx)",
              "type":"function",
              "name":"at",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"idx",
                "map":{
                  "s":" the string",
                  "idx":" an index (can be negative)"
                }
              },
              "tags":[],
              "kind":"partitioning strings ",
              "section":"Partitioning Strings",
              "description":"",
              "ret":["a substring of length 1 if successful, empty string otherwise."]
            },{
              "name":"text",
              "inferred":true,
              "description":"",
              "file":"<reference cycle>",
              "summary":"",
              "tags":[],
              "lineno":500,
              "display_name":"Text handling",
              "type":"section",
              "modifiers":[]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[[]],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "type":"integer"
                  },
                  "3":{
                    "opt":"' '",
                    "type":"string",
                    "optchain":"' '"
                  },
                  "ch":{
                    "opt":"' '",
                    "type":"string",
                    "optchain":"' '"
                  },
                  "n":{
                    "type":"integer"
                  },
                  "s":{
                    "type":"string"
                  }
                }
              },
              "summary":"indent a multiline string.",
              "lineno":505,
              "retgroups":[{
                  "1":{
                    "text":"indented string",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s, n[, ch=' '])",
              "type":"function",
              "name":"indent",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"n",
                "map":{
                  "ch":" the character to use when indenting",
                  "n":" the size of the indent",
                  "s":" the (multiline) string"
                },
                "3":"ch"
              },
              "tags":[],
              "kind":"text handling ",
              "section":"Text handling",
              "description":"",
              "ret":["indented string"]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[]],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "s":{
                    "type":"string"
                  }
                },
                "return":[[]]
              },
              "summary":"dedent a multiline string by removing any initial indent.",
              "lineno":537,
              "retgroups":[{
                  "1":{
                    "text":"a string with initial indent zero.",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s)",
              "usage":["local s = dedent [[\n         One\n\n       Two\n\n     Three\n]]\nassert(s == [[\n    One\n\n  Two\n\nThree\n]])\n"],
              "type":"function",
              "name":"dedent",
              "parameter":"param",
              "params":{
                "map":{
                  "s":" the (multiline) string"
                },
                "1":"s"
              },
              "tags":[],
              "kind":"text handling ",
              "section":"Text handling",
              "description":"\n useful when working with [[..]] strings.\n Empty lines are ignored.",
              "ret":["a string with initial indent zero."]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "opt":"70",
                    "type":"integer",
                    "optchain":"70"
                  },
                  "3":{
                    "opt":"false",
                    "type":"boolean",
                    "optchain":"false"
                  },
                  "width":{
                    "opt":"70",
                    "type":"integer",
                    "optchain":"70"
                  },
                  "s":{
                    "type":"string"
                  },
                  "breaklong":{
                    "opt":"false",
                    "type":"boolean",
                    "optchain":"false"
                  }
                },
                "return":[[]],
                "see":[[],[]]
              },
              "summary":"format a paragraph into lines so that they fit into a line width.",
              "lineno":594,
              "retgroups":[{
                  "1":{
                    "text":"a list of lines (List object), use `fill` to return a string instead of a `List`.",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s[, width=70[, breaklong=false]])",
              "type":"function",
              "name":"wrap",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"width",
                "map":{
                  "width":" the margin width",
                  "s":" the string to format",
                  "breaklong":" if truthy, words longer than the width given will be forced split."
                },
                "3":"breaklong"
              },
              "tags":{
                "see":[]
              },
              "kind":"text handling ",
              "section":"Text handling",
              "description":"\n It will not break long words by default, so lines can be over the length\n to that extent.",
              "ret":["a list of lines (List object), use `fill` to return a string instead of a `List`."]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "opt":"70",
                    "type":"integer",
                    "optchain":"70"
                  },
                  "3":{
                    "opt":"false",
                    "type":"boolean",
                    "optchain":"false"
                  },
                  "width":{
                    "opt":"70",
                    "type":"integer",
                    "optchain":"70"
                  },
                  "s":{
                    "type":"string"
                  },
                  "breaklong":{
                    "opt":"false",
                    "type":"boolean",
                    "optchain":"false"
                  }
                },
                "return":[[]],
                "see":[[]]
              },
              "summary":"format a paragraph so that it fits into a line width.",
              "lineno":616,
              "retgroups":[{
                  "1":{
                    "text":"a string, use `wrap` to return a list of lines instead of a string.",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s[, width=70[, breaklong=false]])",
              "type":"function",
              "name":"fill",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"width",
                "map":{
                  "width":" the margin width",
                  "s":" the string to format",
                  "breaklong":" if truthy, words longer than the width given will be forced split."
                },
                "3":"breaklong"
              },
              "tags":{
                "see":[]
              },
              "kind":"text handling ",
              "section":"Text handling",
              "description":"",
              "ret":["a string, use `wrap` to return a list of lines instead of a string."]
            },{
              "name":"Template",
              "inferred":true,
              "description":"",
              "file":"<reference cycle>",
              "summary":"",
              "tags":[],
              "lineno":624,
              "display_name":"Template",
              "type":"section",
              "modifiers":[]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "tmpl":{
                    "type":"string"
                  }
                },
                "return":[{
                    "type":"Template"
                  }]
              },
              "summary":"Creates a new Template class.",
              "lineno":662,
              "retgroups":[{
                  "1":{
                    "text":"",
                    "type":"Template",
                    "mods":{
                      "type":"Template"
                    }
                  },
                  "g":0
                }],
              "args":"(tmpl)",
              "section":"Template",
              "name":"Template",
              "params":{
                "map":{
                  "tmpl":" the template string"
                },
                "1":"tmpl"
              },
              "tags":[],
              "kind":"template ",
              "description":"\n This is a shortcut to `Template.new(tmpl)`.",
              "type":"function",
              "ret":[""],
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[[]],
                "param":{
                  "1":{
                    "type":"table"
                  },
                  "tbl":{
                    "type":"table"
                  }
                }
              },
              "summary":"substitute values into a template, throwing an error.",
              "lineno":674,
              "retgroups":[{
                  "1":{
                    "text":"string with place holders substituted",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(tbl)",
              "type":"function",
              "name":"Template:substitute",
              "parameter":"param",
              "params":{
                "map":{
                  "tbl":" a table of name-value pairs."
                },
                "1":"tbl"
              },
              "tags":[],
              "kind":"template ",
              "section":"Template",
              "description":"\n This will throw an error if no name is found.",
              "ret":["string with place holders substituted"]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[[]],
                "param":{
                  "1":{
                    "type":"table"
                  },
                  "tbl":{
                    "type":"table"
                  }
                }
              },
              "summary":"substitute values into a template.",
              "lineno":683,
              "retgroups":[{
                  "1":{
                    "text":"string with place holders substituted",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(tbl)",
              "type":"function",
              "name":"Template:safe_substitute",
              "parameter":"param",
              "params":{
                "map":{
                  "tbl":" a table of name-value pairs."
                },
                "1":"tbl"
              },
              "tags":[],
              "kind":"template ",
              "section":"Template",
              "description":"\n This version just passes unknown names through.",
              "ret":["string with place holders substituted"]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[[]],
                "param":{
                  "1":{
                    "type":"table"
                  },
                  "tbl":{
                    "type":"table"
                  }
                }
              },
              "summary":"substitute values into a template, preserving indentation.",
              "lineno":695,
              "retgroups":[{
                  "1":{
                    "text":"string with place holders substituted",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(tbl)",
              "type":"function",
              "name":"Template:indent_substitute",
              "parameter":"param",
              "params":{
                "map":{
                  "tbl":" a table of name-value pairs."
                },
                "1":"tbl"
              },
              "tags":[],
              "kind":"template ",
              "section":"Template",
              "description":" <br>\n If the value is a multiline string _or_ a template, it will insert\n the lines at the correct indentation. <br>\n Furthermore, if a template, then that template will be substituted\n using the same table.",
              "ret":["string with place holders substituted"]
            },"<reference cycle>",{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[]],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "s":{
                    "type":"string"
                  }
                },
                "return":[[]]
              },
              "summary":"return an iterator over all lines in a string",
              "lineno":751,
              "retgroups":[{
                  "1":{
                    "text":"an iterator",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s)",
              "usage":["local line_no = 1\nfor line in stringx.lines(some_text) do\n  print(line_no, line)\n  line_no = line_no + 1\nend\n"],
              "type":"function",
              "name":"lines",
              "parameter":"param",
              "params":{
                "map":{
                  "s":" the string"
                },
                "1":"s"
              },
              "tags":[],
              "kind":"miscelaneous ",
              "section":"Miscelaneous",
              "description":"",
              "ret":["an iterator"]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[]],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "s":{
                    "type":"string"
                  }
                },
                "return":[[]]
              },
              "summary":"inital word letters uppercase ('title case').",
              "lineno":762,
              "retgroups":[{
                  "1":{
                    "text":"a string with each word's first letter uppercase",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s)",
              "usage":["stringx.title(\"hello world\") == \"Hello World\")\n"],
              "type":"function",
              "name":"title",
              "parameter":"param",
              "params":{
                "map":{
                  "s":" the string"
                },
                "1":"s"
              },
              "tags":[],
              "kind":"miscelaneous ",
              "section":"Miscelaneous",
              "description":"\n Here 'words' mean chunks of non-space characters.",
              "ret":["a string with each word's first letter uppercase"]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[],[],[]],
                "return":[],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "type":"int"
                  },
                  "3":{
                    "type":"bool"
                  },
                  "tail":{
                    "type":"bool"
                  },
                  "s":{
                    "type":"string"
                  },
                  "w":{
                    "type":"int"
                  }
                }
              },
              "summary":"Return a shortened version of a string.",
              "lineno":783,
              "args":"(s, w, tail)",
              "usage":["('1234567890'):shorten(8) == '12345...'\n","('1234567890'):shorten(8, true) == '...67890'\n","('1234567890'):shorten(20) == '1234567890'\n"],
              "section":"Miscelaneous",
              "name":"shorten",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"w",
                "map":{
                  "tail":" true if we want to show the end of the string (head otherwise)",
                  "s":" the string",
                  "w":" the maxinum size allowed"
                },
                "3":"tail"
              },
              "tags":[],
              "kind":"miscelaneous ",
              "description":"\n Fits string within w characters. Removed characters are marked with ellipsis.",
              "type":"function"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[[]],
                "param":{
                  "1":[],
                  "s":[]
                }
              },
              "summary":"Quote the given string and preserve any control or escape characters, such that reloading the string in Lua returns the same result.",
              "lineno":822,
              "retgroups":[{
                  "1":{
                    "text":"The quoted string.",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s)",
              "type":"function",
              "name":"quote_string",
              "parameter":"param",
              "params":{
                "map":{
                  "s":" The string to be quoted."
                },
                "1":"s"
              },
              "tags":[],
              "kind":"miscelaneous ",
              "section":"Miscelaneous",
              "description":"",
              "ret":["The quoted string."]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":[],
                "usage":[[]]
              },
              "summary":"Python-style formatting operator.",
              "lineno":873,
              "args":"()",
              "usage":["require 'pl.text'.format_operator()\nlocal out1 = '%s = %5.3f' % {'PI',math.pi}                   --> 'PI = 3.142'\nlocal out2 = '$name = $value' % {name='dog',value='Pluto'}   --> 'dog = Pluto'\n"],
              "section":"Miscelaneous",
              "name":"format_operator",
              "parameter":"param",
              "params":{
                "map":[]
              },
              "tags":[],
              "kind":"miscelaneous ",
              "description":"\n Calling `text.format_operator()` overloads the % operator for strings to give\n Python/Ruby style formated output.\n This is extended to also do template-like substitution for map-like data.\n\n Note this goes further than the original, and will allow these cases:\n\n 1. a single value\n 2. a list of values\n 3. a map of var=value pairs\n 4. a function, as in gsub\n\n For the second two cases, it uses $-variable substituion.\n\n When called, this function will monkey-patch the global `string` metatable by\n adding a `__mod` method.\n\n See <a href=\"http://lua-users.org/wiki/StringInterpolation\">the lua-users wiki</a>\n",
              "type":"function"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "param":[],
                "return":[]
              },
              "summary":"import the stringx functions into the global string (meta)table",
              "lineno":913,
              "args":"()",
              "section":"Miscelaneous",
              "name":"import",
              "params":{
                "map":[]
              },
              "tags":[],
              "kind":"miscelaneous ",
              "description":"",
              "type":"function",
              "parameter":"param"
            }],
          "sections":[],
          "modules":["<reference cycle>"],
          "args":{
            "one":false,
            "module":false,
            "verbose":false,
            "style":"!",
            "template":"!",
            "date":"system",
            "dir":"doc",
            "quiet":false,
            "all":false,
            "ignore":false,
            "colon":false,
            "not_luadoc":false,
            "ext":"html",
            "boilerplate":false,
            "merge":false,
            "filter":"f.filter",
            "package":"/home/cji/portless/Penlight/lua",
            "dump":false,
            "no_args_infer":false,
            "title":"Reference",
            "project":"ldoc",
            "file":"/home/cji/portless/Penlight/lua/pl",
            "format":"discount",
            "simple":false,
            "tags":"none",
            "define":"none",
            "output":"index",
            "unqualified":false,
            "config":"config.ld",
            "fatalwarnings":false,
            "testing":false
          },
          "error":"<type 'function' is not supported by JSON.>",
          "lang":{
            "line_comment":"^%-%-+",
            "start_comment_":"^%-%-%-+",
            "end_comment_":"[^%-]%-%-+[^-]*\n$",
            "extra":[],
            "block_comment":"^%-%-%[=*%[%-+",
            "empty_comment_":"^%-%-%-+%s*$",
            "method_call":":"
          },
          "base":"/home/cji/portless/Penlight/lua"
        },
        "summary":"",
        "tags":[],
        "lineno":742,
        "display_name":"Miscelaneous",
        "type":"section",
        "modifiers":[]
      },
      "Text_handling":{
        "name":"text",
        "inferred":true,
        "description":"",
        "file":{
          "warning":"<type 'function' is not supported by JSON.>",
          "filename":"/home/cji/portless/Penlight/lua/pl/stringx.lua",
          "items":["<reference cycle>",{
              "name":"predicates",
              "inferred":true,
              "description":"",
              "file":"<reference cycle>",
              "summary":"",
              "tags":[],
              "lineno":53,
              "display_name":"String Predicates",
              "type":"section",
              "modifiers":[]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "s":{
                    "type":"string"
                  }
                }
              },
              "summary":"does s only contain alphabetic characters?",
              "lineno":55,
              "args":"(s)",
              "section":"String Predicates",
              "name":"isalpha",
              "params":{
                "map":{
                  "s":" a string"
                },
                "1":"s"
              },
              "tags":[],
              "kind":"string predicates ",
              "description":"",
              "type":"function",
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "s":{
                    "type":"string"
                  }
                }
              },
              "summary":"does s only contain digits?",
              "lineno":62,
              "args":"(s)",
              "section":"String Predicates",
              "name":"isdigit",
              "params":{
                "map":{
                  "s":" a string"
                },
                "1":"s"
              },
              "tags":[],
              "kind":"string predicates ",
              "description":"",
              "type":"function",
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "s":{
                    "type":"string"
                  }
                }
              },
              "summary":"does s only contain alphanumeric characters?",
              "lineno":69,
              "args":"(s)",
              "section":"String Predicates",
              "name":"isalnum",
              "params":{
                "map":{
                  "s":" a string"
                },
                "1":"s"
              },
              "tags":[],
              "kind":"string predicates ",
              "description":"",
              "type":"function",
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "s":{
                    "type":"string"
                  }
                }
              },
              "summary":"does s only contain whitespace?",
              "lineno":77,
              "args":"(s)",
              "section":"String Predicates",
              "name":"isspace",
              "params":{
                "map":{
                  "s":" a string"
                },
                "1":"s"
              },
              "tags":[],
              "kind":"string predicates ",
              "description":"\n Matches on pattern '%s' so matches space, newline, tabs, etc.",
              "type":"function",
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "s":{
                    "type":"string"
                  }
                }
              },
              "summary":"does s only contain lower case characters?",
              "lineno":84,
              "args":"(s)",
              "section":"String Predicates",
              "name":"islower",
              "params":{
                "map":{
                  "s":" a string"
                },
                "1":"s"
              },
              "tags":[],
              "kind":"string predicates ",
              "description":"",
              "type":"function",
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "s":{
                    "type":"string"
                  }
                }
              },
              "summary":"does s only contain upper case characters?",
              "lineno":91,
              "args":"(s)",
              "section":"String Predicates",
              "name":"isupper",
              "params":{
                "map":{
                  "s":" a string"
                },
                "1":"s"
              },
              "tags":[],
              "kind":"string predicates ",
              "description":"",
              "type":"function",
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":[],
                  "s":{
                    "type":"string"
                  },
                  "prefix":[]
                }
              },
              "summary":"does s start with prefix or one of prefixes?",
              "lineno":120,
              "args":"(s, prefix)",
              "section":"String Predicates",
              "name":"startswith",
              "params":{
                "1":"s",
                "2":"prefix",
                "map":{
                  "s":" a string",
                  "prefix":" a string or an array of strings"
                }
              },
              "tags":[],
              "kind":"string predicates ",
              "description":"",
              "type":"function",
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":[],
                  "s":{
                    "type":"string"
                  },
                  "suffix":[]
                }
              },
              "summary":"does s end with suffix or one of suffixes?",
              "lineno":128,
              "args":"(s, suffix)",
              "section":"String Predicates",
              "name":"endswith",
              "params":{
                "1":"s",
                "2":"suffix",
                "map":{
                  "s":" a string",
                  "suffix":" a string or an array of strings"
                }
              },
              "tags":[],
              "kind":"string predicates ",
              "description":"",
              "type":"function",
              "parameter":"param"
            },{
              "name":"lists",
              "inferred":true,
              "description":"",
              "file":"<reference cycle>",
              "summary":"",
              "tags":[],
              "lineno":136,
              "display_name":"Strings and Lists",
              "type":"section",
              "modifiers":[]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[]],
                "return":[],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":[],
                  "s":{
                    "type":"string"
                  },
                  "seq":[]
                }
              },
              "summary":"concatenate the strings using this string as a delimiter.",
              "lineno":141,
              "args":"(s, seq)",
              "usage":["stringx.join(' ', {1,2,3}) == '1 2 3'\n"],
              "section":"Strings and Lists",
              "name":"join",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"seq",
                "map":{
                  "s":" the string",
                  "seq":" a table of strings or numbers"
                }
              },
              "tags":[],
              "kind":"strings and lists ",
              "description":"\n Note that the arguments are reversed from `string.concat`.",
              "type":"function"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[[]],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "opt":true,
                    "type":"bool",
                    "optchain":true
                  },
                  "s":{
                    "type":"string"
                  },
                  "keep_ends":{
                    "opt":true,
                    "type":"bool",
                    "optchain":true
                  }
                }
              },
              "summary":"Split a string into a list of lines.",
              "lineno":154,
              "retgroups":[{
                  "1":{
                    "text":"List of lines",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s[, keep_ends])",
              "type":"function",
              "name":"splitlines",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"keep_ends",
                "map":{
                  "s":" the string.",
                  "keep_ends":" include line ends."
                }
              },
              "tags":[],
              "kind":"strings and lists ",
              "section":"Strings and Lists",
              "description":"\n `\"\\r\"`, `\"\\n\"`, and `\"\\r\\n\"` are considered line ends.\n They are not included in the lines unless `keepends` is passed.\n Terminal line end does not produce an extra line.\n Splitting an empty string results in an empty list.",
              "ret":["List of lines"]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[],[],[]],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "opt":true,
                    "type":"string",
                    "optchain":true
                  },
                  "3":{
                    "opt":true,
                    "type":"int",
                    "optchain":true
                  },
                  "re":{
                    "opt":true,
                    "type":"string",
                    "optchain":true
                  },
                  "n":{
                    "opt":true,
                    "type":"int",
                    "optchain":true
                  },
                  "s":{
                    "type":"string"
                  }
                },
                "return":[[]]
              },
              "summary":"split a string into a list of strings using a delimiter.",
              "lineno":193,
              "retgroups":[{
                  "1":{
                    "text":"List",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s[, re[, n]])",
              "usage":["#(stringx.split('one two')) == 2\n","stringx.split('one,two,three', ',') == List{'one','two','three'}\n","stringx.split('one,two,three', ',', 2) == List{'one','two,three'}\n"],
              "type":"function",
              "name":"split",
              "params":{
                "1":"s",
                "2":"re",
                "map":{
                  "re":" a delimiter (defaults to whitespace)",
                  "n":" maximum number of results",
                  "s":" the string"
                },
                "3":"n"
              },
              "tags":[],
              "kind":"strings and lists ",
              "section":"Strings and Lists",
              "description":"",
              "ret":["List"],
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[],[]],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "type":"int"
                  },
                  "s":{
                    "type":"string"
                  },
                  "tabsize":{
                    "type":"int"
                  }
                },
                "return":[[]]
              },
              "summary":"replace all tabs in s with tabsize spaces.",
              "lineno":216,
              "retgroups":[{
                  "1":{
                    "text":"expanded string",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s, tabsize)",
              "usage":["stringx.expandtabs('\\tone,two,three', 4)   == '    one,two,three'\n","stringx.expandtabs('  \\tone,two,three', 4) == '    one,two,three'\n"],
              "type":"function",
              "name":"expandtabs",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"tabsize",
                "map":{
                  "s":" the string",
                  "tabsize":"[opt=8] number of spaces to expand each tab"
                }
              },
              "tags":[],
              "kind":"strings and lists ",
              "section":"Strings and Lists",
              "description":" If not specified, tabsize defaults to 8.\n Tab stops will be honored.",
              "ret":["expanded string"]
            },{
              "name":"find",
              "inferred":true,
              "description":"",
              "file":"<reference cycle>",
              "summary":"",
              "tags":[],
              "lineno":231,
              "display_name":"Finding and Replacing",
              "type":"section",
              "modifiers":[]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[[]],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "type":"string"
                  },
                  "3":{
                    "opt":true,
                    "type":"int",
                    "optchain":true
                  },
                  "4":{
                    "opt":true,
                    "type":"int",
                    "optchain":true
                  },
                  "first":{
                    "opt":true,
                    "type":"int",
                    "optchain":true
                  },
                  "sub":{
                    "type":"string"
                  },
                  "s":{
                    "type":"string"
                  },
                  "last":{
                    "opt":true,
                    "type":"int",
                    "optchain":true
                  }
                }
              },
              "summary":"find index of first instance of sub in s from the left.",
              "lineno":257,
              "retgroups":[{
                  "1":{
                    "text":"start index, or nil if not found",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s, sub[, first[, last]])",
              "type":"function",
              "name":"lfind",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"sub",
                "3":"first",
                "4":"last",
                "map":{
                  "first":" first index",
                  "sub":" substring",
                  "s":" the string",
                  "last":" last index"
                }
              },
              "tags":[],
              "kind":"finding and replacing ",
              "section":"Finding and Replacing",
              "description":"",
              "ret":["start index, or nil if not found"]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[[]],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "type":"string"
                  },
                  "3":{
                    "opt":true,
                    "type":"int",
                    "optchain":true
                  },
                  "4":{
                    "opt":true,
                    "type":"int",
                    "optchain":true
                  },
                  "first":{
                    "opt":true,
                    "type":"int",
                    "optchain":true
                  },
                  "sub":{
                    "type":"string"
                  },
                  "s":{
                    "type":"string"
                  },
                  "last":{
                    "opt":true,
                    "type":"int",
                    "optchain":true
                  }
                }
              },
              "summary":"find index of first instance of sub in s from the right.",
              "lineno":275,
              "retgroups":[{
                  "1":{
                    "text":"start index, or nil if not found",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s, sub[, first[, last]])",
              "type":"function",
              "name":"rfind",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"sub",
                "3":"first",
                "4":"last",
                "map":{
                  "first":" first index",
                  "sub":" substring",
                  "s":" the string",
                  "last":" last index"
                }
              },
              "tags":[],
              "kind":"finding and replacing ",
              "section":"Finding and Replacing",
              "description":"",
              "ret":["start index, or nil if not found"]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[[]],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "type":"string"
                  },
                  "3":{
                    "type":"string"
                  },
                  "4":{
                    "opt":true,
                    "type":"int",
                    "optchain":true
                  },
                  "n":{
                    "opt":true,
                    "type":"int",
                    "optchain":true
                  },
                  "old":{
                    "type":"string"
                  },
                  "s":{
                    "type":"string"
                  },
                  "new":{
                    "type":"string"
                  }
                }
              },
              "summary":"replace up to n instances of old by new in the string s.",
              "lineno":288,
              "retgroups":[{
                  "1":{
                    "text":"result string",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s, old, new[, n])",
              "type":"function",
              "name":"replace",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"old",
                "3":"new",
                "4":"n",
                "map":{
                  "n":" optional maximum number of substitutions",
                  "old":" the target substring",
                  "s":" the string",
                  "new":" the substitution"
                }
              },
              "tags":[],
              "kind":"finding and replacing ",
              "section":"Finding and Replacing",
              "description":"\n If n is not present, replace all instances.",
              "ret":["result string"]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[]],
                "return":[],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "type":"string"
                  },
                  "3":{
                    "opt":true,
                    "type":"bool",
                    "optchain":true
                  },
                  "sub":{
                    "type":"string"
                  },
                  "s":{
                    "type":"string"
                  },
                  "allow_overlap":{
                    "opt":true,
                    "type":"bool",
                    "optchain":true
                  }
                }
              },
              "summary":"count all instances of substring in string.",
              "lineno":302,
              "args":"(s, sub[, allow_overlap])",
              "usage":["assert(stringx.count('banana', 'ana') == 1)\nassert(stringx.count('banana', 'ana', true) == 2)\n"],
              "section":"Finding and Replacing",
              "name":"count",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"sub",
                "map":{
                  "sub":" substring",
                  "s":" the string",
                  "allow_overlap":" allow matches to overlap"
                },
                "3":"allow_overlap"
              },
              "tags":[],
              "kind":"finding and replacing ",
              "description":"",
              "type":"function"
            },{
              "name":"strip",
              "inferred":true,
              "description":"",
              "file":"<reference cycle>",
              "summary":"",
              "tags":[],
              "lineno":311,
              "display_name":"Stripping and Justifying",
              "type":"section",
              "modifiers":[]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[]],
                "return":[],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "type":"int"
                  },
                  "3":{
                    "opt":"' '",
                    "type":"string",
                    "optchain":"' '"
                  },
                  "ch":{
                    "opt":"' '",
                    "type":"string",
                    "optchain":"' '"
                  },
                  "s":{
                    "type":"string"
                  },
                  "w":{
                    "type":"int"
                  }
                }
              },
              "summary":"left-justify s with width w.",
              "lineno":339,
              "args":"(s, w[, ch=' '])",
              "usage":["stringx.ljust('hello', 10, '*') == '*****hello'\n"],
              "section":"Stripping and Justifying",
              "name":"ljust",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"w",
                "map":{
                  "ch":" padding character",
                  "s":" the string",
                  "w":" width of justification"
                },
                "3":"ch"
              },
              "tags":[],
              "kind":"stripping and justifying ",
              "description":"",
              "type":"function"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[]],
                "return":[],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "type":"int"
                  },
                  "3":{
                    "opt":"' '",
                    "type":"string",
                    "optchain":"' '"
                  },
                  "ch":{
                    "opt":"' '",
                    "type":"string",
                    "optchain":"' '"
                  },
                  "s":{
                    "type":"string"
                  },
                  "w":{
                    "type":"int"
                  }
                }
              },
              "summary":"right-justify s with width w.",
              "lineno":350,
              "args":"(s, w[, ch=' '])",
              "usage":["stringx.rjust('hello', 10, '*') == 'hello*****'\n"],
              "section":"Stripping and Justifying",
              "name":"rjust",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"w",
                "map":{
                  "ch":" padding character",
                  "s":" the string",
                  "w":" width of justification"
                },
                "3":"ch"
              },
              "tags":[],
              "kind":"stripping and justifying ",
              "description":"",
              "type":"function"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[]],
                "return":[],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "type":"int"
                  },
                  "3":{
                    "opt":"' '",
                    "type":"string",
                    "optchain":"' '"
                  },
                  "ch":{
                    "opt":"' '",
                    "type":"string",
                    "optchain":"' '"
                  },
                  "s":{
                    "type":"string"
                  },
                  "w":{
                    "type":"int"
                  }
                }
              },
              "summary":"center-justify s with width w.",
              "lineno":361,
              "args":"(s, w[, ch=' '])",
              "usage":["stringx.center('hello', 10, '*') == '**hello***'\n"],
              "section":"Stripping and Justifying",
              "name":"center",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"w",
                "map":{
                  "ch":" padding character",
                  "s":" the string",
                  "w":" width of justification"
                },
                "3":"ch"
              },
              "tags":[],
              "kind":"stripping and justifying ",
              "description":"",
              "type":"function"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "opt":"'%s'",
                    "type":"string",
                    "optchain":"'%s'"
                  },
                  "s":{
                    "type":"string"
                  },
                  "chrs":{
                    "opt":"'%s'",
                    "type":"string",
                    "optchain":"'%s'"
                  }
                }
              },
              "summary":"trim any characters on the left of s.",
              "lineno":402,
              "args":"(s[, chrs='%s'])",
              "section":"Stripping and Justifying",
              "name":"lstrip",
              "params":{
                "1":"s",
                "2":"chrs",
                "map":{
                  "s":" the string",
                  "chrs":" default any whitespace character,\n but can be a string of characters to be trimmed"
                }
              },
              "tags":[],
              "kind":"stripping and justifying ",
              "description":"",
              "type":"function",
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "opt":"'%s'",
                    "type":"string",
                    "optchain":"'%s'"
                  },
                  "s":{
                    "type":"string"
                  },
                  "chrs":{
                    "opt":"'%s'",
                    "type":"string",
                    "optchain":"'%s'"
                  }
                }
              },
              "summary":"trim any characters on the right of s.",
              "lineno":412,
              "args":"(s[, chrs='%s'])",
              "section":"Stripping and Justifying",
              "name":"rstrip",
              "params":{
                "1":"s",
                "2":"chrs",
                "map":{
                  "s":" the string",
                  "chrs":" default any whitespace character,\n but can be a string of characters to be trimmed"
                }
              },
              "tags":[],
              "kind":"stripping and justifying ",
              "description":"",
              "type":"function",
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[]],
                "return":[],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "opt":"'%s'",
                    "type":"string",
                    "optchain":"'%s'"
                  },
                  "s":{
                    "type":"string"
                  },
                  "chrs":{
                    "opt":"'%s'",
                    "type":"string",
                    "optchain":"'%s'"
                  }
                }
              },
              "summary":"trim any characters on both left and right of s.",
              "lineno":422,
              "args":"(s[, chrs='%s'])",
              "usage":["stringx.strip('  --== Hello ==--  ', \"- =\")  --> 'Hello'\n"],
              "section":"Stripping and Justifying",
              "name":"strip",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"chrs",
                "map":{
                  "s":" the string",
                  "chrs":" default any whitespace character,\n but can be a string of characters to be trimmed"
                }
              },
              "tags":[],
              "kind":"stripping and justifying ",
              "description":"",
              "type":"function"
            },{
              "name":"partitioning",
              "inferred":true,
              "description":"",
              "file":"<reference cycle>",
              "summary":"",
              "tags":[],
              "lineno":430,
              "display_name":"Partitioning Strings",
              "type":"section",
              "modifiers":[]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "opt":"'%s'",
                    "type":"string",
                    "optchain":"'%s'"
                  },
                  "s":{
                    "type":"string"
                  },
                  "re":{
                    "opt":"'%s'",
                    "type":"string",
                    "optchain":"'%s'"
                  }
                },
                "return":[[]],
                "usage":[[]],
                "see":[[]]
              },
              "summary":"split a string using a pattern.",
              "lineno":436,
              "retgroups":[{
                  "1":{
                    "text":"the parts of the string",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s[, re='%s'])",
              "usage":["a,b = line:splitv('=')\n"],
              "type":"function",
              "name":"splitv",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"re",
                "map":{
                  "s":" the string",
                  "re":" a Lua string pattern (defaults to whitespace)"
                }
              },
              "tags":{
                "see":[]
              },
              "kind":"partitioning strings ",
              "section":"Partitioning Strings",
              "description":" Note that at least one value will be returned!",
              "ret":["the parts of the string"]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[],[]],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "type":"string"
                  },
                  "s":{
                    "type":"string"
                  },
                  "ch":{
                    "type":"string"
                  }
                },
                "return":[[],[],[]]
              },
              "summary":"partition the string using first occurance of a delimiter",
              "lineno":461,
              "retgroups":[{
                  "1":{
                    "text":"part before ch",
                    "type":"",
                    "mods":[]
                  },
                  "2":{
                    "text":"ch",
                    "type":"",
                    "mods":[]
                  },
                  "3":{
                    "text":"part after ch",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s, ch)",
              "usage":["{stringx.partition('a,b,c', ','))} == {'a', ',', 'b,c'}\n","{stringx.partition('abc', 'x'))} == {'abc', '', ''}\n"],
              "type":"function",
              "name":"partition",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"ch",
                "map":{
                  "s":" the string",
                  "ch":" delimiter (match as plain string, no patterns)"
                }
              },
              "tags":[],
              "kind":"partitioning strings ",
              "section":"Partitioning Strings",
              "description":"",
              "ret":["part before ch","ch","part after ch"]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[],[]],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "type":"string"
                  },
                  "s":{
                    "type":"string"
                  },
                  "ch":{
                    "type":"string"
                  }
                },
                "return":[[],[],[]]
              },
              "summary":"partition the string p using last occurance of a delimiter",
              "lineno":475,
              "retgroups":[{
                  "1":{
                    "text":"part before ch",
                    "type":"",
                    "mods":[]
                  },
                  "2":{
                    "text":"ch",
                    "type":"",
                    "mods":[]
                  },
                  "3":{
                    "text":"part after ch",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s, ch)",
              "usage":["{stringx.rpartition('a,b,c', ','))} == {'a,b', ',', 'c'}\n","{stringx.rpartition('abc', 'x'))} == {'', '', 'abc'}\n"],
              "type":"function",
              "name":"rpartition",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"ch",
                "map":{
                  "s":" the string",
                  "ch":" delimiter (match as plain string, no patterns)"
                }
              },
              "tags":[],
              "kind":"partitioning strings ",
              "section":"Partitioning Strings",
              "description":"",
              "ret":["part before ch","ch","part after ch"]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[[]],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "type":"int"
                  },
                  "s":{
                    "type":"string"
                  },
                  "idx":{
                    "type":"int"
                  }
                }
              },
              "summary":"return the 'character' at the index.",
              "lineno":489,
              "retgroups":[{
                  "1":{
                    "text":"a substring of length 1 if successful, empty string otherwise.",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s, idx)",
              "type":"function",
              "name":"at",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"idx",
                "map":{
                  "s":" the string",
                  "idx":" an index (can be negative)"
                }
              },
              "tags":[],
              "kind":"partitioning strings ",
              "section":"Partitioning Strings",
              "description":"",
              "ret":["a substring of length 1 if successful, empty string otherwise."]
            },"<reference cycle>",{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[[]],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "type":"integer"
                  },
                  "3":{
                    "opt":"' '",
                    "type":"string",
                    "optchain":"' '"
                  },
                  "ch":{
                    "opt":"' '",
                    "type":"string",
                    "optchain":"' '"
                  },
                  "n":{
                    "type":"integer"
                  },
                  "s":{
                    "type":"string"
                  }
                }
              },
              "summary":"indent a multiline string.",
              "lineno":505,
              "retgroups":[{
                  "1":{
                    "text":"indented string",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s, n[, ch=' '])",
              "type":"function",
              "name":"indent",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"n",
                "map":{
                  "ch":" the character to use when indenting",
                  "n":" the size of the indent",
                  "s":" the (multiline) string"
                },
                "3":"ch"
              },
              "tags":[],
              "kind":"text handling ",
              "section":"Text handling",
              "description":"",
              "ret":["indented string"]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[]],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "s":{
                    "type":"string"
                  }
                },
                "return":[[]]
              },
              "summary":"dedent a multiline string by removing any initial indent.",
              "lineno":537,
              "retgroups":[{
                  "1":{
                    "text":"a string with initial indent zero.",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s)",
              "usage":["local s = dedent [[\n         One\n\n       Two\n\n     Three\n]]\nassert(s == [[\n    One\n\n  Two\n\nThree\n]])\n"],
              "type":"function",
              "name":"dedent",
              "parameter":"param",
              "params":{
                "map":{
                  "s":" the (multiline) string"
                },
                "1":"s"
              },
              "tags":[],
              "kind":"text handling ",
              "section":"Text handling",
              "description":"\n useful when working with [[..]] strings.\n Empty lines are ignored.",
              "ret":["a string with initial indent zero."]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "opt":"70",
                    "type":"integer",
                    "optchain":"70"
                  },
                  "3":{
                    "opt":"false",
                    "type":"boolean",
                    "optchain":"false"
                  },
                  "width":{
                    "opt":"70",
                    "type":"integer",
                    "optchain":"70"
                  },
                  "s":{
                    "type":"string"
                  },
                  "breaklong":{
                    "opt":"false",
                    "type":"boolean",
                    "optchain":"false"
                  }
                },
                "return":[[]],
                "see":[[],[]]
              },
              "summary":"format a paragraph into lines so that they fit into a line width.",
              "lineno":594,
              "retgroups":[{
                  "1":{
                    "text":"a list of lines (List object), use `fill` to return a string instead of a `List`.",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s[, width=70[, breaklong=false]])",
              "type":"function",
              "name":"wrap",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"width",
                "map":{
                  "width":" the margin width",
                  "s":" the string to format",
                  "breaklong":" if truthy, words longer than the width given will be forced split."
                },
                "3":"breaklong"
              },
              "tags":{
                "see":[]
              },
              "kind":"text handling ",
              "section":"Text handling",
              "description":"\n It will not break long words by default, so lines can be over the length\n to that extent.",
              "ret":["a list of lines (List object), use `fill` to return a string instead of a `List`."]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "opt":"70",
                    "type":"integer",
                    "optchain":"70"
                  },
                  "3":{
                    "opt":"false",
                    "type":"boolean",
                    "optchain":"false"
                  },
                  "width":{
                    "opt":"70",
                    "type":"integer",
                    "optchain":"70"
                  },
                  "s":{
                    "type":"string"
                  },
                  "breaklong":{
                    "opt":"false",
                    "type":"boolean",
                    "optchain":"false"
                  }
                },
                "return":[[]],
                "see":[[]]
              },
              "summary":"format a paragraph so that it fits into a line width.",
              "lineno":616,
              "retgroups":[{
                  "1":{
                    "text":"a string, use `wrap` to return a list of lines instead of a string.",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s[, width=70[, breaklong=false]])",
              "type":"function",
              "name":"fill",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"width",
                "map":{
                  "width":" the margin width",
                  "s":" the string to format",
                  "breaklong":" if truthy, words longer than the width given will be forced split."
                },
                "3":"breaklong"
              },
              "tags":{
                "see":[]
              },
              "kind":"text handling ",
              "section":"Text handling",
              "description":"",
              "ret":["a string, use `wrap` to return a list of lines instead of a string."]
            },{
              "name":"Template",
              "inferred":true,
              "description":"",
              "file":"<reference cycle>",
              "summary":"",
              "tags":[],
              "lineno":624,
              "display_name":"Template",
              "type":"section",
              "modifiers":[]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "tmpl":{
                    "type":"string"
                  }
                },
                "return":[{
                    "type":"Template"
                  }]
              },
              "summary":"Creates a new Template class.",
              "lineno":662,
              "retgroups":[{
                  "1":{
                    "text":"",
                    "type":"Template",
                    "mods":{
                      "type":"Template"
                    }
                  },
                  "g":0
                }],
              "args":"(tmpl)",
              "section":"Template",
              "name":"Template",
              "params":{
                "map":{
                  "tmpl":" the template string"
                },
                "1":"tmpl"
              },
              "tags":[],
              "kind":"template ",
              "description":"\n This is a shortcut to `Template.new(tmpl)`.",
              "type":"function",
              "ret":[""],
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[[]],
                "param":{
                  "1":{
                    "type":"table"
                  },
                  "tbl":{
                    "type":"table"
                  }
                }
              },
              "summary":"substitute values into a template, throwing an error.",
              "lineno":674,
              "retgroups":[{
                  "1":{
                    "text":"string with place holders substituted",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(tbl)",
              "type":"function",
              "name":"Template:substitute",
              "parameter":"param",
              "params":{
                "map":{
                  "tbl":" a table of name-value pairs."
                },
                "1":"tbl"
              },
              "tags":[],
              "kind":"template ",
              "section":"Template",
              "description":"\n This will throw an error if no name is found.",
              "ret":["string with place holders substituted"]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[[]],
                "param":{
                  "1":{
                    "type":"table"
                  },
                  "tbl":{
                    "type":"table"
                  }
                }
              },
              "summary":"substitute values into a template.",
              "lineno":683,
              "retgroups":[{
                  "1":{
                    "text":"string with place holders substituted",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(tbl)",
              "type":"function",
              "name":"Template:safe_substitute",
              "parameter":"param",
              "params":{
                "map":{
                  "tbl":" a table of name-value pairs."
                },
                "1":"tbl"
              },
              "tags":[],
              "kind":"template ",
              "section":"Template",
              "description":"\n This version just passes unknown names through.",
              "ret":["string with place holders substituted"]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[[]],
                "param":{
                  "1":{
                    "type":"table"
                  },
                  "tbl":{
                    "type":"table"
                  }
                }
              },
              "summary":"substitute values into a template, preserving indentation.",
              "lineno":695,
              "retgroups":[{
                  "1":{
                    "text":"string with place holders substituted",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(tbl)",
              "type":"function",
              "name":"Template:indent_substitute",
              "parameter":"param",
              "params":{
                "map":{
                  "tbl":" a table of name-value pairs."
                },
                "1":"tbl"
              },
              "tags":[],
              "kind":"template ",
              "section":"Template",
              "description":" <br>\n If the value is a multiline string _or_ a template, it will insert\n the lines at the correct indentation. <br>\n Furthermore, if a template, then that template will be substituted\n using the same table.",
              "ret":["string with place holders substituted"]
            },{
              "name":"misc",
              "inferred":true,
              "description":"",
              "file":"<reference cycle>",
              "summary":"",
              "tags":[],
              "lineno":742,
              "display_name":"Miscelaneous",
              "type":"section",
              "modifiers":[]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[]],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "s":{
                    "type":"string"
                  }
                },
                "return":[[]]
              },
              "summary":"return an iterator over all lines in a string",
              "lineno":751,
              "retgroups":[{
                  "1":{
                    "text":"an iterator",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s)",
              "usage":["local line_no = 1\nfor line in stringx.lines(some_text) do\n  print(line_no, line)\n  line_no = line_no + 1\nend\n"],
              "type":"function",
              "name":"lines",
              "parameter":"param",
              "params":{
                "map":{
                  "s":" the string"
                },
                "1":"s"
              },
              "tags":[],
              "kind":"miscelaneous ",
              "section":"Miscelaneous",
              "description":"",
              "ret":["an iterator"]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[]],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "s":{
                    "type":"string"
                  }
                },
                "return":[[]]
              },
              "summary":"inital word letters uppercase ('title case').",
              "lineno":762,
              "retgroups":[{
                  "1":{
                    "text":"a string with each word's first letter uppercase",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s)",
              "usage":["stringx.title(\"hello world\") == \"Hello World\")\n"],
              "type":"function",
              "name":"title",
              "parameter":"param",
              "params":{
                "map":{
                  "s":" the string"
                },
                "1":"s"
              },
              "tags":[],
              "kind":"miscelaneous ",
              "section":"Miscelaneous",
              "description":"\n Here 'words' mean chunks of non-space characters.",
              "ret":["a string with each word's first letter uppercase"]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[],[],[]],
                "return":[],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "type":"int"
                  },
                  "3":{
                    "type":"bool"
                  },
                  "tail":{
                    "type":"bool"
                  },
                  "s":{
                    "type":"string"
                  },
                  "w":{
                    "type":"int"
                  }
                }
              },
              "summary":"Return a shortened version of a string.",
              "lineno":783,
              "args":"(s, w, tail)",
              "usage":["('1234567890'):shorten(8) == '12345...'\n","('1234567890'):shorten(8, true) == '...67890'\n","('1234567890'):shorten(20) == '1234567890'\n"],
              "section":"Miscelaneous",
              "name":"shorten",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"w",
                "map":{
                  "tail":" true if we want to show the end of the string (head otherwise)",
                  "s":" the string",
                  "w":" the maxinum size allowed"
                },
                "3":"tail"
              },
              "tags":[],
              "kind":"miscelaneous ",
              "description":"\n Fits string within w characters. Removed characters are marked with ellipsis.",
              "type":"function"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[[]],
                "param":{
                  "1":[],
                  "s":[]
                }
              },
              "summary":"Quote the given string and preserve any control or escape characters, such that reloading the string in Lua returns the same result.",
              "lineno":822,
              "retgroups":[{
                  "1":{
                    "text":"The quoted string.",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s)",
              "type":"function",
              "name":"quote_string",
              "parameter":"param",
              "params":{
                "map":{
                  "s":" The string to be quoted."
                },
                "1":"s"
              },
              "tags":[],
              "kind":"miscelaneous ",
              "section":"Miscelaneous",
              "description":"",
              "ret":["The quoted string."]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":[],
                "usage":[[]]
              },
              "summary":"Python-style formatting operator.",
              "lineno":873,
              "args":"()",
              "usage":["require 'pl.text'.format_operator()\nlocal out1 = '%s = %5.3f' % {'PI',math.pi}                   --> 'PI = 3.142'\nlocal out2 = '$name = $value' % {name='dog',value='Pluto'}   --> 'dog = Pluto'\n"],
              "section":"Miscelaneous",
              "name":"format_operator",
              "parameter":"param",
              "params":{
                "map":[]
              },
              "tags":[],
              "kind":"miscelaneous ",
              "description":"\n Calling `text.format_operator()` overloads the % operator for strings to give\n Python/Ruby style formated output.\n This is extended to also do template-like substitution for map-like data.\n\n Note this goes further than the original, and will allow these cases:\n\n 1. a single value\n 2. a list of values\n 3. a map of var=value pairs\n 4. a function, as in gsub\n\n For the second two cases, it uses $-variable substituion.\n\n When called, this function will monkey-patch the global `string` metatable by\n adding a `__mod` method.\n\n See <a href=\"http://lua-users.org/wiki/StringInterpolation\">the lua-users wiki</a>\n",
              "type":"function"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "param":[],
                "return":[]
              },
              "summary":"import the stringx functions into the global string (meta)table",
              "lineno":913,
              "args":"()",
              "section":"Miscelaneous",
              "name":"import",
              "params":{
                "map":[]
              },
              "tags":[],
              "kind":"miscelaneous ",
              "description":"",
              "type":"function",
              "parameter":"param"
            }],
          "sections":[],
          "modules":["<reference cycle>"],
          "args":{
            "one":false,
            "module":false,
            "verbose":false,
            "style":"!",
            "template":"!",
            "date":"system",
            "dir":"doc",
            "quiet":false,
            "all":false,
            "ignore":false,
            "colon":false,
            "not_luadoc":false,
            "ext":"html",
            "boilerplate":false,
            "merge":false,
            "filter":"f.filter",
            "package":"/home/cji/portless/Penlight/lua",
            "dump":false,
            "no_args_infer":false,
            "title":"Reference",
            "project":"ldoc",
            "file":"/home/cji/portless/Penlight/lua/pl",
            "format":"discount",
            "simple":false,
            "tags":"none",
            "define":"none",
            "output":"index",
            "unqualified":false,
            "config":"config.ld",
            "fatalwarnings":false,
            "testing":false
          },
          "error":"<type 'function' is not supported by JSON.>",
          "lang":{
            "line_comment":"^%-%-+",
            "start_comment_":"^%-%-%-+",
            "end_comment_":"[^%-]%-%-+[^-]*\n$",
            "extra":[],
            "block_comment":"^%-%-%[=*%[%-+",
            "empty_comment_":"^%-%-%-+%s*$",
            "method_call":":"
          },
          "base":"/home/cji/portless/Penlight/lua"
        },
        "summary":"",
        "tags":[],
        "lineno":500,
        "display_name":"Text handling",
        "type":"section",
        "modifiers":[]
      },
      "String_Predicates":{
        "name":"predicates",
        "inferred":true,
        "description":"",
        "file":{
          "warning":"<type 'function' is not supported by JSON.>",
          "filename":"/home/cji/portless/Penlight/lua/pl/stringx.lua",
          "items":["<reference cycle>","<reference cycle>",{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "s":{
                    "type":"string"
                  }
                }
              },
              "summary":"does s only contain alphabetic characters?",
              "lineno":55,
              "args":"(s)",
              "section":"String Predicates",
              "name":"isalpha",
              "params":{
                "map":{
                  "s":" a string"
                },
                "1":"s"
              },
              "tags":[],
              "kind":"string predicates ",
              "description":"",
              "type":"function",
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "s":{
                    "type":"string"
                  }
                }
              },
              "summary":"does s only contain digits?",
              "lineno":62,
              "args":"(s)",
              "section":"String Predicates",
              "name":"isdigit",
              "params":{
                "map":{
                  "s":" a string"
                },
                "1":"s"
              },
              "tags":[],
              "kind":"string predicates ",
              "description":"",
              "type":"function",
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "s":{
                    "type":"string"
                  }
                }
              },
              "summary":"does s only contain alphanumeric characters?",
              "lineno":69,
              "args":"(s)",
              "section":"String Predicates",
              "name":"isalnum",
              "params":{
                "map":{
                  "s":" a string"
                },
                "1":"s"
              },
              "tags":[],
              "kind":"string predicates ",
              "description":"",
              "type":"function",
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "s":{
                    "type":"string"
                  }
                }
              },
              "summary":"does s only contain whitespace?",
              "lineno":77,
              "args":"(s)",
              "section":"String Predicates",
              "name":"isspace",
              "params":{
                "map":{
                  "s":" a string"
                },
                "1":"s"
              },
              "tags":[],
              "kind":"string predicates ",
              "description":"\n Matches on pattern '%s' so matches space, newline, tabs, etc.",
              "type":"function",
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "s":{
                    "type":"string"
                  }
                }
              },
              "summary":"does s only contain lower case characters?",
              "lineno":84,
              "args":"(s)",
              "section":"String Predicates",
              "name":"islower",
              "params":{
                "map":{
                  "s":" a string"
                },
                "1":"s"
              },
              "tags":[],
              "kind":"string predicates ",
              "description":"",
              "type":"function",
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "s":{
                    "type":"string"
                  }
                }
              },
              "summary":"does s only contain upper case characters?",
              "lineno":91,
              "args":"(s)",
              "section":"String Predicates",
              "name":"isupper",
              "params":{
                "map":{
                  "s":" a string"
                },
                "1":"s"
              },
              "tags":[],
              "kind":"string predicates ",
              "description":"",
              "type":"function",
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":[],
                  "s":{
                    "type":"string"
                  },
                  "prefix":[]
                }
              },
              "summary":"does s start with prefix or one of prefixes?",
              "lineno":120,
              "args":"(s, prefix)",
              "section":"String Predicates",
              "name":"startswith",
              "params":{
                "1":"s",
                "2":"prefix",
                "map":{
                  "s":" a string",
                  "prefix":" a string or an array of strings"
                }
              },
              "tags":[],
              "kind":"string predicates ",
              "description":"",
              "type":"function",
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":[],
                  "s":{
                    "type":"string"
                  },
                  "suffix":[]
                }
              },
              "summary":"does s end with suffix or one of suffixes?",
              "lineno":128,
              "args":"(s, suffix)",
              "section":"String Predicates",
              "name":"endswith",
              "params":{
                "1":"s",
                "2":"suffix",
                "map":{
                  "s":" a string",
                  "suffix":" a string or an array of strings"
                }
              },
              "tags":[],
              "kind":"string predicates ",
              "description":"",
              "type":"function",
              "parameter":"param"
            },{
              "name":"lists",
              "inferred":true,
              "description":"",
              "file":"<reference cycle>",
              "summary":"",
              "tags":[],
              "lineno":136,
              "display_name":"Strings and Lists",
              "type":"section",
              "modifiers":[]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[]],
                "return":[],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":[],
                  "s":{
                    "type":"string"
                  },
                  "seq":[]
                }
              },
              "summary":"concatenate the strings using this string as a delimiter.",
              "lineno":141,
              "args":"(s, seq)",
              "usage":["stringx.join(' ', {1,2,3}) == '1 2 3'\n"],
              "section":"Strings and Lists",
              "name":"join",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"seq",
                "map":{
                  "s":" the string",
                  "seq":" a table of strings or numbers"
                }
              },
              "tags":[],
              "kind":"strings and lists ",
              "description":"\n Note that the arguments are reversed from `string.concat`.",
              "type":"function"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[[]],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "opt":true,
                    "type":"bool",
                    "optchain":true
                  },
                  "s":{
                    "type":"string"
                  },
                  "keep_ends":{
                    "opt":true,
                    "type":"bool",
                    "optchain":true
                  }
                }
              },
              "summary":"Split a string into a list of lines.",
              "lineno":154,
              "retgroups":[{
                  "1":{
                    "text":"List of lines",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s[, keep_ends])",
              "type":"function",
              "name":"splitlines",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"keep_ends",
                "map":{
                  "s":" the string.",
                  "keep_ends":" include line ends."
                }
              },
              "tags":[],
              "kind":"strings and lists ",
              "section":"Strings and Lists",
              "description":"\n `\"\\r\"`, `\"\\n\"`, and `\"\\r\\n\"` are considered line ends.\n They are not included in the lines unless `keepends` is passed.\n Terminal line end does not produce an extra line.\n Splitting an empty string results in an empty list.",
              "ret":["List of lines"]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[],[],[]],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "opt":true,
                    "type":"string",
                    "optchain":true
                  },
                  "3":{
                    "opt":true,
                    "type":"int",
                    "optchain":true
                  },
                  "re":{
                    "opt":true,
                    "type":"string",
                    "optchain":true
                  },
                  "n":{
                    "opt":true,
                    "type":"int",
                    "optchain":true
                  },
                  "s":{
                    "type":"string"
                  }
                },
                "return":[[]]
              },
              "summary":"split a string into a list of strings using a delimiter.",
              "lineno":193,
              "retgroups":[{
                  "1":{
                    "text":"List",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s[, re[, n]])",
              "usage":["#(stringx.split('one two')) == 2\n","stringx.split('one,two,three', ',') == List{'one','two','three'}\n","stringx.split('one,two,three', ',', 2) == List{'one','two,three'}\n"],
              "type":"function",
              "name":"split",
              "params":{
                "1":"s",
                "2":"re",
                "map":{
                  "re":" a delimiter (defaults to whitespace)",
                  "n":" maximum number of results",
                  "s":" the string"
                },
                "3":"n"
              },
              "tags":[],
              "kind":"strings and lists ",
              "section":"Strings and Lists",
              "description":"",
              "ret":["List"],
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[],[]],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "type":"int"
                  },
                  "s":{
                    "type":"string"
                  },
                  "tabsize":{
                    "type":"int"
                  }
                },
                "return":[[]]
              },
              "summary":"replace all tabs in s with tabsize spaces.",
              "lineno":216,
              "retgroups":[{
                  "1":{
                    "text":"expanded string",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s, tabsize)",
              "usage":["stringx.expandtabs('\\tone,two,three', 4)   == '    one,two,three'\n","stringx.expandtabs('  \\tone,two,three', 4) == '    one,two,three'\n"],
              "type":"function",
              "name":"expandtabs",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"tabsize",
                "map":{
                  "s":" the string",
                  "tabsize":"[opt=8] number of spaces to expand each tab"
                }
              },
              "tags":[],
              "kind":"strings and lists ",
              "section":"Strings and Lists",
              "description":" If not specified, tabsize defaults to 8.\n Tab stops will be honored.",
              "ret":["expanded string"]
            },{
              "name":"find",
              "inferred":true,
              "description":"",
              "file":"<reference cycle>",
              "summary":"",
              "tags":[],
              "lineno":231,
              "display_name":"Finding and Replacing",
              "type":"section",
              "modifiers":[]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[[]],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "type":"string"
                  },
                  "3":{
                    "opt":true,
                    "type":"int",
                    "optchain":true
                  },
                  "4":{
                    "opt":true,
                    "type":"int",
                    "optchain":true
                  },
                  "first":{
                    "opt":true,
                    "type":"int",
                    "optchain":true
                  },
                  "sub":{
                    "type":"string"
                  },
                  "s":{
                    "type":"string"
                  },
                  "last":{
                    "opt":true,
                    "type":"int",
                    "optchain":true
                  }
                }
              },
              "summary":"find index of first instance of sub in s from the left.",
              "lineno":257,
              "retgroups":[{
                  "1":{
                    "text":"start index, or nil if not found",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s, sub[, first[, last]])",
              "type":"function",
              "name":"lfind",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"sub",
                "3":"first",
                "4":"last",
                "map":{
                  "first":" first index",
                  "sub":" substring",
                  "s":" the string",
                  "last":" last index"
                }
              },
              "tags":[],
              "kind":"finding and replacing ",
              "section":"Finding and Replacing",
              "description":"",
              "ret":["start index, or nil if not found"]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[[]],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "type":"string"
                  },
                  "3":{
                    "opt":true,
                    "type":"int",
                    "optchain":true
                  },
                  "4":{
                    "opt":true,
                    "type":"int",
                    "optchain":true
                  },
                  "first":{
                    "opt":true,
                    "type":"int",
                    "optchain":true
                  },
                  "sub":{
                    "type":"string"
                  },
                  "s":{
                    "type":"string"
                  },
                  "last":{
                    "opt":true,
                    "type":"int",
                    "optchain":true
                  }
                }
              },
              "summary":"find index of first instance of sub in s from the right.",
              "lineno":275,
              "retgroups":[{
                  "1":{
                    "text":"start index, or nil if not found",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s, sub[, first[, last]])",
              "type":"function",
              "name":"rfind",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"sub",
                "3":"first",
                "4":"last",
                "map":{
                  "first":" first index",
                  "sub":" substring",
                  "s":" the string",
                  "last":" last index"
                }
              },
              "tags":[],
              "kind":"finding and replacing ",
              "section":"Finding and Replacing",
              "description":"",
              "ret":["start index, or nil if not found"]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[[]],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "type":"string"
                  },
                  "3":{
                    "type":"string"
                  },
                  "4":{
                    "opt":true,
                    "type":"int",
                    "optchain":true
                  },
                  "n":{
                    "opt":true,
                    "type":"int",
                    "optchain":true
                  },
                  "old":{
                    "type":"string"
                  },
                  "s":{
                    "type":"string"
                  },
                  "new":{
                    "type":"string"
                  }
                }
              },
              "summary":"replace up to n instances of old by new in the string s.",
              "lineno":288,
              "retgroups":[{
                  "1":{
                    "text":"result string",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s, old, new[, n])",
              "type":"function",
              "name":"replace",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"old",
                "3":"new",
                "4":"n",
                "map":{
                  "n":" optional maximum number of substitutions",
                  "old":" the target substring",
                  "s":" the string",
                  "new":" the substitution"
                }
              },
              "tags":[],
              "kind":"finding and replacing ",
              "section":"Finding and Replacing",
              "description":"\n If n is not present, replace all instances.",
              "ret":["result string"]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[]],
                "return":[],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "type":"string"
                  },
                  "3":{
                    "opt":true,
                    "type":"bool",
                    "optchain":true
                  },
                  "sub":{
                    "type":"string"
                  },
                  "s":{
                    "type":"string"
                  },
                  "allow_overlap":{
                    "opt":true,
                    "type":"bool",
                    "optchain":true
                  }
                }
              },
              "summary":"count all instances of substring in string.",
              "lineno":302,
              "args":"(s, sub[, allow_overlap])",
              "usage":["assert(stringx.count('banana', 'ana') == 1)\nassert(stringx.count('banana', 'ana', true) == 2)\n"],
              "section":"Finding and Replacing",
              "name":"count",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"sub",
                "map":{
                  "sub":" substring",
                  "s":" the string",
                  "allow_overlap":" allow matches to overlap"
                },
                "3":"allow_overlap"
              },
              "tags":[],
              "kind":"finding and replacing ",
              "description":"",
              "type":"function"
            },{
              "name":"strip",
              "inferred":true,
              "description":"",
              "file":"<reference cycle>",
              "summary":"",
              "tags":[],
              "lineno":311,
              "display_name":"Stripping and Justifying",
              "type":"section",
              "modifiers":[]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[]],
                "return":[],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "type":"int"
                  },
                  "3":{
                    "opt":"' '",
                    "type":"string",
                    "optchain":"' '"
                  },
                  "ch":{
                    "opt":"' '",
                    "type":"string",
                    "optchain":"' '"
                  },
                  "s":{
                    "type":"string"
                  },
                  "w":{
                    "type":"int"
                  }
                }
              },
              "summary":"left-justify s with width w.",
              "lineno":339,
              "args":"(s, w[, ch=' '])",
              "usage":["stringx.ljust('hello', 10, '*') == '*****hello'\n"],
              "section":"Stripping and Justifying",
              "name":"ljust",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"w",
                "map":{
                  "ch":" padding character",
                  "s":" the string",
                  "w":" width of justification"
                },
                "3":"ch"
              },
              "tags":[],
              "kind":"stripping and justifying ",
              "description":"",
              "type":"function"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[]],
                "return":[],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "type":"int"
                  },
                  "3":{
                    "opt":"' '",
                    "type":"string",
                    "optchain":"' '"
                  },
                  "ch":{
                    "opt":"' '",
                    "type":"string",
                    "optchain":"' '"
                  },
                  "s":{
                    "type":"string"
                  },
                  "w":{
                    "type":"int"
                  }
                }
              },
              "summary":"right-justify s with width w.",
              "lineno":350,
              "args":"(s, w[, ch=' '])",
              "usage":["stringx.rjust('hello', 10, '*') == 'hello*****'\n"],
              "section":"Stripping and Justifying",
              "name":"rjust",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"w",
                "map":{
                  "ch":" padding character",
                  "s":" the string",
                  "w":" width of justification"
                },
                "3":"ch"
              },
              "tags":[],
              "kind":"stripping and justifying ",
              "description":"",
              "type":"function"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[]],
                "return":[],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "type":"int"
                  },
                  "3":{
                    "opt":"' '",
                    "type":"string",
                    "optchain":"' '"
                  },
                  "ch":{
                    "opt":"' '",
                    "type":"string",
                    "optchain":"' '"
                  },
                  "s":{
                    "type":"string"
                  },
                  "w":{
                    "type":"int"
                  }
                }
              },
              "summary":"center-justify s with width w.",
              "lineno":361,
              "args":"(s, w[, ch=' '])",
              "usage":["stringx.center('hello', 10, '*') == '**hello***'\n"],
              "section":"Stripping and Justifying",
              "name":"center",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"w",
                "map":{
                  "ch":" padding character",
                  "s":" the string",
                  "w":" width of justification"
                },
                "3":"ch"
              },
              "tags":[],
              "kind":"stripping and justifying ",
              "description":"",
              "type":"function"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "opt":"'%s'",
                    "type":"string",
                    "optchain":"'%s'"
                  },
                  "s":{
                    "type":"string"
                  },
                  "chrs":{
                    "opt":"'%s'",
                    "type":"string",
                    "optchain":"'%s'"
                  }
                }
              },
              "summary":"trim any characters on the left of s.",
              "lineno":402,
              "args":"(s[, chrs='%s'])",
              "section":"Stripping and Justifying",
              "name":"lstrip",
              "params":{
                "1":"s",
                "2":"chrs",
                "map":{
                  "s":" the string",
                  "chrs":" default any whitespace character,\n but can be a string of characters to be trimmed"
                }
              },
              "tags":[],
              "kind":"stripping and justifying ",
              "description":"",
              "type":"function",
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "opt":"'%s'",
                    "type":"string",
                    "optchain":"'%s'"
                  },
                  "s":{
                    "type":"string"
                  },
                  "chrs":{
                    "opt":"'%s'",
                    "type":"string",
                    "optchain":"'%s'"
                  }
                }
              },
              "summary":"trim any characters on the right of s.",
              "lineno":412,
              "args":"(s[, chrs='%s'])",
              "section":"Stripping and Justifying",
              "name":"rstrip",
              "params":{
                "1":"s",
                "2":"chrs",
                "map":{
                  "s":" the string",
                  "chrs":" default any whitespace character,\n but can be a string of characters to be trimmed"
                }
              },
              "tags":[],
              "kind":"stripping and justifying ",
              "description":"",
              "type":"function",
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[]],
                "return":[],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "opt":"'%s'",
                    "type":"string",
                    "optchain":"'%s'"
                  },
                  "s":{
                    "type":"string"
                  },
                  "chrs":{
                    "opt":"'%s'",
                    "type":"string",
                    "optchain":"'%s'"
                  }
                }
              },
              "summary":"trim any characters on both left and right of s.",
              "lineno":422,
              "args":"(s[, chrs='%s'])",
              "usage":["stringx.strip('  --== Hello ==--  ', \"- =\")  --> 'Hello'\n"],
              "section":"Stripping and Justifying",
              "name":"strip",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"chrs",
                "map":{
                  "s":" the string",
                  "chrs":" default any whitespace character,\n but can be a string of characters to be trimmed"
                }
              },
              "tags":[],
              "kind":"stripping and justifying ",
              "description":"",
              "type":"function"
            },{
              "name":"partitioning",
              "inferred":true,
              "description":"",
              "file":"<reference cycle>",
              "summary":"",
              "tags":[],
              "lineno":430,
              "display_name":"Partitioning Strings",
              "type":"section",
              "modifiers":[]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "opt":"'%s'",
                    "type":"string",
                    "optchain":"'%s'"
                  },
                  "s":{
                    "type":"string"
                  },
                  "re":{
                    "opt":"'%s'",
                    "type":"string",
                    "optchain":"'%s'"
                  }
                },
                "return":[[]],
                "usage":[[]],
                "see":[[]]
              },
              "summary":"split a string using a pattern.",
              "lineno":436,
              "retgroups":[{
                  "1":{
                    "text":"the parts of the string",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s[, re='%s'])",
              "usage":["a,b = line:splitv('=')\n"],
              "type":"function",
              "name":"splitv",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"re",
                "map":{
                  "s":" the string",
                  "re":" a Lua string pattern (defaults to whitespace)"
                }
              },
              "tags":{
                "see":[]
              },
              "kind":"partitioning strings ",
              "section":"Partitioning Strings",
              "description":" Note that at least one value will be returned!",
              "ret":["the parts of the string"]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[],[]],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "type":"string"
                  },
                  "s":{
                    "type":"string"
                  },
                  "ch":{
                    "type":"string"
                  }
                },
                "return":[[],[],[]]
              },
              "summary":"partition the string using first occurance of a delimiter",
              "lineno":461,
              "retgroups":[{
                  "1":{
                    "text":"part before ch",
                    "type":"",
                    "mods":[]
                  },
                  "2":{
                    "text":"ch",
                    "type":"",
                    "mods":[]
                  },
                  "3":{
                    "text":"part after ch",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s, ch)",
              "usage":["{stringx.partition('a,b,c', ','))} == {'a', ',', 'b,c'}\n","{stringx.partition('abc', 'x'))} == {'abc', '', ''}\n"],
              "type":"function",
              "name":"partition",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"ch",
                "map":{
                  "s":" the string",
                  "ch":" delimiter (match as plain string, no patterns)"
                }
              },
              "tags":[],
              "kind":"partitioning strings ",
              "section":"Partitioning Strings",
              "description":"",
              "ret":["part before ch","ch","part after ch"]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[],[]],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "type":"string"
                  },
                  "s":{
                    "type":"string"
                  },
                  "ch":{
                    "type":"string"
                  }
                },
                "return":[[],[],[]]
              },
              "summary":"partition the string p using last occurance of a delimiter",
              "lineno":475,
              "retgroups":[{
                  "1":{
                    "text":"part before ch",
                    "type":"",
                    "mods":[]
                  },
                  "2":{
                    "text":"ch",
                    "type":"",
                    "mods":[]
                  },
                  "3":{
                    "text":"part after ch",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s, ch)",
              "usage":["{stringx.rpartition('a,b,c', ','))} == {'a,b', ',', 'c'}\n","{stringx.rpartition('abc', 'x'))} == {'', '', 'abc'}\n"],
              "type":"function",
              "name":"rpartition",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"ch",
                "map":{
                  "s":" the string",
                  "ch":" delimiter (match as plain string, no patterns)"
                }
              },
              "tags":[],
              "kind":"partitioning strings ",
              "section":"Partitioning Strings",
              "description":"",
              "ret":["part before ch","ch","part after ch"]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[[]],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "type":"int"
                  },
                  "s":{
                    "type":"string"
                  },
                  "idx":{
                    "type":"int"
                  }
                }
              },
              "summary":"return the 'character' at the index.",
              "lineno":489,
              "retgroups":[{
                  "1":{
                    "text":"a substring of length 1 if successful, empty string otherwise.",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s, idx)",
              "type":"function",
              "name":"at",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"idx",
                "map":{
                  "s":" the string",
                  "idx":" an index (can be negative)"
                }
              },
              "tags":[],
              "kind":"partitioning strings ",
              "section":"Partitioning Strings",
              "description":"",
              "ret":["a substring of length 1 if successful, empty string otherwise."]
            },{
              "name":"text",
              "inferred":true,
              "description":"",
              "file":"<reference cycle>",
              "summary":"",
              "tags":[],
              "lineno":500,
              "display_name":"Text handling",
              "type":"section",
              "modifiers":[]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[[]],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "type":"integer"
                  },
                  "3":{
                    "opt":"' '",
                    "type":"string",
                    "optchain":"' '"
                  },
                  "ch":{
                    "opt":"' '",
                    "type":"string",
                    "optchain":"' '"
                  },
                  "n":{
                    "type":"integer"
                  },
                  "s":{
                    "type":"string"
                  }
                }
              },
              "summary":"indent a multiline string.",
              "lineno":505,
              "retgroups":[{
                  "1":{
                    "text":"indented string",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s, n[, ch=' '])",
              "type":"function",
              "name":"indent",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"n",
                "map":{
                  "ch":" the character to use when indenting",
                  "n":" the size of the indent",
                  "s":" the (multiline) string"
                },
                "3":"ch"
              },
              "tags":[],
              "kind":"text handling ",
              "section":"Text handling",
              "description":"",
              "ret":["indented string"]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[]],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "s":{
                    "type":"string"
                  }
                },
                "return":[[]]
              },
              "summary":"dedent a multiline string by removing any initial indent.",
              "lineno":537,
              "retgroups":[{
                  "1":{
                    "text":"a string with initial indent zero.",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s)",
              "usage":["local s = dedent [[\n         One\n\n       Two\n\n     Three\n]]\nassert(s == [[\n    One\n\n  Two\n\nThree\n]])\n"],
              "type":"function",
              "name":"dedent",
              "parameter":"param",
              "params":{
                "map":{
                  "s":" the (multiline) string"
                },
                "1":"s"
              },
              "tags":[],
              "kind":"text handling ",
              "section":"Text handling",
              "description":"\n useful when working with [[..]] strings.\n Empty lines are ignored.",
              "ret":["a string with initial indent zero."]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "opt":"70",
                    "type":"integer",
                    "optchain":"70"
                  },
                  "3":{
                    "opt":"false",
                    "type":"boolean",
                    "optchain":"false"
                  },
                  "width":{
                    "opt":"70",
                    "type":"integer",
                    "optchain":"70"
                  },
                  "s":{
                    "type":"string"
                  },
                  "breaklong":{
                    "opt":"false",
                    "type":"boolean",
                    "optchain":"false"
                  }
                },
                "return":[[]],
                "see":[[],[]]
              },
              "summary":"format a paragraph into lines so that they fit into a line width.",
              "lineno":594,
              "retgroups":[{
                  "1":{
                    "text":"a list of lines (List object), use `fill` to return a string instead of a `List`.",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s[, width=70[, breaklong=false]])",
              "type":"function",
              "name":"wrap",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"width",
                "map":{
                  "width":" the margin width",
                  "s":" the string to format",
                  "breaklong":" if truthy, words longer than the width given will be forced split."
                },
                "3":"breaklong"
              },
              "tags":{
                "see":[]
              },
              "kind":"text handling ",
              "section":"Text handling",
              "description":"\n It will not break long words by default, so lines can be over the length\n to that extent.",
              "ret":["a list of lines (List object), use `fill` to return a string instead of a `List`."]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "opt":"70",
                    "type":"integer",
                    "optchain":"70"
                  },
                  "3":{
                    "opt":"false",
                    "type":"boolean",
                    "optchain":"false"
                  },
                  "width":{
                    "opt":"70",
                    "type":"integer",
                    "optchain":"70"
                  },
                  "s":{
                    "type":"string"
                  },
                  "breaklong":{
                    "opt":"false",
                    "type":"boolean",
                    "optchain":"false"
                  }
                },
                "return":[[]],
                "see":[[]]
              },
              "summary":"format a paragraph so that it fits into a line width.",
              "lineno":616,
              "retgroups":[{
                  "1":{
                    "text":"a string, use `wrap` to return a list of lines instead of a string.",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s[, width=70[, breaklong=false]])",
              "type":"function",
              "name":"fill",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"width",
                "map":{
                  "width":" the margin width",
                  "s":" the string to format",
                  "breaklong":" if truthy, words longer than the width given will be forced split."
                },
                "3":"breaklong"
              },
              "tags":{
                "see":[]
              },
              "kind":"text handling ",
              "section":"Text handling",
              "description":"",
              "ret":["a string, use `wrap` to return a list of lines instead of a string."]
            },{
              "name":"Template",
              "inferred":true,
              "description":"",
              "file":"<reference cycle>",
              "summary":"",
              "tags":[],
              "lineno":624,
              "display_name":"Template",
              "type":"section",
              "modifiers":[]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "tmpl":{
                    "type":"string"
                  }
                },
                "return":[{
                    "type":"Template"
                  }]
              },
              "summary":"Creates a new Template class.",
              "lineno":662,
              "retgroups":[{
                  "1":{
                    "text":"",
                    "type":"Template",
                    "mods":{
                      "type":"Template"
                    }
                  },
                  "g":0
                }],
              "args":"(tmpl)",
              "section":"Template",
              "name":"Template",
              "params":{
                "map":{
                  "tmpl":" the template string"
                },
                "1":"tmpl"
              },
              "tags":[],
              "kind":"template ",
              "description":"\n This is a shortcut to `Template.new(tmpl)`.",
              "type":"function",
              "ret":[""],
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[[]],
                "param":{
                  "1":{
                    "type":"table"
                  },
                  "tbl":{
                    "type":"table"
                  }
                }
              },
              "summary":"substitute values into a template, throwing an error.",
              "lineno":674,
              "retgroups":[{
                  "1":{
                    "text":"string with place holders substituted",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(tbl)",
              "type":"function",
              "name":"Template:substitute",
              "parameter":"param",
              "params":{
                "map":{
                  "tbl":" a table of name-value pairs."
                },
                "1":"tbl"
              },
              "tags":[],
              "kind":"template ",
              "section":"Template",
              "description":"\n This will throw an error if no name is found.",
              "ret":["string with place holders substituted"]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[[]],
                "param":{
                  "1":{
                    "type":"table"
                  },
                  "tbl":{
                    "type":"table"
                  }
                }
              },
              "summary":"substitute values into a template.",
              "lineno":683,
              "retgroups":[{
                  "1":{
                    "text":"string with place holders substituted",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(tbl)",
              "type":"function",
              "name":"Template:safe_substitute",
              "parameter":"param",
              "params":{
                "map":{
                  "tbl":" a table of name-value pairs."
                },
                "1":"tbl"
              },
              "tags":[],
              "kind":"template ",
              "section":"Template",
              "description":"\n This version just passes unknown names through.",
              "ret":["string with place holders substituted"]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[[]],
                "param":{
                  "1":{
                    "type":"table"
                  },
                  "tbl":{
                    "type":"table"
                  }
                }
              },
              "summary":"substitute values into a template, preserving indentation.",
              "lineno":695,
              "retgroups":[{
                  "1":{
                    "text":"string with place holders substituted",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(tbl)",
              "type":"function",
              "name":"Template:indent_substitute",
              "parameter":"param",
              "params":{
                "map":{
                  "tbl":" a table of name-value pairs."
                },
                "1":"tbl"
              },
              "tags":[],
              "kind":"template ",
              "section":"Template",
              "description":" <br>\n If the value is a multiline string _or_ a template, it will insert\n the lines at the correct indentation. <br>\n Furthermore, if a template, then that template will be substituted\n using the same table.",
              "ret":["string with place holders substituted"]
            },{
              "name":"misc",
              "inferred":true,
              "description":"",
              "file":"<reference cycle>",
              "summary":"",
              "tags":[],
              "lineno":742,
              "display_name":"Miscelaneous",
              "type":"section",
              "modifiers":[]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[]],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "s":{
                    "type":"string"
                  }
                },
                "return":[[]]
              },
              "summary":"return an iterator over all lines in a string",
              "lineno":751,
              "retgroups":[{
                  "1":{
                    "text":"an iterator",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s)",
              "usage":["local line_no = 1\nfor line in stringx.lines(some_text) do\n  print(line_no, line)\n  line_no = line_no + 1\nend\n"],
              "type":"function",
              "name":"lines",
              "parameter":"param",
              "params":{
                "map":{
                  "s":" the string"
                },
                "1":"s"
              },
              "tags":[],
              "kind":"miscelaneous ",
              "section":"Miscelaneous",
              "description":"",
              "ret":["an iterator"]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[]],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "s":{
                    "type":"string"
                  }
                },
                "return":[[]]
              },
              "summary":"inital word letters uppercase ('title case').",
              "lineno":762,
              "retgroups":[{
                  "1":{
                    "text":"a string with each word's first letter uppercase",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s)",
              "usage":["stringx.title(\"hello world\") == \"Hello World\")\n"],
              "type":"function",
              "name":"title",
              "parameter":"param",
              "params":{
                "map":{
                  "s":" the string"
                },
                "1":"s"
              },
              "tags":[],
              "kind":"miscelaneous ",
              "section":"Miscelaneous",
              "description":"\n Here 'words' mean chunks of non-space characters.",
              "ret":["a string with each word's first letter uppercase"]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[],[],[]],
                "return":[],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "type":"int"
                  },
                  "3":{
                    "type":"bool"
                  },
                  "tail":{
                    "type":"bool"
                  },
                  "s":{
                    "type":"string"
                  },
                  "w":{
                    "type":"int"
                  }
                }
              },
              "summary":"Return a shortened version of a string.",
              "lineno":783,
              "args":"(s, w, tail)",
              "usage":["('1234567890'):shorten(8) == '12345...'\n","('1234567890'):shorten(8, true) == '...67890'\n","('1234567890'):shorten(20) == '1234567890'\n"],
              "section":"Miscelaneous",
              "name":"shorten",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"w",
                "map":{
                  "tail":" true if we want to show the end of the string (head otherwise)",
                  "s":" the string",
                  "w":" the maxinum size allowed"
                },
                "3":"tail"
              },
              "tags":[],
              "kind":"miscelaneous ",
              "description":"\n Fits string within w characters. Removed characters are marked with ellipsis.",
              "type":"function"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[[]],
                "param":{
                  "1":[],
                  "s":[]
                }
              },
              "summary":"Quote the given string and preserve any control or escape characters, such that reloading the string in Lua returns the same result.",
              "lineno":822,
              "retgroups":[{
                  "1":{
                    "text":"The quoted string.",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s)",
              "type":"function",
              "name":"quote_string",
              "parameter":"param",
              "params":{
                "map":{
                  "s":" The string to be quoted."
                },
                "1":"s"
              },
              "tags":[],
              "kind":"miscelaneous ",
              "section":"Miscelaneous",
              "description":"",
              "ret":["The quoted string."]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":[],
                "usage":[[]]
              },
              "summary":"Python-style formatting operator.",
              "lineno":873,
              "args":"()",
              "usage":["require 'pl.text'.format_operator()\nlocal out1 = '%s = %5.3f' % {'PI',math.pi}                   --> 'PI = 3.142'\nlocal out2 = '$name = $value' % {name='dog',value='Pluto'}   --> 'dog = Pluto'\n"],
              "section":"Miscelaneous",
              "name":"format_operator",
              "parameter":"param",
              "params":{
                "map":[]
              },
              "tags":[],
              "kind":"miscelaneous ",
              "description":"\n Calling `text.format_operator()` overloads the % operator for strings to give\n Python/Ruby style formated output.\n This is extended to also do template-like substitution for map-like data.\n\n Note this goes further than the original, and will allow these cases:\n\n 1. a single value\n 2. a list of values\n 3. a map of var=value pairs\n 4. a function, as in gsub\n\n For the second two cases, it uses $-variable substituion.\n\n When called, this function will monkey-patch the global `string` metatable by\n adding a `__mod` method.\n\n See <a href=\"http://lua-users.org/wiki/StringInterpolation\">the lua-users wiki</a>\n",
              "type":"function"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "param":[],
                "return":[]
              },
              "summary":"import the stringx functions into the global string (meta)table",
              "lineno":913,
              "args":"()",
              "section":"Miscelaneous",
              "name":"import",
              "params":{
                "map":[]
              },
              "tags":[],
              "kind":"miscelaneous ",
              "description":"",
              "type":"function",
              "parameter":"param"
            }],
          "sections":[],
          "modules":["<reference cycle>"],
          "args":{
            "one":false,
            "module":false,
            "verbose":false,
            "style":"!",
            "template":"!",
            "date":"system",
            "dir":"doc",
            "quiet":false,
            "all":false,
            "ignore":false,
            "colon":false,
            "not_luadoc":false,
            "ext":"html",
            "boilerplate":false,
            "merge":false,
            "filter":"f.filter",
            "package":"/home/cji/portless/Penlight/lua",
            "dump":false,
            "no_args_infer":false,
            "title":"Reference",
            "project":"ldoc",
            "file":"/home/cji/portless/Penlight/lua/pl",
            "format":"discount",
            "simple":false,
            "tags":"none",
            "define":"none",
            "output":"index",
            "unqualified":false,
            "config":"config.ld",
            "fatalwarnings":false,
            "testing":false
          },
          "error":"<type 'function' is not supported by JSON.>",
          "lang":{
            "line_comment":"^%-%-+",
            "start_comment_":"^%-%-%-+",
            "end_comment_":"[^%-]%-%-+[^-]*\n$",
            "extra":[],
            "block_comment":"^%-%-%[=*%[%-+",
            "empty_comment_":"^%-%-%-+%s*$",
            "method_call":":"
          },
          "base":"/home/cji/portless/Penlight/lua"
        },
        "summary":"",
        "tags":[],
        "lineno":53,
        "display_name":"String Predicates",
        "type":"section",
        "modifiers":[]
      },
      "Finding_and_Replacing":{
        "name":"find",
        "inferred":true,
        "description":"",
        "file":{
          "warning":"<type 'function' is not supported by JSON.>",
          "filename":"/home/cji/portless/Penlight/lua/pl/stringx.lua",
          "items":["<reference cycle>",{
              "name":"predicates",
              "inferred":true,
              "description":"",
              "file":"<reference cycle>",
              "summary":"",
              "tags":[],
              "lineno":53,
              "display_name":"String Predicates",
              "type":"section",
              "modifiers":[]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "s":{
                    "type":"string"
                  }
                }
              },
              "summary":"does s only contain alphabetic characters?",
              "lineno":55,
              "args":"(s)",
              "section":"String Predicates",
              "name":"isalpha",
              "params":{
                "map":{
                  "s":" a string"
                },
                "1":"s"
              },
              "tags":[],
              "kind":"string predicates ",
              "description":"",
              "type":"function",
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "s":{
                    "type":"string"
                  }
                }
              },
              "summary":"does s only contain digits?",
              "lineno":62,
              "args":"(s)",
              "section":"String Predicates",
              "name":"isdigit",
              "params":{
                "map":{
                  "s":" a string"
                },
                "1":"s"
              },
              "tags":[],
              "kind":"string predicates ",
              "description":"",
              "type":"function",
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "s":{
                    "type":"string"
                  }
                }
              },
              "summary":"does s only contain alphanumeric characters?",
              "lineno":69,
              "args":"(s)",
              "section":"String Predicates",
              "name":"isalnum",
              "params":{
                "map":{
                  "s":" a string"
                },
                "1":"s"
              },
              "tags":[],
              "kind":"string predicates ",
              "description":"",
              "type":"function",
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "s":{
                    "type":"string"
                  }
                }
              },
              "summary":"does s only contain whitespace?",
              "lineno":77,
              "args":"(s)",
              "section":"String Predicates",
              "name":"isspace",
              "params":{
                "map":{
                  "s":" a string"
                },
                "1":"s"
              },
              "tags":[],
              "kind":"string predicates ",
              "description":"\n Matches on pattern '%s' so matches space, newline, tabs, etc.",
              "type":"function",
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "s":{
                    "type":"string"
                  }
                }
              },
              "summary":"does s only contain lower case characters?",
              "lineno":84,
              "args":"(s)",
              "section":"String Predicates",
              "name":"islower",
              "params":{
                "map":{
                  "s":" a string"
                },
                "1":"s"
              },
              "tags":[],
              "kind":"string predicates ",
              "description":"",
              "type":"function",
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "s":{
                    "type":"string"
                  }
                }
              },
              "summary":"does s only contain upper case characters?",
              "lineno":91,
              "args":"(s)",
              "section":"String Predicates",
              "name":"isupper",
              "params":{
                "map":{
                  "s":" a string"
                },
                "1":"s"
              },
              "tags":[],
              "kind":"string predicates ",
              "description":"",
              "type":"function",
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":[],
                  "s":{
                    "type":"string"
                  },
                  "prefix":[]
                }
              },
              "summary":"does s start with prefix or one of prefixes?",
              "lineno":120,
              "args":"(s, prefix)",
              "section":"String Predicates",
              "name":"startswith",
              "params":{
                "1":"s",
                "2":"prefix",
                "map":{
                  "s":" a string",
                  "prefix":" a string or an array of strings"
                }
              },
              "tags":[],
              "kind":"string predicates ",
              "description":"",
              "type":"function",
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":[],
                  "s":{
                    "type":"string"
                  },
                  "suffix":[]
                }
              },
              "summary":"does s end with suffix or one of suffixes?",
              "lineno":128,
              "args":"(s, suffix)",
              "section":"String Predicates",
              "name":"endswith",
              "params":{
                "1":"s",
                "2":"suffix",
                "map":{
                  "s":" a string",
                  "suffix":" a string or an array of strings"
                }
              },
              "tags":[],
              "kind":"string predicates ",
              "description":"",
              "type":"function",
              "parameter":"param"
            },{
              "name":"lists",
              "inferred":true,
              "description":"",
              "file":"<reference cycle>",
              "summary":"",
              "tags":[],
              "lineno":136,
              "display_name":"Strings and Lists",
              "type":"section",
              "modifiers":[]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[]],
                "return":[],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":[],
                  "s":{
                    "type":"string"
                  },
                  "seq":[]
                }
              },
              "summary":"concatenate the strings using this string as a delimiter.",
              "lineno":141,
              "args":"(s, seq)",
              "usage":["stringx.join(' ', {1,2,3}) == '1 2 3'\n"],
              "section":"Strings and Lists",
              "name":"join",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"seq",
                "map":{
                  "s":" the string",
                  "seq":" a table of strings or numbers"
                }
              },
              "tags":[],
              "kind":"strings and lists ",
              "description":"\n Note that the arguments are reversed from `string.concat`.",
              "type":"function"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[[]],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "opt":true,
                    "type":"bool",
                    "optchain":true
                  },
                  "s":{
                    "type":"string"
                  },
                  "keep_ends":{
                    "opt":true,
                    "type":"bool",
                    "optchain":true
                  }
                }
              },
              "summary":"Split a string into a list of lines.",
              "lineno":154,
              "retgroups":[{
                  "1":{
                    "text":"List of lines",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s[, keep_ends])",
              "type":"function",
              "name":"splitlines",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"keep_ends",
                "map":{
                  "s":" the string.",
                  "keep_ends":" include line ends."
                }
              },
              "tags":[],
              "kind":"strings and lists ",
              "section":"Strings and Lists",
              "description":"\n `\"\\r\"`, `\"\\n\"`, and `\"\\r\\n\"` are considered line ends.\n They are not included in the lines unless `keepends` is passed.\n Terminal line end does not produce an extra line.\n Splitting an empty string results in an empty list.",
              "ret":["List of lines"]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[],[],[]],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "opt":true,
                    "type":"string",
                    "optchain":true
                  },
                  "3":{
                    "opt":true,
                    "type":"int",
                    "optchain":true
                  },
                  "re":{
                    "opt":true,
                    "type":"string",
                    "optchain":true
                  },
                  "n":{
                    "opt":true,
                    "type":"int",
                    "optchain":true
                  },
                  "s":{
                    "type":"string"
                  }
                },
                "return":[[]]
              },
              "summary":"split a string into a list of strings using a delimiter.",
              "lineno":193,
              "retgroups":[{
                  "1":{
                    "text":"List",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s[, re[, n]])",
              "usage":["#(stringx.split('one two')) == 2\n","stringx.split('one,two,three', ',') == List{'one','two','three'}\n","stringx.split('one,two,three', ',', 2) == List{'one','two,three'}\n"],
              "type":"function",
              "name":"split",
              "params":{
                "1":"s",
                "2":"re",
                "map":{
                  "re":" a delimiter (defaults to whitespace)",
                  "n":" maximum number of results",
                  "s":" the string"
                },
                "3":"n"
              },
              "tags":[],
              "kind":"strings and lists ",
              "section":"Strings and Lists",
              "description":"",
              "ret":["List"],
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[],[]],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "type":"int"
                  },
                  "s":{
                    "type":"string"
                  },
                  "tabsize":{
                    "type":"int"
                  }
                },
                "return":[[]]
              },
              "summary":"replace all tabs in s with tabsize spaces.",
              "lineno":216,
              "retgroups":[{
                  "1":{
                    "text":"expanded string",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s, tabsize)",
              "usage":["stringx.expandtabs('\\tone,two,three', 4)   == '    one,two,three'\n","stringx.expandtabs('  \\tone,two,three', 4) == '    one,two,three'\n"],
              "type":"function",
              "name":"expandtabs",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"tabsize",
                "map":{
                  "s":" the string",
                  "tabsize":"[opt=8] number of spaces to expand each tab"
                }
              },
              "tags":[],
              "kind":"strings and lists ",
              "section":"Strings and Lists",
              "description":" If not specified, tabsize defaults to 8.\n Tab stops will be honored.",
              "ret":["expanded string"]
            },"<reference cycle>",{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[[]],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "type":"string"
                  },
                  "3":{
                    "opt":true,
                    "type":"int",
                    "optchain":true
                  },
                  "4":{
                    "opt":true,
                    "type":"int",
                    "optchain":true
                  },
                  "first":{
                    "opt":true,
                    "type":"int",
                    "optchain":true
                  },
                  "sub":{
                    "type":"string"
                  },
                  "s":{
                    "type":"string"
                  },
                  "last":{
                    "opt":true,
                    "type":"int",
                    "optchain":true
                  }
                }
              },
              "summary":"find index of first instance of sub in s from the left.",
              "lineno":257,
              "retgroups":[{
                  "1":{
                    "text":"start index, or nil if not found",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s, sub[, first[, last]])",
              "type":"function",
              "name":"lfind",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"sub",
                "3":"first",
                "4":"last",
                "map":{
                  "first":" first index",
                  "sub":" substring",
                  "s":" the string",
                  "last":" last index"
                }
              },
              "tags":[],
              "kind":"finding and replacing ",
              "section":"Finding and Replacing",
              "description":"",
              "ret":["start index, or nil if not found"]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[[]],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "type":"string"
                  },
                  "3":{
                    "opt":true,
                    "type":"int",
                    "optchain":true
                  },
                  "4":{
                    "opt":true,
                    "type":"int",
                    "optchain":true
                  },
                  "first":{
                    "opt":true,
                    "type":"int",
                    "optchain":true
                  },
                  "sub":{
                    "type":"string"
                  },
                  "s":{
                    "type":"string"
                  },
                  "last":{
                    "opt":true,
                    "type":"int",
                    "optchain":true
                  }
                }
              },
              "summary":"find index of first instance of sub in s from the right.",
              "lineno":275,
              "retgroups":[{
                  "1":{
                    "text":"start index, or nil if not found",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s, sub[, first[, last]])",
              "type":"function",
              "name":"rfind",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"sub",
                "3":"first",
                "4":"last",
                "map":{
                  "first":" first index",
                  "sub":" substring",
                  "s":" the string",
                  "last":" last index"
                }
              },
              "tags":[],
              "kind":"finding and replacing ",
              "section":"Finding and Replacing",
              "description":"",
              "ret":["start index, or nil if not found"]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[[]],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "type":"string"
                  },
                  "3":{
                    "type":"string"
                  },
                  "4":{
                    "opt":true,
                    "type":"int",
                    "optchain":true
                  },
                  "n":{
                    "opt":true,
                    "type":"int",
                    "optchain":true
                  },
                  "old":{
                    "type":"string"
                  },
                  "s":{
                    "type":"string"
                  },
                  "new":{
                    "type":"string"
                  }
                }
              },
              "summary":"replace up to n instances of old by new in the string s.",
              "lineno":288,
              "retgroups":[{
                  "1":{
                    "text":"result string",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s, old, new[, n])",
              "type":"function",
              "name":"replace",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"old",
                "3":"new",
                "4":"n",
                "map":{
                  "n":" optional maximum number of substitutions",
                  "old":" the target substring",
                  "s":" the string",
                  "new":" the substitution"
                }
              },
              "tags":[],
              "kind":"finding and replacing ",
              "section":"Finding and Replacing",
              "description":"\n If n is not present, replace all instances.",
              "ret":["result string"]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[]],
                "return":[],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "type":"string"
                  },
                  "3":{
                    "opt":true,
                    "type":"bool",
                    "optchain":true
                  },
                  "sub":{
                    "type":"string"
                  },
                  "s":{
                    "type":"string"
                  },
                  "allow_overlap":{
                    "opt":true,
                    "type":"bool",
                    "optchain":true
                  }
                }
              },
              "summary":"count all instances of substring in string.",
              "lineno":302,
              "args":"(s, sub[, allow_overlap])",
              "usage":["assert(stringx.count('banana', 'ana') == 1)\nassert(stringx.count('banana', 'ana', true) == 2)\n"],
              "section":"Finding and Replacing",
              "name":"count",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"sub",
                "map":{
                  "sub":" substring",
                  "s":" the string",
                  "allow_overlap":" allow matches to overlap"
                },
                "3":"allow_overlap"
              },
              "tags":[],
              "kind":"finding and replacing ",
              "description":"",
              "type":"function"
            },{
              "name":"strip",
              "inferred":true,
              "description":"",
              "file":"<reference cycle>",
              "summary":"",
              "tags":[],
              "lineno":311,
              "display_name":"Stripping and Justifying",
              "type":"section",
              "modifiers":[]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[]],
                "return":[],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "type":"int"
                  },
                  "3":{
                    "opt":"' '",
                    "type":"string",
                    "optchain":"' '"
                  },
                  "ch":{
                    "opt":"' '",
                    "type":"string",
                    "optchain":"' '"
                  },
                  "s":{
                    "type":"string"
                  },
                  "w":{
                    "type":"int"
                  }
                }
              },
              "summary":"left-justify s with width w.",
              "lineno":339,
              "args":"(s, w[, ch=' '])",
              "usage":["stringx.ljust('hello', 10, '*') == '*****hello'\n"],
              "section":"Stripping and Justifying",
              "name":"ljust",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"w",
                "map":{
                  "ch":" padding character",
                  "s":" the string",
                  "w":" width of justification"
                },
                "3":"ch"
              },
              "tags":[],
              "kind":"stripping and justifying ",
              "description":"",
              "type":"function"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[]],
                "return":[],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "type":"int"
                  },
                  "3":{
                    "opt":"' '",
                    "type":"string",
                    "optchain":"' '"
                  },
                  "ch":{
                    "opt":"' '",
                    "type":"string",
                    "optchain":"' '"
                  },
                  "s":{
                    "type":"string"
                  },
                  "w":{
                    "type":"int"
                  }
                }
              },
              "summary":"right-justify s with width w.",
              "lineno":350,
              "args":"(s, w[, ch=' '])",
              "usage":["stringx.rjust('hello', 10, '*') == 'hello*****'\n"],
              "section":"Stripping and Justifying",
              "name":"rjust",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"w",
                "map":{
                  "ch":" padding character",
                  "s":" the string",
                  "w":" width of justification"
                },
                "3":"ch"
              },
              "tags":[],
              "kind":"stripping and justifying ",
              "description":"",
              "type":"function"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[]],
                "return":[],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "type":"int"
                  },
                  "3":{
                    "opt":"' '",
                    "type":"string",
                    "optchain":"' '"
                  },
                  "ch":{
                    "opt":"' '",
                    "type":"string",
                    "optchain":"' '"
                  },
                  "s":{
                    "type":"string"
                  },
                  "w":{
                    "type":"int"
                  }
                }
              },
              "summary":"center-justify s with width w.",
              "lineno":361,
              "args":"(s, w[, ch=' '])",
              "usage":["stringx.center('hello', 10, '*') == '**hello***'\n"],
              "section":"Stripping and Justifying",
              "name":"center",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"w",
                "map":{
                  "ch":" padding character",
                  "s":" the string",
                  "w":" width of justification"
                },
                "3":"ch"
              },
              "tags":[],
              "kind":"stripping and justifying ",
              "description":"",
              "type":"function"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "opt":"'%s'",
                    "type":"string",
                    "optchain":"'%s'"
                  },
                  "s":{
                    "type":"string"
                  },
                  "chrs":{
                    "opt":"'%s'",
                    "type":"string",
                    "optchain":"'%s'"
                  }
                }
              },
              "summary":"trim any characters on the left of s.",
              "lineno":402,
              "args":"(s[, chrs='%s'])",
              "section":"Stripping and Justifying",
              "name":"lstrip",
              "params":{
                "1":"s",
                "2":"chrs",
                "map":{
                  "s":" the string",
                  "chrs":" default any whitespace character,\n but can be a string of characters to be trimmed"
                }
              },
              "tags":[],
              "kind":"stripping and justifying ",
              "description":"",
              "type":"function",
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "opt":"'%s'",
                    "type":"string",
                    "optchain":"'%s'"
                  },
                  "s":{
                    "type":"string"
                  },
                  "chrs":{
                    "opt":"'%s'",
                    "type":"string",
                    "optchain":"'%s'"
                  }
                }
              },
              "summary":"trim any characters on the right of s.",
              "lineno":412,
              "args":"(s[, chrs='%s'])",
              "section":"Stripping and Justifying",
              "name":"rstrip",
              "params":{
                "1":"s",
                "2":"chrs",
                "map":{
                  "s":" the string",
                  "chrs":" default any whitespace character,\n but can be a string of characters to be trimmed"
                }
              },
              "tags":[],
              "kind":"stripping and justifying ",
              "description":"",
              "type":"function",
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[]],
                "return":[],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "opt":"'%s'",
                    "type":"string",
                    "optchain":"'%s'"
                  },
                  "s":{
                    "type":"string"
                  },
                  "chrs":{
                    "opt":"'%s'",
                    "type":"string",
                    "optchain":"'%s'"
                  }
                }
              },
              "summary":"trim any characters on both left and right of s.",
              "lineno":422,
              "args":"(s[, chrs='%s'])",
              "usage":["stringx.strip('  --== Hello ==--  ', \"- =\")  --> 'Hello'\n"],
              "section":"Stripping and Justifying",
              "name":"strip",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"chrs",
                "map":{
                  "s":" the string",
                  "chrs":" default any whitespace character,\n but can be a string of characters to be trimmed"
                }
              },
              "tags":[],
              "kind":"stripping and justifying ",
              "description":"",
              "type":"function"
            },{
              "name":"partitioning",
              "inferred":true,
              "description":"",
              "file":"<reference cycle>",
              "summary":"",
              "tags":[],
              "lineno":430,
              "display_name":"Partitioning Strings",
              "type":"section",
              "modifiers":[]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "opt":"'%s'",
                    "type":"string",
                    "optchain":"'%s'"
                  },
                  "s":{
                    "type":"string"
                  },
                  "re":{
                    "opt":"'%s'",
                    "type":"string",
                    "optchain":"'%s'"
                  }
                },
                "return":[[]],
                "usage":[[]],
                "see":[[]]
              },
              "summary":"split a string using a pattern.",
              "lineno":436,
              "retgroups":[{
                  "1":{
                    "text":"the parts of the string",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s[, re='%s'])",
              "usage":["a,b = line:splitv('=')\n"],
              "type":"function",
              "name":"splitv",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"re",
                "map":{
                  "s":" the string",
                  "re":" a Lua string pattern (defaults to whitespace)"
                }
              },
              "tags":{
                "see":[]
              },
              "kind":"partitioning strings ",
              "section":"Partitioning Strings",
              "description":" Note that at least one value will be returned!",
              "ret":["the parts of the string"]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[],[]],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "type":"string"
                  },
                  "s":{
                    "type":"string"
                  },
                  "ch":{
                    "type":"string"
                  }
                },
                "return":[[],[],[]]
              },
              "summary":"partition the string using first occurance of a delimiter",
              "lineno":461,
              "retgroups":[{
                  "1":{
                    "text":"part before ch",
                    "type":"",
                    "mods":[]
                  },
                  "2":{
                    "text":"ch",
                    "type":"",
                    "mods":[]
                  },
                  "3":{
                    "text":"part after ch",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s, ch)",
              "usage":["{stringx.partition('a,b,c', ','))} == {'a', ',', 'b,c'}\n","{stringx.partition('abc', 'x'))} == {'abc', '', ''}\n"],
              "type":"function",
              "name":"partition",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"ch",
                "map":{
                  "s":" the string",
                  "ch":" delimiter (match as plain string, no patterns)"
                }
              },
              "tags":[],
              "kind":"partitioning strings ",
              "section":"Partitioning Strings",
              "description":"",
              "ret":["part before ch","ch","part after ch"]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[],[]],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "type":"string"
                  },
                  "s":{
                    "type":"string"
                  },
                  "ch":{
                    "type":"string"
                  }
                },
                "return":[[],[],[]]
              },
              "summary":"partition the string p using last occurance of a delimiter",
              "lineno":475,
              "retgroups":[{
                  "1":{
                    "text":"part before ch",
                    "type":"",
                    "mods":[]
                  },
                  "2":{
                    "text":"ch",
                    "type":"",
                    "mods":[]
                  },
                  "3":{
                    "text":"part after ch",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s, ch)",
              "usage":["{stringx.rpartition('a,b,c', ','))} == {'a,b', ',', 'c'}\n","{stringx.rpartition('abc', 'x'))} == {'', '', 'abc'}\n"],
              "type":"function",
              "name":"rpartition",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"ch",
                "map":{
                  "s":" the string",
                  "ch":" delimiter (match as plain string, no patterns)"
                }
              },
              "tags":[],
              "kind":"partitioning strings ",
              "section":"Partitioning Strings",
              "description":"",
              "ret":["part before ch","ch","part after ch"]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[[]],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "type":"int"
                  },
                  "s":{
                    "type":"string"
                  },
                  "idx":{
                    "type":"int"
                  }
                }
              },
              "summary":"return the 'character' at the index.",
              "lineno":489,
              "retgroups":[{
                  "1":{
                    "text":"a substring of length 1 if successful, empty string otherwise.",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s, idx)",
              "type":"function",
              "name":"at",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"idx",
                "map":{
                  "s":" the string",
                  "idx":" an index (can be negative)"
                }
              },
              "tags":[],
              "kind":"partitioning strings ",
              "section":"Partitioning Strings",
              "description":"",
              "ret":["a substring of length 1 if successful, empty string otherwise."]
            },{
              "name":"text",
              "inferred":true,
              "description":"",
              "file":"<reference cycle>",
              "summary":"",
              "tags":[],
              "lineno":500,
              "display_name":"Text handling",
              "type":"section",
              "modifiers":[]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[[]],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "type":"integer"
                  },
                  "3":{
                    "opt":"' '",
                    "type":"string",
                    "optchain":"' '"
                  },
                  "ch":{
                    "opt":"' '",
                    "type":"string",
                    "optchain":"' '"
                  },
                  "n":{
                    "type":"integer"
                  },
                  "s":{
                    "type":"string"
                  }
                }
              },
              "summary":"indent a multiline string.",
              "lineno":505,
              "retgroups":[{
                  "1":{
                    "text":"indented string",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s, n[, ch=' '])",
              "type":"function",
              "name":"indent",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"n",
                "map":{
                  "ch":" the character to use when indenting",
                  "n":" the size of the indent",
                  "s":" the (multiline) string"
                },
                "3":"ch"
              },
              "tags":[],
              "kind":"text handling ",
              "section":"Text handling",
              "description":"",
              "ret":["indented string"]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[]],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "s":{
                    "type":"string"
                  }
                },
                "return":[[]]
              },
              "summary":"dedent a multiline string by removing any initial indent.",
              "lineno":537,
              "retgroups":[{
                  "1":{
                    "text":"a string with initial indent zero.",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s)",
              "usage":["local s = dedent [[\n         One\n\n       Two\n\n     Three\n]]\nassert(s == [[\n    One\n\n  Two\n\nThree\n]])\n"],
              "type":"function",
              "name":"dedent",
              "parameter":"param",
              "params":{
                "map":{
                  "s":" the (multiline) string"
                },
                "1":"s"
              },
              "tags":[],
              "kind":"text handling ",
              "section":"Text handling",
              "description":"\n useful when working with [[..]] strings.\n Empty lines are ignored.",
              "ret":["a string with initial indent zero."]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "opt":"70",
                    "type":"integer",
                    "optchain":"70"
                  },
                  "3":{
                    "opt":"false",
                    "type":"boolean",
                    "optchain":"false"
                  },
                  "width":{
                    "opt":"70",
                    "type":"integer",
                    "optchain":"70"
                  },
                  "s":{
                    "type":"string"
                  },
                  "breaklong":{
                    "opt":"false",
                    "type":"boolean",
                    "optchain":"false"
                  }
                },
                "return":[[]],
                "see":[[],[]]
              },
              "summary":"format a paragraph into lines so that they fit into a line width.",
              "lineno":594,
              "retgroups":[{
                  "1":{
                    "text":"a list of lines (List object), use `fill` to return a string instead of a `List`.",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s[, width=70[, breaklong=false]])",
              "type":"function",
              "name":"wrap",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"width",
                "map":{
                  "width":" the margin width",
                  "s":" the string to format",
                  "breaklong":" if truthy, words longer than the width given will be forced split."
                },
                "3":"breaklong"
              },
              "tags":{
                "see":[]
              },
              "kind":"text handling ",
              "section":"Text handling",
              "description":"\n It will not break long words by default, so lines can be over the length\n to that extent.",
              "ret":["a list of lines (List object), use `fill` to return a string instead of a `List`."]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "opt":"70",
                    "type":"integer",
                    "optchain":"70"
                  },
                  "3":{
                    "opt":"false",
                    "type":"boolean",
                    "optchain":"false"
                  },
                  "width":{
                    "opt":"70",
                    "type":"integer",
                    "optchain":"70"
                  },
                  "s":{
                    "type":"string"
                  },
                  "breaklong":{
                    "opt":"false",
                    "type":"boolean",
                    "optchain":"false"
                  }
                },
                "return":[[]],
                "see":[[]]
              },
              "summary":"format a paragraph so that it fits into a line width.",
              "lineno":616,
              "retgroups":[{
                  "1":{
                    "text":"a string, use `wrap` to return a list of lines instead of a string.",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s[, width=70[, breaklong=false]])",
              "type":"function",
              "name":"fill",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"width",
                "map":{
                  "width":" the margin width",
                  "s":" the string to format",
                  "breaklong":" if truthy, words longer than the width given will be forced split."
                },
                "3":"breaklong"
              },
              "tags":{
                "see":[]
              },
              "kind":"text handling ",
              "section":"Text handling",
              "description":"",
              "ret":["a string, use `wrap` to return a list of lines instead of a string."]
            },{
              "name":"Template",
              "inferred":true,
              "description":"",
              "file":"<reference cycle>",
              "summary":"",
              "tags":[],
              "lineno":624,
              "display_name":"Template",
              "type":"section",
              "modifiers":[]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "tmpl":{
                    "type":"string"
                  }
                },
                "return":[{
                    "type":"Template"
                  }]
              },
              "summary":"Creates a new Template class.",
              "lineno":662,
              "retgroups":[{
                  "1":{
                    "text":"",
                    "type":"Template",
                    "mods":{
                      "type":"Template"
                    }
                  },
                  "g":0
                }],
              "args":"(tmpl)",
              "section":"Template",
              "name":"Template",
              "params":{
                "map":{
                  "tmpl":" the template string"
                },
                "1":"tmpl"
              },
              "tags":[],
              "kind":"template ",
              "description":"\n This is a shortcut to `Template.new(tmpl)`.",
              "type":"function",
              "ret":[""],
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[[]],
                "param":{
                  "1":{
                    "type":"table"
                  },
                  "tbl":{
                    "type":"table"
                  }
                }
              },
              "summary":"substitute values into a template, throwing an error.",
              "lineno":674,
              "retgroups":[{
                  "1":{
                    "text":"string with place holders substituted",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(tbl)",
              "type":"function",
              "name":"Template:substitute",
              "parameter":"param",
              "params":{
                "map":{
                  "tbl":" a table of name-value pairs."
                },
                "1":"tbl"
              },
              "tags":[],
              "kind":"template ",
              "section":"Template",
              "description":"\n This will throw an error if no name is found.",
              "ret":["string with place holders substituted"]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[[]],
                "param":{
                  "1":{
                    "type":"table"
                  },
                  "tbl":{
                    "type":"table"
                  }
                }
              },
              "summary":"substitute values into a template.",
              "lineno":683,
              "retgroups":[{
                  "1":{
                    "text":"string with place holders substituted",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(tbl)",
              "type":"function",
              "name":"Template:safe_substitute",
              "parameter":"param",
              "params":{
                "map":{
                  "tbl":" a table of name-value pairs."
                },
                "1":"tbl"
              },
              "tags":[],
              "kind":"template ",
              "section":"Template",
              "description":"\n This version just passes unknown names through.",
              "ret":["string with place holders substituted"]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[[]],
                "param":{
                  "1":{
                    "type":"table"
                  },
                  "tbl":{
                    "type":"table"
                  }
                }
              },
              "summary":"substitute values into a template, preserving indentation.",
              "lineno":695,
              "retgroups":[{
                  "1":{
                    "text":"string with place holders substituted",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(tbl)",
              "type":"function",
              "name":"Template:indent_substitute",
              "parameter":"param",
              "params":{
                "map":{
                  "tbl":" a table of name-value pairs."
                },
                "1":"tbl"
              },
              "tags":[],
              "kind":"template ",
              "section":"Template",
              "description":" <br>\n If the value is a multiline string _or_ a template, it will insert\n the lines at the correct indentation. <br>\n Furthermore, if a template, then that template will be substituted\n using the same table.",
              "ret":["string with place holders substituted"]
            },{
              "name":"misc",
              "inferred":true,
              "description":"",
              "file":"<reference cycle>",
              "summary":"",
              "tags":[],
              "lineno":742,
              "display_name":"Miscelaneous",
              "type":"section",
              "modifiers":[]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[]],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "s":{
                    "type":"string"
                  }
                },
                "return":[[]]
              },
              "summary":"return an iterator over all lines in a string",
              "lineno":751,
              "retgroups":[{
                  "1":{
                    "text":"an iterator",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s)",
              "usage":["local line_no = 1\nfor line in stringx.lines(some_text) do\n  print(line_no, line)\n  line_no = line_no + 1\nend\n"],
              "type":"function",
              "name":"lines",
              "parameter":"param",
              "params":{
                "map":{
                  "s":" the string"
                },
                "1":"s"
              },
              "tags":[],
              "kind":"miscelaneous ",
              "section":"Miscelaneous",
              "description":"",
              "ret":["an iterator"]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[]],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "s":{
                    "type":"string"
                  }
                },
                "return":[[]]
              },
              "summary":"inital word letters uppercase ('title case').",
              "lineno":762,
              "retgroups":[{
                  "1":{
                    "text":"a string with each word's first letter uppercase",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s)",
              "usage":["stringx.title(\"hello world\") == \"Hello World\")\n"],
              "type":"function",
              "name":"title",
              "parameter":"param",
              "params":{
                "map":{
                  "s":" the string"
                },
                "1":"s"
              },
              "tags":[],
              "kind":"miscelaneous ",
              "section":"Miscelaneous",
              "description":"\n Here 'words' mean chunks of non-space characters.",
              "ret":["a string with each word's first letter uppercase"]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[],[],[]],
                "return":[],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "type":"int"
                  },
                  "3":{
                    "type":"bool"
                  },
                  "tail":{
                    "type":"bool"
                  },
                  "s":{
                    "type":"string"
                  },
                  "w":{
                    "type":"int"
                  }
                }
              },
              "summary":"Return a shortened version of a string.",
              "lineno":783,
              "args":"(s, w, tail)",
              "usage":["('1234567890'):shorten(8) == '12345...'\n","('1234567890'):shorten(8, true) == '...67890'\n","('1234567890'):shorten(20) == '1234567890'\n"],
              "section":"Miscelaneous",
              "name":"shorten",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"w",
                "map":{
                  "tail":" true if we want to show the end of the string (head otherwise)",
                  "s":" the string",
                  "w":" the maxinum size allowed"
                },
                "3":"tail"
              },
              "tags":[],
              "kind":"miscelaneous ",
              "description":"\n Fits string within w characters. Removed characters are marked with ellipsis.",
              "type":"function"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[[]],
                "param":{
                  "1":[],
                  "s":[]
                }
              },
              "summary":"Quote the given string and preserve any control or escape characters, such that reloading the string in Lua returns the same result.",
              "lineno":822,
              "retgroups":[{
                  "1":{
                    "text":"The quoted string.",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s)",
              "type":"function",
              "name":"quote_string",
              "parameter":"param",
              "params":{
                "map":{
                  "s":" The string to be quoted."
                },
                "1":"s"
              },
              "tags":[],
              "kind":"miscelaneous ",
              "section":"Miscelaneous",
              "description":"",
              "ret":["The quoted string."]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":[],
                "usage":[[]]
              },
              "summary":"Python-style formatting operator.",
              "lineno":873,
              "args":"()",
              "usage":["require 'pl.text'.format_operator()\nlocal out1 = '%s = %5.3f' % {'PI',math.pi}                   --> 'PI = 3.142'\nlocal out2 = '$name = $value' % {name='dog',value='Pluto'}   --> 'dog = Pluto'\n"],
              "section":"Miscelaneous",
              "name":"format_operator",
              "parameter":"param",
              "params":{
                "map":[]
              },
              "tags":[],
              "kind":"miscelaneous ",
              "description":"\n Calling `text.format_operator()` overloads the % operator for strings to give\n Python/Ruby style formated output.\n This is extended to also do template-like substitution for map-like data.\n\n Note this goes further than the original, and will allow these cases:\n\n 1. a single value\n 2. a list of values\n 3. a map of var=value pairs\n 4. a function, as in gsub\n\n For the second two cases, it uses $-variable substituion.\n\n When called, this function will monkey-patch the global `string` metatable by\n adding a `__mod` method.\n\n See <a href=\"http://lua-users.org/wiki/StringInterpolation\">the lua-users wiki</a>\n",
              "type":"function"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "param":[],
                "return":[]
              },
              "summary":"import the stringx functions into the global string (meta)table",
              "lineno":913,
              "args":"()",
              "section":"Miscelaneous",
              "name":"import",
              "params":{
                "map":[]
              },
              "tags":[],
              "kind":"miscelaneous ",
              "description":"",
              "type":"function",
              "parameter":"param"
            }],
          "sections":[],
          "modules":["<reference cycle>"],
          "args":{
            "one":false,
            "module":false,
            "verbose":false,
            "style":"!",
            "template":"!",
            "date":"system",
            "dir":"doc",
            "quiet":false,
            "all":false,
            "ignore":false,
            "colon":false,
            "not_luadoc":false,
            "ext":"html",
            "boilerplate":false,
            "merge":false,
            "filter":"f.filter",
            "package":"/home/cji/portless/Penlight/lua",
            "dump":false,
            "no_args_infer":false,
            "title":"Reference",
            "project":"ldoc",
            "file":"/home/cji/portless/Penlight/lua/pl",
            "format":"discount",
            "simple":false,
            "tags":"none",
            "define":"none",
            "output":"index",
            "unqualified":false,
            "config":"config.ld",
            "fatalwarnings":false,
            "testing":false
          },
          "error":"<type 'function' is not supported by JSON.>",
          "lang":{
            "line_comment":"^%-%-+",
            "start_comment_":"^%-%-%-+",
            "end_comment_":"[^%-]%-%-+[^-]*\n$",
            "extra":[],
            "block_comment":"^%-%-%[=*%[%-+",
            "empty_comment_":"^%-%-%-+%s*$",
            "method_call":":"
          },
          "base":"/home/cji/portless/Penlight/lua"
        },
        "summary":"",
        "tags":[],
        "lineno":231,
        "display_name":"Finding and Replacing",
        "type":"section",
        "modifiers":[]
      },
      "Partitioning_Strings":{
        "name":"partitioning",
        "inferred":true,
        "description":"",
        "file":{
          "warning":"<type 'function' is not supported by JSON.>",
          "filename":"/home/cji/portless/Penlight/lua/pl/stringx.lua",
          "items":["<reference cycle>",{
              "name":"predicates",
              "inferred":true,
              "description":"",
              "file":"<reference cycle>",
              "summary":"",
              "tags":[],
              "lineno":53,
              "display_name":"String Predicates",
              "type":"section",
              "modifiers":[]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "s":{
                    "type":"string"
                  }
                }
              },
              "summary":"does s only contain alphabetic characters?",
              "lineno":55,
              "args":"(s)",
              "section":"String Predicates",
              "name":"isalpha",
              "params":{
                "map":{
                  "s":" a string"
                },
                "1":"s"
              },
              "tags":[],
              "kind":"string predicates ",
              "description":"",
              "type":"function",
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "s":{
                    "type":"string"
                  }
                }
              },
              "summary":"does s only contain digits?",
              "lineno":62,
              "args":"(s)",
              "section":"String Predicates",
              "name":"isdigit",
              "params":{
                "map":{
                  "s":" a string"
                },
                "1":"s"
              },
              "tags":[],
              "kind":"string predicates ",
              "description":"",
              "type":"function",
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "s":{
                    "type":"string"
                  }
                }
              },
              "summary":"does s only contain alphanumeric characters?",
              "lineno":69,
              "args":"(s)",
              "section":"String Predicates",
              "name":"isalnum",
              "params":{
                "map":{
                  "s":" a string"
                },
                "1":"s"
              },
              "tags":[],
              "kind":"string predicates ",
              "description":"",
              "type":"function",
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "s":{
                    "type":"string"
                  }
                }
              },
              "summary":"does s only contain whitespace?",
              "lineno":77,
              "args":"(s)",
              "section":"String Predicates",
              "name":"isspace",
              "params":{
                "map":{
                  "s":" a string"
                },
                "1":"s"
              },
              "tags":[],
              "kind":"string predicates ",
              "description":"\n Matches on pattern '%s' so matches space, newline, tabs, etc.",
              "type":"function",
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "s":{
                    "type":"string"
                  }
                }
              },
              "summary":"does s only contain lower case characters?",
              "lineno":84,
              "args":"(s)",
              "section":"String Predicates",
              "name":"islower",
              "params":{
                "map":{
                  "s":" a string"
                },
                "1":"s"
              },
              "tags":[],
              "kind":"string predicates ",
              "description":"",
              "type":"function",
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "s":{
                    "type":"string"
                  }
                }
              },
              "summary":"does s only contain upper case characters?",
              "lineno":91,
              "args":"(s)",
              "section":"String Predicates",
              "name":"isupper",
              "params":{
                "map":{
                  "s":" a string"
                },
                "1":"s"
              },
              "tags":[],
              "kind":"string predicates ",
              "description":"",
              "type":"function",
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":[],
                  "s":{
                    "type":"string"
                  },
                  "prefix":[]
                }
              },
              "summary":"does s start with prefix or one of prefixes?",
              "lineno":120,
              "args":"(s, prefix)",
              "section":"String Predicates",
              "name":"startswith",
              "params":{
                "1":"s",
                "2":"prefix",
                "map":{
                  "s":" a string",
                  "prefix":" a string or an array of strings"
                }
              },
              "tags":[],
              "kind":"string predicates ",
              "description":"",
              "type":"function",
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":[],
                  "s":{
                    "type":"string"
                  },
                  "suffix":[]
                }
              },
              "summary":"does s end with suffix or one of suffixes?",
              "lineno":128,
              "args":"(s, suffix)",
              "section":"String Predicates",
              "name":"endswith",
              "params":{
                "1":"s",
                "2":"suffix",
                "map":{
                  "s":" a string",
                  "suffix":" a string or an array of strings"
                }
              },
              "tags":[],
              "kind":"string predicates ",
              "description":"",
              "type":"function",
              "parameter":"param"
            },{
              "name":"lists",
              "inferred":true,
              "description":"",
              "file":"<reference cycle>",
              "summary":"",
              "tags":[],
              "lineno":136,
              "display_name":"Strings and Lists",
              "type":"section",
              "modifiers":[]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[]],
                "return":[],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":[],
                  "s":{
                    "type":"string"
                  },
                  "seq":[]
                }
              },
              "summary":"concatenate the strings using this string as a delimiter.",
              "lineno":141,
              "args":"(s, seq)",
              "usage":["stringx.join(' ', {1,2,3}) == '1 2 3'\n"],
              "section":"Strings and Lists",
              "name":"join",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"seq",
                "map":{
                  "s":" the string",
                  "seq":" a table of strings or numbers"
                }
              },
              "tags":[],
              "kind":"strings and lists ",
              "description":"\n Note that the arguments are reversed from `string.concat`.",
              "type":"function"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[[]],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "opt":true,
                    "type":"bool",
                    "optchain":true
                  },
                  "s":{
                    "type":"string"
                  },
                  "keep_ends":{
                    "opt":true,
                    "type":"bool",
                    "optchain":true
                  }
                }
              },
              "summary":"Split a string into a list of lines.",
              "lineno":154,
              "retgroups":[{
                  "1":{
                    "text":"List of lines",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s[, keep_ends])",
              "type":"function",
              "name":"splitlines",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"keep_ends",
                "map":{
                  "s":" the string.",
                  "keep_ends":" include line ends."
                }
              },
              "tags":[],
              "kind":"strings and lists ",
              "section":"Strings and Lists",
              "description":"\n `\"\\r\"`, `\"\\n\"`, and `\"\\r\\n\"` are considered line ends.\n They are not included in the lines unless `keepends` is passed.\n Terminal line end does not produce an extra line.\n Splitting an empty string results in an empty list.",
              "ret":["List of lines"]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[],[],[]],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "opt":true,
                    "type":"string",
                    "optchain":true
                  },
                  "3":{
                    "opt":true,
                    "type":"int",
                    "optchain":true
                  },
                  "re":{
                    "opt":true,
                    "type":"string",
                    "optchain":true
                  },
                  "n":{
                    "opt":true,
                    "type":"int",
                    "optchain":true
                  },
                  "s":{
                    "type":"string"
                  }
                },
                "return":[[]]
              },
              "summary":"split a string into a list of strings using a delimiter.",
              "lineno":193,
              "retgroups":[{
                  "1":{
                    "text":"List",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s[, re[, n]])",
              "usage":["#(stringx.split('one two')) == 2\n","stringx.split('one,two,three', ',') == List{'one','two','three'}\n","stringx.split('one,two,three', ',', 2) == List{'one','two,three'}\n"],
              "type":"function",
              "name":"split",
              "params":{
                "1":"s",
                "2":"re",
                "map":{
                  "re":" a delimiter (defaults to whitespace)",
                  "n":" maximum number of results",
                  "s":" the string"
                },
                "3":"n"
              },
              "tags":[],
              "kind":"strings and lists ",
              "section":"Strings and Lists",
              "description":"",
              "ret":["List"],
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[],[]],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "type":"int"
                  },
                  "s":{
                    "type":"string"
                  },
                  "tabsize":{
                    "type":"int"
                  }
                },
                "return":[[]]
              },
              "summary":"replace all tabs in s with tabsize spaces.",
              "lineno":216,
              "retgroups":[{
                  "1":{
                    "text":"expanded string",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s, tabsize)",
              "usage":["stringx.expandtabs('\\tone,two,three', 4)   == '    one,two,three'\n","stringx.expandtabs('  \\tone,two,three', 4) == '    one,two,three'\n"],
              "type":"function",
              "name":"expandtabs",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"tabsize",
                "map":{
                  "s":" the string",
                  "tabsize":"[opt=8] number of spaces to expand each tab"
                }
              },
              "tags":[],
              "kind":"strings and lists ",
              "section":"Strings and Lists",
              "description":" If not specified, tabsize defaults to 8.\n Tab stops will be honored.",
              "ret":["expanded string"]
            },{
              "name":"find",
              "inferred":true,
              "description":"",
              "file":"<reference cycle>",
              "summary":"",
              "tags":[],
              "lineno":231,
              "display_name":"Finding and Replacing",
              "type":"section",
              "modifiers":[]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[[]],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "type":"string"
                  },
                  "3":{
                    "opt":true,
                    "type":"int",
                    "optchain":true
                  },
                  "4":{
                    "opt":true,
                    "type":"int",
                    "optchain":true
                  },
                  "first":{
                    "opt":true,
                    "type":"int",
                    "optchain":true
                  },
                  "sub":{
                    "type":"string"
                  },
                  "s":{
                    "type":"string"
                  },
                  "last":{
                    "opt":true,
                    "type":"int",
                    "optchain":true
                  }
                }
              },
              "summary":"find index of first instance of sub in s from the left.",
              "lineno":257,
              "retgroups":[{
                  "1":{
                    "text":"start index, or nil if not found",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s, sub[, first[, last]])",
              "type":"function",
              "name":"lfind",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"sub",
                "3":"first",
                "4":"last",
                "map":{
                  "first":" first index",
                  "sub":" substring",
                  "s":" the string",
                  "last":" last index"
                }
              },
              "tags":[],
              "kind":"finding and replacing ",
              "section":"Finding and Replacing",
              "description":"",
              "ret":["start index, or nil if not found"]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[[]],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "type":"string"
                  },
                  "3":{
                    "opt":true,
                    "type":"int",
                    "optchain":true
                  },
                  "4":{
                    "opt":true,
                    "type":"int",
                    "optchain":true
                  },
                  "first":{
                    "opt":true,
                    "type":"int",
                    "optchain":true
                  },
                  "sub":{
                    "type":"string"
                  },
                  "s":{
                    "type":"string"
                  },
                  "last":{
                    "opt":true,
                    "type":"int",
                    "optchain":true
                  }
                }
              },
              "summary":"find index of first instance of sub in s from the right.",
              "lineno":275,
              "retgroups":[{
                  "1":{
                    "text":"start index, or nil if not found",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s, sub[, first[, last]])",
              "type":"function",
              "name":"rfind",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"sub",
                "3":"first",
                "4":"last",
                "map":{
                  "first":" first index",
                  "sub":" substring",
                  "s":" the string",
                  "last":" last index"
                }
              },
              "tags":[],
              "kind":"finding and replacing ",
              "section":"Finding and Replacing",
              "description":"",
              "ret":["start index, or nil if not found"]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[[]],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "type":"string"
                  },
                  "3":{
                    "type":"string"
                  },
                  "4":{
                    "opt":true,
                    "type":"int",
                    "optchain":true
                  },
                  "n":{
                    "opt":true,
                    "type":"int",
                    "optchain":true
                  },
                  "old":{
                    "type":"string"
                  },
                  "s":{
                    "type":"string"
                  },
                  "new":{
                    "type":"string"
                  }
                }
              },
              "summary":"replace up to n instances of old by new in the string s.",
              "lineno":288,
              "retgroups":[{
                  "1":{
                    "text":"result string",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s, old, new[, n])",
              "type":"function",
              "name":"replace",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"old",
                "3":"new",
                "4":"n",
                "map":{
                  "n":" optional maximum number of substitutions",
                  "old":" the target substring",
                  "s":" the string",
                  "new":" the substitution"
                }
              },
              "tags":[],
              "kind":"finding and replacing ",
              "section":"Finding and Replacing",
              "description":"\n If n is not present, replace all instances.",
              "ret":["result string"]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[]],
                "return":[],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "type":"string"
                  },
                  "3":{
                    "opt":true,
                    "type":"bool",
                    "optchain":true
                  },
                  "sub":{
                    "type":"string"
                  },
                  "s":{
                    "type":"string"
                  },
                  "allow_overlap":{
                    "opt":true,
                    "type":"bool",
                    "optchain":true
                  }
                }
              },
              "summary":"count all instances of substring in string.",
              "lineno":302,
              "args":"(s, sub[, allow_overlap])",
              "usage":["assert(stringx.count('banana', 'ana') == 1)\nassert(stringx.count('banana', 'ana', true) == 2)\n"],
              "section":"Finding and Replacing",
              "name":"count",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"sub",
                "map":{
                  "sub":" substring",
                  "s":" the string",
                  "allow_overlap":" allow matches to overlap"
                },
                "3":"allow_overlap"
              },
              "tags":[],
              "kind":"finding and replacing ",
              "description":"",
              "type":"function"
            },{
              "name":"strip",
              "inferred":true,
              "description":"",
              "file":"<reference cycle>",
              "summary":"",
              "tags":[],
              "lineno":311,
              "display_name":"Stripping and Justifying",
              "type":"section",
              "modifiers":[]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[]],
                "return":[],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "type":"int"
                  },
                  "3":{
                    "opt":"' '",
                    "type":"string",
                    "optchain":"' '"
                  },
                  "ch":{
                    "opt":"' '",
                    "type":"string",
                    "optchain":"' '"
                  },
                  "s":{
                    "type":"string"
                  },
                  "w":{
                    "type":"int"
                  }
                }
              },
              "summary":"left-justify s with width w.",
              "lineno":339,
              "args":"(s, w[, ch=' '])",
              "usage":["stringx.ljust('hello', 10, '*') == '*****hello'\n"],
              "section":"Stripping and Justifying",
              "name":"ljust",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"w",
                "map":{
                  "ch":" padding character",
                  "s":" the string",
                  "w":" width of justification"
                },
                "3":"ch"
              },
              "tags":[],
              "kind":"stripping and justifying ",
              "description":"",
              "type":"function"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[]],
                "return":[],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "type":"int"
                  },
                  "3":{
                    "opt":"' '",
                    "type":"string",
                    "optchain":"' '"
                  },
                  "ch":{
                    "opt":"' '",
                    "type":"string",
                    "optchain":"' '"
                  },
                  "s":{
                    "type":"string"
                  },
                  "w":{
                    "type":"int"
                  }
                }
              },
              "summary":"right-justify s with width w.",
              "lineno":350,
              "args":"(s, w[, ch=' '])",
              "usage":["stringx.rjust('hello', 10, '*') == 'hello*****'\n"],
              "section":"Stripping and Justifying",
              "name":"rjust",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"w",
                "map":{
                  "ch":" padding character",
                  "s":" the string",
                  "w":" width of justification"
                },
                "3":"ch"
              },
              "tags":[],
              "kind":"stripping and justifying ",
              "description":"",
              "type":"function"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[]],
                "return":[],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "type":"int"
                  },
                  "3":{
                    "opt":"' '",
                    "type":"string",
                    "optchain":"' '"
                  },
                  "ch":{
                    "opt":"' '",
                    "type":"string",
                    "optchain":"' '"
                  },
                  "s":{
                    "type":"string"
                  },
                  "w":{
                    "type":"int"
                  }
                }
              },
              "summary":"center-justify s with width w.",
              "lineno":361,
              "args":"(s, w[, ch=' '])",
              "usage":["stringx.center('hello', 10, '*') == '**hello***'\n"],
              "section":"Stripping and Justifying",
              "name":"center",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"w",
                "map":{
                  "ch":" padding character",
                  "s":" the string",
                  "w":" width of justification"
                },
                "3":"ch"
              },
              "tags":[],
              "kind":"stripping and justifying ",
              "description":"",
              "type":"function"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "opt":"'%s'",
                    "type":"string",
                    "optchain":"'%s'"
                  },
                  "s":{
                    "type":"string"
                  },
                  "chrs":{
                    "opt":"'%s'",
                    "type":"string",
                    "optchain":"'%s'"
                  }
                }
              },
              "summary":"trim any characters on the left of s.",
              "lineno":402,
              "args":"(s[, chrs='%s'])",
              "section":"Stripping and Justifying",
              "name":"lstrip",
              "params":{
                "1":"s",
                "2":"chrs",
                "map":{
                  "s":" the string",
                  "chrs":" default any whitespace character,\n but can be a string of characters to be trimmed"
                }
              },
              "tags":[],
              "kind":"stripping and justifying ",
              "description":"",
              "type":"function",
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "opt":"'%s'",
                    "type":"string",
                    "optchain":"'%s'"
                  },
                  "s":{
                    "type":"string"
                  },
                  "chrs":{
                    "opt":"'%s'",
                    "type":"string",
                    "optchain":"'%s'"
                  }
                }
              },
              "summary":"trim any characters on the right of s.",
              "lineno":412,
              "args":"(s[, chrs='%s'])",
              "section":"Stripping and Justifying",
              "name":"rstrip",
              "params":{
                "1":"s",
                "2":"chrs",
                "map":{
                  "s":" the string",
                  "chrs":" default any whitespace character,\n but can be a string of characters to be trimmed"
                }
              },
              "tags":[],
              "kind":"stripping and justifying ",
              "description":"",
              "type":"function",
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[]],
                "return":[],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "opt":"'%s'",
                    "type":"string",
                    "optchain":"'%s'"
                  },
                  "s":{
                    "type":"string"
                  },
                  "chrs":{
                    "opt":"'%s'",
                    "type":"string",
                    "optchain":"'%s'"
                  }
                }
              },
              "summary":"trim any characters on both left and right of s.",
              "lineno":422,
              "args":"(s[, chrs='%s'])",
              "usage":["stringx.strip('  --== Hello ==--  ', \"- =\")  --> 'Hello'\n"],
              "section":"Stripping and Justifying",
              "name":"strip",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"chrs",
                "map":{
                  "s":" the string",
                  "chrs":" default any whitespace character,\n but can be a string of characters to be trimmed"
                }
              },
              "tags":[],
              "kind":"stripping and justifying ",
              "description":"",
              "type":"function"
            },"<reference cycle>",{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "opt":"'%s'",
                    "type":"string",
                    "optchain":"'%s'"
                  },
                  "s":{
                    "type":"string"
                  },
                  "re":{
                    "opt":"'%s'",
                    "type":"string",
                    "optchain":"'%s'"
                  }
                },
                "return":[[]],
                "usage":[[]],
                "see":[[]]
              },
              "summary":"split a string using a pattern.",
              "lineno":436,
              "retgroups":[{
                  "1":{
                    "text":"the parts of the string",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s[, re='%s'])",
              "usage":["a,b = line:splitv('=')\n"],
              "type":"function",
              "name":"splitv",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"re",
                "map":{
                  "s":" the string",
                  "re":" a Lua string pattern (defaults to whitespace)"
                }
              },
              "tags":{
                "see":[]
              },
              "kind":"partitioning strings ",
              "section":"Partitioning Strings",
              "description":" Note that at least one value will be returned!",
              "ret":["the parts of the string"]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[],[]],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "type":"string"
                  },
                  "s":{
                    "type":"string"
                  },
                  "ch":{
                    "type":"string"
                  }
                },
                "return":[[],[],[]]
              },
              "summary":"partition the string using first occurance of a delimiter",
              "lineno":461,
              "retgroups":[{
                  "1":{
                    "text":"part before ch",
                    "type":"",
                    "mods":[]
                  },
                  "2":{
                    "text":"ch",
                    "type":"",
                    "mods":[]
                  },
                  "3":{
                    "text":"part after ch",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s, ch)",
              "usage":["{stringx.partition('a,b,c', ','))} == {'a', ',', 'b,c'}\n","{stringx.partition('abc', 'x'))} == {'abc', '', ''}\n"],
              "type":"function",
              "name":"partition",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"ch",
                "map":{
                  "s":" the string",
                  "ch":" delimiter (match as plain string, no patterns)"
                }
              },
              "tags":[],
              "kind":"partitioning strings ",
              "section":"Partitioning Strings",
              "description":"",
              "ret":["part before ch","ch","part after ch"]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[],[]],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "type":"string"
                  },
                  "s":{
                    "type":"string"
                  },
                  "ch":{
                    "type":"string"
                  }
                },
                "return":[[],[],[]]
              },
              "summary":"partition the string p using last occurance of a delimiter",
              "lineno":475,
              "retgroups":[{
                  "1":{
                    "text":"part before ch",
                    "type":"",
                    "mods":[]
                  },
                  "2":{
                    "text":"ch",
                    "type":"",
                    "mods":[]
                  },
                  "3":{
                    "text":"part after ch",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s, ch)",
              "usage":["{stringx.rpartition('a,b,c', ','))} == {'a,b', ',', 'c'}\n","{stringx.rpartition('abc', 'x'))} == {'', '', 'abc'}\n"],
              "type":"function",
              "name":"rpartition",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"ch",
                "map":{
                  "s":" the string",
                  "ch":" delimiter (match as plain string, no patterns)"
                }
              },
              "tags":[],
              "kind":"partitioning strings ",
              "section":"Partitioning Strings",
              "description":"",
              "ret":["part before ch","ch","part after ch"]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[[]],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "type":"int"
                  },
                  "s":{
                    "type":"string"
                  },
                  "idx":{
                    "type":"int"
                  }
                }
              },
              "summary":"return the 'character' at the index.",
              "lineno":489,
              "retgroups":[{
                  "1":{
                    "text":"a substring of length 1 if successful, empty string otherwise.",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s, idx)",
              "type":"function",
              "name":"at",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"idx",
                "map":{
                  "s":" the string",
                  "idx":" an index (can be negative)"
                }
              },
              "tags":[],
              "kind":"partitioning strings ",
              "section":"Partitioning Strings",
              "description":"",
              "ret":["a substring of length 1 if successful, empty string otherwise."]
            },{
              "name":"text",
              "inferred":true,
              "description":"",
              "file":"<reference cycle>",
              "summary":"",
              "tags":[],
              "lineno":500,
              "display_name":"Text handling",
              "type":"section",
              "modifiers":[]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[[]],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "type":"integer"
                  },
                  "3":{
                    "opt":"' '",
                    "type":"string",
                    "optchain":"' '"
                  },
                  "ch":{
                    "opt":"' '",
                    "type":"string",
                    "optchain":"' '"
                  },
                  "n":{
                    "type":"integer"
                  },
                  "s":{
                    "type":"string"
                  }
                }
              },
              "summary":"indent a multiline string.",
              "lineno":505,
              "retgroups":[{
                  "1":{
                    "text":"indented string",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s, n[, ch=' '])",
              "type":"function",
              "name":"indent",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"n",
                "map":{
                  "ch":" the character to use when indenting",
                  "n":" the size of the indent",
                  "s":" the (multiline) string"
                },
                "3":"ch"
              },
              "tags":[],
              "kind":"text handling ",
              "section":"Text handling",
              "description":"",
              "ret":["indented string"]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[]],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "s":{
                    "type":"string"
                  }
                },
                "return":[[]]
              },
              "summary":"dedent a multiline string by removing any initial indent.",
              "lineno":537,
              "retgroups":[{
                  "1":{
                    "text":"a string with initial indent zero.",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s)",
              "usage":["local s = dedent [[\n         One\n\n       Two\n\n     Three\n]]\nassert(s == [[\n    One\n\n  Two\n\nThree\n]])\n"],
              "type":"function",
              "name":"dedent",
              "parameter":"param",
              "params":{
                "map":{
                  "s":" the (multiline) string"
                },
                "1":"s"
              },
              "tags":[],
              "kind":"text handling ",
              "section":"Text handling",
              "description":"\n useful when working with [[..]] strings.\n Empty lines are ignored.",
              "ret":["a string with initial indent zero."]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "opt":"70",
                    "type":"integer",
                    "optchain":"70"
                  },
                  "3":{
                    "opt":"false",
                    "type":"boolean",
                    "optchain":"false"
                  },
                  "width":{
                    "opt":"70",
                    "type":"integer",
                    "optchain":"70"
                  },
                  "s":{
                    "type":"string"
                  },
                  "breaklong":{
                    "opt":"false",
                    "type":"boolean",
                    "optchain":"false"
                  }
                },
                "return":[[]],
                "see":[[],[]]
              },
              "summary":"format a paragraph into lines so that they fit into a line width.",
              "lineno":594,
              "retgroups":[{
                  "1":{
                    "text":"a list of lines (List object), use `fill` to return a string instead of a `List`.",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s[, width=70[, breaklong=false]])",
              "type":"function",
              "name":"wrap",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"width",
                "map":{
                  "width":" the margin width",
                  "s":" the string to format",
                  "breaklong":" if truthy, words longer than the width given will be forced split."
                },
                "3":"breaklong"
              },
              "tags":{
                "see":[]
              },
              "kind":"text handling ",
              "section":"Text handling",
              "description":"\n It will not break long words by default, so lines can be over the length\n to that extent.",
              "ret":["a list of lines (List object), use `fill` to return a string instead of a `List`."]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "opt":"70",
                    "type":"integer",
                    "optchain":"70"
                  },
                  "3":{
                    "opt":"false",
                    "type":"boolean",
                    "optchain":"false"
                  },
                  "width":{
                    "opt":"70",
                    "type":"integer",
                    "optchain":"70"
                  },
                  "s":{
                    "type":"string"
                  },
                  "breaklong":{
                    "opt":"false",
                    "type":"boolean",
                    "optchain":"false"
                  }
                },
                "return":[[]],
                "see":[[]]
              },
              "summary":"format a paragraph so that it fits into a line width.",
              "lineno":616,
              "retgroups":[{
                  "1":{
                    "text":"a string, use `wrap` to return a list of lines instead of a string.",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s[, width=70[, breaklong=false]])",
              "type":"function",
              "name":"fill",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"width",
                "map":{
                  "width":" the margin width",
                  "s":" the string to format",
                  "breaklong":" if truthy, words longer than the width given will be forced split."
                },
                "3":"breaklong"
              },
              "tags":{
                "see":[]
              },
              "kind":"text handling ",
              "section":"Text handling",
              "description":"",
              "ret":["a string, use `wrap` to return a list of lines instead of a string."]
            },{
              "name":"Template",
              "inferred":true,
              "description":"",
              "file":"<reference cycle>",
              "summary":"",
              "tags":[],
              "lineno":624,
              "display_name":"Template",
              "type":"section",
              "modifiers":[]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "tmpl":{
                    "type":"string"
                  }
                },
                "return":[{
                    "type":"Template"
                  }]
              },
              "summary":"Creates a new Template class.",
              "lineno":662,
              "retgroups":[{
                  "1":{
                    "text":"",
                    "type":"Template",
                    "mods":{
                      "type":"Template"
                    }
                  },
                  "g":0
                }],
              "args":"(tmpl)",
              "section":"Template",
              "name":"Template",
              "params":{
                "map":{
                  "tmpl":" the template string"
                },
                "1":"tmpl"
              },
              "tags":[],
              "kind":"template ",
              "description":"\n This is a shortcut to `Template.new(tmpl)`.",
              "type":"function",
              "ret":[""],
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[[]],
                "param":{
                  "1":{
                    "type":"table"
                  },
                  "tbl":{
                    "type":"table"
                  }
                }
              },
              "summary":"substitute values into a template, throwing an error.",
              "lineno":674,
              "retgroups":[{
                  "1":{
                    "text":"string with place holders substituted",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(tbl)",
              "type":"function",
              "name":"Template:substitute",
              "parameter":"param",
              "params":{
                "map":{
                  "tbl":" a table of name-value pairs."
                },
                "1":"tbl"
              },
              "tags":[],
              "kind":"template ",
              "section":"Template",
              "description":"\n This will throw an error if no name is found.",
              "ret":["string with place holders substituted"]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[[]],
                "param":{
                  "1":{
                    "type":"table"
                  },
                  "tbl":{
                    "type":"table"
                  }
                }
              },
              "summary":"substitute values into a template.",
              "lineno":683,
              "retgroups":[{
                  "1":{
                    "text":"string with place holders substituted",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(tbl)",
              "type":"function",
              "name":"Template:safe_substitute",
              "parameter":"param",
              "params":{
                "map":{
                  "tbl":" a table of name-value pairs."
                },
                "1":"tbl"
              },
              "tags":[],
              "kind":"template ",
              "section":"Template",
              "description":"\n This version just passes unknown names through.",
              "ret":["string with place holders substituted"]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[[]],
                "param":{
                  "1":{
                    "type":"table"
                  },
                  "tbl":{
                    "type":"table"
                  }
                }
              },
              "summary":"substitute values into a template, preserving indentation.",
              "lineno":695,
              "retgroups":[{
                  "1":{
                    "text":"string with place holders substituted",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(tbl)",
              "type":"function",
              "name":"Template:indent_substitute",
              "parameter":"param",
              "params":{
                "map":{
                  "tbl":" a table of name-value pairs."
                },
                "1":"tbl"
              },
              "tags":[],
              "kind":"template ",
              "section":"Template",
              "description":" <br>\n If the value is a multiline string _or_ a template, it will insert\n the lines at the correct indentation. <br>\n Furthermore, if a template, then that template will be substituted\n using the same table.",
              "ret":["string with place holders substituted"]
            },{
              "name":"misc",
              "inferred":true,
              "description":"",
              "file":"<reference cycle>",
              "summary":"",
              "tags":[],
              "lineno":742,
              "display_name":"Miscelaneous",
              "type":"section",
              "modifiers":[]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[]],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "s":{
                    "type":"string"
                  }
                },
                "return":[[]]
              },
              "summary":"return an iterator over all lines in a string",
              "lineno":751,
              "retgroups":[{
                  "1":{
                    "text":"an iterator",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s)",
              "usage":["local line_no = 1\nfor line in stringx.lines(some_text) do\n  print(line_no, line)\n  line_no = line_no + 1\nend\n"],
              "type":"function",
              "name":"lines",
              "parameter":"param",
              "params":{
                "map":{
                  "s":" the string"
                },
                "1":"s"
              },
              "tags":[],
              "kind":"miscelaneous ",
              "section":"Miscelaneous",
              "description":"",
              "ret":["an iterator"]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[]],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "s":{
                    "type":"string"
                  }
                },
                "return":[[]]
              },
              "summary":"inital word letters uppercase ('title case').",
              "lineno":762,
              "retgroups":[{
                  "1":{
                    "text":"a string with each word's first letter uppercase",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s)",
              "usage":["stringx.title(\"hello world\") == \"Hello World\")\n"],
              "type":"function",
              "name":"title",
              "parameter":"param",
              "params":{
                "map":{
                  "s":" the string"
                },
                "1":"s"
              },
              "tags":[],
              "kind":"miscelaneous ",
              "section":"Miscelaneous",
              "description":"\n Here 'words' mean chunks of non-space characters.",
              "ret":["a string with each word's first letter uppercase"]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[],[],[]],
                "return":[],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "type":"int"
                  },
                  "3":{
                    "type":"bool"
                  },
                  "tail":{
                    "type":"bool"
                  },
                  "s":{
                    "type":"string"
                  },
                  "w":{
                    "type":"int"
                  }
                }
              },
              "summary":"Return a shortened version of a string.",
              "lineno":783,
              "args":"(s, w, tail)",
              "usage":["('1234567890'):shorten(8) == '12345...'\n","('1234567890'):shorten(8, true) == '...67890'\n","('1234567890'):shorten(20) == '1234567890'\n"],
              "section":"Miscelaneous",
              "name":"shorten",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"w",
                "map":{
                  "tail":" true if we want to show the end of the string (head otherwise)",
                  "s":" the string",
                  "w":" the maxinum size allowed"
                },
                "3":"tail"
              },
              "tags":[],
              "kind":"miscelaneous ",
              "description":"\n Fits string within w characters. Removed characters are marked with ellipsis.",
              "type":"function"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[[]],
                "param":{
                  "1":[],
                  "s":[]
                }
              },
              "summary":"Quote the given string and preserve any control or escape characters, such that reloading the string in Lua returns the same result.",
              "lineno":822,
              "retgroups":[{
                  "1":{
                    "text":"The quoted string.",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s)",
              "type":"function",
              "name":"quote_string",
              "parameter":"param",
              "params":{
                "map":{
                  "s":" The string to be quoted."
                },
                "1":"s"
              },
              "tags":[],
              "kind":"miscelaneous ",
              "section":"Miscelaneous",
              "description":"",
              "ret":["The quoted string."]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":[],
                "usage":[[]]
              },
              "summary":"Python-style formatting operator.",
              "lineno":873,
              "args":"()",
              "usage":["require 'pl.text'.format_operator()\nlocal out1 = '%s = %5.3f' % {'PI',math.pi}                   --> 'PI = 3.142'\nlocal out2 = '$name = $value' % {name='dog',value='Pluto'}   --> 'dog = Pluto'\n"],
              "section":"Miscelaneous",
              "name":"format_operator",
              "parameter":"param",
              "params":{
                "map":[]
              },
              "tags":[],
              "kind":"miscelaneous ",
              "description":"\n Calling `text.format_operator()` overloads the % operator for strings to give\n Python/Ruby style formated output.\n This is extended to also do template-like substitution for map-like data.\n\n Note this goes further than the original, and will allow these cases:\n\n 1. a single value\n 2. a list of values\n 3. a map of var=value pairs\n 4. a function, as in gsub\n\n For the second two cases, it uses $-variable substituion.\n\n When called, this function will monkey-patch the global `string` metatable by\n adding a `__mod` method.\n\n See <a href=\"http://lua-users.org/wiki/StringInterpolation\">the lua-users wiki</a>\n",
              "type":"function"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "param":[],
                "return":[]
              },
              "summary":"import the stringx functions into the global string (meta)table",
              "lineno":913,
              "args":"()",
              "section":"Miscelaneous",
              "name":"import",
              "params":{
                "map":[]
              },
              "tags":[],
              "kind":"miscelaneous ",
              "description":"",
              "type":"function",
              "parameter":"param"
            }],
          "sections":[],
          "modules":["<reference cycle>"],
          "args":{
            "one":false,
            "module":false,
            "verbose":false,
            "style":"!",
            "template":"!",
            "date":"system",
            "dir":"doc",
            "quiet":false,
            "all":false,
            "ignore":false,
            "colon":false,
            "not_luadoc":false,
            "ext":"html",
            "boilerplate":false,
            "merge":false,
            "filter":"f.filter",
            "package":"/home/cji/portless/Penlight/lua",
            "dump":false,
            "no_args_infer":false,
            "title":"Reference",
            "project":"ldoc",
            "file":"/home/cji/portless/Penlight/lua/pl",
            "format":"discount",
            "simple":false,
            "tags":"none",
            "define":"none",
            "output":"index",
            "unqualified":false,
            "config":"config.ld",
            "fatalwarnings":false,
            "testing":false
          },
          "error":"<type 'function' is not supported by JSON.>",
          "lang":{
            "line_comment":"^%-%-+",
            "start_comment_":"^%-%-%-+",
            "end_comment_":"[^%-]%-%-+[^-]*\n$",
            "extra":[],
            "block_comment":"^%-%-%[=*%[%-+",
            "empty_comment_":"^%-%-%-+%s*$",
            "method_call":":"
          },
          "base":"/home/cji/portless/Penlight/lua"
        },
        "summary":"",
        "tags":[],
        "lineno":430,
        "display_name":"Partitioning Strings",
        "type":"section",
        "modifiers":[]
      },
      "Strings_and_Lists":{
        "name":"lists",
        "inferred":true,
        "description":"",
        "file":{
          "warning":"<type 'function' is not supported by JSON.>",
          "filename":"/home/cji/portless/Penlight/lua/pl/stringx.lua",
          "items":["<reference cycle>",{
              "name":"predicates",
              "inferred":true,
              "description":"",
              "file":"<reference cycle>",
              "summary":"",
              "tags":[],
              "lineno":53,
              "display_name":"String Predicates",
              "type":"section",
              "modifiers":[]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "s":{
                    "type":"string"
                  }
                }
              },
              "summary":"does s only contain alphabetic characters?",
              "lineno":55,
              "args":"(s)",
              "section":"String Predicates",
              "name":"isalpha",
              "params":{
                "map":{
                  "s":" a string"
                },
                "1":"s"
              },
              "tags":[],
              "kind":"string predicates ",
              "description":"",
              "type":"function",
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "s":{
                    "type":"string"
                  }
                }
              },
              "summary":"does s only contain digits?",
              "lineno":62,
              "args":"(s)",
              "section":"String Predicates",
              "name":"isdigit",
              "params":{
                "map":{
                  "s":" a string"
                },
                "1":"s"
              },
              "tags":[],
              "kind":"string predicates ",
              "description":"",
              "type":"function",
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "s":{
                    "type":"string"
                  }
                }
              },
              "summary":"does s only contain alphanumeric characters?",
              "lineno":69,
              "args":"(s)",
              "section":"String Predicates",
              "name":"isalnum",
              "params":{
                "map":{
                  "s":" a string"
                },
                "1":"s"
              },
              "tags":[],
              "kind":"string predicates ",
              "description":"",
              "type":"function",
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "s":{
                    "type":"string"
                  }
                }
              },
              "summary":"does s only contain whitespace?",
              "lineno":77,
              "args":"(s)",
              "section":"String Predicates",
              "name":"isspace",
              "params":{
                "map":{
                  "s":" a string"
                },
                "1":"s"
              },
              "tags":[],
              "kind":"string predicates ",
              "description":"\n Matches on pattern '%s' so matches space, newline, tabs, etc.",
              "type":"function",
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "s":{
                    "type":"string"
                  }
                }
              },
              "summary":"does s only contain lower case characters?",
              "lineno":84,
              "args":"(s)",
              "section":"String Predicates",
              "name":"islower",
              "params":{
                "map":{
                  "s":" a string"
                },
                "1":"s"
              },
              "tags":[],
              "kind":"string predicates ",
              "description":"",
              "type":"function",
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "s":{
                    "type":"string"
                  }
                }
              },
              "summary":"does s only contain upper case characters?",
              "lineno":91,
              "args":"(s)",
              "section":"String Predicates",
              "name":"isupper",
              "params":{
                "map":{
                  "s":" a string"
                },
                "1":"s"
              },
              "tags":[],
              "kind":"string predicates ",
              "description":"",
              "type":"function",
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":[],
                  "s":{
                    "type":"string"
                  },
                  "prefix":[]
                }
              },
              "summary":"does s start with prefix or one of prefixes?",
              "lineno":120,
              "args":"(s, prefix)",
              "section":"String Predicates",
              "name":"startswith",
              "params":{
                "1":"s",
                "2":"prefix",
                "map":{
                  "s":" a string",
                  "prefix":" a string or an array of strings"
                }
              },
              "tags":[],
              "kind":"string predicates ",
              "description":"",
              "type":"function",
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":[],
                  "s":{
                    "type":"string"
                  },
                  "suffix":[]
                }
              },
              "summary":"does s end with suffix or one of suffixes?",
              "lineno":128,
              "args":"(s, suffix)",
              "section":"String Predicates",
              "name":"endswith",
              "params":{
                "1":"s",
                "2":"suffix",
                "map":{
                  "s":" a string",
                  "suffix":" a string or an array of strings"
                }
              },
              "tags":[],
              "kind":"string predicates ",
              "description":"",
              "type":"function",
              "parameter":"param"
            },"<reference cycle>",{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[]],
                "return":[],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":[],
                  "s":{
                    "type":"string"
                  },
                  "seq":[]
                }
              },
              "summary":"concatenate the strings using this string as a delimiter.",
              "lineno":141,
              "args":"(s, seq)",
              "usage":["stringx.join(' ', {1,2,3}) == '1 2 3'\n"],
              "section":"Strings and Lists",
              "name":"join",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"seq",
                "map":{
                  "s":" the string",
                  "seq":" a table of strings or numbers"
                }
              },
              "tags":[],
              "kind":"strings and lists ",
              "description":"\n Note that the arguments are reversed from `string.concat`.",
              "type":"function"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[[]],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "opt":true,
                    "type":"bool",
                    "optchain":true
                  },
                  "s":{
                    "type":"string"
                  },
                  "keep_ends":{
                    "opt":true,
                    "type":"bool",
                    "optchain":true
                  }
                }
              },
              "summary":"Split a string into a list of lines.",
              "lineno":154,
              "retgroups":[{
                  "1":{
                    "text":"List of lines",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s[, keep_ends])",
              "type":"function",
              "name":"splitlines",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"keep_ends",
                "map":{
                  "s":" the string.",
                  "keep_ends":" include line ends."
                }
              },
              "tags":[],
              "kind":"strings and lists ",
              "section":"Strings and Lists",
              "description":"\n `\"\\r\"`, `\"\\n\"`, and `\"\\r\\n\"` are considered line ends.\n They are not included in the lines unless `keepends` is passed.\n Terminal line end does not produce an extra line.\n Splitting an empty string results in an empty list.",
              "ret":["List of lines"]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[],[],[]],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "opt":true,
                    "type":"string",
                    "optchain":true
                  },
                  "3":{
                    "opt":true,
                    "type":"int",
                    "optchain":true
                  },
                  "re":{
                    "opt":true,
                    "type":"string",
                    "optchain":true
                  },
                  "n":{
                    "opt":true,
                    "type":"int",
                    "optchain":true
                  },
                  "s":{
                    "type":"string"
                  }
                },
                "return":[[]]
              },
              "summary":"split a string into a list of strings using a delimiter.",
              "lineno":193,
              "retgroups":[{
                  "1":{
                    "text":"List",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s[, re[, n]])",
              "usage":["#(stringx.split('one two')) == 2\n","stringx.split('one,two,three', ',') == List{'one','two','three'}\n","stringx.split('one,two,three', ',', 2) == List{'one','two,three'}\n"],
              "type":"function",
              "name":"split",
              "params":{
                "1":"s",
                "2":"re",
                "map":{
                  "re":" a delimiter (defaults to whitespace)",
                  "n":" maximum number of results",
                  "s":" the string"
                },
                "3":"n"
              },
              "tags":[],
              "kind":"strings and lists ",
              "section":"Strings and Lists",
              "description":"",
              "ret":["List"],
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[],[]],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "type":"int"
                  },
                  "s":{
                    "type":"string"
                  },
                  "tabsize":{
                    "type":"int"
                  }
                },
                "return":[[]]
              },
              "summary":"replace all tabs in s with tabsize spaces.",
              "lineno":216,
              "retgroups":[{
                  "1":{
                    "text":"expanded string",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s, tabsize)",
              "usage":["stringx.expandtabs('\\tone,two,three', 4)   == '    one,two,three'\n","stringx.expandtabs('  \\tone,two,three', 4) == '    one,two,three'\n"],
              "type":"function",
              "name":"expandtabs",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"tabsize",
                "map":{
                  "s":" the string",
                  "tabsize":"[opt=8] number of spaces to expand each tab"
                }
              },
              "tags":[],
              "kind":"strings and lists ",
              "section":"Strings and Lists",
              "description":" If not specified, tabsize defaults to 8.\n Tab stops will be honored.",
              "ret":["expanded string"]
            },{
              "name":"find",
              "inferred":true,
              "description":"",
              "file":"<reference cycle>",
              "summary":"",
              "tags":[],
              "lineno":231,
              "display_name":"Finding and Replacing",
              "type":"section",
              "modifiers":[]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[[]],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "type":"string"
                  },
                  "3":{
                    "opt":true,
                    "type":"int",
                    "optchain":true
                  },
                  "4":{
                    "opt":true,
                    "type":"int",
                    "optchain":true
                  },
                  "first":{
                    "opt":true,
                    "type":"int",
                    "optchain":true
                  },
                  "sub":{
                    "type":"string"
                  },
                  "s":{
                    "type":"string"
                  },
                  "last":{
                    "opt":true,
                    "type":"int",
                    "optchain":true
                  }
                }
              },
              "summary":"find index of first instance of sub in s from the left.",
              "lineno":257,
              "retgroups":[{
                  "1":{
                    "text":"start index, or nil if not found",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s, sub[, first[, last]])",
              "type":"function",
              "name":"lfind",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"sub",
                "3":"first",
                "4":"last",
                "map":{
                  "first":" first index",
                  "sub":" substring",
                  "s":" the string",
                  "last":" last index"
                }
              },
              "tags":[],
              "kind":"finding and replacing ",
              "section":"Finding and Replacing",
              "description":"",
              "ret":["start index, or nil if not found"]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[[]],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "type":"string"
                  },
                  "3":{
                    "opt":true,
                    "type":"int",
                    "optchain":true
                  },
                  "4":{
                    "opt":true,
                    "type":"int",
                    "optchain":true
                  },
                  "first":{
                    "opt":true,
                    "type":"int",
                    "optchain":true
                  },
                  "sub":{
                    "type":"string"
                  },
                  "s":{
                    "type":"string"
                  },
                  "last":{
                    "opt":true,
                    "type":"int",
                    "optchain":true
                  }
                }
              },
              "summary":"find index of first instance of sub in s from the right.",
              "lineno":275,
              "retgroups":[{
                  "1":{
                    "text":"start index, or nil if not found",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s, sub[, first[, last]])",
              "type":"function",
              "name":"rfind",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"sub",
                "3":"first",
                "4":"last",
                "map":{
                  "first":" first index",
                  "sub":" substring",
                  "s":" the string",
                  "last":" last index"
                }
              },
              "tags":[],
              "kind":"finding and replacing ",
              "section":"Finding and Replacing",
              "description":"",
              "ret":["start index, or nil if not found"]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[[]],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "type":"string"
                  },
                  "3":{
                    "type":"string"
                  },
                  "4":{
                    "opt":true,
                    "type":"int",
                    "optchain":true
                  },
                  "n":{
                    "opt":true,
                    "type":"int",
                    "optchain":true
                  },
                  "old":{
                    "type":"string"
                  },
                  "s":{
                    "type":"string"
                  },
                  "new":{
                    "type":"string"
                  }
                }
              },
              "summary":"replace up to n instances of old by new in the string s.",
              "lineno":288,
              "retgroups":[{
                  "1":{
                    "text":"result string",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s, old, new[, n])",
              "type":"function",
              "name":"replace",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"old",
                "3":"new",
                "4":"n",
                "map":{
                  "n":" optional maximum number of substitutions",
                  "old":" the target substring",
                  "s":" the string",
                  "new":" the substitution"
                }
              },
              "tags":[],
              "kind":"finding and replacing ",
              "section":"Finding and Replacing",
              "description":"\n If n is not present, replace all instances.",
              "ret":["result string"]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[]],
                "return":[],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "type":"string"
                  },
                  "3":{
                    "opt":true,
                    "type":"bool",
                    "optchain":true
                  },
                  "sub":{
                    "type":"string"
                  },
                  "s":{
                    "type":"string"
                  },
                  "allow_overlap":{
                    "opt":true,
                    "type":"bool",
                    "optchain":true
                  }
                }
              },
              "summary":"count all instances of substring in string.",
              "lineno":302,
              "args":"(s, sub[, allow_overlap])",
              "usage":["assert(stringx.count('banana', 'ana') == 1)\nassert(stringx.count('banana', 'ana', true) == 2)\n"],
              "section":"Finding and Replacing",
              "name":"count",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"sub",
                "map":{
                  "sub":" substring",
                  "s":" the string",
                  "allow_overlap":" allow matches to overlap"
                },
                "3":"allow_overlap"
              },
              "tags":[],
              "kind":"finding and replacing ",
              "description":"",
              "type":"function"
            },{
              "name":"strip",
              "inferred":true,
              "description":"",
              "file":"<reference cycle>",
              "summary":"",
              "tags":[],
              "lineno":311,
              "display_name":"Stripping and Justifying",
              "type":"section",
              "modifiers":[]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[]],
                "return":[],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "type":"int"
                  },
                  "3":{
                    "opt":"' '",
                    "type":"string",
                    "optchain":"' '"
                  },
                  "ch":{
                    "opt":"' '",
                    "type":"string",
                    "optchain":"' '"
                  },
                  "s":{
                    "type":"string"
                  },
                  "w":{
                    "type":"int"
                  }
                }
              },
              "summary":"left-justify s with width w.",
              "lineno":339,
              "args":"(s, w[, ch=' '])",
              "usage":["stringx.ljust('hello', 10, '*') == '*****hello'\n"],
              "section":"Stripping and Justifying",
              "name":"ljust",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"w",
                "map":{
                  "ch":" padding character",
                  "s":" the string",
                  "w":" width of justification"
                },
                "3":"ch"
              },
              "tags":[],
              "kind":"stripping and justifying ",
              "description":"",
              "type":"function"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[]],
                "return":[],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "type":"int"
                  },
                  "3":{
                    "opt":"' '",
                    "type":"string",
                    "optchain":"' '"
                  },
                  "ch":{
                    "opt":"' '",
                    "type":"string",
                    "optchain":"' '"
                  },
                  "s":{
                    "type":"string"
                  },
                  "w":{
                    "type":"int"
                  }
                }
              },
              "summary":"right-justify s with width w.",
              "lineno":350,
              "args":"(s, w[, ch=' '])",
              "usage":["stringx.rjust('hello', 10, '*') == 'hello*****'\n"],
              "section":"Stripping and Justifying",
              "name":"rjust",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"w",
                "map":{
                  "ch":" padding character",
                  "s":" the string",
                  "w":" width of justification"
                },
                "3":"ch"
              },
              "tags":[],
              "kind":"stripping and justifying ",
              "description":"",
              "type":"function"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[]],
                "return":[],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "type":"int"
                  },
                  "3":{
                    "opt":"' '",
                    "type":"string",
                    "optchain":"' '"
                  },
                  "ch":{
                    "opt":"' '",
                    "type":"string",
                    "optchain":"' '"
                  },
                  "s":{
                    "type":"string"
                  },
                  "w":{
                    "type":"int"
                  }
                }
              },
              "summary":"center-justify s with width w.",
              "lineno":361,
              "args":"(s, w[, ch=' '])",
              "usage":["stringx.center('hello', 10, '*') == '**hello***'\n"],
              "section":"Stripping and Justifying",
              "name":"center",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"w",
                "map":{
                  "ch":" padding character",
                  "s":" the string",
                  "w":" width of justification"
                },
                "3":"ch"
              },
              "tags":[],
              "kind":"stripping and justifying ",
              "description":"",
              "type":"function"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "opt":"'%s'",
                    "type":"string",
                    "optchain":"'%s'"
                  },
                  "s":{
                    "type":"string"
                  },
                  "chrs":{
                    "opt":"'%s'",
                    "type":"string",
                    "optchain":"'%s'"
                  }
                }
              },
              "summary":"trim any characters on the left of s.",
              "lineno":402,
              "args":"(s[, chrs='%s'])",
              "section":"Stripping and Justifying",
              "name":"lstrip",
              "params":{
                "1":"s",
                "2":"chrs",
                "map":{
                  "s":" the string",
                  "chrs":" default any whitespace character,\n but can be a string of characters to be trimmed"
                }
              },
              "tags":[],
              "kind":"stripping and justifying ",
              "description":"",
              "type":"function",
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "opt":"'%s'",
                    "type":"string",
                    "optchain":"'%s'"
                  },
                  "s":{
                    "type":"string"
                  },
                  "chrs":{
                    "opt":"'%s'",
                    "type":"string",
                    "optchain":"'%s'"
                  }
                }
              },
              "summary":"trim any characters on the right of s.",
              "lineno":412,
              "args":"(s[, chrs='%s'])",
              "section":"Stripping and Justifying",
              "name":"rstrip",
              "params":{
                "1":"s",
                "2":"chrs",
                "map":{
                  "s":" the string",
                  "chrs":" default any whitespace character,\n but can be a string of characters to be trimmed"
                }
              },
              "tags":[],
              "kind":"stripping and justifying ",
              "description":"",
              "type":"function",
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[]],
                "return":[],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "opt":"'%s'",
                    "type":"string",
                    "optchain":"'%s'"
                  },
                  "s":{
                    "type":"string"
                  },
                  "chrs":{
                    "opt":"'%s'",
                    "type":"string",
                    "optchain":"'%s'"
                  }
                }
              },
              "summary":"trim any characters on both left and right of s.",
              "lineno":422,
              "args":"(s[, chrs='%s'])",
              "usage":["stringx.strip('  --== Hello ==--  ', \"- =\")  --> 'Hello'\n"],
              "section":"Stripping and Justifying",
              "name":"strip",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"chrs",
                "map":{
                  "s":" the string",
                  "chrs":" default any whitespace character,\n but can be a string of characters to be trimmed"
                }
              },
              "tags":[],
              "kind":"stripping and justifying ",
              "description":"",
              "type":"function"
            },{
              "name":"partitioning",
              "inferred":true,
              "description":"",
              "file":"<reference cycle>",
              "summary":"",
              "tags":[],
              "lineno":430,
              "display_name":"Partitioning Strings",
              "type":"section",
              "modifiers":[]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "opt":"'%s'",
                    "type":"string",
                    "optchain":"'%s'"
                  },
                  "s":{
                    "type":"string"
                  },
                  "re":{
                    "opt":"'%s'",
                    "type":"string",
                    "optchain":"'%s'"
                  }
                },
                "return":[[]],
                "usage":[[]],
                "see":[[]]
              },
              "summary":"split a string using a pattern.",
              "lineno":436,
              "retgroups":[{
                  "1":{
                    "text":"the parts of the string",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s[, re='%s'])",
              "usage":["a,b = line:splitv('=')\n"],
              "type":"function",
              "name":"splitv",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"re",
                "map":{
                  "s":" the string",
                  "re":" a Lua string pattern (defaults to whitespace)"
                }
              },
              "tags":{
                "see":[]
              },
              "kind":"partitioning strings ",
              "section":"Partitioning Strings",
              "description":" Note that at least one value will be returned!",
              "ret":["the parts of the string"]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[],[]],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "type":"string"
                  },
                  "s":{
                    "type":"string"
                  },
                  "ch":{
                    "type":"string"
                  }
                },
                "return":[[],[],[]]
              },
              "summary":"partition the string using first occurance of a delimiter",
              "lineno":461,
              "retgroups":[{
                  "1":{
                    "text":"part before ch",
                    "type":"",
                    "mods":[]
                  },
                  "2":{
                    "text":"ch",
                    "type":"",
                    "mods":[]
                  },
                  "3":{
                    "text":"part after ch",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s, ch)",
              "usage":["{stringx.partition('a,b,c', ','))} == {'a', ',', 'b,c'}\n","{stringx.partition('abc', 'x'))} == {'abc', '', ''}\n"],
              "type":"function",
              "name":"partition",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"ch",
                "map":{
                  "s":" the string",
                  "ch":" delimiter (match as plain string, no patterns)"
                }
              },
              "tags":[],
              "kind":"partitioning strings ",
              "section":"Partitioning Strings",
              "description":"",
              "ret":["part before ch","ch","part after ch"]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[],[]],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "type":"string"
                  },
                  "s":{
                    "type":"string"
                  },
                  "ch":{
                    "type":"string"
                  }
                },
                "return":[[],[],[]]
              },
              "summary":"partition the string p using last occurance of a delimiter",
              "lineno":475,
              "retgroups":[{
                  "1":{
                    "text":"part before ch",
                    "type":"",
                    "mods":[]
                  },
                  "2":{
                    "text":"ch",
                    "type":"",
                    "mods":[]
                  },
                  "3":{
                    "text":"part after ch",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s, ch)",
              "usage":["{stringx.rpartition('a,b,c', ','))} == {'a,b', ',', 'c'}\n","{stringx.rpartition('abc', 'x'))} == {'', '', 'abc'}\n"],
              "type":"function",
              "name":"rpartition",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"ch",
                "map":{
                  "s":" the string",
                  "ch":" delimiter (match as plain string, no patterns)"
                }
              },
              "tags":[],
              "kind":"partitioning strings ",
              "section":"Partitioning Strings",
              "description":"",
              "ret":["part before ch","ch","part after ch"]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[[]],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "type":"int"
                  },
                  "s":{
                    "type":"string"
                  },
                  "idx":{
                    "type":"int"
                  }
                }
              },
              "summary":"return the 'character' at the index.",
              "lineno":489,
              "retgroups":[{
                  "1":{
                    "text":"a substring of length 1 if successful, empty string otherwise.",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s, idx)",
              "type":"function",
              "name":"at",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"idx",
                "map":{
                  "s":" the string",
                  "idx":" an index (can be negative)"
                }
              },
              "tags":[],
              "kind":"partitioning strings ",
              "section":"Partitioning Strings",
              "description":"",
              "ret":["a substring of length 1 if successful, empty string otherwise."]
            },{
              "name":"text",
              "inferred":true,
              "description":"",
              "file":"<reference cycle>",
              "summary":"",
              "tags":[],
              "lineno":500,
              "display_name":"Text handling",
              "type":"section",
              "modifiers":[]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[[]],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "type":"integer"
                  },
                  "3":{
                    "opt":"' '",
                    "type":"string",
                    "optchain":"' '"
                  },
                  "ch":{
                    "opt":"' '",
                    "type":"string",
                    "optchain":"' '"
                  },
                  "n":{
                    "type":"integer"
                  },
                  "s":{
                    "type":"string"
                  }
                }
              },
              "summary":"indent a multiline string.",
              "lineno":505,
              "retgroups":[{
                  "1":{
                    "text":"indented string",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s, n[, ch=' '])",
              "type":"function",
              "name":"indent",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"n",
                "map":{
                  "ch":" the character to use when indenting",
                  "n":" the size of the indent",
                  "s":" the (multiline) string"
                },
                "3":"ch"
              },
              "tags":[],
              "kind":"text handling ",
              "section":"Text handling",
              "description":"",
              "ret":["indented string"]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[]],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "s":{
                    "type":"string"
                  }
                },
                "return":[[]]
              },
              "summary":"dedent a multiline string by removing any initial indent.",
              "lineno":537,
              "retgroups":[{
                  "1":{
                    "text":"a string with initial indent zero.",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s)",
              "usage":["local s = dedent [[\n         One\n\n       Two\n\n     Three\n]]\nassert(s == [[\n    One\n\n  Two\n\nThree\n]])\n"],
              "type":"function",
              "name":"dedent",
              "parameter":"param",
              "params":{
                "map":{
                  "s":" the (multiline) string"
                },
                "1":"s"
              },
              "tags":[],
              "kind":"text handling ",
              "section":"Text handling",
              "description":"\n useful when working with [[..]] strings.\n Empty lines are ignored.",
              "ret":["a string with initial indent zero."]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "opt":"70",
                    "type":"integer",
                    "optchain":"70"
                  },
                  "3":{
                    "opt":"false",
                    "type":"boolean",
                    "optchain":"false"
                  },
                  "width":{
                    "opt":"70",
                    "type":"integer",
                    "optchain":"70"
                  },
                  "s":{
                    "type":"string"
                  },
                  "breaklong":{
                    "opt":"false",
                    "type":"boolean",
                    "optchain":"false"
                  }
                },
                "return":[[]],
                "see":[[],[]]
              },
              "summary":"format a paragraph into lines so that they fit into a line width.",
              "lineno":594,
              "retgroups":[{
                  "1":{
                    "text":"a list of lines (List object), use `fill` to return a string instead of a `List`.",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s[, width=70[, breaklong=false]])",
              "type":"function",
              "name":"wrap",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"width",
                "map":{
                  "width":" the margin width",
                  "s":" the string to format",
                  "breaklong":" if truthy, words longer than the width given will be forced split."
                },
                "3":"breaklong"
              },
              "tags":{
                "see":[]
              },
              "kind":"text handling ",
              "section":"Text handling",
              "description":"\n It will not break long words by default, so lines can be over the length\n to that extent.",
              "ret":["a list of lines (List object), use `fill` to return a string instead of a `List`."]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "opt":"70",
                    "type":"integer",
                    "optchain":"70"
                  },
                  "3":{
                    "opt":"false",
                    "type":"boolean",
                    "optchain":"false"
                  },
                  "width":{
                    "opt":"70",
                    "type":"integer",
                    "optchain":"70"
                  },
                  "s":{
                    "type":"string"
                  },
                  "breaklong":{
                    "opt":"false",
                    "type":"boolean",
                    "optchain":"false"
                  }
                },
                "return":[[]],
                "see":[[]]
              },
              "summary":"format a paragraph so that it fits into a line width.",
              "lineno":616,
              "retgroups":[{
                  "1":{
                    "text":"a string, use `wrap` to return a list of lines instead of a string.",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s[, width=70[, breaklong=false]])",
              "type":"function",
              "name":"fill",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"width",
                "map":{
                  "width":" the margin width",
                  "s":" the string to format",
                  "breaklong":" if truthy, words longer than the width given will be forced split."
                },
                "3":"breaklong"
              },
              "tags":{
                "see":[]
              },
              "kind":"text handling ",
              "section":"Text handling",
              "description":"",
              "ret":["a string, use `wrap` to return a list of lines instead of a string."]
            },{
              "name":"Template",
              "inferred":true,
              "description":"",
              "file":"<reference cycle>",
              "summary":"",
              "tags":[],
              "lineno":624,
              "display_name":"Template",
              "type":"section",
              "modifiers":[]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "tmpl":{
                    "type":"string"
                  }
                },
                "return":[{
                    "type":"Template"
                  }]
              },
              "summary":"Creates a new Template class.",
              "lineno":662,
              "retgroups":[{
                  "1":{
                    "text":"",
                    "type":"Template",
                    "mods":{
                      "type":"Template"
                    }
                  },
                  "g":0
                }],
              "args":"(tmpl)",
              "section":"Template",
              "name":"Template",
              "params":{
                "map":{
                  "tmpl":" the template string"
                },
                "1":"tmpl"
              },
              "tags":[],
              "kind":"template ",
              "description":"\n This is a shortcut to `Template.new(tmpl)`.",
              "type":"function",
              "ret":[""],
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[[]],
                "param":{
                  "1":{
                    "type":"table"
                  },
                  "tbl":{
                    "type":"table"
                  }
                }
              },
              "summary":"substitute values into a template, throwing an error.",
              "lineno":674,
              "retgroups":[{
                  "1":{
                    "text":"string with place holders substituted",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(tbl)",
              "type":"function",
              "name":"Template:substitute",
              "parameter":"param",
              "params":{
                "map":{
                  "tbl":" a table of name-value pairs."
                },
                "1":"tbl"
              },
              "tags":[],
              "kind":"template ",
              "section":"Template",
              "description":"\n This will throw an error if no name is found.",
              "ret":["string with place holders substituted"]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[[]],
                "param":{
                  "1":{
                    "type":"table"
                  },
                  "tbl":{
                    "type":"table"
                  }
                }
              },
              "summary":"substitute values into a template.",
              "lineno":683,
              "retgroups":[{
                  "1":{
                    "text":"string with place holders substituted",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(tbl)",
              "type":"function",
              "name":"Template:safe_substitute",
              "parameter":"param",
              "params":{
                "map":{
                  "tbl":" a table of name-value pairs."
                },
                "1":"tbl"
              },
              "tags":[],
              "kind":"template ",
              "section":"Template",
              "description":"\n This version just passes unknown names through.",
              "ret":["string with place holders substituted"]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[[]],
                "param":{
                  "1":{
                    "type":"table"
                  },
                  "tbl":{
                    "type":"table"
                  }
                }
              },
              "summary":"substitute values into a template, preserving indentation.",
              "lineno":695,
              "retgroups":[{
                  "1":{
                    "text":"string with place holders substituted",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(tbl)",
              "type":"function",
              "name":"Template:indent_substitute",
              "parameter":"param",
              "params":{
                "map":{
                  "tbl":" a table of name-value pairs."
                },
                "1":"tbl"
              },
              "tags":[],
              "kind":"template ",
              "section":"Template",
              "description":" <br>\n If the value is a multiline string _or_ a template, it will insert\n the lines at the correct indentation. <br>\n Furthermore, if a template, then that template will be substituted\n using the same table.",
              "ret":["string with place holders substituted"]
            },{
              "name":"misc",
              "inferred":true,
              "description":"",
              "file":"<reference cycle>",
              "summary":"",
              "tags":[],
              "lineno":742,
              "display_name":"Miscelaneous",
              "type":"section",
              "modifiers":[]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[]],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "s":{
                    "type":"string"
                  }
                },
                "return":[[]]
              },
              "summary":"return an iterator over all lines in a string",
              "lineno":751,
              "retgroups":[{
                  "1":{
                    "text":"an iterator",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s)",
              "usage":["local line_no = 1\nfor line in stringx.lines(some_text) do\n  print(line_no, line)\n  line_no = line_no + 1\nend\n"],
              "type":"function",
              "name":"lines",
              "parameter":"param",
              "params":{
                "map":{
                  "s":" the string"
                },
                "1":"s"
              },
              "tags":[],
              "kind":"miscelaneous ",
              "section":"Miscelaneous",
              "description":"",
              "ret":["an iterator"]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[]],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "s":{
                    "type":"string"
                  }
                },
                "return":[[]]
              },
              "summary":"inital word letters uppercase ('title case').",
              "lineno":762,
              "retgroups":[{
                  "1":{
                    "text":"a string with each word's first letter uppercase",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s)",
              "usage":["stringx.title(\"hello world\") == \"Hello World\")\n"],
              "type":"function",
              "name":"title",
              "parameter":"param",
              "params":{
                "map":{
                  "s":" the string"
                },
                "1":"s"
              },
              "tags":[],
              "kind":"miscelaneous ",
              "section":"Miscelaneous",
              "description":"\n Here 'words' mean chunks of non-space characters.",
              "ret":["a string with each word's first letter uppercase"]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[],[],[]],
                "return":[],
                "param":{
                  "1":{
                    "type":"string"
                  },
                  "2":{
                    "type":"int"
                  },
                  "3":{
                    "type":"bool"
                  },
                  "tail":{
                    "type":"bool"
                  },
                  "s":{
                    "type":"string"
                  },
                  "w":{
                    "type":"int"
                  }
                }
              },
              "summary":"Return a shortened version of a string.",
              "lineno":783,
              "args":"(s, w, tail)",
              "usage":["('1234567890'):shorten(8) == '12345...'\n","('1234567890'):shorten(8, true) == '...67890'\n","('1234567890'):shorten(20) == '1234567890'\n"],
              "section":"Miscelaneous",
              "name":"shorten",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"w",
                "map":{
                  "tail":" true if we want to show the end of the string (head otherwise)",
                  "s":" the string",
                  "w":" the maxinum size allowed"
                },
                "3":"tail"
              },
              "tags":[],
              "kind":"miscelaneous ",
              "description":"\n Fits string within w characters. Removed characters are marked with ellipsis.",
              "type":"function"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[[]],
                "param":{
                  "1":[],
                  "s":[]
                }
              },
              "summary":"Quote the given string and preserve any control or escape characters, such that reloading the string in Lua returns the same result.",
              "lineno":822,
              "retgroups":[{
                  "1":{
                    "text":"The quoted string.",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s)",
              "type":"function",
              "name":"quote_string",
              "parameter":"param",
              "params":{
                "map":{
                  "s":" The string to be quoted."
                },
                "1":"s"
              },
              "tags":[],
              "kind":"miscelaneous ",
              "section":"Miscelaneous",
              "description":"",
              "ret":["The quoted string."]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":[],
                "usage":[[]]
              },
              "summary":"Python-style formatting operator.",
              "lineno":873,
              "args":"()",
              "usage":["require 'pl.text'.format_operator()\nlocal out1 = '%s = %5.3f' % {'PI',math.pi}                   --> 'PI = 3.142'\nlocal out2 = '$name = $value' % {name='dog',value='Pluto'}   --> 'dog = Pluto'\n"],
              "section":"Miscelaneous",
              "name":"format_operator",
              "parameter":"param",
              "params":{
                "map":[]
              },
              "tags":[],
              "kind":"miscelaneous ",
              "description":"\n Calling `text.format_operator()` overloads the % operator for strings to give\n Python/Ruby style formated output.\n This is extended to also do template-like substitution for map-like data.\n\n Note this goes further than the original, and will allow these cases:\n\n 1. a single value\n 2. a list of values\n 3. a map of var=value pairs\n 4. a function, as in gsub\n\n For the second two cases, it uses $-variable substituion.\n\n When called, this function will monkey-patch the global `string` metatable by\n adding a `__mod` method.\n\n See <a href=\"http://lua-users.org/wiki/StringInterpolation\">the lua-users wiki</a>\n",
              "type":"function"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "param":[],
                "return":[]
              },
              "summary":"import the stringx functions into the global string (meta)table",
              "lineno":913,
              "args":"()",
              "section":"Miscelaneous",
              "name":"import",
              "params":{
                "map":[]
              },
              "tags":[],
              "kind":"miscelaneous ",
              "description":"",
              "type":"function",
              "parameter":"param"
            }],
          "sections":[],
          "modules":["<reference cycle>"],
          "args":{
            "one":false,
            "module":false,
            "verbose":false,
            "style":"!",
            "template":"!",
            "date":"system",
            "dir":"doc",
            "quiet":false,
            "all":false,
            "ignore":false,
            "colon":false,
            "not_luadoc":false,
            "ext":"html",
            "boilerplate":false,
            "merge":false,
            "filter":"f.filter",
            "package":"/home/cji/portless/Penlight/lua",
            "dump":false,
            "no_args_infer":false,
            "title":"Reference",
            "project":"ldoc",
            "file":"/home/cji/portless/Penlight/lua/pl",
            "format":"discount",
            "simple":false,
            "tags":"none",
            "define":"none",
            "output":"index",
            "unqualified":false,
            "config":"config.ld",
            "fatalwarnings":false,
            "testing":false
          },
          "error":"<type 'function' is not supported by JSON.>",
          "lang":{
            "line_comment":"^%-%-+",
            "start_comment_":"^%-%-%-+",
            "end_comment_":"[^%-]%-%-+[^-]*\n$",
            "extra":[],
            "block_comment":"^%-%-%[=*%[%-+",
            "empty_comment_":"^%-%-%-+%s*$",
            "method_call":":"
          },
          "base":"/home/cji/portless/Penlight/lua"
        },
        "summary":"",
        "tags":[],
        "lineno":136,
        "display_name":"Strings and Lists",
        "type":"section",
        "modifiers":[]
      }
    }
  },
  "mod_name":"stringx",
  "lineno":11,
  "items":[{
      "inferred":true,
      "subparams":[],
      "modifiers":{
        "return":[],
        "param":{
          "1":{
            "type":"string"
          },
          "s":{
            "type":"string"
          }
        }
      },
      "summary":"does s only contain alphabetic characters?",
      "lineno":55,
      "args":"(s)",
      "section":"String Predicates",
      "name":"isalpha",
      "params":{
        "map":{
          "s":" a string"
        },
        "1":"s"
      },
      "tags":[],
      "kind":"string predicates ",
      "description":"",
      "type":"function",
      "parameter":"param"
    },{
      "inferred":true,
      "subparams":[],
      "modifiers":{
        "return":[],
        "param":{
          "1":{
            "type":"string"
          },
          "s":{
            "type":"string"
          }
        }
      },
      "summary":"does s only contain digits?",
      "lineno":62,
      "args":"(s)",
      "section":"String Predicates",
      "name":"isdigit",
      "params":{
        "map":{
          "s":" a string"
        },
        "1":"s"
      },
      "tags":[],
      "kind":"string predicates ",
      "description":"",
      "type":"function",
      "parameter":"param"
    },{
      "inferred":true,
      "subparams":[],
      "modifiers":{
        "return":[],
        "param":{
          "1":{
            "type":"string"
          },
          "s":{
            "type":"string"
          }
        }
      },
      "summary":"does s only contain alphanumeric characters?",
      "lineno":69,
      "args":"(s)",
      "section":"String Predicates",
      "name":"isalnum",
      "params":{
        "map":{
          "s":" a string"
        },
        "1":"s"
      },
      "tags":[],
      "kind":"string predicates ",
      "description":"",
      "type":"function",
      "parameter":"param"
    },{
      "inferred":true,
      "subparams":[],
      "modifiers":{
        "return":[],
        "param":{
          "1":{
            "type":"string"
          },
          "s":{
            "type":"string"
          }
        }
      },
      "summary":"does s only contain whitespace?",
      "lineno":77,
      "args":"(s)",
      "section":"String Predicates",
      "name":"isspace",
      "params":{
        "map":{
          "s":" a string"
        },
        "1":"s"
      },
      "tags":[],
      "kind":"string predicates ",
      "description":"\n Matches on pattern '%s' so matches space, newline, tabs, etc.",
      "type":"function",
      "parameter":"param"
    },{
      "inferred":true,
      "subparams":[],
      "modifiers":{
        "return":[],
        "param":{
          "1":{
            "type":"string"
          },
          "s":{
            "type":"string"
          }
        }
      },
      "summary":"does s only contain lower case characters?",
      "lineno":84,
      "args":"(s)",
      "section":"String Predicates",
      "name":"islower",
      "params":{
        "map":{
          "s":" a string"
        },
        "1":"s"
      },
      "tags":[],
      "kind":"string predicates ",
      "description":"",
      "type":"function",
      "parameter":"param"
    },{
      "inferred":true,
      "subparams":[],
      "modifiers":{
        "return":[],
        "param":{
          "1":{
            "type":"string"
          },
          "s":{
            "type":"string"
          }
        }
      },
      "summary":"does s only contain upper case characters?",
      "lineno":91,
      "args":"(s)",
      "section":"String Predicates",
      "name":"isupper",
      "params":{
        "map":{
          "s":" a string"
        },
        "1":"s"
      },
      "tags":[],
      "kind":"string predicates ",
      "description":"",
      "type":"function",
      "parameter":"param"
    },{
      "inferred":true,
      "subparams":[],
      "modifiers":{
        "return":[],
        "param":{
          "1":{
            "type":"string"
          },
          "2":[],
          "s":{
            "type":"string"
          },
          "prefix":[]
        }
      },
      "summary":"does s start with prefix or one of prefixes?",
      "lineno":120,
      "args":"(s, prefix)",
      "section":"String Predicates",
      "name":"startswith",
      "params":{
        "1":"s",
        "2":"prefix",
        "map":{
          "s":" a string",
          "prefix":" a string or an array of strings"
        }
      },
      "tags":[],
      "kind":"string predicates ",
      "description":"",
      "type":"function",
      "parameter":"param"
    },{
      "inferred":true,
      "subparams":[],
      "modifiers":{
        "return":[],
        "param":{
          "1":{
            "type":"string"
          },
          "2":[],
          "s":{
            "type":"string"
          },
          "suffix":[]
        }
      },
      "summary":"does s end with suffix or one of suffixes?",
      "lineno":128,
      "args":"(s, suffix)",
      "section":"String Predicates",
      "name":"endswith",
      "params":{
        "1":"s",
        "2":"suffix",
        "map":{
          "s":" a string",
          "suffix":" a string or an array of strings"
        }
      },
      "tags":[],
      "kind":"string predicates ",
      "description":"",
      "type":"function",
      "parameter":"param"
    },{
      "inferred":true,
      "subparams":[],
      "modifiers":{
        "usage":[[]],
        "return":[],
        "param":{
          "1":{
            "type":"string"
          },
          "2":[],
          "s":{
            "type":"string"
          },
          "seq":[]
        }
      },
      "summary":"concatenate the strings using this string as a delimiter.",
      "lineno":141,
      "args":"(s, seq)",
      "usage":["stringx.join(' ', {1,2,3}) == '1 2 3'\n"],
      "section":"Strings and Lists",
      "name":"join",
      "parameter":"param",
      "params":{
        "1":"s",
        "2":"seq",
        "map":{
          "s":" the string",
          "seq":" a table of strings or numbers"
        }
      },
      "tags":[],
      "kind":"strings and lists ",
      "description":"\n Note that the arguments are reversed from `string.concat`.",
      "type":"function"
    },{
      "inferred":true,
      "subparams":[],
      "modifiers":{
        "return":[[]],
        "param":{
          "1":{
            "type":"string"
          },
          "2":{
            "opt":true,
            "type":"bool",
            "optchain":true
          },
          "s":{
            "type":"string"
          },
          "keep_ends":{
            "opt":true,
            "type":"bool",
            "optchain":true
          }
        }
      },
      "summary":"Split a string into a list of lines.",
      "lineno":154,
      "retgroups":[{
          "1":{
            "text":"List of lines",
            "type":"",
            "mods":[]
          },
          "g":0
        }],
      "args":"(s[, keep_ends])",
      "type":"function",
      "name":"splitlines",
      "parameter":"param",
      "params":{
        "1":"s",
        "2":"keep_ends",
        "map":{
          "s":" the string.",
          "keep_ends":" include line ends."
        }
      },
      "tags":[],
      "kind":"strings and lists ",
      "section":"Strings and Lists",
      "description":"\n `\"\\r\"`, `\"\\n\"`, and `\"\\r\\n\"` are considered line ends.\n They are not included in the lines unless `keepends` is passed.\n Terminal line end does not produce an extra line.\n Splitting an empty string results in an empty list.",
      "ret":["List of lines"]
    },{
      "inferred":true,
      "subparams":[],
      "modifiers":{
        "usage":[[],[],[]],
        "param":{
          "1":{
            "type":"string"
          },
          "2":{
            "opt":true,
            "type":"string",
            "optchain":true
          },
          "3":{
            "opt":true,
            "type":"int",
            "optchain":true
          },
          "re":{
            "opt":true,
            "type":"string",
            "optchain":true
          },
          "n":{
            "opt":true,
            "type":"int",
            "optchain":true
          },
          "s":{
            "type":"string"
          }
        },
        "return":[[]]
      },
      "summary":"split a string into a list of strings using a delimiter.",
      "lineno":193,
      "retgroups":[{
          "1":{
            "text":"List",
            "type":"",
            "mods":[]
          },
          "g":0
        }],
      "args":"(s[, re[, n]])",
      "usage":["#(stringx.split('one two')) == 2\n","stringx.split('one,two,three', ',') == List{'one','two','three'}\n","stringx.split('one,two,three', ',', 2) == List{'one','two,three'}\n"],
      "type":"function",
      "name":"split",
      "params":{
        "1":"s",
        "2":"re",
        "map":{
          "re":" a delimiter (defaults to whitespace)",
          "n":" maximum number of results",
          "s":" the string"
        },
        "3":"n"
      },
      "tags":[],
      "kind":"strings and lists ",
      "section":"Strings and Lists",
      "description":"",
      "ret":["List"],
      "parameter":"param"
    },{
      "inferred":true,
      "subparams":[],
      "modifiers":{
        "usage":[[],[]],
        "param":{
          "1":{
            "type":"string"
          },
          "2":{
            "type":"int"
          },
          "s":{
            "type":"string"
          },
          "tabsize":{
            "type":"int"
          }
        },
        "return":[[]]
      },
      "summary":"replace all tabs in s with tabsize spaces.",
      "lineno":216,
      "retgroups":[{
          "1":{
            "text":"expanded string",
            "type":"",
            "mods":[]
          },
          "g":0
        }],
      "args":"(s, tabsize)",
      "usage":["stringx.expandtabs('\\tone,two,three', 4)   == '    one,two,three'\n","stringx.expandtabs('  \\tone,two,three', 4) == '    one,two,three'\n"],
      "type":"function",
      "name":"expandtabs",
      "parameter":"param",
      "params":{
        "1":"s",
        "2":"tabsize",
        "map":{
          "s":" the string",
          "tabsize":"[opt=8] number of spaces to expand each tab"
        }
      },
      "tags":[],
      "kind":"strings and lists ",
      "section":"Strings and Lists",
      "description":" If not specified, tabsize defaults to 8.\n Tab stops will be honored.",
      "ret":["expanded string"]
    },{
      "inferred":true,
      "subparams":[],
      "modifiers":{
        "return":[[]],
        "param":{
          "1":{
            "type":"string"
          },
          "2":{
            "type":"string"
          },
          "3":{
            "opt":true,
            "type":"int",
            "optchain":true
          },
          "4":{
            "opt":true,
            "type":"int",
            "optchain":true
          },
          "first":{
            "opt":true,
            "type":"int",
            "optchain":true
          },
          "sub":{
            "type":"string"
          },
          "s":{
            "type":"string"
          },
          "last":{
            "opt":true,
            "type":"int",
            "optchain":true
          }
        }
      },
      "summary":"find index of first instance of sub in s from the left.",
      "lineno":257,
      "retgroups":[{
          "1":{
            "text":"start index, or nil if not found",
            "type":"",
            "mods":[]
          },
          "g":0
        }],
      "args":"(s, sub[, first[, last]])",
      "type":"function",
      "name":"lfind",
      "parameter":"param",
      "params":{
        "1":"s",
        "2":"sub",
        "3":"first",
        "4":"last",
        "map":{
          "first":" first index",
          "sub":" substring",
          "s":" the string",
          "last":" last index"
        }
      },
      "tags":[],
      "kind":"finding and replacing ",
      "section":"Finding and Replacing",
      "description":"",
      "ret":["start index, or nil if not found"]
    },{
      "inferred":true,
      "subparams":[],
      "modifiers":{
        "return":[[]],
        "param":{
          "1":{
            "type":"string"
          },
          "2":{
            "type":"string"
          },
          "3":{
            "opt":true,
            "type":"int",
            "optchain":true
          },
          "4":{
            "opt":true,
            "type":"int",
            "optchain":true
          },
          "first":{
            "opt":true,
            "type":"int",
            "optchain":true
          },
          "sub":{
            "type":"string"
          },
          "s":{
            "type":"string"
          },
          "last":{
            "opt":true,
            "type":"int",
            "optchain":true
          }
        }
      },
      "summary":"find index of first instance of sub in s from the right.",
      "lineno":275,
      "retgroups":[{
          "1":{
            "text":"start index, or nil if not found",
            "type":"",
            "mods":[]
          },
          "g":0
        }],
      "args":"(s, sub[, first[, last]])",
      "type":"function",
      "name":"rfind",
      "parameter":"param",
      "params":{
        "1":"s",
        "2":"sub",
        "3":"first",
        "4":"last",
        "map":{
          "first":" first index",
          "sub":" substring",
          "s":" the string",
          "last":" last index"
        }
      },
      "tags":[],
      "kind":"finding and replacing ",
      "section":"Finding and Replacing",
      "description":"",
      "ret":["start index, or nil if not found"]
    },{
      "inferred":true,
      "subparams":[],
      "modifiers":{
        "return":[[]],
        "param":{
          "1":{
            "type":"string"
          },
          "2":{
            "type":"string"
          },
          "3":{
            "type":"string"
          },
          "4":{
            "opt":true,
            "type":"int",
            "optchain":true
          },
          "n":{
            "opt":true,
            "type":"int",
            "optchain":true
          },
          "old":{
            "type":"string"
          },
          "s":{
            "type":"string"
          },
          "new":{
            "type":"string"
          }
        }
      },
      "summary":"replace up to n instances of old by new in the string s.",
      "lineno":288,
      "retgroups":[{
          "1":{
            "text":"result string",
            "type":"",
            "mods":[]
          },
          "g":0
        }],
      "args":"(s, old, new[, n])",
      "type":"function",
      "name":"replace",
      "parameter":"param",
      "params":{
        "1":"s",
        "2":"old",
        "3":"new",
        "4":"n",
        "map":{
          "n":" optional maximum number of substitutions",
          "old":" the target substring",
          "s":" the string",
          "new":" the substitution"
        }
      },
      "tags":[],
      "kind":"finding and replacing ",
      "section":"Finding and Replacing",
      "description":"\n If n is not present, replace all instances.",
      "ret":["result string"]
    },{
      "inferred":true,
      "subparams":[],
      "modifiers":{
        "usage":[[]],
        "return":[],
        "param":{
          "1":{
            "type":"string"
          },
          "2":{
            "type":"string"
          },
          "3":{
            "opt":true,
            "type":"bool",
            "optchain":true
          },
          "sub":{
            "type":"string"
          },
          "s":{
            "type":"string"
          },
          "allow_overlap":{
            "opt":true,
            "type":"bool",
            "optchain":true
          }
        }
      },
      "summary":"count all instances of substring in string.",
      "lineno":302,
      "args":"(s, sub[, allow_overlap])",
      "usage":["assert(stringx.count('banana', 'ana') == 1)\nassert(stringx.count('banana', 'ana', true) == 2)\n"],
      "section":"Finding and Replacing",
      "name":"count",
      "parameter":"param",
      "params":{
        "1":"s",
        "2":"sub",
        "map":{
          "sub":" substring",
          "s":" the string",
          "allow_overlap":" allow matches to overlap"
        },
        "3":"allow_overlap"
      },
      "tags":[],
      "kind":"finding and replacing ",
      "description":"",
      "type":"function"
    },{
      "inferred":true,
      "subparams":[],
      "modifiers":{
        "usage":[[]],
        "return":[],
        "param":{
          "1":{
            "type":"string"
          },
          "2":{
            "type":"int"
          },
          "3":{
            "opt":"' '",
            "type":"string",
            "optchain":"' '"
          },
          "ch":{
            "opt":"' '",
            "type":"string",
            "optchain":"' '"
          },
          "s":{
            "type":"string"
          },
          "w":{
            "type":"int"
          }
        }
      },
      "summary":"left-justify s with width w.",
      "lineno":339,
      "args":"(s, w[, ch=' '])",
      "usage":["stringx.ljust('hello', 10, '*') == '*****hello'\n"],
      "section":"Stripping and Justifying",
      "name":"ljust",
      "parameter":"param",
      "params":{
        "1":"s",
        "2":"w",
        "map":{
          "ch":" padding character",
          "s":" the string",
          "w":" width of justification"
        },
        "3":"ch"
      },
      "tags":[],
      "kind":"stripping and justifying ",
      "description":"",
      "type":"function"
    },{
      "inferred":true,
      "subparams":[],
      "modifiers":{
        "usage":[[]],
        "return":[],
        "param":{
          "1":{
            "type":"string"
          },
          "2":{
            "type":"int"
          },
          "3":{
            "opt":"' '",
            "type":"string",
            "optchain":"' '"
          },
          "ch":{
            "opt":"' '",
            "type":"string",
            "optchain":"' '"
          },
          "s":{
            "type":"string"
          },
          "w":{
            "type":"int"
          }
        }
      },
      "summary":"right-justify s with width w.",
      "lineno":350,
      "args":"(s, w[, ch=' '])",
      "usage":["stringx.rjust('hello', 10, '*') == 'hello*****'\n"],
      "section":"Stripping and Justifying",
      "name":"rjust",
      "parameter":"param",
      "params":{
        "1":"s",
        "2":"w",
        "map":{
          "ch":" padding character",
          "s":" the string",
          "w":" width of justification"
        },
        "3":"ch"
      },
      "tags":[],
      "kind":"stripping and justifying ",
      "description":"",
      "type":"function"
    },{
      "inferred":true,
      "subparams":[],
      "modifiers":{
        "usage":[[]],
        "return":[],
        "param":{
          "1":{
            "type":"string"
          },
          "2":{
            "type":"int"
          },
          "3":{
            "opt":"' '",
            "type":"string",
            "optchain":"' '"
          },
          "ch":{
            "opt":"' '",
            "type":"string",
            "optchain":"' '"
          },
          "s":{
            "type":"string"
          },
          "w":{
            "type":"int"
          }
        }
      },
      "summary":"center-justify s with width w.",
      "lineno":361,
      "args":"(s, w[, ch=' '])",
      "usage":["stringx.center('hello', 10, '*') == '**hello***'\n"],
      "section":"Stripping and Justifying",
      "name":"center",
      "parameter":"param",
      "params":{
        "1":"s",
        "2":"w",
        "map":{
          "ch":" padding character",
          "s":" the string",
          "w":" width of justification"
        },
        "3":"ch"
      },
      "tags":[],
      "kind":"stripping and justifying ",
      "description":"",
      "type":"function"
    },{
      "inferred":true,
      "subparams":[],
      "modifiers":{
        "return":[],
        "param":{
          "1":{
            "type":"string"
          },
          "2":{
            "opt":"'%s'",
            "type":"string",
            "optchain":"'%s'"
          },
          "s":{
            "type":"string"
          },
          "chrs":{
            "opt":"'%s'",
            "type":"string",
            "optchain":"'%s'"
          }
        }
      },
      "summary":"trim any characters on the left of s.",
      "lineno":402,
      "args":"(s[, chrs='%s'])",
      "section":"Stripping and Justifying",
      "name":"lstrip",
      "params":{
        "1":"s",
        "2":"chrs",
        "map":{
          "s":" the string",
          "chrs":" default any whitespace character,\n but can be a string of characters to be trimmed"
        }
      },
      "tags":[],
      "kind":"stripping and justifying ",
      "description":"",
      "type":"function",
      "parameter":"param"
    },{
      "inferred":true,
      "subparams":[],
      "modifiers":{
        "return":[],
        "param":{
          "1":{
            "type":"string"
          },
          "2":{
            "opt":"'%s'",
            "type":"string",
            "optchain":"'%s'"
          },
          "s":{
            "type":"string"
          },
          "chrs":{
            "opt":"'%s'",
            "type":"string",
            "optchain":"'%s'"
          }
        }
      },
      "summary":"trim any characters on the right of s.",
      "lineno":412,
      "args":"(s[, chrs='%s'])",
      "section":"Stripping and Justifying",
      "name":"rstrip",
      "params":{
        "1":"s",
        "2":"chrs",
        "map":{
          "s":" the string",
          "chrs":" default any whitespace character,\n but can be a string of characters to be trimmed"
        }
      },
      "tags":[],
      "kind":"stripping and justifying ",
      "description":"",
      "type":"function",
      "parameter":"param"
    },{
      "inferred":true,
      "subparams":[],
      "modifiers":{
        "usage":[[]],
        "return":[],
        "param":{
          "1":{
            "type":"string"
          },
          "2":{
            "opt":"'%s'",
            "type":"string",
            "optchain":"'%s'"
          },
          "s":{
            "type":"string"
          },
          "chrs":{
            "opt":"'%s'",
            "type":"string",
            "optchain":"'%s'"
          }
        }
      },
      "summary":"trim any characters on both left and right of s.",
      "lineno":422,
      "args":"(s[, chrs='%s'])",
      "usage":["stringx.strip('  --== Hello ==--  ', \"- =\")  --> 'Hello'\n"],
      "section":"Stripping and Justifying",
      "name":"strip",
      "parameter":"param",
      "params":{
        "1":"s",
        "2":"chrs",
        "map":{
          "s":" the string",
          "chrs":" default any whitespace character,\n but can be a string of characters to be trimmed"
        }
      },
      "tags":[],
      "kind":"stripping and justifying ",
      "description":"",
      "type":"function"
    },{
      "inferred":true,
      "subparams":[],
      "modifiers":{
        "param":{
          "1":{
            "type":"string"
          },
          "2":{
            "opt":"'%s'",
            "type":"string",
            "optchain":"'%s'"
          },
          "s":{
            "type":"string"
          },
          "re":{
            "opt":"'%s'",
            "type":"string",
            "optchain":"'%s'"
          }
        },
        "return":[[]],
        "usage":[[]],
        "see":[[]]
      },
      "summary":"split a string using a pattern.",
      "lineno":436,
      "retgroups":[{
          "1":{
            "text":"the parts of the string",
            "type":"",
            "mods":[]
          },
          "g":0
        }],
      "args":"(s[, re='%s'])",
      "usage":["a,b = line:splitv('=')\n"],
      "type":"function",
      "name":"splitv",
      "parameter":"param",
      "params":{
        "1":"s",
        "2":"re",
        "map":{
          "s":" the string",
          "re":" a Lua string pattern (defaults to whitespace)"
        }
      },
      "tags":{
        "see":[]
      },
      "kind":"partitioning strings ",
      "section":"Partitioning Strings",
      "description":" Note that at least one value will be returned!",
      "ret":["the parts of the string"]
    },{
      "inferred":true,
      "subparams":[],
      "modifiers":{
        "usage":[[],[]],
        "param":{
          "1":{
            "type":"string"
          },
          "2":{
            "type":"string"
          },
          "s":{
            "type":"string"
          },
          "ch":{
            "type":"string"
          }
        },
        "return":[[],[],[]]
      },
      "summary":"partition the string using first occurance of a delimiter",
      "lineno":461,
      "retgroups":[{
          "1":{
            "text":"part before ch",
            "type":"",
            "mods":[]
          },
          "2":{
            "text":"ch",
            "type":"",
            "mods":[]
          },
          "3":{
            "text":"part after ch",
            "type":"",
            "mods":[]
          },
          "g":0
        }],
      "args":"(s, ch)",
      "usage":["{stringx.partition('a,b,c', ','))} == {'a', ',', 'b,c'}\n","{stringx.partition('abc', 'x'))} == {'abc', '', ''}\n"],
      "type":"function",
      "name":"partition",
      "parameter":"param",
      "params":{
        "1":"s",
        "2":"ch",
        "map":{
          "s":" the string",
          "ch":" delimiter (match as plain string, no patterns)"
        }
      },
      "tags":[],
      "kind":"partitioning strings ",
      "section":"Partitioning Strings",
      "description":"",
      "ret":["part before ch","ch","part after ch"]
    },{
      "inferred":true,
      "subparams":[],
      "modifiers":{
        "usage":[[],[]],
        "param":{
          "1":{
            "type":"string"
          },
          "2":{
            "type":"string"
          },
          "s":{
            "type":"string"
          },
          "ch":{
            "type":"string"
          }
        },
        "return":[[],[],[]]
      },
      "summary":"partition the string p using last occurance of a delimiter",
      "lineno":475,
      "retgroups":[{
          "1":{
            "text":"part before ch",
            "type":"",
            "mods":[]
          },
          "2":{
            "text":"ch",
            "type":"",
            "mods":[]
          },
          "3":{
            "text":"part after ch",
            "type":"",
            "mods":[]
          },
          "g":0
        }],
      "args":"(s, ch)",
      "usage":["{stringx.rpartition('a,b,c', ','))} == {'a,b', ',', 'c'}\n","{stringx.rpartition('abc', 'x'))} == {'', '', 'abc'}\n"],
      "type":"function",
      "name":"rpartition",
      "parameter":"param",
      "params":{
        "1":"s",
        "2":"ch",
        "map":{
          "s":" the string",
          "ch":" delimiter (match as plain string, no patterns)"
        }
      },
      "tags":[],
      "kind":"partitioning strings ",
      "section":"Partitioning Strings",
      "description":"",
      "ret":["part before ch","ch","part after ch"]
    },{
      "inferred":true,
      "subparams":[],
      "modifiers":{
        "return":[[]],
        "param":{
          "1":{
            "type":"string"
          },
          "2":{
            "type":"int"
          },
          "s":{
            "type":"string"
          },
          "idx":{
            "type":"int"
          }
        }
      },
      "summary":"return the 'character' at the index.",
      "lineno":489,
      "retgroups":[{
          "1":{
            "text":"a substring of length 1 if successful, empty string otherwise.",
            "type":"",
            "mods":[]
          },
          "g":0
        }],
      "args":"(s, idx)",
      "type":"function",
      "name":"at",
      "parameter":"param",
      "params":{
        "1":"s",
        "2":"idx",
        "map":{
          "s":" the string",
          "idx":" an index (can be negative)"
        }
      },
      "tags":[],
      "kind":"partitioning strings ",
      "section":"Partitioning Strings",
      "description":"",
      "ret":["a substring of length 1 if successful, empty string otherwise."]
    },{
      "inferred":true,
      "subparams":[],
      "modifiers":{
        "return":[[]],
        "param":{
          "1":{
            "type":"string"
          },
          "2":{
            "type":"integer"
          },
          "3":{
            "opt":"' '",
            "type":"string",
            "optchain":"' '"
          },
          "ch":{
            "opt":"' '",
            "type":"string",
            "optchain":"' '"
          },
          "n":{
            "type":"integer"
          },
          "s":{
            "type":"string"
          }
        }
      },
      "summary":"indent a multiline string.",
      "lineno":505,
      "retgroups":[{
          "1":{
            "text":"indented string",
            "type":"",
            "mods":[]
          },
          "g":0
        }],
      "args":"(s, n[, ch=' '])",
      "type":"function",
      "name":"indent",
      "parameter":"param",
      "params":{
        "1":"s",
        "2":"n",
        "map":{
          "ch":" the character to use when indenting",
          "n":" the size of the indent",
          "s":" the (multiline) string"
        },
        "3":"ch"
      },
      "tags":[],
      "kind":"text handling ",
      "section":"Text handling",
      "description":"",
      "ret":["indented string"]
    },{
      "inferred":true,
      "subparams":[],
      "modifiers":{
        "usage":[[]],
        "param":{
          "1":{
            "type":"string"
          },
          "s":{
            "type":"string"
          }
        },
        "return":[[]]
      },
      "summary":"dedent a multiline string by removing any initial indent.",
      "lineno":537,
      "retgroups":[{
          "1":{
            "text":"a string with initial indent zero.",
            "type":"",
            "mods":[]
          },
          "g":0
        }],
      "args":"(s)",
      "usage":["local s = dedent [[\n         One\n\n       Two\n\n     Three\n]]\nassert(s == [[\n    One\n\n  Two\n\nThree\n]])\n"],
      "type":"function",
      "name":"dedent",
      "parameter":"param",
      "params":{
        "map":{
          "s":" the (multiline) string"
        },
        "1":"s"
      },
      "tags":[],
      "kind":"text handling ",
      "section":"Text handling",
      "description":"\n useful when working with [[..]] strings.\n Empty lines are ignored.",
      "ret":["a string with initial indent zero."]
    },{
      "inferred":true,
      "subparams":[],
      "modifiers":{
        "param":{
          "1":{
            "type":"string"
          },
          "2":{
            "opt":"70",
            "type":"integer",
            "optchain":"70"
          },
          "3":{
            "opt":"false",
            "type":"boolean",
            "optchain":"false"
          },
          "width":{
            "opt":"70",
            "type":"integer",
            "optchain":"70"
          },
          "s":{
            "type":"string"
          },
          "breaklong":{
            "opt":"false",
            "type":"boolean",
            "optchain":"false"
          }
        },
        "return":[[]],
        "see":[[],[]]
      },
      "summary":"format a paragraph into lines so that they fit into a line width.",
      "lineno":594,
      "retgroups":[{
          "1":{
            "text":"a list of lines (List object), use `fill` to return a string instead of a `List`.",
            "type":"",
            "mods":[]
          },
          "g":0
        }],
      "args":"(s[, width=70[, breaklong=false]])",
      "type":"function",
      "name":"wrap",
      "parameter":"param",
      "params":{
        "1":"s",
        "2":"width",
        "map":{
          "width":" the margin width",
          "s":" the string to format",
          "breaklong":" if truthy, words longer than the width given will be forced split."
        },
        "3":"breaklong"
      },
      "tags":{
        "see":[]
      },
      "kind":"text handling ",
      "section":"Text handling",
      "description":"\n It will not break long words by default, so lines can be over the length\n to that extent.",
      "ret":["a list of lines (List object), use `fill` to return a string instead of a `List`."]
    },{
      "inferred":true,
      "subparams":[],
      "modifiers":{
        "param":{
          "1":{
            "type":"string"
          },
          "2":{
            "opt":"70",
            "type":"integer",
            "optchain":"70"
          },
          "3":{
            "opt":"false",
            "type":"boolean",
            "optchain":"false"
          },
          "width":{
            "opt":"70",
            "type":"integer",
            "optchain":"70"
          },
          "s":{
            "type":"string"
          },
          "breaklong":{
            "opt":"false",
            "type":"boolean",
            "optchain":"false"
          }
        },
        "return":[[]],
        "see":[[]]
      },
      "summary":"format a paragraph so that it fits into a line width.",
      "lineno":616,
      "retgroups":[{
          "1":{
            "text":"a string, use `wrap` to return a list of lines instead of a string.",
            "type":"",
            "mods":[]
          },
          "g":0
        }],
      "args":"(s[, width=70[, breaklong=false]])",
      "type":"function",
      "name":"fill",
      "parameter":"param",
      "params":{
        "1":"s",
        "2":"width",
        "map":{
          "width":" the margin width",
          "s":" the string to format",
          "breaklong":" if truthy, words longer than the width given will be forced split."
        },
        "3":"breaklong"
      },
      "tags":{
        "see":[]
      },
      "kind":"text handling ",
      "section":"Text handling",
      "description":"",
      "ret":["a string, use `wrap` to return a list of lines instead of a string."]
    },{
      "inferred":true,
      "subparams":[],
      "modifiers":{
        "param":{
          "1":{
            "type":"string"
          },
          "tmpl":{
            "type":"string"
          }
        },
        "return":[{
            "type":"Template"
          }]
      },
      "summary":"Creates a new Template class.",
      "lineno":662,
      "retgroups":[{
          "1":{
            "text":"",
            "type":"Template",
            "mods":{
              "type":"Template"
            }
          },
          "g":0
        }],
      "args":"(tmpl)",
      "section":"Template",
      "name":"Template",
      "params":{
        "map":{
          "tmpl":" the template string"
        },
        "1":"tmpl"
      },
      "tags":[],
      "kind":"template ",
      "description":"\n This is a shortcut to `Template.new(tmpl)`.",
      "type":"function",
      "ret":[""],
      "parameter":"param"
    },{
      "inferred":true,
      "subparams":[],
      "modifiers":{
        "return":[[]],
        "param":{
          "1":{
            "type":"table"
          },
          "tbl":{
            "type":"table"
          }
        }
      },
      "summary":"substitute values into a template, throwing an error.",
      "lineno":674,
      "retgroups":[{
          "1":{
            "text":"string with place holders substituted",
            "type":"",
            "mods":[]
          },
          "g":0
        }],
      "args":"(tbl)",
      "type":"function",
      "name":"Template:substitute",
      "parameter":"param",
      "params":{
        "map":{
          "tbl":" a table of name-value pairs."
        },
        "1":"tbl"
      },
      "tags":[],
      "kind":"template ",
      "section":"Template",
      "description":"\n This will throw an error if no name is found.",
      "ret":["string with place holders substituted"]
    },{
      "inferred":true,
      "subparams":[],
      "modifiers":{
        "return":[[]],
        "param":{
          "1":{
            "type":"table"
          },
          "tbl":{
            "type":"table"
          }
        }
      },
      "summary":"substitute values into a template.",
      "lineno":683,
      "retgroups":[{
          "1":{
            "text":"string with place holders substituted",
            "type":"",
            "mods":[]
          },
          "g":0
        }],
      "args":"(tbl)",
      "type":"function",
      "name":"Template:safe_substitute",
      "parameter":"param",
      "params":{
        "map":{
          "tbl":" a table of name-value pairs."
        },
        "1":"tbl"
      },
      "tags":[],
      "kind":"template ",
      "section":"Template",
      "description":"\n This version just passes unknown names through.",
      "ret":["string with place holders substituted"]
    },{
      "inferred":true,
      "subparams":[],
      "modifiers":{
        "return":[[]],
        "param":{
          "1":{
            "type":"table"
          },
          "tbl":{
            "type":"table"
          }
        }
      },
      "summary":"substitute values into a template, preserving indentation.",
      "lineno":695,
      "retgroups":[{
          "1":{
            "text":"string with place holders substituted",
            "type":"",
            "mods":[]
          },
          "g":0
        }],
      "args":"(tbl)",
      "type":"function",
      "name":"Template:indent_substitute",
      "parameter":"param",
      "params":{
        "map":{
          "tbl":" a table of name-value pairs."
        },
        "1":"tbl"
      },
      "tags":[],
      "kind":"template ",
      "section":"Template",
      "description":" <br>\n If the value is a multiline string _or_ a template, it will insert\n the lines at the correct indentation. <br>\n Furthermore, if a template, then that template will be substituted\n using the same table.",
      "ret":["string with place holders substituted"]
    },{
      "inferred":true,
      "subparams":[],
      "modifiers":{
        "usage":[[]],
        "param":{
          "1":{
            "type":"string"
          },
          "s":{
            "type":"string"
          }
        },
        "return":[[]]
      },
      "summary":"return an iterator over all lines in a string",
      "lineno":751,
      "retgroups":[{
          "1":{
            "text":"an iterator",
            "type":"",
            "mods":[]
          },
          "g":0
        }],
      "args":"(s)",
      "usage":["local line_no = 1\nfor line in stringx.lines(some_text) do\n  print(line_no, line)\n  line_no = line_no + 1\nend\n"],
      "type":"function",
      "name":"lines",
      "parameter":"param",
      "params":{
        "map":{
          "s":" the string"
        },
        "1":"s"
      },
      "tags":[],
      "kind":"miscelaneous ",
      "section":"Miscelaneous",
      "description":"",
      "ret":["an iterator"]
    },{
      "inferred":true,
      "subparams":[],
      "modifiers":{
        "usage":[[]],
        "param":{
          "1":{
            "type":"string"
          },
          "s":{
            "type":"string"
          }
        },
        "return":[[]]
      },
      "summary":"inital word letters uppercase ('title case').",
      "lineno":762,
      "retgroups":[{
          "1":{
            "text":"a string with each word's first letter uppercase",
            "type":"",
            "mods":[]
          },
          "g":0
        }],
      "args":"(s)",
      "usage":["stringx.title(\"hello world\") == \"Hello World\")\n"],
      "type":"function",
      "name":"title",
      "parameter":"param",
      "params":{
        "map":{
          "s":" the string"
        },
        "1":"s"
      },
      "tags":[],
      "kind":"miscelaneous ",
      "section":"Miscelaneous",
      "description":"\n Here 'words' mean chunks of non-space characters.",
      "ret":["a string with each word's first letter uppercase"]
    },{
      "inferred":true,
      "subparams":[],
      "modifiers":{
        "usage":[[],[],[]],
        "return":[],
        "param":{
          "1":{
            "type":"string"
          },
          "2":{
            "type":"int"
          },
          "3":{
            "type":"bool"
          },
          "tail":{
            "type":"bool"
          },
          "s":{
            "type":"string"
          },
          "w":{
            "type":"int"
          }
        }
      },
      "summary":"Return a shortened version of a string.",
      "lineno":783,
      "args":"(s, w, tail)",
      "usage":["('1234567890'):shorten(8) == '12345...'\n","('1234567890'):shorten(8, true) == '...67890'\n","('1234567890'):shorten(20) == '1234567890'\n"],
      "section":"Miscelaneous",
      "name":"shorten",
      "parameter":"param",
      "params":{
        "1":"s",
        "2":"w",
        "map":{
          "tail":" true if we want to show the end of the string (head otherwise)",
          "s":" the string",
          "w":" the maxinum size allowed"
        },
        "3":"tail"
      },
      "tags":[],
      "kind":"miscelaneous ",
      "description":"\n Fits string within w characters. Removed characters are marked with ellipsis.",
      "type":"function"
    },{
      "inferred":true,
      "subparams":[],
      "modifiers":{
        "return":[[]],
        "param":{
          "1":[],
          "s":[]
        }
      },
      "summary":"Quote the given string and preserve any control or escape characters, such that reloading the string in Lua returns the same result.",
      "lineno":822,
      "retgroups":[{
          "1":{
            "text":"The quoted string.",
            "type":"",
            "mods":[]
          },
          "g":0
        }],
      "args":"(s)",
      "type":"function",
      "name":"quote_string",
      "parameter":"param",
      "params":{
        "map":{
          "s":" The string to be quoted."
        },
        "1":"s"
      },
      "tags":[],
      "kind":"miscelaneous ",
      "section":"Miscelaneous",
      "description":"",
      "ret":["The quoted string."]
    },{
      "inferred":true,
      "subparams":[],
      "modifiers":{
        "return":[],
        "param":[],
        "usage":[[]]
      },
      "summary":"Python-style formatting operator.",
      "lineno":873,
      "args":"()",
      "usage":["require 'pl.text'.format_operator()\nlocal out1 = '%s = %5.3f' % {'PI',math.pi}                   --> 'PI = 3.142'\nlocal out2 = '$name = $value' % {name='dog',value='Pluto'}   --> 'dog = Pluto'\n"],
      "section":"Miscelaneous",
      "name":"format_operator",
      "parameter":"param",
      "params":{
        "map":[]
      },
      "tags":[],
      "kind":"miscelaneous ",
      "description":"\n Calling `text.format_operator()` overloads the % operator for strings to give\n Python/Ruby style formated output.\n This is extended to also do template-like substitution for map-like data.\n\n Note this goes further than the original, and will allow these cases:\n\n 1. a single value\n 2. a list of values\n 3. a map of var=value pairs\n 4. a function, as in gsub\n\n For the second two cases, it uses $-variable substituion.\n\n When called, this function will monkey-patch the global `string` metatable by\n adding a `__mod` method.\n\n See <a href=\"http://lua-users.org/wiki/StringInterpolation\">the lua-users wiki</a>\n",
      "type":"function"
    },{
      "inferred":true,
      "subparams":[],
      "modifiers":{
        "param":[],
        "return":[]
      },
      "summary":"import the stringx functions into the global string (meta)table",
      "lineno":913,
      "args":"()",
      "section":"Miscelaneous",
      "name":"import",
      "params":{
        "map":[]
      },
      "tags":[],
      "kind":"miscelaneous ",
      "description":"",
      "type":"function",
      "parameter":"param"
    }],
  "package":"pl",
  "tags":[],
  "section":{
    "name":"misc",
    "inferred":true,
    "description":"",
    "file":{
      "warning":"<type 'function' is not supported by JSON.>",
      "filename":"/home/cji/portless/Penlight/lua/pl/stringx.lua",
      "items":["<reference cycle>",{
          "name":"predicates",
          "inferred":true,
          "description":"",
          "file":"<reference cycle>",
          "summary":"",
          "tags":[],
          "lineno":53,
          "display_name":"String Predicates",
          "type":"section",
          "modifiers":[]
        },{
          "inferred":true,
          "subparams":[],
          "modifiers":{
            "return":[],
            "param":{
              "1":{
                "type":"string"
              },
              "s":{
                "type":"string"
              }
            }
          },
          "summary":"does s only contain alphabetic characters?",
          "lineno":55,
          "args":"(s)",
          "section":"String Predicates",
          "name":"isalpha",
          "params":{
            "map":{
              "s":" a string"
            },
            "1":"s"
          },
          "tags":[],
          "kind":"string predicates ",
          "description":"",
          "type":"function",
          "parameter":"param"
        },{
          "inferred":true,
          "subparams":[],
          "modifiers":{
            "return":[],
            "param":{
              "1":{
                "type":"string"
              },
              "s":{
                "type":"string"
              }
            }
          },
          "summary":"does s only contain digits?",
          "lineno":62,
          "args":"(s)",
          "section":"String Predicates",
          "name":"isdigit",
          "params":{
            "map":{
              "s":" a string"
            },
            "1":"s"
          },
          "tags":[],
          "kind":"string predicates ",
          "description":"",
          "type":"function",
          "parameter":"param"
        },{
          "inferred":true,
          "subparams":[],
          "modifiers":{
            "return":[],
            "param":{
              "1":{
                "type":"string"
              },
              "s":{
                "type":"string"
              }
            }
          },
          "summary":"does s only contain alphanumeric characters?",
          "lineno":69,
          "args":"(s)",
          "section":"String Predicates",
          "name":"isalnum",
          "params":{
            "map":{
              "s":" a string"
            },
            "1":"s"
          },
          "tags":[],
          "kind":"string predicates ",
          "description":"",
          "type":"function",
          "parameter":"param"
        },{
          "inferred":true,
          "subparams":[],
          "modifiers":{
            "return":[],
            "param":{
              "1":{
                "type":"string"
              },
              "s":{
                "type":"string"
              }
            }
          },
          "summary":"does s only contain whitespace?",
          "lineno":77,
          "args":"(s)",
          "section":"String Predicates",
          "name":"isspace",
          "params":{
            "map":{
              "s":" a string"
            },
            "1":"s"
          },
          "tags":[],
          "kind":"string predicates ",
          "description":"\n Matches on pattern '%s' so matches space, newline, tabs, etc.",
          "type":"function",
          "parameter":"param"
        },{
          "inferred":true,
          "subparams":[],
          "modifiers":{
            "return":[],
            "param":{
              "1":{
                "type":"string"
              },
              "s":{
                "type":"string"
              }
            }
          },
          "summary":"does s only contain lower case characters?",
          "lineno":84,
          "args":"(s)",
          "section":"String Predicates",
          "name":"islower",
          "params":{
            "map":{
              "s":" a string"
            },
            "1":"s"
          },
          "tags":[],
          "kind":"string predicates ",
          "description":"",
          "type":"function",
          "parameter":"param"
        },{
          "inferred":true,
          "subparams":[],
          "modifiers":{
            "return":[],
            "param":{
              "1":{
                "type":"string"
              },
              "s":{
                "type":"string"
              }
            }
          },
          "summary":"does s only contain upper case characters?",
          "lineno":91,
          "args":"(s)",
          "section":"String Predicates",
          "name":"isupper",
          "params":{
            "map":{
              "s":" a string"
            },
            "1":"s"
          },
          "tags":[],
          "kind":"string predicates ",
          "description":"",
          "type":"function",
          "parameter":"param"
        },{
          "inferred":true,
          "subparams":[],
          "modifiers":{
            "return":[],
            "param":{
              "1":{
                "type":"string"
              },
              "2":[],
              "s":{
                "type":"string"
              },
              "prefix":[]
            }
          },
          "summary":"does s start with prefix or one of prefixes?",
          "lineno":120,
          "args":"(s, prefix)",
          "section":"String Predicates",
          "name":"startswith",
          "params":{
            "1":"s",
            "2":"prefix",
            "map":{
              "s":" a string",
              "prefix":" a string or an array of strings"
            }
          },
          "tags":[],
          "kind":"string predicates ",
          "description":"",
          "type":"function",
          "parameter":"param"
        },{
          "inferred":true,
          "subparams":[],
          "modifiers":{
            "return":[],
            "param":{
              "1":{
                "type":"string"
              },
              "2":[],
              "s":{
                "type":"string"
              },
              "suffix":[]
            }
          },
          "summary":"does s end with suffix or one of suffixes?",
          "lineno":128,
          "args":"(s, suffix)",
          "section":"String Predicates",
          "name":"endswith",
          "params":{
            "1":"s",
            "2":"suffix",
            "map":{
              "s":" a string",
              "suffix":" a string or an array of strings"
            }
          },
          "tags":[],
          "kind":"string predicates ",
          "description":"",
          "type":"function",
          "parameter":"param"
        },{
          "name":"lists",
          "inferred":true,
          "description":"",
          "file":"<reference cycle>",
          "summary":"",
          "tags":[],
          "lineno":136,
          "display_name":"Strings and Lists",
          "type":"section",
          "modifiers":[]
        },{
          "inferred":true,
          "subparams":[],
          "modifiers":{
            "usage":[[]],
            "return":[],
            "param":{
              "1":{
                "type":"string"
              },
              "2":[],
              "s":{
                "type":"string"
              },
              "seq":[]
            }
          },
          "summary":"concatenate the strings using this string as a delimiter.",
          "lineno":141,
          "args":"(s, seq)",
          "usage":["stringx.join(' ', {1,2,3}) == '1 2 3'\n"],
          "section":"Strings and Lists",
          "name":"join",
          "parameter":"param",
          "params":{
            "1":"s",
            "2":"seq",
            "map":{
              "s":" the string",
              "seq":" a table of strings or numbers"
            }
          },
          "tags":[],
          "kind":"strings and lists ",
          "description":"\n Note that the arguments are reversed from `string.concat`.",
          "type":"function"
        },{
          "inferred":true,
          "subparams":[],
          "modifiers":{
            "return":[[]],
            "param":{
              "1":{
                "type":"string"
              },
              "2":{
                "opt":true,
                "type":"bool",
                "optchain":true
              },
              "s":{
                "type":"string"
              },
              "keep_ends":{
                "opt":true,
                "type":"bool",
                "optchain":true
              }
            }
          },
          "summary":"Split a string into a list of lines.",
          "lineno":154,
          "retgroups":[{
              "1":{
                "text":"List of lines",
                "type":"",
                "mods":[]
              },
              "g":0
            }],
          "args":"(s[, keep_ends])",
          "type":"function",
          "name":"splitlines",
          "parameter":"param",
          "params":{
            "1":"s",
            "2":"keep_ends",
            "map":{
              "s":" the string.",
              "keep_ends":" include line ends."
            }
          },
          "tags":[],
          "kind":"strings and lists ",
          "section":"Strings and Lists",
          "description":"\n `\"\\r\"`, `\"\\n\"`, and `\"\\r\\n\"` are considered line ends.\n They are not included in the lines unless `keepends` is passed.\n Terminal line end does not produce an extra line.\n Splitting an empty string results in an empty list.",
          "ret":["List of lines"]
        },{
          "inferred":true,
          "subparams":[],
          "modifiers":{
            "usage":[[],[],[]],
            "param":{
              "1":{
                "type":"string"
              },
              "2":{
                "opt":true,
                "type":"string",
                "optchain":true
              },
              "3":{
                "opt":true,
                "type":"int",
                "optchain":true
              },
              "re":{
                "opt":true,
                "type":"string",
                "optchain":true
              },
              "n":{
                "opt":true,
                "type":"int",
                "optchain":true
              },
              "s":{
                "type":"string"
              }
            },
            "return":[[]]
          },
          "summary":"split a string into a list of strings using a delimiter.",
          "lineno":193,
          "retgroups":[{
              "1":{
                "text":"List",
                "type":"",
                "mods":[]
              },
              "g":0
            }],
          "args":"(s[, re[, n]])",
          "usage":["#(stringx.split('one two')) == 2\n","stringx.split('one,two,three', ',') == List{'one','two','three'}\n","stringx.split('one,two,three', ',', 2) == List{'one','two,three'}\n"],
          "type":"function",
          "name":"split",
          "params":{
            "1":"s",
            "2":"re",
            "map":{
              "re":" a delimiter (defaults to whitespace)",
              "n":" maximum number of results",
              "s":" the string"
            },
            "3":"n"
          },
          "tags":[],
          "kind":"strings and lists ",
          "section":"Strings and Lists",
          "description":"",
          "ret":["List"],
          "parameter":"param"
        },{
          "inferred":true,
          "subparams":[],
          "modifiers":{
            "usage":[[],[]],
            "param":{
              "1":{
                "type":"string"
              },
              "2":{
                "type":"int"
              },
              "s":{
                "type":"string"
              },
              "tabsize":{
                "type":"int"
              }
            },
            "return":[[]]
          },
          "summary":"replace all tabs in s with tabsize spaces.",
          "lineno":216,
          "retgroups":[{
              "1":{
                "text":"expanded string",
                "type":"",
                "mods":[]
              },
              "g":0
            }],
          "args":"(s, tabsize)",
          "usage":["stringx.expandtabs('\\tone,two,three', 4)   == '    one,two,three'\n","stringx.expandtabs('  \\tone,two,three', 4) == '    one,two,three'\n"],
          "type":"function",
          "name":"expandtabs",
          "parameter":"param",
          "params":{
            "1":"s",
            "2":"tabsize",
            "map":{
              "s":" the string",
              "tabsize":"[opt=8] number of spaces to expand each tab"
            }
          },
          "tags":[],
          "kind":"strings and lists ",
          "section":"Strings and Lists",
          "description":" If not specified, tabsize defaults to 8.\n Tab stops will be honored.",
          "ret":["expanded string"]
        },{
          "name":"find",
          "inferred":true,
          "description":"",
          "file":"<reference cycle>",
          "summary":"",
          "tags":[],
          "lineno":231,
          "display_name":"Finding and Replacing",
          "type":"section",
          "modifiers":[]
        },{
          "inferred":true,
          "subparams":[],
          "modifiers":{
            "return":[[]],
            "param":{
              "1":{
                "type":"string"
              },
              "2":{
                "type":"string"
              },
              "3":{
                "opt":true,
                "type":"int",
                "optchain":true
              },
              "4":{
                "opt":true,
                "type":"int",
                "optchain":true
              },
              "first":{
                "opt":true,
                "type":"int",
                "optchain":true
              },
              "sub":{
                "type":"string"
              },
              "s":{
                "type":"string"
              },
              "last":{
                "opt":true,
                "type":"int",
                "optchain":true
              }
            }
          },
          "summary":"find index of first instance of sub in s from the left.",
          "lineno":257,
          "retgroups":[{
              "1":{
                "text":"start index, or nil if not found",
                "type":"",
                "mods":[]
              },
              "g":0
            }],
          "args":"(s, sub[, first[, last]])",
          "type":"function",
          "name":"lfind",
          "parameter":"param",
          "params":{
            "1":"s",
            "2":"sub",
            "3":"first",
            "4":"last",
            "map":{
              "first":" first index",
              "sub":" substring",
              "s":" the string",
              "last":" last index"
            }
          },
          "tags":[],
          "kind":"finding and replacing ",
          "section":"Finding and Replacing",
          "description":"",
          "ret":["start index, or nil if not found"]
        },{
          "inferred":true,
          "subparams":[],
          "modifiers":{
            "return":[[]],
            "param":{
              "1":{
                "type":"string"
              },
              "2":{
                "type":"string"
              },
              "3":{
                "opt":true,
                "type":"int",
                "optchain":true
              },
              "4":{
                "opt":true,
                "type":"int",
                "optchain":true
              },
              "first":{
                "opt":true,
                "type":"int",
                "optchain":true
              },
              "sub":{
                "type":"string"
              },
              "s":{
                "type":"string"
              },
              "last":{
                "opt":true,
                "type":"int",
                "optchain":true
              }
            }
          },
          "summary":"find index of first instance of sub in s from the right.",
          "lineno":275,
          "retgroups":[{
              "1":{
                "text":"start index, or nil if not found",
                "type":"",
                "mods":[]
              },
              "g":0
            }],
          "args":"(s, sub[, first[, last]])",
          "type":"function",
          "name":"rfind",
          "parameter":"param",
          "params":{
            "1":"s",
            "2":"sub",
            "3":"first",
            "4":"last",
            "map":{
              "first":" first index",
              "sub":" substring",
              "s":" the string",
              "last":" last index"
            }
          },
          "tags":[],
          "kind":"finding and replacing ",
          "section":"Finding and Replacing",
          "description":"",
          "ret":["start index, or nil if not found"]
        },{
          "inferred":true,
          "subparams":[],
          "modifiers":{
            "return":[[]],
            "param":{
              "1":{
                "type":"string"
              },
              "2":{
                "type":"string"
              },
              "3":{
                "type":"string"
              },
              "4":{
                "opt":true,
                "type":"int",
                "optchain":true
              },
              "n":{
                "opt":true,
                "type":"int",
                "optchain":true
              },
              "old":{
                "type":"string"
              },
              "s":{
                "type":"string"
              },
              "new":{
                "type":"string"
              }
            }
          },
          "summary":"replace up to n instances of old by new in the string s.",
          "lineno":288,
          "retgroups":[{
              "1":{
                "text":"result string",
                "type":"",
                "mods":[]
              },
              "g":0
            }],
          "args":"(s, old, new[, n])",
          "type":"function",
          "name":"replace",
          "parameter":"param",
          "params":{
            "1":"s",
            "2":"old",
            "3":"new",
            "4":"n",
            "map":{
              "n":" optional maximum number of substitutions",
              "old":" the target substring",
              "s":" the string",
              "new":" the substitution"
            }
          },
          "tags":[],
          "kind":"finding and replacing ",
          "section":"Finding and Replacing",
          "description":"\n If n is not present, replace all instances.",
          "ret":["result string"]
        },{
          "inferred":true,
          "subparams":[],
          "modifiers":{
            "usage":[[]],
            "return":[],
            "param":{
              "1":{
                "type":"string"
              },
              "2":{
                "type":"string"
              },
              "3":{
                "opt":true,
                "type":"bool",
                "optchain":true
              },
              "sub":{
                "type":"string"
              },
              "s":{
                "type":"string"
              },
              "allow_overlap":{
                "opt":true,
                "type":"bool",
                "optchain":true
              }
            }
          },
          "summary":"count all instances of substring in string.",
          "lineno":302,
          "args":"(s, sub[, allow_overlap])",
          "usage":["assert(stringx.count('banana', 'ana') == 1)\nassert(stringx.count('banana', 'ana', true) == 2)\n"],
          "section":"Finding and Replacing",
          "name":"count",
          "parameter":"param",
          "params":{
            "1":"s",
            "2":"sub",
            "map":{
              "sub":" substring",
              "s":" the string",
              "allow_overlap":" allow matches to overlap"
            },
            "3":"allow_overlap"
          },
          "tags":[],
          "kind":"finding and replacing ",
          "description":"",
          "type":"function"
        },{
          "name":"strip",
          "inferred":true,
          "description":"",
          "file":"<reference cycle>",
          "summary":"",
          "tags":[],
          "lineno":311,
          "display_name":"Stripping and Justifying",
          "type":"section",
          "modifiers":[]
        },{
          "inferred":true,
          "subparams":[],
          "modifiers":{
            "usage":[[]],
            "return":[],
            "param":{
              "1":{
                "type":"string"
              },
              "2":{
                "type":"int"
              },
              "3":{
                "opt":"' '",
                "type":"string",
                "optchain":"' '"
              },
              "ch":{
                "opt":"' '",
                "type":"string",
                "optchain":"' '"
              },
              "s":{
                "type":"string"
              },
              "w":{
                "type":"int"
              }
            }
          },
          "summary":"left-justify s with width w.",
          "lineno":339,
          "args":"(s, w[, ch=' '])",
          "usage":["stringx.ljust('hello', 10, '*') == '*****hello'\n"],
          "section":"Stripping and Justifying",
          "name":"ljust",
          "parameter":"param",
          "params":{
            "1":"s",
            "2":"w",
            "map":{
              "ch":" padding character",
              "s":" the string",
              "w":" width of justification"
            },
            "3":"ch"
          },
          "tags":[],
          "kind":"stripping and justifying ",
          "description":"",
          "type":"function"
        },{
          "inferred":true,
          "subparams":[],
          "modifiers":{
            "usage":[[]],
            "return":[],
            "param":{
              "1":{
                "type":"string"
              },
              "2":{
                "type":"int"
              },
              "3":{
                "opt":"' '",
                "type":"string",
                "optchain":"' '"
              },
              "ch":{
                "opt":"' '",
                "type":"string",
                "optchain":"' '"
              },
              "s":{
                "type":"string"
              },
              "w":{
                "type":"int"
              }
            }
          },
          "summary":"right-justify s with width w.",
          "lineno":350,
          "args":"(s, w[, ch=' '])",
          "usage":["stringx.rjust('hello', 10, '*') == 'hello*****'\n"],
          "section":"Stripping and Justifying",
          "name":"rjust",
          "parameter":"param",
          "params":{
            "1":"s",
            "2":"w",
            "map":{
              "ch":" padding character",
              "s":" the string",
              "w":" width of justification"
            },
            "3":"ch"
          },
          "tags":[],
          "kind":"stripping and justifying ",
          "description":"",
          "type":"function"
        },{
          "inferred":true,
          "subparams":[],
          "modifiers":{
            "usage":[[]],
            "return":[],
            "param":{
              "1":{
                "type":"string"
              },
              "2":{
                "type":"int"
              },
              "3":{
                "opt":"' '",
                "type":"string",
                "optchain":"' '"
              },
              "ch":{
                "opt":"' '",
                "type":"string",
                "optchain":"' '"
              },
              "s":{
                "type":"string"
              },
              "w":{
                "type":"int"
              }
            }
          },
          "summary":"center-justify s with width w.",
          "lineno":361,
          "args":"(s, w[, ch=' '])",
          "usage":["stringx.center('hello', 10, '*') == '**hello***'\n"],
          "section":"Stripping and Justifying",
          "name":"center",
          "parameter":"param",
          "params":{
            "1":"s",
            "2":"w",
            "map":{
              "ch":" padding character",
              "s":" the string",
              "w":" width of justification"
            },
            "3":"ch"
          },
          "tags":[],
          "kind":"stripping and justifying ",
          "description":"",
          "type":"function"
        },{
          "inferred":true,
          "subparams":[],
          "modifiers":{
            "return":[],
            "param":{
              "1":{
                "type":"string"
              },
              "2":{
                "opt":"'%s'",
                "type":"string",
                "optchain":"'%s'"
              },
              "s":{
                "type":"string"
              },
              "chrs":{
                "opt":"'%s'",
                "type":"string",
                "optchain":"'%s'"
              }
            }
          },
          "summary":"trim any characters on the left of s.",
          "lineno":402,
          "args":"(s[, chrs='%s'])",
          "section":"Stripping and Justifying",
          "name":"lstrip",
          "params":{
            "1":"s",
            "2":"chrs",
            "map":{
              "s":" the string",
              "chrs":" default any whitespace character,\n but can be a string of characters to be trimmed"
            }
          },
          "tags":[],
          "kind":"stripping and justifying ",
          "description":"",
          "type":"function",
          "parameter":"param"
        },{
          "inferred":true,
          "subparams":[],
          "modifiers":{
            "return":[],
            "param":{
              "1":{
                "type":"string"
              },
              "2":{
                "opt":"'%s'",
                "type":"string",
                "optchain":"'%s'"
              },
              "s":{
                "type":"string"
              },
              "chrs":{
                "opt":"'%s'",
                "type":"string",
                "optchain":"'%s'"
              }
            }
          },
          "summary":"trim any characters on the right of s.",
          "lineno":412,
          "args":"(s[, chrs='%s'])",
          "section":"Stripping and Justifying",
          "name":"rstrip",
          "params":{
            "1":"s",
            "2":"chrs",
            "map":{
              "s":" the string",
              "chrs":" default any whitespace character,\n but can be a string of characters to be trimmed"
            }
          },
          "tags":[],
          "kind":"stripping and justifying ",
          "description":"",
          "type":"function",
          "parameter":"param"
        },{
          "inferred":true,
          "subparams":[],
          "modifiers":{
            "usage":[[]],
            "return":[],
            "param":{
              "1":{
                "type":"string"
              },
              "2":{
                "opt":"'%s'",
                "type":"string",
                "optchain":"'%s'"
              },
              "s":{
                "type":"string"
              },
              "chrs":{
                "opt":"'%s'",
                "type":"string",
                "optchain":"'%s'"
              }
            }
          },
          "summary":"trim any characters on both left and right of s.",
          "lineno":422,
          "args":"(s[, chrs='%s'])",
          "usage":["stringx.strip('  --== Hello ==--  ', \"- =\")  --> 'Hello'\n"],
          "section":"Stripping and Justifying",
          "name":"strip",
          "parameter":"param",
          "params":{
            "1":"s",
            "2":"chrs",
            "map":{
              "s":" the string",
              "chrs":" default any whitespace character,\n but can be a string of characters to be trimmed"
            }
          },
          "tags":[],
          "kind":"stripping and justifying ",
          "description":"",
          "type":"function"
        },{
          "name":"partitioning",
          "inferred":true,
          "description":"",
          "file":"<reference cycle>",
          "summary":"",
          "tags":[],
          "lineno":430,
          "display_name":"Partitioning Strings",
          "type":"section",
          "modifiers":[]
        },{
          "inferred":true,
          "subparams":[],
          "modifiers":{
            "param":{
              "1":{
                "type":"string"
              },
              "2":{
                "opt":"'%s'",
                "type":"string",
                "optchain":"'%s'"
              },
              "s":{
                "type":"string"
              },
              "re":{
                "opt":"'%s'",
                "type":"string",
                "optchain":"'%s'"
              }
            },
            "return":[[]],
            "usage":[[]],
            "see":[[]]
          },
          "summary":"split a string using a pattern.",
          "lineno":436,
          "retgroups":[{
              "1":{
                "text":"the parts of the string",
                "type":"",
                "mods":[]
              },
              "g":0
            }],
          "args":"(s[, re='%s'])",
          "usage":["a,b = line:splitv('=')\n"],
          "type":"function",
          "name":"splitv",
          "parameter":"param",
          "params":{
            "1":"s",
            "2":"re",
            "map":{
              "s":" the string",
              "re":" a Lua string pattern (defaults to whitespace)"
            }
          },
          "tags":{
            "see":[]
          },
          "kind":"partitioning strings ",
          "section":"Partitioning Strings",
          "description":" Note that at least one value will be returned!",
          "ret":["the parts of the string"]
        },{
          "inferred":true,
          "subparams":[],
          "modifiers":{
            "usage":[[],[]],
            "param":{
              "1":{
                "type":"string"
              },
              "2":{
                "type":"string"
              },
              "s":{
                "type":"string"
              },
              "ch":{
                "type":"string"
              }
            },
            "return":[[],[],[]]
          },
          "summary":"partition the string using first occurance of a delimiter",
          "lineno":461,
          "retgroups":[{
              "1":{
                "text":"part before ch",
                "type":"",
                "mods":[]
              },
              "2":{
                "text":"ch",
                "type":"",
                "mods":[]
              },
              "3":{
                "text":"part after ch",
                "type":"",
                "mods":[]
              },
              "g":0
            }],
          "args":"(s, ch)",
          "usage":["{stringx.partition('a,b,c', ','))} == {'a', ',', 'b,c'}\n","{stringx.partition('abc', 'x'))} == {'abc', '', ''}\n"],
          "type":"function",
          "name":"partition",
          "parameter":"param",
          "params":{
            "1":"s",
            "2":"ch",
            "map":{
              "s":" the string",
              "ch":" delimiter (match as plain string, no patterns)"
            }
          },
          "tags":[],
          "kind":"partitioning strings ",
          "section":"Partitioning Strings",
          "description":"",
          "ret":["part before ch","ch","part after ch"]
        },{
          "inferred":true,
          "subparams":[],
          "modifiers":{
            "usage":[[],[]],
            "param":{
              "1":{
                "type":"string"
              },
              "2":{
                "type":"string"
              },
              "s":{
                "type":"string"
              },
              "ch":{
                "type":"string"
              }
            },
            "return":[[],[],[]]
          },
          "summary":"partition the string p using last occurance of a delimiter",
          "lineno":475,
          "retgroups":[{
              "1":{
                "text":"part before ch",
                "type":"",
                "mods":[]
              },
              "2":{
                "text":"ch",
                "type":"",
                "mods":[]
              },
              "3":{
                "text":"part after ch",
                "type":"",
                "mods":[]
              },
              "g":0
            }],
          "args":"(s, ch)",
          "usage":["{stringx.rpartition('a,b,c', ','))} == {'a,b', ',', 'c'}\n","{stringx.rpartition('abc', 'x'))} == {'', '', 'abc'}\n"],
          "type":"function",
          "name":"rpartition",
          "parameter":"param",
          "params":{
            "1":"s",
            "2":"ch",
            "map":{
              "s":" the string",
              "ch":" delimiter (match as plain string, no patterns)"
            }
          },
          "tags":[],
          "kind":"partitioning strings ",
          "section":"Partitioning Strings",
          "description":"",
          "ret":["part before ch","ch","part after ch"]
        },{
          "inferred":true,
          "subparams":[],
          "modifiers":{
            "return":[[]],
            "param":{
              "1":{
                "type":"string"
              },
              "2":{
                "type":"int"
              },
              "s":{
                "type":"string"
              },
              "idx":{
                "type":"int"
              }
            }
          },
          "summary":"return the 'character' at the index.",
          "lineno":489,
          "retgroups":[{
              "1":{
                "text":"a substring of length 1 if successful, empty string otherwise.",
                "type":"",
                "mods":[]
              },
              "g":0
            }],
          "args":"(s, idx)",
          "type":"function",
          "name":"at",
          "parameter":"param",
          "params":{
            "1":"s",
            "2":"idx",
            "map":{
              "s":" the string",
              "idx":" an index (can be negative)"
            }
          },
          "tags":[],
          "kind":"partitioning strings ",
          "section":"Partitioning Strings",
          "description":"",
          "ret":["a substring of length 1 if successful, empty string otherwise."]
        },{
          "name":"text",
          "inferred":true,
          "description":"",
          "file":"<reference cycle>",
          "summary":"",
          "tags":[],
          "lineno":500,
          "display_name":"Text handling",
          "type":"section",
          "modifiers":[]
        },{
          "inferred":true,
          "subparams":[],
          "modifiers":{
            "return":[[]],
            "param":{
              "1":{
                "type":"string"
              },
              "2":{
                "type":"integer"
              },
              "3":{
                "opt":"' '",
                "type":"string",
                "optchain":"' '"
              },
              "ch":{
                "opt":"' '",
                "type":"string",
                "optchain":"' '"
              },
              "n":{
                "type":"integer"
              },
              "s":{
                "type":"string"
              }
            }
          },
          "summary":"indent a multiline string.",
          "lineno":505,
          "retgroups":[{
              "1":{
                "text":"indented string",
                "type":"",
                "mods":[]
              },
              "g":0
            }],
          "args":"(s, n[, ch=' '])",
          "type":"function",
          "name":"indent",
          "parameter":"param",
          "params":{
            "1":"s",
            "2":"n",
            "map":{
              "ch":" the character to use when indenting",
              "n":" the size of the indent",
              "s":" the (multiline) string"
            },
            "3":"ch"
          },
          "tags":[],
          "kind":"text handling ",
          "section":"Text handling",
          "description":"",
          "ret":["indented string"]
        },{
          "inferred":true,
          "subparams":[],
          "modifiers":{
            "usage":[[]],
            "param":{
              "1":{
                "type":"string"
              },
              "s":{
                "type":"string"
              }
            },
            "return":[[]]
          },
          "summary":"dedent a multiline string by removing any initial indent.",
          "lineno":537,
          "retgroups":[{
              "1":{
                "text":"a string with initial indent zero.",
                "type":"",
                "mods":[]
              },
              "g":0
            }],
          "args":"(s)",
          "usage":["local s = dedent [[\n         One\n\n       Two\n\n     Three\n]]\nassert(s == [[\n    One\n\n  Two\n\nThree\n]])\n"],
          "type":"function",
          "name":"dedent",
          "parameter":"param",
          "params":{
            "map":{
              "s":" the (multiline) string"
            },
            "1":"s"
          },
          "tags":[],
          "kind":"text handling ",
          "section":"Text handling",
          "description":"\n useful when working with [[..]] strings.\n Empty lines are ignored.",
          "ret":["a string with initial indent zero."]
        },{
          "inferred":true,
          "subparams":[],
          "modifiers":{
            "param":{
              "1":{
                "type":"string"
              },
              "2":{
                "opt":"70",
                "type":"integer",
                "optchain":"70"
              },
              "3":{
                "opt":"false",
                "type":"boolean",
                "optchain":"false"
              },
              "width":{
                "opt":"70",
                "type":"integer",
                "optchain":"70"
              },
              "s":{
                "type":"string"
              },
              "breaklong":{
                "opt":"false",
                "type":"boolean",
                "optchain":"false"
              }
            },
            "return":[[]],
            "see":[[],[]]
          },
          "summary":"format a paragraph into lines so that they fit into a line width.",
          "lineno":594,
          "retgroups":[{
              "1":{
                "text":"a list of lines (List object), use `fill` to return a string instead of a `List`.",
                "type":"",
                "mods":[]
              },
              "g":0
            }],
          "args":"(s[, width=70[, breaklong=false]])",
          "type":"function",
          "name":"wrap",
          "parameter":"param",
          "params":{
            "1":"s",
            "2":"width",
            "map":{
              "width":" the margin width",
              "s":" the string to format",
              "breaklong":" if truthy, words longer than the width given will be forced split."
            },
            "3":"breaklong"
          },
          "tags":{
            "see":[]
          },
          "kind":"text handling ",
          "section":"Text handling",
          "description":"\n It will not break long words by default, so lines can be over the length\n to that extent.",
          "ret":["a list of lines (List object), use `fill` to return a string instead of a `List`."]
        },{
          "inferred":true,
          "subparams":[],
          "modifiers":{
            "param":{
              "1":{
                "type":"string"
              },
              "2":{
                "opt":"70",
                "type":"integer",
                "optchain":"70"
              },
              "3":{
                "opt":"false",
                "type":"boolean",
                "optchain":"false"
              },
              "width":{
                "opt":"70",
                "type":"integer",
                "optchain":"70"
              },
              "s":{
                "type":"string"
              },
              "breaklong":{
                "opt":"false",
                "type":"boolean",
                "optchain":"false"
              }
            },
            "return":[[]],
            "see":[[]]
          },
          "summary":"format a paragraph so that it fits into a line width.",
          "lineno":616,
          "retgroups":[{
              "1":{
                "text":"a string, use `wrap` to return a list of lines instead of a string.",
                "type":"",
                "mods":[]
              },
              "g":0
            }],
          "args":"(s[, width=70[, breaklong=false]])",
          "type":"function",
          "name":"fill",
          "parameter":"param",
          "params":{
            "1":"s",
            "2":"width",
            "map":{
              "width":" the margin width",
              "s":" the string to format",
              "breaklong":" if truthy, words longer than the width given will be forced split."
            },
            "3":"breaklong"
          },
          "tags":{
            "see":[]
          },
          "kind":"text handling ",
          "section":"Text handling",
          "description":"",
          "ret":["a string, use `wrap` to return a list of lines instead of a string."]
        },{
          "name":"Template",
          "inferred":true,
          "description":"",
          "file":"<reference cycle>",
          "summary":"",
          "tags":[],
          "lineno":624,
          "display_name":"Template",
          "type":"section",
          "modifiers":[]
        },{
          "inferred":true,
          "subparams":[],
          "modifiers":{
            "param":{
              "1":{
                "type":"string"
              },
              "tmpl":{
                "type":"string"
              }
            },
            "return":[{
                "type":"Template"
              }]
          },
          "summary":"Creates a new Template class.",
          "lineno":662,
          "retgroups":[{
              "1":{
                "text":"",
                "type":"Template",
                "mods":{
                  "type":"Template"
                }
              },
              "g":0
            }],
          "args":"(tmpl)",
          "section":"Template",
          "name":"Template",
          "params":{
            "map":{
              "tmpl":" the template string"
            },
            "1":"tmpl"
          },
          "tags":[],
          "kind":"template ",
          "description":"\n This is a shortcut to `Template.new(tmpl)`.",
          "type":"function",
          "ret":[""],
          "parameter":"param"
        },{
          "inferred":true,
          "subparams":[],
          "modifiers":{
            "return":[[]],
            "param":{
              "1":{
                "type":"table"
              },
              "tbl":{
                "type":"table"
              }
            }
          },
          "summary":"substitute values into a template, throwing an error.",
          "lineno":674,
          "retgroups":[{
              "1":{
                "text":"string with place holders substituted",
                "type":"",
                "mods":[]
              },
              "g":0
            }],
          "args":"(tbl)",
          "type":"function",
          "name":"Template:substitute",
          "parameter":"param",
          "params":{
            "map":{
              "tbl":" a table of name-value pairs."
            },
            "1":"tbl"
          },
          "tags":[],
          "kind":"template ",
          "section":"Template",
          "description":"\n This will throw an error if no name is found.",
          "ret":["string with place holders substituted"]
        },{
          "inferred":true,
          "subparams":[],
          "modifiers":{
            "return":[[]],
            "param":{
              "1":{
                "type":"table"
              },
              "tbl":{
                "type":"table"
              }
            }
          },
          "summary":"substitute values into a template.",
          "lineno":683,
          "retgroups":[{
              "1":{
                "text":"string with place holders substituted",
                "type":"",
                "mods":[]
              },
              "g":0
            }],
          "args":"(tbl)",
          "type":"function",
          "name":"Template:safe_substitute",
          "parameter":"param",
          "params":{
            "map":{
              "tbl":" a table of name-value pairs."
            },
            "1":"tbl"
          },
          "tags":[],
          "kind":"template ",
          "section":"Template",
          "description":"\n This version just passes unknown names through.",
          "ret":["string with place holders substituted"]
        },{
          "inferred":true,
          "subparams":[],
          "modifiers":{
            "return":[[]],
            "param":{
              "1":{
                "type":"table"
              },
              "tbl":{
                "type":"table"
              }
            }
          },
          "summary":"substitute values into a template, preserving indentation.",
          "lineno":695,
          "retgroups":[{
              "1":{
                "text":"string with place holders substituted",
                "type":"",
                "mods":[]
              },
              "g":0
            }],
          "args":"(tbl)",
          "type":"function",
          "name":"Template:indent_substitute",
          "parameter":"param",
          "params":{
            "map":{
              "tbl":" a table of name-value pairs."
            },
            "1":"tbl"
          },
          "tags":[],
          "kind":"template ",
          "section":"Template",
          "description":" <br>\n If the value is a multiline string _or_ a template, it will insert\n the lines at the correct indentation. <br>\n Furthermore, if a template, then that template will be substituted\n using the same table.",
          "ret":["string with place holders substituted"]
        },"<reference cycle>",{
          "inferred":true,
          "subparams":[],
          "modifiers":{
            "usage":[[]],
            "param":{
              "1":{
                "type":"string"
              },
              "s":{
                "type":"string"
              }
            },
            "return":[[]]
          },
          "summary":"return an iterator over all lines in a string",
          "lineno":751,
          "retgroups":[{
              "1":{
                "text":"an iterator",
                "type":"",
                "mods":[]
              },
              "g":0
            }],
          "args":"(s)",
          "usage":["local line_no = 1\nfor line in stringx.lines(some_text) do\n  print(line_no, line)\n  line_no = line_no + 1\nend\n"],
          "type":"function",
          "name":"lines",
          "parameter":"param",
          "params":{
            "map":{
              "s":" the string"
            },
            "1":"s"
          },
          "tags":[],
          "kind":"miscelaneous ",
          "section":"Miscelaneous",
          "description":"",
          "ret":["an iterator"]
        },{
          "inferred":true,
          "subparams":[],
          "modifiers":{
            "usage":[[]],
            "param":{
              "1":{
                "type":"string"
              },
              "s":{
                "type":"string"
              }
            },
            "return":[[]]
          },
          "summary":"inital word letters uppercase ('title case').",
          "lineno":762,
          "retgroups":[{
              "1":{
                "text":"a string with each word's first letter uppercase",
                "type":"",
                "mods":[]
              },
              "g":0
            }],
          "args":"(s)",
          "usage":["stringx.title(\"hello world\") == \"Hello World\")\n"],
          "type":"function",
          "name":"title",
          "parameter":"param",
          "params":{
            "map":{
              "s":" the string"
            },
            "1":"s"
          },
          "tags":[],
          "kind":"miscelaneous ",
          "section":"Miscelaneous",
          "description":"\n Here 'words' mean chunks of non-space characters.",
          "ret":["a string with each word's first letter uppercase"]
        },{
          "inferred":true,
          "subparams":[],
          "modifiers":{
            "usage":[[],[],[]],
            "return":[],
            "param":{
              "1":{
                "type":"string"
              },
              "2":{
                "type":"int"
              },
              "3":{
                "type":"bool"
              },
              "tail":{
                "type":"bool"
              },
              "s":{
                "type":"string"
              },
              "w":{
                "type":"int"
              }
            }
          },
          "summary":"Return a shortened version of a string.",
          "lineno":783,
          "args":"(s, w, tail)",
          "usage":["('1234567890'):shorten(8) == '12345...'\n","('1234567890'):shorten(8, true) == '...67890'\n","('1234567890'):shorten(20) == '1234567890'\n"],
          "section":"Miscelaneous",
          "name":"shorten",
          "parameter":"param",
          "params":{
            "1":"s",
            "2":"w",
            "map":{
              "tail":" true if we want to show the end of the string (head otherwise)",
              "s":" the string",
              "w":" the maxinum size allowed"
            },
            "3":"tail"
          },
          "tags":[],
          "kind":"miscelaneous ",
          "description":"\n Fits string within w characters. Removed characters are marked with ellipsis.",
          "type":"function"
        },{
          "inferred":true,
          "subparams":[],
          "modifiers":{
            "return":[[]],
            "param":{
              "1":[],
              "s":[]
            }
          },
          "summary":"Quote the given string and preserve any control or escape characters, such that reloading the string in Lua returns the same result.",
          "lineno":822,
          "retgroups":[{
              "1":{
                "text":"The quoted string.",
                "type":"",
                "mods":[]
              },
              "g":0
            }],
          "args":"(s)",
          "type":"function",
          "name":"quote_string",
          "parameter":"param",
          "params":{
            "map":{
              "s":" The string to be quoted."
            },
            "1":"s"
          },
          "tags":[],
          "kind":"miscelaneous ",
          "section":"Miscelaneous",
          "description":"",
          "ret":["The quoted string."]
        },{
          "inferred":true,
          "subparams":[],
          "modifiers":{
            "return":[],
            "param":[],
            "usage":[[]]
          },
          "summary":"Python-style formatting operator.",
          "lineno":873,
          "args":"()",
          "usage":["require 'pl.text'.format_operator()\nlocal out1 = '%s = %5.3f' % {'PI',math.pi}                   --> 'PI = 3.142'\nlocal out2 = '$name = $value' % {name='dog',value='Pluto'}   --> 'dog = Pluto'\n"],
          "section":"Miscelaneous",
          "name":"format_operator",
          "parameter":"param",
          "params":{
            "map":[]
          },
          "tags":[],
          "kind":"miscelaneous ",
          "description":"\n Calling `text.format_operator()` overloads the % operator for strings to give\n Python/Ruby style formated output.\n This is extended to also do template-like substitution for map-like data.\n\n Note this goes further than the original, and will allow these cases:\n\n 1. a single value\n 2. a list of values\n 3. a map of var=value pairs\n 4. a function, as in gsub\n\n For the second two cases, it uses $-variable substituion.\n\n When called, this function will monkey-patch the global `string` metatable by\n adding a `__mod` method.\n\n See <a href=\"http://lua-users.org/wiki/StringInterpolation\">the lua-users wiki</a>\n",
          "type":"function"
        },{
          "inferred":true,
          "subparams":[],
          "modifiers":{
            "param":[],
            "return":[]
          },
          "summary":"import the stringx functions into the global string (meta)table",
          "lineno":913,
          "args":"()",
          "section":"Miscelaneous",
          "name":"import",
          "params":{
            "map":[]
          },
          "tags":[],
          "kind":"miscelaneous ",
          "description":"",
          "type":"function",
          "parameter":"param"
        }],
      "sections":[],
      "modules":["<reference cycle>"],
      "args":{
        "one":false,
        "module":false,
        "verbose":false,
        "style":"!",
        "template":"!",
        "date":"system",
        "dir":"doc",
        "quiet":false,
        "all":false,
        "ignore":false,
        "colon":false,
        "not_luadoc":false,
        "ext":"html",
        "boilerplate":false,
        "merge":false,
        "filter":"f.filter",
        "package":"/home/cji/portless/Penlight/lua",
        "dump":false,
        "no_args_infer":false,
        "title":"Reference",
        "project":"ldoc",
        "file":"/home/cji/portless/Penlight/lua/pl",
        "format":"discount",
        "simple":false,
        "tags":"none",
        "define":"none",
        "output":"index",
        "unqualified":false,
        "config":"config.ld",
        "fatalwarnings":false,
        "testing":false
      },
      "error":"<type 'function' is not supported by JSON.>",
      "lang":{
        "line_comment":"^%-%-+",
        "start_comment_":"^%-%-%-+",
        "end_comment_":"[^%-]%-%-+[^-]*\n$",
        "extra":[],
        "block_comment":"^%-%-%[=*%[%-+",
        "empty_comment_":"^%-%-%-+%s*$",
        "method_call":":"
      },
      "base":"/home/cji/portless/Penlight/lua"
    },
    "summary":"",
    "tags":[],
    "lineno":742,
    "display_name":"Miscelaneous",
    "type":"section",
    "modifiers":[]
  },
  "inferred":true
}