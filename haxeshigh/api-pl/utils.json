{
  "kind":"libraries",
  "name":"pl.utils",
  "modifiers":[],
  "type":"module",
  "description":"\n See  @{01-introduction.md.Generally_useful_functions|the Guide}.\n\n Dependencies: `pl.compat`, all exported fields and functions from\n `pl.compat` are also available in this module.\n",
  "file":"/home/cji/portless/Penlight/lua/pl/utils.lua",
  "summary":"Generally useful routines.",
  "sections":{
    "1":{
      "name":"Error-handling",
      "inferred":true,
      "description":"",
      "file":{
        "warning":"<type 'function' is not supported by JSON.>",
        "filename":"/home/cji/portless/Penlight/lua/pl/utils.lua",
        "items":["<reference cycle>",{
            "inferred":true,
            "description":"",
            "modifiers":{
              "field":[],
              "return":[]
            },
            "summary":"Some standard patterns",
            "lineno":31,
            "args":"(FLOAT, INTEGER, IDEN, FILE)",
            "type":"table",
            "name":"patterns",
            "parameter":"field",
            "params":{
              "1":"FLOAT",
              "2":"INTEGER",
              "3":"IDEN",
              "4":"FILE",
              "map":{
                "FILE":"file",
                "INTEGER":"integer number",
                "IDEN":"identifier",
                "FLOAT":"floating point number"
              }
            },
            "tags":[],
            "kind":"tables",
            "section":"table",
            "subparams":[]
          },{
            "name":"stdmt",
            "section":"table",
            "inferred":true,
            "description":"",
            "kind":"tables",
            "summary":"Standard meta-tables as used by other Penlight modules",
            "params":{
              "1":"List",
              "2":"Map",
              "3":"Set",
              "4":"MultiMap",
              "map":{
                "Map":" the Map metatable",
                "Set":" the Set metatable",
                "MultiMap":" the MultiMap metatable",
                "List":" the List metatable"
              }
            },
            "tags":[],
            "lineno":45,
            "subparams":[],
            "args":"(List, Map, Set, MultiMap)",
            "parameter":"field",
            "type":"table",
            "modifiers":{
              "field":{
                "1":[],
                "2":[],
                "3":[],
                "4":[],
                "Map":[],
                "Set":[],
                "MultiMap":[],
                "List":[]
              },
              "return":[]
            }
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "param":{
                "1":[],
                "...":[]
              },
              "return":[[]],
              "see":[[],[],[]]
            },
            "summary":"pack an argument list into a table.",
            "lineno":60,
            "retgroups":[{
                "1":{
                  "text":"a table with field `n` set to the length",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(...)",
            "section":"function",
            "name":"pack",
            "params":{
              "map":{
                "...":" any arguments"
              },
              "1":"..."
            },
            "tags":{
              "see":[]
            },
            "kind":"functions",
            "description":"",
            "type":"function",
            "ret":["a table with field `n` set to the length"],
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[[]],
              "usage":[[]],
              "param":{
                "1":[],
                "2":{
                  "optchain":true,
                  "opt":true
                },
                "3":{
                  "optchain":true,
                  "opt":true
                },
                "t":[],
                "j":{
                  "optchain":true,
                  "opt":true
                },
                "i":{
                  "optchain":true,
                  "opt":true
                }
              },
              "see":[[],[],[]]
            },
            "summary":"unpack a table and return its contents.",
            "lineno":79,
            "retgroups":[{
                "1":{
                  "text":"multiple return values from the table",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(t[, i[, j]])",
            "usage":["local t = table.pack(nil, nil, nil, 4)\nlocal a, b, c, d = table.unpack(t)   -- this `unpack` is NOT nil-safe, so d == nil\n\nlocal a, b, c, d = utils.unpack(t)   -- this is nil-safe, so d == 4\n"],
            "type":"function",
            "name":"unpack",
            "params":{
              "1":"t",
              "2":"i",
              "map":{
                "t":" table to unpack",
                "j":" index of the last element to unpack, defaults to `t.n` or else `#t`",
                "i":" index from which to start unpacking, defaults to 1"
              },
              "3":"j"
            },
            "tags":{
              "see":[]
            },
            "kind":"functions",
            "section":"function",
            "description":"\n\n NOTE: this implementation differs from the Lua implementation in the way\n that this one DOES honor the `n` field in the table `t`, such that it is 'nil-safe'.",
            "ret":["multiple return values from the table"],
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":{
                "1":[],
                "2":[],
                "fmt":[],
                "...":[]
              }
            },
            "summary":"print an arbitrary number of arguments using a format.",
            "lineno":87,
            "args":"(fmt, ...)",
            "section":"function",
            "name":"printf",
            "params":{
              "1":"fmt",
              "2":"...",
              "map":{
                "fmt":" The format (see `string.format`)",
                "...":" Extra arguments for format"
              }
            },
            "tags":[],
            "kind":"functions",
            "description":"\n Output will be sent to `stdout`.",
            "type":"function",
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":{
                "1":[],
                "2":[],
                "3":[],
                "fmt":[],
                "f":[],
                "...":[]
              }
            },
            "summary":"write an arbitrary number of arguments to a file using a format.",
            "lineno":96,
            "args":"(f, fmt, ...)",
            "section":"function",
            "name":"fprintf",
            "params":{
              "1":"f",
              "2":"fmt",
              "map":{
                "fmt":" The format (see `string.format`).",
                "f":" File handle to write to.",
                "...":" Extra arguments for format"
              },
              "3":"..."
            },
            "tags":[],
            "kind":"functions",
            "description":"",
            "type":"function",
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":{
                "1":[],
                "2":[],
                "t":[],
                "T":[]
              }
            },
            "summary":"take a table and 'inject' it into the local namespace.",
            "lineno":124,
            "args":"(t, T)",
            "section":"function",
            "name":"import",
            "params":{
              "1":"t",
              "2":"T",
              "map":{
                "t":" The table (table), or module name (string), defaults to this `utils` module table",
                "T":" An optional destination table (defaults to callers environment)"
              }
            },
            "tags":[],
            "kind":"functions",
            "description":"",
            "type":"function",
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":{
                "1":[],
                "2":[],
                "3":[],
                "cond":[],
                "value1":[],
                "value2":[]
              }
            },
            "summary":"return either of two values, depending on a condition.",
            "lineno":143,
            "args":"(cond, value1, value2)",
            "section":"function",
            "name":"choose",
            "params":{
              "1":"cond",
              "2":"value1",
              "map":{
                "cond":" A condition",
                "value1":" Value returned if cond is truthy",
                "value2":" Value returned if cond is falsy"
              },
              "3":"value2"
            },
            "tags":[],
            "kind":"functions",
            "description":"",
            "type":"function",
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[[]],
              "param":{
                "1":[],
                "2":{
                  "optchain":true,
                  "opt":true
                },
                "3":{
                  "optchain":true,
                  "opt":true
                },
                "t":[],
                "temp":{
                  "optchain":true,
                  "opt":true
                },
                "tostr":{
                  "optchain":true,
                  "opt":true
                }
              }
            },
            "summary":"convert an array of values to strings.",
            "lineno":152,
            "retgroups":[{
                "1":{
                  "text":"the converted buffer",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(t[, temp[, tostr]])",
            "type":"function",
            "name":"array_tostring",
            "parameter":"param",
            "params":{
              "1":"t",
              "2":"temp",
              "map":{
                "t":" a list-like table",
                "temp":" (table) buffer to use, otherwise allocate",
                "tostr":" custom tostring function, called with (value,index). Defaults to `tostring`."
              },
              "3":"tostr"
            },
            "tags":[],
            "kind":"functions",
            "section":"function",
            "description":"",
            "ret":["the converted buffer"]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[]],
              "param":{
                "1":[],
                "2":[],
                "obj":[],
                "tp":[]
              },
              "return":[[]]
            },
            "summary":"is the object of the specified type?",
            "lineno":172,
            "retgroups":[{
                "1":{
                  "text":"boolean",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(obj, tp)",
            "usage":["utils.is_type(\"hello world\", \"string\")   --> true\n-- or check metatable\nlocal my_mt = {}\nlocal my_obj = setmetatable(my_obj, my_mt)\nutils.is_type(my_obj, my_mt)  --> true\n"],
            "type":"function",
            "name":"is_type",
            "parameter":"param",
            "params":{
              "1":"obj",
              "2":"tp",
              "map":{
                "obj":" An object to check",
                "tp":" String of what type it should be"
              }
            },
            "tags":[],
            "kind":"functions",
            "section":"function",
            "description":"\n If the type is a string, then use type, otherwise compare with metatable",
            "ret":["boolean"]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[]],
              "return":[{
                  "type":"integer"
                },{
                  "type":"any"
                }],
              "param":{
                "1":{
                  "type":"table"
                },
                "2":{
                  "opt":"1",
                  "type":"integer",
                  "optchain":"1"
                },
                "3":{
                  "opt":"t.n or #t",
                  "type":"integer",
                  "optchain":"t.n or #t"
                },
                "4":{
                  "opt":"1",
                  "type":"integer",
                  "optchain":"1"
                },
                "t":{
                  "type":"table"
                },
                "step":{
                  "opt":"1",
                  "type":"integer",
                  "optchain":"1"
                },
                "i_start":{
                  "opt":"1",
                  "type":"integer",
                  "optchain":"1"
                },
                "i_end":{
                  "opt":"t.n or #t",
                  "type":"integer",
                  "optchain":"t.n or #t"
                }
              },
              "see":[[],[]]
            },
            "summary":"an iterator with indices, similar to `ipairs`, but with a range.",
            "lineno":199,
            "retgroups":[{
                "1":{
                  "text":"index",
                  "type":"integer",
                  "mods":{
                    "type":"integer"
                  }
                },
                "2":{
                  "text":"value at index (which can be `nil`!)",
                  "type":"any",
                  "mods":{
                    "type":"any"
                  }
                },
                "g":0
              }],
            "args":"(t[, i_start=1[, i_end=t.n or #t[, step=1]]])",
            "usage":["local t = utils.pack(nil, 123, nil)  -- adds an `n` field when packing\n\nfor i, v in utils.npairs(t, 2) do  -- start at index 2\n  t[i] = tostring(t[i])\nend\n\n-- t = { n = 3, [2] = \"123\", [3] = \"nil\" }\n"],
            "type":"function",
            "name":"npairs",
            "parameter":"param",
            "params":{
              "1":"t",
              "2":"i_start",
              "3":"i_end",
              "4":"step",
              "map":{
                "t":" the table to iterate over",
                "step":" step size",
                "i_start":" start index",
                "i_end":" end index"
              }
            },
            "tags":{
              "see":[]
            },
            "kind":"functions",
            "section":"function",
            "description":"\n This is a nil-safe index based iterator that will return `nil` when there\n is a hole in a list. To be safe ensure that table `t.n` contains the length.",
            "ret":["index","value at index (which can be `nil`!)"]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[]],
              "param":{
                "1":{
                  "type":"table"
                },
                "t":{
                  "type":"table"
                }
              },
              "return":[{
                  "type":"key"
                },{
                  "type":"value"
                }]
            },
            "summary":"an iterator over all non-integer keys (inverse of `ipairs`).",
            "lineno":253,
            "retgroups":[{
                "1":{
                  "text":"",
                  "type":"key",
                  "mods":{
                    "type":"key"
                  }
                },
                "2":{
                  "text":"",
                  "type":"value",
                  "mods":{
                    "type":"value"
                  }
                },
                "g":0
              }],
            "args":"(t)",
            "usage":["local t = {\n  \"hello\",\n  \"world\",\n  hello = \"hallo\",\n  world = \"Welt\",\n}\n\nfor k, v in utils.kpairs(t) do\n  print(\"German: \", v)\nend\n\n-- output;\n-- German: hallo\n-- German: Welt\n"],
            "type":"function",
            "name":"kpairs",
            "parameter":"param",
            "params":{
              "map":{
                "t":" the table to iterate over"
              },
              "1":"t"
            },
            "tags":[],
            "kind":"functions",
            "section":"function",
            "description":"\n It will skip any key that is an integer number, so negative indices or an\n array with holes will not return those either (so it returns slightly less than\n 'the inverse of `ipairs`').\n\n This uses `pairs` under the hood, so any value that is iterable using `pairs`\n will work with this function.",
            "ret":["",""]
          },"<reference cycle>",{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[]],
              "param":{
                "1":[],
                "2":[],
                "3":[],
                "4":[],
                "5":[],
                "6":[],
                "n":[],
                "verify":[],
                "val":[],
                "lev":[],
                "msg":[],
                "tp":[]
              },
              "raise":[],
              "return":[[]]
            },
            "summary":"assert that the given argument is in fact of the correct type.",
            "lineno":285,
            "retgroups":[{
                "1":{
                  "text":"the validated value",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(n, val, tp, verify, msg, lev)",
            "usage":["local param1 = assert_arg(1,\"hello\",'table')  --> error: argument 1 expected a 'table', got a 'string'\nlocal param4 = assert_arg(4,'!@#$%^&*','string',path.isdir,'not a directory')\n     --> error: argument 4: '!@#$%^&*' not a directory\n"],
            "raise":"if `val` is not the correct type",
            "name":"assert_arg",
            "params":{
              "1":"n",
              "2":"val",
              "3":"tp",
              "4":"verify",
              "5":"msg",
              "6":"lev",
              "map":{
                "n":" argument index",
                "verify":" an optional verification function",
                "val":" the value",
                "lev":" optional stack position for trace, default 2",
                "msg":" an optional custom message",
                "tp":" the type"
              }
            },
            "tags":[],
            "kind":"error handling ",
            "section":"Error handling",
            "type":"function",
            "parameter":"param",
            "ret":["the validated value"],
            "description":""
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[],[],[]],
              "param":{
                "1":{
                  "type":"table|vararg"
                },
                "...":{
                  "type":"table|vararg"
                }
              },
              "return":[[]]
            },
            "summary":"creates an Enum or constants lookup table for improved error handling.",
            "lineno":355,
            "retgroups":[{
                "1":{
                  "text":"Enum object (read-only table/object)",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(...)",
            "usage":["-- Enum access at runtime\nlocal obj = {}\nobj.MOVEMENT = utils.enum(\"FORWARD\", \"REVERSE\", \"LEFT\", \"RIGHT\")\n\nif current_movement == obj.MOVEMENT.FORWARD then\n  -- do something\n\nelseif current_movement == obj.MOVEMENT.REVERES then\n  -- throws error due to typo 'REVERES', so a silent mistake becomes a hard error\n  -- \"'REVERES' is not a valid value (expected one of: 'FORWARD', 'REVERSE', 'LEFT', 'RIGHT')\"\n\nend\n","-- standardized error codes\nlocal obj = {\n  ERR = utils.enum {\n    NOT_FOUND = \"the item was not found\",\n    OUT_OF_BOUNDS = \"the index is outside the allowed range\"\n  },\n\n  some_method = function(self)\n    return self.ERR.OUT_OF_BOUNDS\n  end,\n}\n\nlocal result, err = obj:some_method()\nif not result then\n  if err == obj.ERR.NOT_FOUND then\n    -- check on error code, not magic strings\n\n  else\n    -- return the error description, contained in the constant\n    return nil, \"error: \"..err  -- \"error: the index is outside the allowed range\"\n  end\nend\n","-- validating/converting user-input\nlocal color = \"purple\"\nlocal ansi_colors = utils.enum {\n  black     = 30,\n  red       = 31,\n  green     = 32,\n}\nlocal color_code, err = ansi_colors(color) -- calling on the object, returns the value from the enum\nif not color_code then\n  print(\"bad 'color', \" .. err)\n  -- \"bad 'color', 'purple' is not a valid value (expected one of: 'black', 'red', 'green')\"\n  os.exit(1)\nend\n"],
            "type":"function",
            "name":"enum",
            "parameter":"param",
            "params":{
              "map":{
                "...":" the input for the Enum. If varargs or an array then the\n values in the Enum will be equal to the names (must be strings), if a hash-table\n then values remain (any type), and the keys must be strings."
              },
              "1":"..."
            },
            "tags":[],
            "kind":"error handling ",
            "section":"Error handling",
            "description":"\n This helps prevent magic strings in code by throwing errors for accessing\n non-existing values, and/or converting strings/identifiers to other values.\n\n Calling on the object does the same, but returns a soft error; `nil + err`, if\n the call is succesful (the key exists), it will return the value.\n\n When calling with varargs or an array the values will be equal to the keys.\n The enum object is read-only.",
            "ret":["Enum object (read-only table/object)"]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "param":{
                "1":[],
                "2":[],
                "3":[],
                "f":[],
                "msg":[],
                "idx":[]
              },
              "raise":[],
              "return":[[]]
            },
            "summary":"process a function argument.",
            "lineno":430,
            "retgroups":[{
                "1":{
                  "text":"a callable",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(idx, f, msg)",
            "type":"function",
            "name":"function_arg",
            "params":{
              "1":"idx",
              "2":"f",
              "map":{
                "f":" a function, operator string, or callable object",
                "msg":" optional error message",
                "idx":" argument index"
              },
              "3":"msg"
            },
            "tags":[],
            "kind":"error handling ",
            "section":"Error handling",
            "description":"\n This is used throughout Penlight and defines what is meant by a function:\n Something that is callable, or an operator string as defined by <code>pl.operator</code>,\n such as '>' or '#'. If a function factory has been registered for the type, it will\n be called to get the function.",
            "raise":"if idx is not a number or if f is not callable",
            "ret":["a callable"],
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[]],
              "param":{
                "1":[],
                "2":[],
                "val":[],
                "n":[]
              },
              "raise":[],
              "return":[[]]
            },
            "summary":"assert the common case that the argument is a string.",
            "lineno":470,
            "retgroups":[{
                "1":{
                  "text":"the validated value",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(n, val)",
            "usage":["local val = 42\nlocal param2 = utils.assert_string(2, val) --> error: argument 2 expected a 'string', got a 'number'\n"],
            "raise":"val must be a string",
            "name":"assert_string",
            "params":{
              "1":"n",
              "2":"val",
              "map":{
                "val":" a value that must be a string",
                "n":" argument index"
              }
            },
            "tags":[],
            "kind":"error handling ",
            "section":"Error handling",
            "type":"function",
            "parameter":"param",
            "ret":["the validated value"],
            "description":""
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "param":{
                "1":[],
                "mode":[]
              },
              "return":[],
              "see":[[]]
            },
            "summary":"control the error strategy used by Penlight.",
            "lineno":483,
            "args":"(mode)",
            "section":"Error handling",
            "name":"on_error",
            "params":{
              "map":{
                "mode":" either 'default', 'quit'  or 'error'"
              },
              "1":"mode"
            },
            "tags":{
              "see":[]
            },
            "kind":"error handling ",
            "description":"\n This is a global setting that controls how `utils.raise` behaves:\n\n - 'default': return `nil + error` (this is the default)\n - 'error': throw a Lua error\n - 'quit': exit the program\n",
            "type":"function",
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":{
                "1":[],
                "err":[]
              },
              "usage":[[]],
              "see":[[]]
            },
            "summary":"used by Penlight functions to return errors.",
            "lineno":507,
            "args":"(err)",
            "usage":["if some_condition then\n  return utils.raise(\"some condition was not met\")  -- MUST use 'return'!\nend\n"],
            "section":"Error handling",
            "name":"raise",
            "parameter":"param",
            "params":{
              "map":{
                "err":" the error string."
              },
              "1":"err"
            },
            "tags":{
              "see":[]
            },
            "kind":"error handling ",
            "description":" Its global behaviour is controlled\n by `utils.on_error`.\n To use this function you MUST use it in conjunction with `return`, since it might\n return `nil + error`.",
            "type":"function"
          },{
            "name":"files",
            "inferred":true,
            "description":"",
            "file":"<reference cycle>",
            "summary":"",
            "tags":[],
            "lineno":523,
            "display_name":"File handling",
            "type":"section",
            "modifiers":[]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[[]],
              "param":{
                "1":[],
                "2":[],
                "filename":[],
                "is_bin":[]
              }
            },
            "summary":"return the contents of a file as a string",
            "lineno":527,
            "retgroups":[{
                "1":{
                  "text":"file contents",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(filename, is_bin)",
            "type":"function",
            "name":"readfile",
            "parameter":"param",
            "params":{
              "1":"filename",
              "2":"is_bin",
              "map":{
                "filename":" The file path",
                "is_bin":" open in binary mode"
              }
            },
            "tags":[],
            "kind":"file handling ",
            "section":"File handling",
            "description":"",
            "ret":["file contents"]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "param":{
                "1":[],
                "2":[],
                "3":[],
                "filename":[],
                "str":[],
                "is_bin":[]
              },
              "raise":[],
              "return":[[],[]]
            },
            "summary":"write a string to a file",
            "lineno":549,
            "retgroups":[{
                "1":{
                  "text":"true or nil",
                  "type":"",
                  "mods":[]
                },
                "2":{
                  "text":"error message",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(filename, str, is_bin)",
            "type":"function",
            "name":"writefile",
            "params":{
              "1":"filename",
              "2":"str",
              "map":{
                "filename":" The file path",
                "str":" The string",
                "is_bin":" open in binary mode"
              },
              "3":"is_bin"
            },
            "tags":[],
            "kind":"file handling ",
            "section":"File handling",
            "description":"",
            "raise":"error if filename or str aren't strings",
            "ret":["true or nil","error message"],
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "param":{
                "1":[],
                "filename":[]
              },
              "raise":[],
              "return":[[]]
            },
            "summary":"return the contents of a file as a list of lines",
            "lineno":569,
            "retgroups":[{
                "1":{
                  "text":"file contents as a table",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(filename)",
            "type":"function",
            "name":"readlines",
            "params":{
              "map":{
                "filename":" The file path"
              },
              "1":"filename"
            },
            "tags":[],
            "kind":"file handling ",
            "section":"File handling",
            "description":"",
            "raise":"error if filename is not a string",
            "ret":["file contents as a table"],
            "parameter":"param"
          },{
            "name":"OS-functions",
            "inferred":true,
            "description":"",
            "file":"<reference cycle>",
            "summary":"",
            "tags":[],
            "lineno":584,
            "display_name":"OS functions",
            "type":"section",
            "modifiers":[]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[[],[],[],[]],
              "param":{
                "1":[],
                "2":[],
                "bin":[],
                "cmd":[]
              }
            },
            "summary":"execute a shell command and return the output.",
            "lineno":592,
            "retgroups":[{
                "1":{
                  "text":"true if successful",
                  "type":"",
                  "mods":[]
                },
                "2":{
                  "text":"actual return code",
                  "type":"",
                  "mods":[]
                },
                "3":{
                  "text":"stdout output (string)",
                  "type":"",
                  "mods":[]
                },
                "4":{
                  "text":"errout output (string)",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(cmd, bin)",
            "type":"function",
            "name":"executeex",
            "parameter":"param",
            "params":{
              "1":"cmd",
              "2":"bin",
              "map":{
                "bin":" boolean, if true, read output as binary file",
                "cmd":" a shell command"
              }
            },
            "tags":[],
            "kind":"os functions ",
            "section":"OS functions",
            "description":"\n This function redirects the output to tempfiles and returns the content of those files.",
            "ret":["true if successful","actual return code","stdout output (string)","errout output (string)"]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[]],
              "param":{
                "1":[],
                "argument":[]
              },
              "return":[[]]
            },
            "summary":"Quote and escape an argument of a command.",
            "lineno":623,
            "retgroups":[{
                "1":{
                  "text":"quoted and escaped argument.",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(argument)",
            "usage":["local options = utils.quote_arg {\n    \"-lluacov\",\n    \"-e\",\n    \"utils = print(require('pl.utils')._VERSION\",\n}\n-- returns: -lluacov -e 'utils = print(require('\\''pl.utils'\\'')._VERSION'\n"],
            "type":"function",
            "name":"quote_arg",
            "parameter":"param",
            "params":{
              "map":{
                "argument":" (string or table/list) the argument to quote. If a list then\n all arguments in the list will be returned as a single string quoted."
              },
              "1":"argument"
            },
            "tags":[],
            "kind":"os functions ",
            "section":"OS functions",
            "description":"\n Quotes a single (or list of) argument(s) of a command to be passed\n to `os.execute`, `pl.utils.execute` or `pl.utils.executeex`.",
            "ret":["quoted and escaped argument."]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":{
                "1":{
                  "opt":true
                },
                "2":[],
                "3":[],
                "msg":[],
                "...":[],
                "code":{
                  "opt":true
                }
              },
              "usage":[[]],
              "see":[[]]
            },
            "summary":"error out of this program gracefully.",
            "lineno":667,
            "args":"([code], msg, ...)",
            "usage":["utils.quit(-1, \"Error '%s' happened\", \"42\")\n-- is equivalent to\nutils.quit(\"Error '%s' happened\", \"42\")  --> Error '42' happened\n"],
            "section":"OS functions",
            "name":"quit",
            "parameter":"param",
            "params":{
              "1":"code",
              "2":"msg",
              "map":{
                "msg":" The exit message will be sent to `stderr` (will be formatted with the extra parameters)",
                "...":" extra arguments for message's format'",
                "code":" The exit code, defaults to -`1` if omitted"
              },
              "3":"..."
            },
            "tags":{
              "see":[]
            },
            "kind":"os functions ",
            "description":"",
            "type":"function"
          },{
            "name":"string-functions",
            "inferred":true,
            "description":"",
            "file":"<reference cycle>",
            "summary":"",
            "tags":[],
            "lineno":683,
            "display_name":"String functions",
            "type":"section",
            "modifiers":[]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":{
                "1":[],
                "s":[]
              }
            },
            "summary":"escape any Lua 'magic' characters in a string",
            "lineno":685,
            "args":"(s)",
            "section":"String functions",
            "name":"escape",
            "params":{
              "map":{
                "s":" The input string"
              },
              "1":"s"
            },
            "tags":[],
            "kind":"string functions ",
            "description":"",
            "type":"function",
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "param":{
                "1":[],
                "2":[],
                "3":[],
                "4":[],
                "re":[],
                "n":[],
                "s":[],
                "plain":[]
              },
              "return":[[]],
              "raise":[],
              "see":[[]]
            },
            "summary":"split a string into a list of strings separated by a delimiter.",
            "lineno":698,
            "retgroups":[{
                "1":{
                  "text":"a list-like table",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s, re, plain, n)",
            "type":"function",
            "name":"split",
            "params":{
              "1":"s",
              "2":"re",
              "3":"plain",
              "4":"n",
              "map":{
                "re":" optional A Lua string pattern; defaults to '%s+'",
                "n":" optional maximum number of elements (if there are more, the last will remian un-split)",
                "s":" The input string",
                "plain":" optional If truthy don't use Lua patterns"
              }
            },
            "tags":{
              "see":[]
            },
            "kind":"string functions ",
            "section":"String functions",
            "description":"",
            "raise":"error if s is not a string",
            "ret":["a list-like table"],
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "param":{
                "1":[],
                "2":[],
                "3":[],
                "4":[],
                "re":[],
                "n":[],
                "s":[],
                "plain":[]
              },
              "return":[[]],
              "usage":[[]],
              "see":[[]]
            },
            "summary":"split a string into a number of return values.",
            "lineno":735,
            "retgroups":[{
                "1":{
                  "text":"n values",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s, re, plain, n)",
            "usage":["first,next = splitv('user=jane=doe','=', false, 2)\nassert(first == \"user\")\nassert(next == \"jane=doe\")\n"],
            "type":"function",
            "name":"splitv",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"re",
              "3":"plain",
              "4":"n",
              "map":{
                "re":" A Lua string pattern; defaults to '%s+'",
                "n":" optional maximum number of splits",
                "s":" the string",
                "plain":" don't use Lua patterns"
              }
            },
            "tags":{
              "see":[]
            },
            "kind":"string functions ",
            "section":"String functions",
            "description":"\n Identical to `split` but returns multiple sub-strings instead of\n a single list of sub-strings.",
            "ret":["n values"]
          },{
            "name":"functional",
            "inferred":true,
            "description":"",
            "file":"<reference cycle>",
            "summary":"",
            "tags":[],
            "lineno":744,
            "display_name":"Functional",
            "type":"section",
            "modifiers":[]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[[]],
              "param":{
                "1":[],
                "func":[]
              }
            },
            "summary":"'memoize' a function (cache returned value for next call).",
            "lineno":750,
            "retgroups":[{
                "1":{
                  "text":"a function with at least one argument, which is used as the key.",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(func)",
            "type":"function",
            "name":"memoize",
            "parameter":"param",
            "params":{
              "map":{
                "func":" a function of at least one argument"
              },
              "1":"func"
            },
            "tags":[],
            "kind":"functional ",
            "section":"Functional",
            "description":"\n This is useful if you have a function which is relatively expensive,\n but you don't know in advance what values will be required, so\n building a table upfront is wasteful/impossible.",
            "ret":["a function with at least one argument, which is used as the key."]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":{
                "1":{
                  "type":"tab"
                },
                "2":{
                  "type":"func"
                },
                "fun":{
                  "type":"func"
                },
                "mt":{
                  "type":"tab"
                }
              }
            },
            "summary":"associate a function factory with a type.",
            "lineno":768,
            "args":"(mt, fun)",
            "section":"Functional",
            "name":"add_function_factory",
            "params":{
              "1":"mt",
              "2":"fun",
              "map":{
                "fun":" a callable that returns a function",
                "mt":" metatable"
              }
            },
            "tags":[],
            "kind":"functional ",
            "description":"\n A function factory takes an object of the given type and\n returns a function for evaluating it",
            "type":"function",
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "param":{
                "1":[],
                "lf":[]
              },
              "return":[[]],
              "usage":[[]]
            },
            "summary":"an anonymous function as a string.",
            "lineno":800,
            "retgroups":[{
                "1":{
                  "text":"a function",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(lf)",
            "usage":["string_lambda '|x|x+1' (2) == 3\nstring_lambda '_+1' (2) == 3\n"],
            "type":"function",
            "name":"string_lambda",
            "params":{
              "map":{
                "lf":" function as a string"
              },
              "1":"lf"
            },
            "tags":[],
            "kind":"functional ",
            "section":"Functional",
            "description":" This string is either of the form\n '|args| expression' or is a function of one argument, '_'",
            "ret":["a function"],
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[[]],
              "see":[[]],
              "param":{
                "1":[],
                "2":[],
                "p":[],
                "fn":[]
              },
              "raise":[],
              "usage":[[]]
            },
            "summary":"bind the first argument of the function to a value.",
            "lineno":817,
            "retgroups":[{
                "1":{
                  "text":"a function such that f(x) is fn(p,x)",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(fn, p)",
            "usage":["local function f(msg, name)\n  print(msg .. \" \" .. name)\nend\n\nlocal hello = utils.bind1(f, \"Hello\")\n\nprint(hello(\"world\"))     --> \"Hello world\"\nprint(hello(\"sunshine\"))  --> \"Hello sunshine\"\n"],
            "raise":"same as @{function_arg}",
            "name":"bind1",
            "params":{
              "1":"fn",
              "2":"p",
              "map":{
                "p":" a value",
                "fn":" a function of at least two values (may be an operator string)"
              }
            },
            "tags":{
              "see":[]
            },
            "kind":"functional ",
            "section":"Functional",
            "type":"function",
            "parameter":"param",
            "ret":["a function such that f(x) is fn(p,x)"],
            "description":""
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[]],
              "param":{
                "1":[],
                "2":[],
                "p":[],
                "fn":[]
              },
              "raise":[],
              "return":[[]]
            },
            "summary":"bind the second argument of the function to a value.",
            "lineno":836,
            "retgroups":[{
                "1":{
                  "text":"a function such that f(x) is fn(x,p)",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(fn, p)",
            "usage":["local function f(a, b, c)\n  print(a .. \" \" .. b .. \" \" .. c)\nend\n\nlocal hello = utils.bind1(f, \"world\")\n\nprint(hello(\"Hello\", \"!\"))  --> \"Hello world !\"\nprint(hello(\"Bye\", \"?\"))    --> \"Bye world ?\"\n"],
            "raise":"same as @{function_arg}",
            "name":"bind2",
            "params":{
              "1":"fn",
              "2":"p",
              "map":{
                "p":" a value",
                "fn":" a function of at least two values (may be an operator string)"
              }
            },
            "tags":[],
            "kind":"functional ",
            "section":"Functional",
            "type":"function",
            "parameter":"param",
            "ret":["a function such that f(x) is fn(x,p)"],
            "description":""
          },{
            "name":"deprecation",
            "inferred":true,
            "description":"",
            "file":"<reference cycle>",
            "summary":"",
            "tags":[],
            "lineno":847,
            "display_name":"Deprecation",
            "type":"section",
            "modifiers":[]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":{
                "1":[],
                "func":[]
              },
              "usage":[[]],
              "see":[[]]
            },
            "summary":"Sets a deprecation warning function.",
            "lineno":875,
            "args":"(func)",
            "usage":["-- write to the Nginx logs with OpenResty\nutils.set_deprecation_func(function(msg, trace)\n  ngx.log(ngx.WARN, msg, (trace and (\" \" .. trace) or nil))\nend)\n\n-- disable deprecation warnings\nutils.set_deprecation_func()\n"],
            "section":"Deprecation",
            "name":"set_deprecation_func",
            "parameter":"param",
            "params":{
              "map":{
                "func":" a callback with signature: `function(msg, trace)` both arguments are strings, the latter being optional."
              },
              "1":"func"
            },
            "tags":{
              "see":[]
            },
            "kind":"deprecation ",
            "description":"\n An application can override this function to support proper output of\n deprecation warnings. The warnings can be generated from libraries or\n functions by calling `utils.raise_deprecation`. The default function\n will write to the 'warn' system (introduced in Lua 5.4, or the compatibility\n function from the `compat` module for earlier versions).\n\n Note: only applications should set/change this function, libraries should not.",
            "type":"function"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":{
                "1":[],
                "opts":[]
              },
              "usage":[[]],
              "see":[[]]
            },
            "summary":"raises a deprecation warning.",
            "lineno":907,
            "args":"(opts)",
            "usage":["warn(\"@on\")   -- enable Lua warnings, they are usually off by default\n\nfunction stringx.islower(str)\n  raise_deprecation {\n    source = \"Penlight \" .. utils._VERSION,                   -- optional\n    message = \"function 'islower' was renamed to 'is_lower'\", -- required\n    version_removed = \"2.0.0\",                                -- optional\n    deprecated_after = \"1.2.3\",                               -- optional\n    no_trace = true,                                          -- optional\n  }\n  return stringx.is_lower(str)\nend\n-- output: \"[Penlight 1.9.2] function 'islower' was renamed to 'is_lower' (deprecated after 1.2.3, scheduled for removal in 2.0.0)\"\n"],
            "section":"Deprecation",
            "name":"raise_deprecation",
            "parameter":"param",
            "params":{
              "map":{
                "opts":" options table"
              },
              "1":"opts"
            },
            "tags":{
              "see":[]
            },
            "kind":"deprecation ",
            "description":"\n For options see the usage example below.\n\n Note: the `opts.deprecated_after` field is the last version in which\n a feature or option was NOT YET deprecated! Because when writing the code it\n is quite often not known in what version the code will land. But the last\n released version is usually known.",
            "type":"function"
          }],
        "sections":[],
        "modules":["<reference cycle>"],
        "args":{
          "one":false,
          "module":false,
          "verbose":false,
          "style":"!",
          "template":"!",
          "date":"system",
          "dir":"doc",
          "quiet":false,
          "all":false,
          "ignore":false,
          "colon":false,
          "not_luadoc":false,
          "ext":"html",
          "boilerplate":false,
          "merge":false,
          "filter":"f.filter",
          "package":"/home/cji/portless/Penlight/lua",
          "dump":false,
          "no_args_infer":false,
          "title":"Reference",
          "project":"ldoc",
          "file":"/home/cji/portless/Penlight/lua/pl",
          "format":"discount",
          "simple":false,
          "tags":"none",
          "define":"none",
          "output":"index",
          "unqualified":false,
          "config":"config.ld",
          "fatalwarnings":false,
          "testing":false
        },
        "error":"<type 'function' is not supported by JSON.>",
        "lang":{
          "line_comment":"^%-%-+",
          "start_comment_":"^%-%-%-+",
          "end_comment_":"[^%-]%-%-+[^-]*\n$",
          "extra":[],
          "block_comment":"^%-%-%[=*%[%-+",
          "empty_comment_":"^%-%-%-+%s*$",
          "method_call":":"
        },
        "base":"/home/cji/portless/Penlight/lua"
      },
      "summary":"",
      "tags":[],
      "lineno":272,
      "display_name":"Error handling",
      "type":"section",
      "modifiers":[]
    },
    "2":{
      "name":"files",
      "inferred":true,
      "description":"",
      "file":{
        "warning":"<type 'function' is not supported by JSON.>",
        "filename":"/home/cji/portless/Penlight/lua/pl/utils.lua",
        "items":["<reference cycle>",{
            "inferred":true,
            "description":"",
            "modifiers":{
              "field":[],
              "return":[]
            },
            "summary":"Some standard patterns",
            "lineno":31,
            "args":"(FLOAT, INTEGER, IDEN, FILE)",
            "type":"table",
            "name":"patterns",
            "parameter":"field",
            "params":{
              "1":"FLOAT",
              "2":"INTEGER",
              "3":"IDEN",
              "4":"FILE",
              "map":{
                "FILE":"file",
                "INTEGER":"integer number",
                "IDEN":"identifier",
                "FLOAT":"floating point number"
              }
            },
            "tags":[],
            "kind":"tables",
            "section":"table",
            "subparams":[]
          },{
            "name":"stdmt",
            "section":"table",
            "inferred":true,
            "description":"",
            "kind":"tables",
            "summary":"Standard meta-tables as used by other Penlight modules",
            "params":{
              "1":"List",
              "2":"Map",
              "3":"Set",
              "4":"MultiMap",
              "map":{
                "Map":" the Map metatable",
                "Set":" the Set metatable",
                "MultiMap":" the MultiMap metatable",
                "List":" the List metatable"
              }
            },
            "tags":[],
            "lineno":45,
            "subparams":[],
            "args":"(List, Map, Set, MultiMap)",
            "parameter":"field",
            "type":"table",
            "modifiers":{
              "field":{
                "1":[],
                "2":[],
                "3":[],
                "4":[],
                "Map":[],
                "Set":[],
                "MultiMap":[],
                "List":[]
              },
              "return":[]
            }
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "param":{
                "1":[],
                "...":[]
              },
              "return":[[]],
              "see":[[],[],[]]
            },
            "summary":"pack an argument list into a table.",
            "lineno":60,
            "retgroups":[{
                "1":{
                  "text":"a table with field `n` set to the length",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(...)",
            "section":"function",
            "name":"pack",
            "params":{
              "map":{
                "...":" any arguments"
              },
              "1":"..."
            },
            "tags":{
              "see":[]
            },
            "kind":"functions",
            "description":"",
            "type":"function",
            "ret":["a table with field `n` set to the length"],
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[[]],
              "usage":[[]],
              "param":{
                "1":[],
                "2":{
                  "optchain":true,
                  "opt":true
                },
                "3":{
                  "optchain":true,
                  "opt":true
                },
                "t":[],
                "j":{
                  "optchain":true,
                  "opt":true
                },
                "i":{
                  "optchain":true,
                  "opt":true
                }
              },
              "see":[[],[],[]]
            },
            "summary":"unpack a table and return its contents.",
            "lineno":79,
            "retgroups":[{
                "1":{
                  "text":"multiple return values from the table",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(t[, i[, j]])",
            "usage":["local t = table.pack(nil, nil, nil, 4)\nlocal a, b, c, d = table.unpack(t)   -- this `unpack` is NOT nil-safe, so d == nil\n\nlocal a, b, c, d = utils.unpack(t)   -- this is nil-safe, so d == 4\n"],
            "type":"function",
            "name":"unpack",
            "params":{
              "1":"t",
              "2":"i",
              "map":{
                "t":" table to unpack",
                "j":" index of the last element to unpack, defaults to `t.n` or else `#t`",
                "i":" index from which to start unpacking, defaults to 1"
              },
              "3":"j"
            },
            "tags":{
              "see":[]
            },
            "kind":"functions",
            "section":"function",
            "description":"\n\n NOTE: this implementation differs from the Lua implementation in the way\n that this one DOES honor the `n` field in the table `t`, such that it is 'nil-safe'.",
            "ret":["multiple return values from the table"],
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":{
                "1":[],
                "2":[],
                "fmt":[],
                "...":[]
              }
            },
            "summary":"print an arbitrary number of arguments using a format.",
            "lineno":87,
            "args":"(fmt, ...)",
            "section":"function",
            "name":"printf",
            "params":{
              "1":"fmt",
              "2":"...",
              "map":{
                "fmt":" The format (see `string.format`)",
                "...":" Extra arguments for format"
              }
            },
            "tags":[],
            "kind":"functions",
            "description":"\n Output will be sent to `stdout`.",
            "type":"function",
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":{
                "1":[],
                "2":[],
                "3":[],
                "fmt":[],
                "f":[],
                "...":[]
              }
            },
            "summary":"write an arbitrary number of arguments to a file using a format.",
            "lineno":96,
            "args":"(f, fmt, ...)",
            "section":"function",
            "name":"fprintf",
            "params":{
              "1":"f",
              "2":"fmt",
              "map":{
                "fmt":" The format (see `string.format`).",
                "f":" File handle to write to.",
                "...":" Extra arguments for format"
              },
              "3":"..."
            },
            "tags":[],
            "kind":"functions",
            "description":"",
            "type":"function",
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":{
                "1":[],
                "2":[],
                "t":[],
                "T":[]
              }
            },
            "summary":"take a table and 'inject' it into the local namespace.",
            "lineno":124,
            "args":"(t, T)",
            "section":"function",
            "name":"import",
            "params":{
              "1":"t",
              "2":"T",
              "map":{
                "t":" The table (table), or module name (string), defaults to this `utils` module table",
                "T":" An optional destination table (defaults to callers environment)"
              }
            },
            "tags":[],
            "kind":"functions",
            "description":"",
            "type":"function",
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":{
                "1":[],
                "2":[],
                "3":[],
                "cond":[],
                "value1":[],
                "value2":[]
              }
            },
            "summary":"return either of two values, depending on a condition.",
            "lineno":143,
            "args":"(cond, value1, value2)",
            "section":"function",
            "name":"choose",
            "params":{
              "1":"cond",
              "2":"value1",
              "map":{
                "cond":" A condition",
                "value1":" Value returned if cond is truthy",
                "value2":" Value returned if cond is falsy"
              },
              "3":"value2"
            },
            "tags":[],
            "kind":"functions",
            "description":"",
            "type":"function",
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[[]],
              "param":{
                "1":[],
                "2":{
                  "optchain":true,
                  "opt":true
                },
                "3":{
                  "optchain":true,
                  "opt":true
                },
                "t":[],
                "temp":{
                  "optchain":true,
                  "opt":true
                },
                "tostr":{
                  "optchain":true,
                  "opt":true
                }
              }
            },
            "summary":"convert an array of values to strings.",
            "lineno":152,
            "retgroups":[{
                "1":{
                  "text":"the converted buffer",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(t[, temp[, tostr]])",
            "type":"function",
            "name":"array_tostring",
            "parameter":"param",
            "params":{
              "1":"t",
              "2":"temp",
              "map":{
                "t":" a list-like table",
                "temp":" (table) buffer to use, otherwise allocate",
                "tostr":" custom tostring function, called with (value,index). Defaults to `tostring`."
              },
              "3":"tostr"
            },
            "tags":[],
            "kind":"functions",
            "section":"function",
            "description":"",
            "ret":["the converted buffer"]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[]],
              "param":{
                "1":[],
                "2":[],
                "obj":[],
                "tp":[]
              },
              "return":[[]]
            },
            "summary":"is the object of the specified type?",
            "lineno":172,
            "retgroups":[{
                "1":{
                  "text":"boolean",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(obj, tp)",
            "usage":["utils.is_type(\"hello world\", \"string\")   --> true\n-- or check metatable\nlocal my_mt = {}\nlocal my_obj = setmetatable(my_obj, my_mt)\nutils.is_type(my_obj, my_mt)  --> true\n"],
            "type":"function",
            "name":"is_type",
            "parameter":"param",
            "params":{
              "1":"obj",
              "2":"tp",
              "map":{
                "obj":" An object to check",
                "tp":" String of what type it should be"
              }
            },
            "tags":[],
            "kind":"functions",
            "section":"function",
            "description":"\n If the type is a string, then use type, otherwise compare with metatable",
            "ret":["boolean"]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[]],
              "return":[{
                  "type":"integer"
                },{
                  "type":"any"
                }],
              "param":{
                "1":{
                  "type":"table"
                },
                "2":{
                  "opt":"1",
                  "type":"integer",
                  "optchain":"1"
                },
                "3":{
                  "opt":"t.n or #t",
                  "type":"integer",
                  "optchain":"t.n or #t"
                },
                "4":{
                  "opt":"1",
                  "type":"integer",
                  "optchain":"1"
                },
                "t":{
                  "type":"table"
                },
                "step":{
                  "opt":"1",
                  "type":"integer",
                  "optchain":"1"
                },
                "i_start":{
                  "opt":"1",
                  "type":"integer",
                  "optchain":"1"
                },
                "i_end":{
                  "opt":"t.n or #t",
                  "type":"integer",
                  "optchain":"t.n or #t"
                }
              },
              "see":[[],[]]
            },
            "summary":"an iterator with indices, similar to `ipairs`, but with a range.",
            "lineno":199,
            "retgroups":[{
                "1":{
                  "text":"index",
                  "type":"integer",
                  "mods":{
                    "type":"integer"
                  }
                },
                "2":{
                  "text":"value at index (which can be `nil`!)",
                  "type":"any",
                  "mods":{
                    "type":"any"
                  }
                },
                "g":0
              }],
            "args":"(t[, i_start=1[, i_end=t.n or #t[, step=1]]])",
            "usage":["local t = utils.pack(nil, 123, nil)  -- adds an `n` field when packing\n\nfor i, v in utils.npairs(t, 2) do  -- start at index 2\n  t[i] = tostring(t[i])\nend\n\n-- t = { n = 3, [2] = \"123\", [3] = \"nil\" }\n"],
            "type":"function",
            "name":"npairs",
            "parameter":"param",
            "params":{
              "1":"t",
              "2":"i_start",
              "3":"i_end",
              "4":"step",
              "map":{
                "t":" the table to iterate over",
                "step":" step size",
                "i_start":" start index",
                "i_end":" end index"
              }
            },
            "tags":{
              "see":[]
            },
            "kind":"functions",
            "section":"function",
            "description":"\n This is a nil-safe index based iterator that will return `nil` when there\n is a hole in a list. To be safe ensure that table `t.n` contains the length.",
            "ret":["index","value at index (which can be `nil`!)"]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[]],
              "param":{
                "1":{
                  "type":"table"
                },
                "t":{
                  "type":"table"
                }
              },
              "return":[{
                  "type":"key"
                },{
                  "type":"value"
                }]
            },
            "summary":"an iterator over all non-integer keys (inverse of `ipairs`).",
            "lineno":253,
            "retgroups":[{
                "1":{
                  "text":"",
                  "type":"key",
                  "mods":{
                    "type":"key"
                  }
                },
                "2":{
                  "text":"",
                  "type":"value",
                  "mods":{
                    "type":"value"
                  }
                },
                "g":0
              }],
            "args":"(t)",
            "usage":["local t = {\n  \"hello\",\n  \"world\",\n  hello = \"hallo\",\n  world = \"Welt\",\n}\n\nfor k, v in utils.kpairs(t) do\n  print(\"German: \", v)\nend\n\n-- output;\n-- German: hallo\n-- German: Welt\n"],
            "type":"function",
            "name":"kpairs",
            "parameter":"param",
            "params":{
              "map":{
                "t":" the table to iterate over"
              },
              "1":"t"
            },
            "tags":[],
            "kind":"functions",
            "section":"function",
            "description":"\n It will skip any key that is an integer number, so negative indices or an\n array with holes will not return those either (so it returns slightly less than\n 'the inverse of `ipairs`').\n\n This uses `pairs` under the hood, so any value that is iterable using `pairs`\n will work with this function.",
            "ret":["",""]
          },{
            "name":"Error-handling",
            "inferred":true,
            "description":"",
            "file":"<reference cycle>",
            "summary":"",
            "tags":[],
            "lineno":272,
            "display_name":"Error handling",
            "type":"section",
            "modifiers":[]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[]],
              "param":{
                "1":[],
                "2":[],
                "3":[],
                "4":[],
                "5":[],
                "6":[],
                "n":[],
                "verify":[],
                "val":[],
                "lev":[],
                "msg":[],
                "tp":[]
              },
              "raise":[],
              "return":[[]]
            },
            "summary":"assert that the given argument is in fact of the correct type.",
            "lineno":285,
            "retgroups":[{
                "1":{
                  "text":"the validated value",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(n, val, tp, verify, msg, lev)",
            "usage":["local param1 = assert_arg(1,\"hello\",'table')  --> error: argument 1 expected a 'table', got a 'string'\nlocal param4 = assert_arg(4,'!@#$%^&*','string',path.isdir,'not a directory')\n     --> error: argument 4: '!@#$%^&*' not a directory\n"],
            "raise":"if `val` is not the correct type",
            "name":"assert_arg",
            "params":{
              "1":"n",
              "2":"val",
              "3":"tp",
              "4":"verify",
              "5":"msg",
              "6":"lev",
              "map":{
                "n":" argument index",
                "verify":" an optional verification function",
                "val":" the value",
                "lev":" optional stack position for trace, default 2",
                "msg":" an optional custom message",
                "tp":" the type"
              }
            },
            "tags":[],
            "kind":"error handling ",
            "section":"Error handling",
            "type":"function",
            "parameter":"param",
            "ret":["the validated value"],
            "description":""
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[],[],[]],
              "param":{
                "1":{
                  "type":"table|vararg"
                },
                "...":{
                  "type":"table|vararg"
                }
              },
              "return":[[]]
            },
            "summary":"creates an Enum or constants lookup table for improved error handling.",
            "lineno":355,
            "retgroups":[{
                "1":{
                  "text":"Enum object (read-only table/object)",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(...)",
            "usage":["-- Enum access at runtime\nlocal obj = {}\nobj.MOVEMENT = utils.enum(\"FORWARD\", \"REVERSE\", \"LEFT\", \"RIGHT\")\n\nif current_movement == obj.MOVEMENT.FORWARD then\n  -- do something\n\nelseif current_movement == obj.MOVEMENT.REVERES then\n  -- throws error due to typo 'REVERES', so a silent mistake becomes a hard error\n  -- \"'REVERES' is not a valid value (expected one of: 'FORWARD', 'REVERSE', 'LEFT', 'RIGHT')\"\n\nend\n","-- standardized error codes\nlocal obj = {\n  ERR = utils.enum {\n    NOT_FOUND = \"the item was not found\",\n    OUT_OF_BOUNDS = \"the index is outside the allowed range\"\n  },\n\n  some_method = function(self)\n    return self.ERR.OUT_OF_BOUNDS\n  end,\n}\n\nlocal result, err = obj:some_method()\nif not result then\n  if err == obj.ERR.NOT_FOUND then\n    -- check on error code, not magic strings\n\n  else\n    -- return the error description, contained in the constant\n    return nil, \"error: \"..err  -- \"error: the index is outside the allowed range\"\n  end\nend\n","-- validating/converting user-input\nlocal color = \"purple\"\nlocal ansi_colors = utils.enum {\n  black     = 30,\n  red       = 31,\n  green     = 32,\n}\nlocal color_code, err = ansi_colors(color) -- calling on the object, returns the value from the enum\nif not color_code then\n  print(\"bad 'color', \" .. err)\n  -- \"bad 'color', 'purple' is not a valid value (expected one of: 'black', 'red', 'green')\"\n  os.exit(1)\nend\n"],
            "type":"function",
            "name":"enum",
            "parameter":"param",
            "params":{
              "map":{
                "...":" the input for the Enum. If varargs or an array then the\n values in the Enum will be equal to the names (must be strings), if a hash-table\n then values remain (any type), and the keys must be strings."
              },
              "1":"..."
            },
            "tags":[],
            "kind":"error handling ",
            "section":"Error handling",
            "description":"\n This helps prevent magic strings in code by throwing errors for accessing\n non-existing values, and/or converting strings/identifiers to other values.\n\n Calling on the object does the same, but returns a soft error; `nil + err`, if\n the call is succesful (the key exists), it will return the value.\n\n When calling with varargs or an array the values will be equal to the keys.\n The enum object is read-only.",
            "ret":["Enum object (read-only table/object)"]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "param":{
                "1":[],
                "2":[],
                "3":[],
                "f":[],
                "msg":[],
                "idx":[]
              },
              "raise":[],
              "return":[[]]
            },
            "summary":"process a function argument.",
            "lineno":430,
            "retgroups":[{
                "1":{
                  "text":"a callable",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(idx, f, msg)",
            "type":"function",
            "name":"function_arg",
            "params":{
              "1":"idx",
              "2":"f",
              "map":{
                "f":" a function, operator string, or callable object",
                "msg":" optional error message",
                "idx":" argument index"
              },
              "3":"msg"
            },
            "tags":[],
            "kind":"error handling ",
            "section":"Error handling",
            "description":"\n This is used throughout Penlight and defines what is meant by a function:\n Something that is callable, or an operator string as defined by <code>pl.operator</code>,\n such as '>' or '#'. If a function factory has been registered for the type, it will\n be called to get the function.",
            "raise":"if idx is not a number or if f is not callable",
            "ret":["a callable"],
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[]],
              "param":{
                "1":[],
                "2":[],
                "val":[],
                "n":[]
              },
              "raise":[],
              "return":[[]]
            },
            "summary":"assert the common case that the argument is a string.",
            "lineno":470,
            "retgroups":[{
                "1":{
                  "text":"the validated value",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(n, val)",
            "usage":["local val = 42\nlocal param2 = utils.assert_string(2, val) --> error: argument 2 expected a 'string', got a 'number'\n"],
            "raise":"val must be a string",
            "name":"assert_string",
            "params":{
              "1":"n",
              "2":"val",
              "map":{
                "val":" a value that must be a string",
                "n":" argument index"
              }
            },
            "tags":[],
            "kind":"error handling ",
            "section":"Error handling",
            "type":"function",
            "parameter":"param",
            "ret":["the validated value"],
            "description":""
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "param":{
                "1":[],
                "mode":[]
              },
              "return":[],
              "see":[[]]
            },
            "summary":"control the error strategy used by Penlight.",
            "lineno":483,
            "args":"(mode)",
            "section":"Error handling",
            "name":"on_error",
            "params":{
              "map":{
                "mode":" either 'default', 'quit'  or 'error'"
              },
              "1":"mode"
            },
            "tags":{
              "see":[]
            },
            "kind":"error handling ",
            "description":"\n This is a global setting that controls how `utils.raise` behaves:\n\n - 'default': return `nil + error` (this is the default)\n - 'error': throw a Lua error\n - 'quit': exit the program\n",
            "type":"function",
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":{
                "1":[],
                "err":[]
              },
              "usage":[[]],
              "see":[[]]
            },
            "summary":"used by Penlight functions to return errors.",
            "lineno":507,
            "args":"(err)",
            "usage":["if some_condition then\n  return utils.raise(\"some condition was not met\")  -- MUST use 'return'!\nend\n"],
            "section":"Error handling",
            "name":"raise",
            "parameter":"param",
            "params":{
              "map":{
                "err":" the error string."
              },
              "1":"err"
            },
            "tags":{
              "see":[]
            },
            "kind":"error handling ",
            "description":" Its global behaviour is controlled\n by `utils.on_error`.\n To use this function you MUST use it in conjunction with `return`, since it might\n return `nil + error`.",
            "type":"function"
          },"<reference cycle>",{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[[]],
              "param":{
                "1":[],
                "2":[],
                "filename":[],
                "is_bin":[]
              }
            },
            "summary":"return the contents of a file as a string",
            "lineno":527,
            "retgroups":[{
                "1":{
                  "text":"file contents",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(filename, is_bin)",
            "type":"function",
            "name":"readfile",
            "parameter":"param",
            "params":{
              "1":"filename",
              "2":"is_bin",
              "map":{
                "filename":" The file path",
                "is_bin":" open in binary mode"
              }
            },
            "tags":[],
            "kind":"file handling ",
            "section":"File handling",
            "description":"",
            "ret":["file contents"]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "param":{
                "1":[],
                "2":[],
                "3":[],
                "filename":[],
                "str":[],
                "is_bin":[]
              },
              "raise":[],
              "return":[[],[]]
            },
            "summary":"write a string to a file",
            "lineno":549,
            "retgroups":[{
                "1":{
                  "text":"true or nil",
                  "type":"",
                  "mods":[]
                },
                "2":{
                  "text":"error message",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(filename, str, is_bin)",
            "type":"function",
            "name":"writefile",
            "params":{
              "1":"filename",
              "2":"str",
              "map":{
                "filename":" The file path",
                "str":" The string",
                "is_bin":" open in binary mode"
              },
              "3":"is_bin"
            },
            "tags":[],
            "kind":"file handling ",
            "section":"File handling",
            "description":"",
            "raise":"error if filename or str aren't strings",
            "ret":["true or nil","error message"],
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "param":{
                "1":[],
                "filename":[]
              },
              "raise":[],
              "return":[[]]
            },
            "summary":"return the contents of a file as a list of lines",
            "lineno":569,
            "retgroups":[{
                "1":{
                  "text":"file contents as a table",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(filename)",
            "type":"function",
            "name":"readlines",
            "params":{
              "map":{
                "filename":" The file path"
              },
              "1":"filename"
            },
            "tags":[],
            "kind":"file handling ",
            "section":"File handling",
            "description":"",
            "raise":"error if filename is not a string",
            "ret":["file contents as a table"],
            "parameter":"param"
          },{
            "name":"OS-functions",
            "inferred":true,
            "description":"",
            "file":"<reference cycle>",
            "summary":"",
            "tags":[],
            "lineno":584,
            "display_name":"OS functions",
            "type":"section",
            "modifiers":[]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[[],[],[],[]],
              "param":{
                "1":[],
                "2":[],
                "bin":[],
                "cmd":[]
              }
            },
            "summary":"execute a shell command and return the output.",
            "lineno":592,
            "retgroups":[{
                "1":{
                  "text":"true if successful",
                  "type":"",
                  "mods":[]
                },
                "2":{
                  "text":"actual return code",
                  "type":"",
                  "mods":[]
                },
                "3":{
                  "text":"stdout output (string)",
                  "type":"",
                  "mods":[]
                },
                "4":{
                  "text":"errout output (string)",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(cmd, bin)",
            "type":"function",
            "name":"executeex",
            "parameter":"param",
            "params":{
              "1":"cmd",
              "2":"bin",
              "map":{
                "bin":" boolean, if true, read output as binary file",
                "cmd":" a shell command"
              }
            },
            "tags":[],
            "kind":"os functions ",
            "section":"OS functions",
            "description":"\n This function redirects the output to tempfiles and returns the content of those files.",
            "ret":["true if successful","actual return code","stdout output (string)","errout output (string)"]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[]],
              "param":{
                "1":[],
                "argument":[]
              },
              "return":[[]]
            },
            "summary":"Quote and escape an argument of a command.",
            "lineno":623,
            "retgroups":[{
                "1":{
                  "text":"quoted and escaped argument.",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(argument)",
            "usage":["local options = utils.quote_arg {\n    \"-lluacov\",\n    \"-e\",\n    \"utils = print(require('pl.utils')._VERSION\",\n}\n-- returns: -lluacov -e 'utils = print(require('\\''pl.utils'\\'')._VERSION'\n"],
            "type":"function",
            "name":"quote_arg",
            "parameter":"param",
            "params":{
              "map":{
                "argument":" (string or table/list) the argument to quote. If a list then\n all arguments in the list will be returned as a single string quoted."
              },
              "1":"argument"
            },
            "tags":[],
            "kind":"os functions ",
            "section":"OS functions",
            "description":"\n Quotes a single (or list of) argument(s) of a command to be passed\n to `os.execute`, `pl.utils.execute` or `pl.utils.executeex`.",
            "ret":["quoted and escaped argument."]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":{
                "1":{
                  "opt":true
                },
                "2":[],
                "3":[],
                "msg":[],
                "...":[],
                "code":{
                  "opt":true
                }
              },
              "usage":[[]],
              "see":[[]]
            },
            "summary":"error out of this program gracefully.",
            "lineno":667,
            "args":"([code], msg, ...)",
            "usage":["utils.quit(-1, \"Error '%s' happened\", \"42\")\n-- is equivalent to\nutils.quit(\"Error '%s' happened\", \"42\")  --> Error '42' happened\n"],
            "section":"OS functions",
            "name":"quit",
            "parameter":"param",
            "params":{
              "1":"code",
              "2":"msg",
              "map":{
                "msg":" The exit message will be sent to `stderr` (will be formatted with the extra parameters)",
                "...":" extra arguments for message's format'",
                "code":" The exit code, defaults to -`1` if omitted"
              },
              "3":"..."
            },
            "tags":{
              "see":[]
            },
            "kind":"os functions ",
            "description":"",
            "type":"function"
          },{
            "name":"string-functions",
            "inferred":true,
            "description":"",
            "file":"<reference cycle>",
            "summary":"",
            "tags":[],
            "lineno":683,
            "display_name":"String functions",
            "type":"section",
            "modifiers":[]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":{
                "1":[],
                "s":[]
              }
            },
            "summary":"escape any Lua 'magic' characters in a string",
            "lineno":685,
            "args":"(s)",
            "section":"String functions",
            "name":"escape",
            "params":{
              "map":{
                "s":" The input string"
              },
              "1":"s"
            },
            "tags":[],
            "kind":"string functions ",
            "description":"",
            "type":"function",
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "param":{
                "1":[],
                "2":[],
                "3":[],
                "4":[],
                "re":[],
                "n":[],
                "s":[],
                "plain":[]
              },
              "return":[[]],
              "raise":[],
              "see":[[]]
            },
            "summary":"split a string into a list of strings separated by a delimiter.",
            "lineno":698,
            "retgroups":[{
                "1":{
                  "text":"a list-like table",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s, re, plain, n)",
            "type":"function",
            "name":"split",
            "params":{
              "1":"s",
              "2":"re",
              "3":"plain",
              "4":"n",
              "map":{
                "re":" optional A Lua string pattern; defaults to '%s+'",
                "n":" optional maximum number of elements (if there are more, the last will remian un-split)",
                "s":" The input string",
                "plain":" optional If truthy don't use Lua patterns"
              }
            },
            "tags":{
              "see":[]
            },
            "kind":"string functions ",
            "section":"String functions",
            "description":"",
            "raise":"error if s is not a string",
            "ret":["a list-like table"],
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "param":{
                "1":[],
                "2":[],
                "3":[],
                "4":[],
                "re":[],
                "n":[],
                "s":[],
                "plain":[]
              },
              "return":[[]],
              "usage":[[]],
              "see":[[]]
            },
            "summary":"split a string into a number of return values.",
            "lineno":735,
            "retgroups":[{
                "1":{
                  "text":"n values",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s, re, plain, n)",
            "usage":["first,next = splitv('user=jane=doe','=', false, 2)\nassert(first == \"user\")\nassert(next == \"jane=doe\")\n"],
            "type":"function",
            "name":"splitv",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"re",
              "3":"plain",
              "4":"n",
              "map":{
                "re":" A Lua string pattern; defaults to '%s+'",
                "n":" optional maximum number of splits",
                "s":" the string",
                "plain":" don't use Lua patterns"
              }
            },
            "tags":{
              "see":[]
            },
            "kind":"string functions ",
            "section":"String functions",
            "description":"\n Identical to `split` but returns multiple sub-strings instead of\n a single list of sub-strings.",
            "ret":["n values"]
          },{
            "name":"functional",
            "inferred":true,
            "description":"",
            "file":"<reference cycle>",
            "summary":"",
            "tags":[],
            "lineno":744,
            "display_name":"Functional",
            "type":"section",
            "modifiers":[]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[[]],
              "param":{
                "1":[],
                "func":[]
              }
            },
            "summary":"'memoize' a function (cache returned value for next call).",
            "lineno":750,
            "retgroups":[{
                "1":{
                  "text":"a function with at least one argument, which is used as the key.",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(func)",
            "type":"function",
            "name":"memoize",
            "parameter":"param",
            "params":{
              "map":{
                "func":" a function of at least one argument"
              },
              "1":"func"
            },
            "tags":[],
            "kind":"functional ",
            "section":"Functional",
            "description":"\n This is useful if you have a function which is relatively expensive,\n but you don't know in advance what values will be required, so\n building a table upfront is wasteful/impossible.",
            "ret":["a function with at least one argument, which is used as the key."]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":{
                "1":{
                  "type":"tab"
                },
                "2":{
                  "type":"func"
                },
                "fun":{
                  "type":"func"
                },
                "mt":{
                  "type":"tab"
                }
              }
            },
            "summary":"associate a function factory with a type.",
            "lineno":768,
            "args":"(mt, fun)",
            "section":"Functional",
            "name":"add_function_factory",
            "params":{
              "1":"mt",
              "2":"fun",
              "map":{
                "fun":" a callable that returns a function",
                "mt":" metatable"
              }
            },
            "tags":[],
            "kind":"functional ",
            "description":"\n A function factory takes an object of the given type and\n returns a function for evaluating it",
            "type":"function",
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "param":{
                "1":[],
                "lf":[]
              },
              "return":[[]],
              "usage":[[]]
            },
            "summary":"an anonymous function as a string.",
            "lineno":800,
            "retgroups":[{
                "1":{
                  "text":"a function",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(lf)",
            "usage":["string_lambda '|x|x+1' (2) == 3\nstring_lambda '_+1' (2) == 3\n"],
            "type":"function",
            "name":"string_lambda",
            "params":{
              "map":{
                "lf":" function as a string"
              },
              "1":"lf"
            },
            "tags":[],
            "kind":"functional ",
            "section":"Functional",
            "description":" This string is either of the form\n '|args| expression' or is a function of one argument, '_'",
            "ret":["a function"],
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[[]],
              "see":[[]],
              "param":{
                "1":[],
                "2":[],
                "p":[],
                "fn":[]
              },
              "raise":[],
              "usage":[[]]
            },
            "summary":"bind the first argument of the function to a value.",
            "lineno":817,
            "retgroups":[{
                "1":{
                  "text":"a function such that f(x) is fn(p,x)",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(fn, p)",
            "usage":["local function f(msg, name)\n  print(msg .. \" \" .. name)\nend\n\nlocal hello = utils.bind1(f, \"Hello\")\n\nprint(hello(\"world\"))     --> \"Hello world\"\nprint(hello(\"sunshine\"))  --> \"Hello sunshine\"\n"],
            "raise":"same as @{function_arg}",
            "name":"bind1",
            "params":{
              "1":"fn",
              "2":"p",
              "map":{
                "p":" a value",
                "fn":" a function of at least two values (may be an operator string)"
              }
            },
            "tags":{
              "see":[]
            },
            "kind":"functional ",
            "section":"Functional",
            "type":"function",
            "parameter":"param",
            "ret":["a function such that f(x) is fn(p,x)"],
            "description":""
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[]],
              "param":{
                "1":[],
                "2":[],
                "p":[],
                "fn":[]
              },
              "raise":[],
              "return":[[]]
            },
            "summary":"bind the second argument of the function to a value.",
            "lineno":836,
            "retgroups":[{
                "1":{
                  "text":"a function such that f(x) is fn(x,p)",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(fn, p)",
            "usage":["local function f(a, b, c)\n  print(a .. \" \" .. b .. \" \" .. c)\nend\n\nlocal hello = utils.bind1(f, \"world\")\n\nprint(hello(\"Hello\", \"!\"))  --> \"Hello world !\"\nprint(hello(\"Bye\", \"?\"))    --> \"Bye world ?\"\n"],
            "raise":"same as @{function_arg}",
            "name":"bind2",
            "params":{
              "1":"fn",
              "2":"p",
              "map":{
                "p":" a value",
                "fn":" a function of at least two values (may be an operator string)"
              }
            },
            "tags":[],
            "kind":"functional ",
            "section":"Functional",
            "type":"function",
            "parameter":"param",
            "ret":["a function such that f(x) is fn(x,p)"],
            "description":""
          },{
            "name":"deprecation",
            "inferred":true,
            "description":"",
            "file":"<reference cycle>",
            "summary":"",
            "tags":[],
            "lineno":847,
            "display_name":"Deprecation",
            "type":"section",
            "modifiers":[]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":{
                "1":[],
                "func":[]
              },
              "usage":[[]],
              "see":[[]]
            },
            "summary":"Sets a deprecation warning function.",
            "lineno":875,
            "args":"(func)",
            "usage":["-- write to the Nginx logs with OpenResty\nutils.set_deprecation_func(function(msg, trace)\n  ngx.log(ngx.WARN, msg, (trace and (\" \" .. trace) or nil))\nend)\n\n-- disable deprecation warnings\nutils.set_deprecation_func()\n"],
            "section":"Deprecation",
            "name":"set_deprecation_func",
            "parameter":"param",
            "params":{
              "map":{
                "func":" a callback with signature: `function(msg, trace)` both arguments are strings, the latter being optional."
              },
              "1":"func"
            },
            "tags":{
              "see":[]
            },
            "kind":"deprecation ",
            "description":"\n An application can override this function to support proper output of\n deprecation warnings. The warnings can be generated from libraries or\n functions by calling `utils.raise_deprecation`. The default function\n will write to the 'warn' system (introduced in Lua 5.4, or the compatibility\n function from the `compat` module for earlier versions).\n\n Note: only applications should set/change this function, libraries should not.",
            "type":"function"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":{
                "1":[],
                "opts":[]
              },
              "usage":[[]],
              "see":[[]]
            },
            "summary":"raises a deprecation warning.",
            "lineno":907,
            "args":"(opts)",
            "usage":["warn(\"@on\")   -- enable Lua warnings, they are usually off by default\n\nfunction stringx.islower(str)\n  raise_deprecation {\n    source = \"Penlight \" .. utils._VERSION,                   -- optional\n    message = \"function 'islower' was renamed to 'is_lower'\", -- required\n    version_removed = \"2.0.0\",                                -- optional\n    deprecated_after = \"1.2.3\",                               -- optional\n    no_trace = true,                                          -- optional\n  }\n  return stringx.is_lower(str)\nend\n-- output: \"[Penlight 1.9.2] function 'islower' was renamed to 'is_lower' (deprecated after 1.2.3, scheduled for removal in 2.0.0)\"\n"],
            "section":"Deprecation",
            "name":"raise_deprecation",
            "parameter":"param",
            "params":{
              "map":{
                "opts":" options table"
              },
              "1":"opts"
            },
            "tags":{
              "see":[]
            },
            "kind":"deprecation ",
            "description":"\n For options see the usage example below.\n\n Note: the `opts.deprecated_after` field is the last version in which\n a feature or option was NOT YET deprecated! Because when writing the code it\n is quite often not known in what version the code will land. But the last\n released version is usually known.",
            "type":"function"
          }],
        "sections":[],
        "modules":["<reference cycle>"],
        "args":{
          "one":false,
          "module":false,
          "verbose":false,
          "style":"!",
          "template":"!",
          "date":"system",
          "dir":"doc",
          "quiet":false,
          "all":false,
          "ignore":false,
          "colon":false,
          "not_luadoc":false,
          "ext":"html",
          "boilerplate":false,
          "merge":false,
          "filter":"f.filter",
          "package":"/home/cji/portless/Penlight/lua",
          "dump":false,
          "no_args_infer":false,
          "title":"Reference",
          "project":"ldoc",
          "file":"/home/cji/portless/Penlight/lua/pl",
          "format":"discount",
          "simple":false,
          "tags":"none",
          "define":"none",
          "output":"index",
          "unqualified":false,
          "config":"config.ld",
          "fatalwarnings":false,
          "testing":false
        },
        "error":"<type 'function' is not supported by JSON.>",
        "lang":{
          "line_comment":"^%-%-+",
          "start_comment_":"^%-%-%-+",
          "end_comment_":"[^%-]%-%-+[^-]*\n$",
          "extra":[],
          "block_comment":"^%-%-%[=*%[%-+",
          "empty_comment_":"^%-%-%-+%s*$",
          "method_call":":"
        },
        "base":"/home/cji/portless/Penlight/lua"
      },
      "summary":"",
      "tags":[],
      "lineno":523,
      "display_name":"File handling",
      "type":"section",
      "modifiers":[]
    },
    "3":{
      "name":"OS-functions",
      "inferred":true,
      "description":"",
      "file":{
        "warning":"<type 'function' is not supported by JSON.>",
        "filename":"/home/cji/portless/Penlight/lua/pl/utils.lua",
        "items":["<reference cycle>",{
            "inferred":true,
            "description":"",
            "modifiers":{
              "field":[],
              "return":[]
            },
            "summary":"Some standard patterns",
            "lineno":31,
            "args":"(FLOAT, INTEGER, IDEN, FILE)",
            "type":"table",
            "name":"patterns",
            "parameter":"field",
            "params":{
              "1":"FLOAT",
              "2":"INTEGER",
              "3":"IDEN",
              "4":"FILE",
              "map":{
                "FILE":"file",
                "INTEGER":"integer number",
                "IDEN":"identifier",
                "FLOAT":"floating point number"
              }
            },
            "tags":[],
            "kind":"tables",
            "section":"table",
            "subparams":[]
          },{
            "name":"stdmt",
            "section":"table",
            "inferred":true,
            "description":"",
            "kind":"tables",
            "summary":"Standard meta-tables as used by other Penlight modules",
            "params":{
              "1":"List",
              "2":"Map",
              "3":"Set",
              "4":"MultiMap",
              "map":{
                "Map":" the Map metatable",
                "Set":" the Set metatable",
                "MultiMap":" the MultiMap metatable",
                "List":" the List metatable"
              }
            },
            "tags":[],
            "lineno":45,
            "subparams":[],
            "args":"(List, Map, Set, MultiMap)",
            "parameter":"field",
            "type":"table",
            "modifiers":{
              "field":{
                "1":[],
                "2":[],
                "3":[],
                "4":[],
                "Map":[],
                "Set":[],
                "MultiMap":[],
                "List":[]
              },
              "return":[]
            }
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "param":{
                "1":[],
                "...":[]
              },
              "return":[[]],
              "see":[[],[],[]]
            },
            "summary":"pack an argument list into a table.",
            "lineno":60,
            "retgroups":[{
                "1":{
                  "text":"a table with field `n` set to the length",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(...)",
            "section":"function",
            "name":"pack",
            "params":{
              "map":{
                "...":" any arguments"
              },
              "1":"..."
            },
            "tags":{
              "see":[]
            },
            "kind":"functions",
            "description":"",
            "type":"function",
            "ret":["a table with field `n` set to the length"],
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[[]],
              "usage":[[]],
              "param":{
                "1":[],
                "2":{
                  "optchain":true,
                  "opt":true
                },
                "3":{
                  "optchain":true,
                  "opt":true
                },
                "t":[],
                "j":{
                  "optchain":true,
                  "opt":true
                },
                "i":{
                  "optchain":true,
                  "opt":true
                }
              },
              "see":[[],[],[]]
            },
            "summary":"unpack a table and return its contents.",
            "lineno":79,
            "retgroups":[{
                "1":{
                  "text":"multiple return values from the table",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(t[, i[, j]])",
            "usage":["local t = table.pack(nil, nil, nil, 4)\nlocal a, b, c, d = table.unpack(t)   -- this `unpack` is NOT nil-safe, so d == nil\n\nlocal a, b, c, d = utils.unpack(t)   -- this is nil-safe, so d == 4\n"],
            "type":"function",
            "name":"unpack",
            "params":{
              "1":"t",
              "2":"i",
              "map":{
                "t":" table to unpack",
                "j":" index of the last element to unpack, defaults to `t.n` or else `#t`",
                "i":" index from which to start unpacking, defaults to 1"
              },
              "3":"j"
            },
            "tags":{
              "see":[]
            },
            "kind":"functions",
            "section":"function",
            "description":"\n\n NOTE: this implementation differs from the Lua implementation in the way\n that this one DOES honor the `n` field in the table `t`, such that it is 'nil-safe'.",
            "ret":["multiple return values from the table"],
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":{
                "1":[],
                "2":[],
                "fmt":[],
                "...":[]
              }
            },
            "summary":"print an arbitrary number of arguments using a format.",
            "lineno":87,
            "args":"(fmt, ...)",
            "section":"function",
            "name":"printf",
            "params":{
              "1":"fmt",
              "2":"...",
              "map":{
                "fmt":" The format (see `string.format`)",
                "...":" Extra arguments for format"
              }
            },
            "tags":[],
            "kind":"functions",
            "description":"\n Output will be sent to `stdout`.",
            "type":"function",
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":{
                "1":[],
                "2":[],
                "3":[],
                "fmt":[],
                "f":[],
                "...":[]
              }
            },
            "summary":"write an arbitrary number of arguments to a file using a format.",
            "lineno":96,
            "args":"(f, fmt, ...)",
            "section":"function",
            "name":"fprintf",
            "params":{
              "1":"f",
              "2":"fmt",
              "map":{
                "fmt":" The format (see `string.format`).",
                "f":" File handle to write to.",
                "...":" Extra arguments for format"
              },
              "3":"..."
            },
            "tags":[],
            "kind":"functions",
            "description":"",
            "type":"function",
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":{
                "1":[],
                "2":[],
                "t":[],
                "T":[]
              }
            },
            "summary":"take a table and 'inject' it into the local namespace.",
            "lineno":124,
            "args":"(t, T)",
            "section":"function",
            "name":"import",
            "params":{
              "1":"t",
              "2":"T",
              "map":{
                "t":" The table (table), or module name (string), defaults to this `utils` module table",
                "T":" An optional destination table (defaults to callers environment)"
              }
            },
            "tags":[],
            "kind":"functions",
            "description":"",
            "type":"function",
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":{
                "1":[],
                "2":[],
                "3":[],
                "cond":[],
                "value1":[],
                "value2":[]
              }
            },
            "summary":"return either of two values, depending on a condition.",
            "lineno":143,
            "args":"(cond, value1, value2)",
            "section":"function",
            "name":"choose",
            "params":{
              "1":"cond",
              "2":"value1",
              "map":{
                "cond":" A condition",
                "value1":" Value returned if cond is truthy",
                "value2":" Value returned if cond is falsy"
              },
              "3":"value2"
            },
            "tags":[],
            "kind":"functions",
            "description":"",
            "type":"function",
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[[]],
              "param":{
                "1":[],
                "2":{
                  "optchain":true,
                  "opt":true
                },
                "3":{
                  "optchain":true,
                  "opt":true
                },
                "t":[],
                "temp":{
                  "optchain":true,
                  "opt":true
                },
                "tostr":{
                  "optchain":true,
                  "opt":true
                }
              }
            },
            "summary":"convert an array of values to strings.",
            "lineno":152,
            "retgroups":[{
                "1":{
                  "text":"the converted buffer",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(t[, temp[, tostr]])",
            "type":"function",
            "name":"array_tostring",
            "parameter":"param",
            "params":{
              "1":"t",
              "2":"temp",
              "map":{
                "t":" a list-like table",
                "temp":" (table) buffer to use, otherwise allocate",
                "tostr":" custom tostring function, called with (value,index). Defaults to `tostring`."
              },
              "3":"tostr"
            },
            "tags":[],
            "kind":"functions",
            "section":"function",
            "description":"",
            "ret":["the converted buffer"]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[]],
              "param":{
                "1":[],
                "2":[],
                "obj":[],
                "tp":[]
              },
              "return":[[]]
            },
            "summary":"is the object of the specified type?",
            "lineno":172,
            "retgroups":[{
                "1":{
                  "text":"boolean",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(obj, tp)",
            "usage":["utils.is_type(\"hello world\", \"string\")   --> true\n-- or check metatable\nlocal my_mt = {}\nlocal my_obj = setmetatable(my_obj, my_mt)\nutils.is_type(my_obj, my_mt)  --> true\n"],
            "type":"function",
            "name":"is_type",
            "parameter":"param",
            "params":{
              "1":"obj",
              "2":"tp",
              "map":{
                "obj":" An object to check",
                "tp":" String of what type it should be"
              }
            },
            "tags":[],
            "kind":"functions",
            "section":"function",
            "description":"\n If the type is a string, then use type, otherwise compare with metatable",
            "ret":["boolean"]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[]],
              "return":[{
                  "type":"integer"
                },{
                  "type":"any"
                }],
              "param":{
                "1":{
                  "type":"table"
                },
                "2":{
                  "opt":"1",
                  "type":"integer",
                  "optchain":"1"
                },
                "3":{
                  "opt":"t.n or #t",
                  "type":"integer",
                  "optchain":"t.n or #t"
                },
                "4":{
                  "opt":"1",
                  "type":"integer",
                  "optchain":"1"
                },
                "t":{
                  "type":"table"
                },
                "step":{
                  "opt":"1",
                  "type":"integer",
                  "optchain":"1"
                },
                "i_start":{
                  "opt":"1",
                  "type":"integer",
                  "optchain":"1"
                },
                "i_end":{
                  "opt":"t.n or #t",
                  "type":"integer",
                  "optchain":"t.n or #t"
                }
              },
              "see":[[],[]]
            },
            "summary":"an iterator with indices, similar to `ipairs`, but with a range.",
            "lineno":199,
            "retgroups":[{
                "1":{
                  "text":"index",
                  "type":"integer",
                  "mods":{
                    "type":"integer"
                  }
                },
                "2":{
                  "text":"value at index (which can be `nil`!)",
                  "type":"any",
                  "mods":{
                    "type":"any"
                  }
                },
                "g":0
              }],
            "args":"(t[, i_start=1[, i_end=t.n or #t[, step=1]]])",
            "usage":["local t = utils.pack(nil, 123, nil)  -- adds an `n` field when packing\n\nfor i, v in utils.npairs(t, 2) do  -- start at index 2\n  t[i] = tostring(t[i])\nend\n\n-- t = { n = 3, [2] = \"123\", [3] = \"nil\" }\n"],
            "type":"function",
            "name":"npairs",
            "parameter":"param",
            "params":{
              "1":"t",
              "2":"i_start",
              "3":"i_end",
              "4":"step",
              "map":{
                "t":" the table to iterate over",
                "step":" step size",
                "i_start":" start index",
                "i_end":" end index"
              }
            },
            "tags":{
              "see":[]
            },
            "kind":"functions",
            "section":"function",
            "description":"\n This is a nil-safe index based iterator that will return `nil` when there\n is a hole in a list. To be safe ensure that table `t.n` contains the length.",
            "ret":["index","value at index (which can be `nil`!)"]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[]],
              "param":{
                "1":{
                  "type":"table"
                },
                "t":{
                  "type":"table"
                }
              },
              "return":[{
                  "type":"key"
                },{
                  "type":"value"
                }]
            },
            "summary":"an iterator over all non-integer keys (inverse of `ipairs`).",
            "lineno":253,
            "retgroups":[{
                "1":{
                  "text":"",
                  "type":"key",
                  "mods":{
                    "type":"key"
                  }
                },
                "2":{
                  "text":"",
                  "type":"value",
                  "mods":{
                    "type":"value"
                  }
                },
                "g":0
              }],
            "args":"(t)",
            "usage":["local t = {\n  \"hello\",\n  \"world\",\n  hello = \"hallo\",\n  world = \"Welt\",\n}\n\nfor k, v in utils.kpairs(t) do\n  print(\"German: \", v)\nend\n\n-- output;\n-- German: hallo\n-- German: Welt\n"],
            "type":"function",
            "name":"kpairs",
            "parameter":"param",
            "params":{
              "map":{
                "t":" the table to iterate over"
              },
              "1":"t"
            },
            "tags":[],
            "kind":"functions",
            "section":"function",
            "description":"\n It will skip any key that is an integer number, so negative indices or an\n array with holes will not return those either (so it returns slightly less than\n 'the inverse of `ipairs`').\n\n This uses `pairs` under the hood, so any value that is iterable using `pairs`\n will work with this function.",
            "ret":["",""]
          },{
            "name":"Error-handling",
            "inferred":true,
            "description":"",
            "file":"<reference cycle>",
            "summary":"",
            "tags":[],
            "lineno":272,
            "display_name":"Error handling",
            "type":"section",
            "modifiers":[]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[]],
              "param":{
                "1":[],
                "2":[],
                "3":[],
                "4":[],
                "5":[],
                "6":[],
                "n":[],
                "verify":[],
                "val":[],
                "lev":[],
                "msg":[],
                "tp":[]
              },
              "raise":[],
              "return":[[]]
            },
            "summary":"assert that the given argument is in fact of the correct type.",
            "lineno":285,
            "retgroups":[{
                "1":{
                  "text":"the validated value",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(n, val, tp, verify, msg, lev)",
            "usage":["local param1 = assert_arg(1,\"hello\",'table')  --> error: argument 1 expected a 'table', got a 'string'\nlocal param4 = assert_arg(4,'!@#$%^&*','string',path.isdir,'not a directory')\n     --> error: argument 4: '!@#$%^&*' not a directory\n"],
            "raise":"if `val` is not the correct type",
            "name":"assert_arg",
            "params":{
              "1":"n",
              "2":"val",
              "3":"tp",
              "4":"verify",
              "5":"msg",
              "6":"lev",
              "map":{
                "n":" argument index",
                "verify":" an optional verification function",
                "val":" the value",
                "lev":" optional stack position for trace, default 2",
                "msg":" an optional custom message",
                "tp":" the type"
              }
            },
            "tags":[],
            "kind":"error handling ",
            "section":"Error handling",
            "type":"function",
            "parameter":"param",
            "ret":["the validated value"],
            "description":""
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[],[],[]],
              "param":{
                "1":{
                  "type":"table|vararg"
                },
                "...":{
                  "type":"table|vararg"
                }
              },
              "return":[[]]
            },
            "summary":"creates an Enum or constants lookup table for improved error handling.",
            "lineno":355,
            "retgroups":[{
                "1":{
                  "text":"Enum object (read-only table/object)",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(...)",
            "usage":["-- Enum access at runtime\nlocal obj = {}\nobj.MOVEMENT = utils.enum(\"FORWARD\", \"REVERSE\", \"LEFT\", \"RIGHT\")\n\nif current_movement == obj.MOVEMENT.FORWARD then\n  -- do something\n\nelseif current_movement == obj.MOVEMENT.REVERES then\n  -- throws error due to typo 'REVERES', so a silent mistake becomes a hard error\n  -- \"'REVERES' is not a valid value (expected one of: 'FORWARD', 'REVERSE', 'LEFT', 'RIGHT')\"\n\nend\n","-- standardized error codes\nlocal obj = {\n  ERR = utils.enum {\n    NOT_FOUND = \"the item was not found\",\n    OUT_OF_BOUNDS = \"the index is outside the allowed range\"\n  },\n\n  some_method = function(self)\n    return self.ERR.OUT_OF_BOUNDS\n  end,\n}\n\nlocal result, err = obj:some_method()\nif not result then\n  if err == obj.ERR.NOT_FOUND then\n    -- check on error code, not magic strings\n\n  else\n    -- return the error description, contained in the constant\n    return nil, \"error: \"..err  -- \"error: the index is outside the allowed range\"\n  end\nend\n","-- validating/converting user-input\nlocal color = \"purple\"\nlocal ansi_colors = utils.enum {\n  black     = 30,\n  red       = 31,\n  green     = 32,\n}\nlocal color_code, err = ansi_colors(color) -- calling on the object, returns the value from the enum\nif not color_code then\n  print(\"bad 'color', \" .. err)\n  -- \"bad 'color', 'purple' is not a valid value (expected one of: 'black', 'red', 'green')\"\n  os.exit(1)\nend\n"],
            "type":"function",
            "name":"enum",
            "parameter":"param",
            "params":{
              "map":{
                "...":" the input for the Enum. If varargs or an array then the\n values in the Enum will be equal to the names (must be strings), if a hash-table\n then values remain (any type), and the keys must be strings."
              },
              "1":"..."
            },
            "tags":[],
            "kind":"error handling ",
            "section":"Error handling",
            "description":"\n This helps prevent magic strings in code by throwing errors for accessing\n non-existing values, and/or converting strings/identifiers to other values.\n\n Calling on the object does the same, but returns a soft error; `nil + err`, if\n the call is succesful (the key exists), it will return the value.\n\n When calling with varargs or an array the values will be equal to the keys.\n The enum object is read-only.",
            "ret":["Enum object (read-only table/object)"]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "param":{
                "1":[],
                "2":[],
                "3":[],
                "f":[],
                "msg":[],
                "idx":[]
              },
              "raise":[],
              "return":[[]]
            },
            "summary":"process a function argument.",
            "lineno":430,
            "retgroups":[{
                "1":{
                  "text":"a callable",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(idx, f, msg)",
            "type":"function",
            "name":"function_arg",
            "params":{
              "1":"idx",
              "2":"f",
              "map":{
                "f":" a function, operator string, or callable object",
                "msg":" optional error message",
                "idx":" argument index"
              },
              "3":"msg"
            },
            "tags":[],
            "kind":"error handling ",
            "section":"Error handling",
            "description":"\n This is used throughout Penlight and defines what is meant by a function:\n Something that is callable, or an operator string as defined by <code>pl.operator</code>,\n such as '>' or '#'. If a function factory has been registered for the type, it will\n be called to get the function.",
            "raise":"if idx is not a number or if f is not callable",
            "ret":["a callable"],
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[]],
              "param":{
                "1":[],
                "2":[],
                "val":[],
                "n":[]
              },
              "raise":[],
              "return":[[]]
            },
            "summary":"assert the common case that the argument is a string.",
            "lineno":470,
            "retgroups":[{
                "1":{
                  "text":"the validated value",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(n, val)",
            "usage":["local val = 42\nlocal param2 = utils.assert_string(2, val) --> error: argument 2 expected a 'string', got a 'number'\n"],
            "raise":"val must be a string",
            "name":"assert_string",
            "params":{
              "1":"n",
              "2":"val",
              "map":{
                "val":" a value that must be a string",
                "n":" argument index"
              }
            },
            "tags":[],
            "kind":"error handling ",
            "section":"Error handling",
            "type":"function",
            "parameter":"param",
            "ret":["the validated value"],
            "description":""
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "param":{
                "1":[],
                "mode":[]
              },
              "return":[],
              "see":[[]]
            },
            "summary":"control the error strategy used by Penlight.",
            "lineno":483,
            "args":"(mode)",
            "section":"Error handling",
            "name":"on_error",
            "params":{
              "map":{
                "mode":" either 'default', 'quit'  or 'error'"
              },
              "1":"mode"
            },
            "tags":{
              "see":[]
            },
            "kind":"error handling ",
            "description":"\n This is a global setting that controls how `utils.raise` behaves:\n\n - 'default': return `nil + error` (this is the default)\n - 'error': throw a Lua error\n - 'quit': exit the program\n",
            "type":"function",
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":{
                "1":[],
                "err":[]
              },
              "usage":[[]],
              "see":[[]]
            },
            "summary":"used by Penlight functions to return errors.",
            "lineno":507,
            "args":"(err)",
            "usage":["if some_condition then\n  return utils.raise(\"some condition was not met\")  -- MUST use 'return'!\nend\n"],
            "section":"Error handling",
            "name":"raise",
            "parameter":"param",
            "params":{
              "map":{
                "err":" the error string."
              },
              "1":"err"
            },
            "tags":{
              "see":[]
            },
            "kind":"error handling ",
            "description":" Its global behaviour is controlled\n by `utils.on_error`.\n To use this function you MUST use it in conjunction with `return`, since it might\n return `nil + error`.",
            "type":"function"
          },{
            "name":"files",
            "inferred":true,
            "description":"",
            "file":"<reference cycle>",
            "summary":"",
            "tags":[],
            "lineno":523,
            "display_name":"File handling",
            "type":"section",
            "modifiers":[]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[[]],
              "param":{
                "1":[],
                "2":[],
                "filename":[],
                "is_bin":[]
              }
            },
            "summary":"return the contents of a file as a string",
            "lineno":527,
            "retgroups":[{
                "1":{
                  "text":"file contents",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(filename, is_bin)",
            "type":"function",
            "name":"readfile",
            "parameter":"param",
            "params":{
              "1":"filename",
              "2":"is_bin",
              "map":{
                "filename":" The file path",
                "is_bin":" open in binary mode"
              }
            },
            "tags":[],
            "kind":"file handling ",
            "section":"File handling",
            "description":"",
            "ret":["file contents"]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "param":{
                "1":[],
                "2":[],
                "3":[],
                "filename":[],
                "str":[],
                "is_bin":[]
              },
              "raise":[],
              "return":[[],[]]
            },
            "summary":"write a string to a file",
            "lineno":549,
            "retgroups":[{
                "1":{
                  "text":"true or nil",
                  "type":"",
                  "mods":[]
                },
                "2":{
                  "text":"error message",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(filename, str, is_bin)",
            "type":"function",
            "name":"writefile",
            "params":{
              "1":"filename",
              "2":"str",
              "map":{
                "filename":" The file path",
                "str":" The string",
                "is_bin":" open in binary mode"
              },
              "3":"is_bin"
            },
            "tags":[],
            "kind":"file handling ",
            "section":"File handling",
            "description":"",
            "raise":"error if filename or str aren't strings",
            "ret":["true or nil","error message"],
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "param":{
                "1":[],
                "filename":[]
              },
              "raise":[],
              "return":[[]]
            },
            "summary":"return the contents of a file as a list of lines",
            "lineno":569,
            "retgroups":[{
                "1":{
                  "text":"file contents as a table",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(filename)",
            "type":"function",
            "name":"readlines",
            "params":{
              "map":{
                "filename":" The file path"
              },
              "1":"filename"
            },
            "tags":[],
            "kind":"file handling ",
            "section":"File handling",
            "description":"",
            "raise":"error if filename is not a string",
            "ret":["file contents as a table"],
            "parameter":"param"
          },"<reference cycle>",{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[[],[],[],[]],
              "param":{
                "1":[],
                "2":[],
                "bin":[],
                "cmd":[]
              }
            },
            "summary":"execute a shell command and return the output.",
            "lineno":592,
            "retgroups":[{
                "1":{
                  "text":"true if successful",
                  "type":"",
                  "mods":[]
                },
                "2":{
                  "text":"actual return code",
                  "type":"",
                  "mods":[]
                },
                "3":{
                  "text":"stdout output (string)",
                  "type":"",
                  "mods":[]
                },
                "4":{
                  "text":"errout output (string)",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(cmd, bin)",
            "type":"function",
            "name":"executeex",
            "parameter":"param",
            "params":{
              "1":"cmd",
              "2":"bin",
              "map":{
                "bin":" boolean, if true, read output as binary file",
                "cmd":" a shell command"
              }
            },
            "tags":[],
            "kind":"os functions ",
            "section":"OS functions",
            "description":"\n This function redirects the output to tempfiles and returns the content of those files.",
            "ret":["true if successful","actual return code","stdout output (string)","errout output (string)"]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[]],
              "param":{
                "1":[],
                "argument":[]
              },
              "return":[[]]
            },
            "summary":"Quote and escape an argument of a command.",
            "lineno":623,
            "retgroups":[{
                "1":{
                  "text":"quoted and escaped argument.",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(argument)",
            "usage":["local options = utils.quote_arg {\n    \"-lluacov\",\n    \"-e\",\n    \"utils = print(require('pl.utils')._VERSION\",\n}\n-- returns: -lluacov -e 'utils = print(require('\\''pl.utils'\\'')._VERSION'\n"],
            "type":"function",
            "name":"quote_arg",
            "parameter":"param",
            "params":{
              "map":{
                "argument":" (string or table/list) the argument to quote. If a list then\n all arguments in the list will be returned as a single string quoted."
              },
              "1":"argument"
            },
            "tags":[],
            "kind":"os functions ",
            "section":"OS functions",
            "description":"\n Quotes a single (or list of) argument(s) of a command to be passed\n to `os.execute`, `pl.utils.execute` or `pl.utils.executeex`.",
            "ret":["quoted and escaped argument."]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":{
                "1":{
                  "opt":true
                },
                "2":[],
                "3":[],
                "msg":[],
                "...":[],
                "code":{
                  "opt":true
                }
              },
              "usage":[[]],
              "see":[[]]
            },
            "summary":"error out of this program gracefully.",
            "lineno":667,
            "args":"([code], msg, ...)",
            "usage":["utils.quit(-1, \"Error '%s' happened\", \"42\")\n-- is equivalent to\nutils.quit(\"Error '%s' happened\", \"42\")  --> Error '42' happened\n"],
            "section":"OS functions",
            "name":"quit",
            "parameter":"param",
            "params":{
              "1":"code",
              "2":"msg",
              "map":{
                "msg":" The exit message will be sent to `stderr` (will be formatted with the extra parameters)",
                "...":" extra arguments for message's format'",
                "code":" The exit code, defaults to -`1` if omitted"
              },
              "3":"..."
            },
            "tags":{
              "see":[]
            },
            "kind":"os functions ",
            "description":"",
            "type":"function"
          },{
            "name":"string-functions",
            "inferred":true,
            "description":"",
            "file":"<reference cycle>",
            "summary":"",
            "tags":[],
            "lineno":683,
            "display_name":"String functions",
            "type":"section",
            "modifiers":[]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":{
                "1":[],
                "s":[]
              }
            },
            "summary":"escape any Lua 'magic' characters in a string",
            "lineno":685,
            "args":"(s)",
            "section":"String functions",
            "name":"escape",
            "params":{
              "map":{
                "s":" The input string"
              },
              "1":"s"
            },
            "tags":[],
            "kind":"string functions ",
            "description":"",
            "type":"function",
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "param":{
                "1":[],
                "2":[],
                "3":[],
                "4":[],
                "re":[],
                "n":[],
                "s":[],
                "plain":[]
              },
              "return":[[]],
              "raise":[],
              "see":[[]]
            },
            "summary":"split a string into a list of strings separated by a delimiter.",
            "lineno":698,
            "retgroups":[{
                "1":{
                  "text":"a list-like table",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s, re, plain, n)",
            "type":"function",
            "name":"split",
            "params":{
              "1":"s",
              "2":"re",
              "3":"plain",
              "4":"n",
              "map":{
                "re":" optional A Lua string pattern; defaults to '%s+'",
                "n":" optional maximum number of elements (if there are more, the last will remian un-split)",
                "s":" The input string",
                "plain":" optional If truthy don't use Lua patterns"
              }
            },
            "tags":{
              "see":[]
            },
            "kind":"string functions ",
            "section":"String functions",
            "description":"",
            "raise":"error if s is not a string",
            "ret":["a list-like table"],
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "param":{
                "1":[],
                "2":[],
                "3":[],
                "4":[],
                "re":[],
                "n":[],
                "s":[],
                "plain":[]
              },
              "return":[[]],
              "usage":[[]],
              "see":[[]]
            },
            "summary":"split a string into a number of return values.",
            "lineno":735,
            "retgroups":[{
                "1":{
                  "text":"n values",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s, re, plain, n)",
            "usage":["first,next = splitv('user=jane=doe','=', false, 2)\nassert(first == \"user\")\nassert(next == \"jane=doe\")\n"],
            "type":"function",
            "name":"splitv",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"re",
              "3":"plain",
              "4":"n",
              "map":{
                "re":" A Lua string pattern; defaults to '%s+'",
                "n":" optional maximum number of splits",
                "s":" the string",
                "plain":" don't use Lua patterns"
              }
            },
            "tags":{
              "see":[]
            },
            "kind":"string functions ",
            "section":"String functions",
            "description":"\n Identical to `split` but returns multiple sub-strings instead of\n a single list of sub-strings.",
            "ret":["n values"]
          },{
            "name":"functional",
            "inferred":true,
            "description":"",
            "file":"<reference cycle>",
            "summary":"",
            "tags":[],
            "lineno":744,
            "display_name":"Functional",
            "type":"section",
            "modifiers":[]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[[]],
              "param":{
                "1":[],
                "func":[]
              }
            },
            "summary":"'memoize' a function (cache returned value for next call).",
            "lineno":750,
            "retgroups":[{
                "1":{
                  "text":"a function with at least one argument, which is used as the key.",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(func)",
            "type":"function",
            "name":"memoize",
            "parameter":"param",
            "params":{
              "map":{
                "func":" a function of at least one argument"
              },
              "1":"func"
            },
            "tags":[],
            "kind":"functional ",
            "section":"Functional",
            "description":"\n This is useful if you have a function which is relatively expensive,\n but you don't know in advance what values will be required, so\n building a table upfront is wasteful/impossible.",
            "ret":["a function with at least one argument, which is used as the key."]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":{
                "1":{
                  "type":"tab"
                },
                "2":{
                  "type":"func"
                },
                "fun":{
                  "type":"func"
                },
                "mt":{
                  "type":"tab"
                }
              }
            },
            "summary":"associate a function factory with a type.",
            "lineno":768,
            "args":"(mt, fun)",
            "section":"Functional",
            "name":"add_function_factory",
            "params":{
              "1":"mt",
              "2":"fun",
              "map":{
                "fun":" a callable that returns a function",
                "mt":" metatable"
              }
            },
            "tags":[],
            "kind":"functional ",
            "description":"\n A function factory takes an object of the given type and\n returns a function for evaluating it",
            "type":"function",
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "param":{
                "1":[],
                "lf":[]
              },
              "return":[[]],
              "usage":[[]]
            },
            "summary":"an anonymous function as a string.",
            "lineno":800,
            "retgroups":[{
                "1":{
                  "text":"a function",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(lf)",
            "usage":["string_lambda '|x|x+1' (2) == 3\nstring_lambda '_+1' (2) == 3\n"],
            "type":"function",
            "name":"string_lambda",
            "params":{
              "map":{
                "lf":" function as a string"
              },
              "1":"lf"
            },
            "tags":[],
            "kind":"functional ",
            "section":"Functional",
            "description":" This string is either of the form\n '|args| expression' or is a function of one argument, '_'",
            "ret":["a function"],
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[[]],
              "see":[[]],
              "param":{
                "1":[],
                "2":[],
                "p":[],
                "fn":[]
              },
              "raise":[],
              "usage":[[]]
            },
            "summary":"bind the first argument of the function to a value.",
            "lineno":817,
            "retgroups":[{
                "1":{
                  "text":"a function such that f(x) is fn(p,x)",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(fn, p)",
            "usage":["local function f(msg, name)\n  print(msg .. \" \" .. name)\nend\n\nlocal hello = utils.bind1(f, \"Hello\")\n\nprint(hello(\"world\"))     --> \"Hello world\"\nprint(hello(\"sunshine\"))  --> \"Hello sunshine\"\n"],
            "raise":"same as @{function_arg}",
            "name":"bind1",
            "params":{
              "1":"fn",
              "2":"p",
              "map":{
                "p":" a value",
                "fn":" a function of at least two values (may be an operator string)"
              }
            },
            "tags":{
              "see":[]
            },
            "kind":"functional ",
            "section":"Functional",
            "type":"function",
            "parameter":"param",
            "ret":["a function such that f(x) is fn(p,x)"],
            "description":""
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[]],
              "param":{
                "1":[],
                "2":[],
                "p":[],
                "fn":[]
              },
              "raise":[],
              "return":[[]]
            },
            "summary":"bind the second argument of the function to a value.",
            "lineno":836,
            "retgroups":[{
                "1":{
                  "text":"a function such that f(x) is fn(x,p)",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(fn, p)",
            "usage":["local function f(a, b, c)\n  print(a .. \" \" .. b .. \" \" .. c)\nend\n\nlocal hello = utils.bind1(f, \"world\")\n\nprint(hello(\"Hello\", \"!\"))  --> \"Hello world !\"\nprint(hello(\"Bye\", \"?\"))    --> \"Bye world ?\"\n"],
            "raise":"same as @{function_arg}",
            "name":"bind2",
            "params":{
              "1":"fn",
              "2":"p",
              "map":{
                "p":" a value",
                "fn":" a function of at least two values (may be an operator string)"
              }
            },
            "tags":[],
            "kind":"functional ",
            "section":"Functional",
            "type":"function",
            "parameter":"param",
            "ret":["a function such that f(x) is fn(x,p)"],
            "description":""
          },{
            "name":"deprecation",
            "inferred":true,
            "description":"",
            "file":"<reference cycle>",
            "summary":"",
            "tags":[],
            "lineno":847,
            "display_name":"Deprecation",
            "type":"section",
            "modifiers":[]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":{
                "1":[],
                "func":[]
              },
              "usage":[[]],
              "see":[[]]
            },
            "summary":"Sets a deprecation warning function.",
            "lineno":875,
            "args":"(func)",
            "usage":["-- write to the Nginx logs with OpenResty\nutils.set_deprecation_func(function(msg, trace)\n  ngx.log(ngx.WARN, msg, (trace and (\" \" .. trace) or nil))\nend)\n\n-- disable deprecation warnings\nutils.set_deprecation_func()\n"],
            "section":"Deprecation",
            "name":"set_deprecation_func",
            "parameter":"param",
            "params":{
              "map":{
                "func":" a callback with signature: `function(msg, trace)` both arguments are strings, the latter being optional."
              },
              "1":"func"
            },
            "tags":{
              "see":[]
            },
            "kind":"deprecation ",
            "description":"\n An application can override this function to support proper output of\n deprecation warnings. The warnings can be generated from libraries or\n functions by calling `utils.raise_deprecation`. The default function\n will write to the 'warn' system (introduced in Lua 5.4, or the compatibility\n function from the `compat` module for earlier versions).\n\n Note: only applications should set/change this function, libraries should not.",
            "type":"function"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":{
                "1":[],
                "opts":[]
              },
              "usage":[[]],
              "see":[[]]
            },
            "summary":"raises a deprecation warning.",
            "lineno":907,
            "args":"(opts)",
            "usage":["warn(\"@on\")   -- enable Lua warnings, they are usually off by default\n\nfunction stringx.islower(str)\n  raise_deprecation {\n    source = \"Penlight \" .. utils._VERSION,                   -- optional\n    message = \"function 'islower' was renamed to 'is_lower'\", -- required\n    version_removed = \"2.0.0\",                                -- optional\n    deprecated_after = \"1.2.3\",                               -- optional\n    no_trace = true,                                          -- optional\n  }\n  return stringx.is_lower(str)\nend\n-- output: \"[Penlight 1.9.2] function 'islower' was renamed to 'is_lower' (deprecated after 1.2.3, scheduled for removal in 2.0.0)\"\n"],
            "section":"Deprecation",
            "name":"raise_deprecation",
            "parameter":"param",
            "params":{
              "map":{
                "opts":" options table"
              },
              "1":"opts"
            },
            "tags":{
              "see":[]
            },
            "kind":"deprecation ",
            "description":"\n For options see the usage example below.\n\n Note: the `opts.deprecated_after` field is the last version in which\n a feature or option was NOT YET deprecated! Because when writing the code it\n is quite often not known in what version the code will land. But the last\n released version is usually known.",
            "type":"function"
          }],
        "sections":[],
        "modules":["<reference cycle>"],
        "args":{
          "one":false,
          "module":false,
          "verbose":false,
          "style":"!",
          "template":"!",
          "date":"system",
          "dir":"doc",
          "quiet":false,
          "all":false,
          "ignore":false,
          "colon":false,
          "not_luadoc":false,
          "ext":"html",
          "boilerplate":false,
          "merge":false,
          "filter":"f.filter",
          "package":"/home/cji/portless/Penlight/lua",
          "dump":false,
          "no_args_infer":false,
          "title":"Reference",
          "project":"ldoc",
          "file":"/home/cji/portless/Penlight/lua/pl",
          "format":"discount",
          "simple":false,
          "tags":"none",
          "define":"none",
          "output":"index",
          "unqualified":false,
          "config":"config.ld",
          "fatalwarnings":false,
          "testing":false
        },
        "error":"<type 'function' is not supported by JSON.>",
        "lang":{
          "line_comment":"^%-%-+",
          "start_comment_":"^%-%-%-+",
          "end_comment_":"[^%-]%-%-+[^-]*\n$",
          "extra":[],
          "block_comment":"^%-%-%[=*%[%-+",
          "empty_comment_":"^%-%-%-+%s*$",
          "method_call":":"
        },
        "base":"/home/cji/portless/Penlight/lua"
      },
      "summary":"",
      "tags":[],
      "lineno":584,
      "display_name":"OS functions",
      "type":"section",
      "modifiers":[]
    },
    "4":{
      "name":"string-functions",
      "inferred":true,
      "description":"",
      "file":{
        "warning":"<type 'function' is not supported by JSON.>",
        "filename":"/home/cji/portless/Penlight/lua/pl/utils.lua",
        "items":["<reference cycle>",{
            "inferred":true,
            "description":"",
            "modifiers":{
              "field":[],
              "return":[]
            },
            "summary":"Some standard patterns",
            "lineno":31,
            "args":"(FLOAT, INTEGER, IDEN, FILE)",
            "type":"table",
            "name":"patterns",
            "parameter":"field",
            "params":{
              "1":"FLOAT",
              "2":"INTEGER",
              "3":"IDEN",
              "4":"FILE",
              "map":{
                "FILE":"file",
                "INTEGER":"integer number",
                "IDEN":"identifier",
                "FLOAT":"floating point number"
              }
            },
            "tags":[],
            "kind":"tables",
            "section":"table",
            "subparams":[]
          },{
            "name":"stdmt",
            "section":"table",
            "inferred":true,
            "description":"",
            "kind":"tables",
            "summary":"Standard meta-tables as used by other Penlight modules",
            "params":{
              "1":"List",
              "2":"Map",
              "3":"Set",
              "4":"MultiMap",
              "map":{
                "Map":" the Map metatable",
                "Set":" the Set metatable",
                "MultiMap":" the MultiMap metatable",
                "List":" the List metatable"
              }
            },
            "tags":[],
            "lineno":45,
            "subparams":[],
            "args":"(List, Map, Set, MultiMap)",
            "parameter":"field",
            "type":"table",
            "modifiers":{
              "field":{
                "1":[],
                "2":[],
                "3":[],
                "4":[],
                "Map":[],
                "Set":[],
                "MultiMap":[],
                "List":[]
              },
              "return":[]
            }
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "param":{
                "1":[],
                "...":[]
              },
              "return":[[]],
              "see":[[],[],[]]
            },
            "summary":"pack an argument list into a table.",
            "lineno":60,
            "retgroups":[{
                "1":{
                  "text":"a table with field `n` set to the length",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(...)",
            "section":"function",
            "name":"pack",
            "params":{
              "map":{
                "...":" any arguments"
              },
              "1":"..."
            },
            "tags":{
              "see":[]
            },
            "kind":"functions",
            "description":"",
            "type":"function",
            "ret":["a table with field `n` set to the length"],
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[[]],
              "usage":[[]],
              "param":{
                "1":[],
                "2":{
                  "optchain":true,
                  "opt":true
                },
                "3":{
                  "optchain":true,
                  "opt":true
                },
                "t":[],
                "j":{
                  "optchain":true,
                  "opt":true
                },
                "i":{
                  "optchain":true,
                  "opt":true
                }
              },
              "see":[[],[],[]]
            },
            "summary":"unpack a table and return its contents.",
            "lineno":79,
            "retgroups":[{
                "1":{
                  "text":"multiple return values from the table",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(t[, i[, j]])",
            "usage":["local t = table.pack(nil, nil, nil, 4)\nlocal a, b, c, d = table.unpack(t)   -- this `unpack` is NOT nil-safe, so d == nil\n\nlocal a, b, c, d = utils.unpack(t)   -- this is nil-safe, so d == 4\n"],
            "type":"function",
            "name":"unpack",
            "params":{
              "1":"t",
              "2":"i",
              "map":{
                "t":" table to unpack",
                "j":" index of the last element to unpack, defaults to `t.n` or else `#t`",
                "i":" index from which to start unpacking, defaults to 1"
              },
              "3":"j"
            },
            "tags":{
              "see":[]
            },
            "kind":"functions",
            "section":"function",
            "description":"\n\n NOTE: this implementation differs from the Lua implementation in the way\n that this one DOES honor the `n` field in the table `t`, such that it is 'nil-safe'.",
            "ret":["multiple return values from the table"],
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":{
                "1":[],
                "2":[],
                "fmt":[],
                "...":[]
              }
            },
            "summary":"print an arbitrary number of arguments using a format.",
            "lineno":87,
            "args":"(fmt, ...)",
            "section":"function",
            "name":"printf",
            "params":{
              "1":"fmt",
              "2":"...",
              "map":{
                "fmt":" The format (see `string.format`)",
                "...":" Extra arguments for format"
              }
            },
            "tags":[],
            "kind":"functions",
            "description":"\n Output will be sent to `stdout`.",
            "type":"function",
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":{
                "1":[],
                "2":[],
                "3":[],
                "fmt":[],
                "f":[],
                "...":[]
              }
            },
            "summary":"write an arbitrary number of arguments to a file using a format.",
            "lineno":96,
            "args":"(f, fmt, ...)",
            "section":"function",
            "name":"fprintf",
            "params":{
              "1":"f",
              "2":"fmt",
              "map":{
                "fmt":" The format (see `string.format`).",
                "f":" File handle to write to.",
                "...":" Extra arguments for format"
              },
              "3":"..."
            },
            "tags":[],
            "kind":"functions",
            "description":"",
            "type":"function",
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":{
                "1":[],
                "2":[],
                "t":[],
                "T":[]
              }
            },
            "summary":"take a table and 'inject' it into the local namespace.",
            "lineno":124,
            "args":"(t, T)",
            "section":"function",
            "name":"import",
            "params":{
              "1":"t",
              "2":"T",
              "map":{
                "t":" The table (table), or module name (string), defaults to this `utils` module table",
                "T":" An optional destination table (defaults to callers environment)"
              }
            },
            "tags":[],
            "kind":"functions",
            "description":"",
            "type":"function",
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":{
                "1":[],
                "2":[],
                "3":[],
                "cond":[],
                "value1":[],
                "value2":[]
              }
            },
            "summary":"return either of two values, depending on a condition.",
            "lineno":143,
            "args":"(cond, value1, value2)",
            "section":"function",
            "name":"choose",
            "params":{
              "1":"cond",
              "2":"value1",
              "map":{
                "cond":" A condition",
                "value1":" Value returned if cond is truthy",
                "value2":" Value returned if cond is falsy"
              },
              "3":"value2"
            },
            "tags":[],
            "kind":"functions",
            "description":"",
            "type":"function",
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[[]],
              "param":{
                "1":[],
                "2":{
                  "optchain":true,
                  "opt":true
                },
                "3":{
                  "optchain":true,
                  "opt":true
                },
                "t":[],
                "temp":{
                  "optchain":true,
                  "opt":true
                },
                "tostr":{
                  "optchain":true,
                  "opt":true
                }
              }
            },
            "summary":"convert an array of values to strings.",
            "lineno":152,
            "retgroups":[{
                "1":{
                  "text":"the converted buffer",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(t[, temp[, tostr]])",
            "type":"function",
            "name":"array_tostring",
            "parameter":"param",
            "params":{
              "1":"t",
              "2":"temp",
              "map":{
                "t":" a list-like table",
                "temp":" (table) buffer to use, otherwise allocate",
                "tostr":" custom tostring function, called with (value,index). Defaults to `tostring`."
              },
              "3":"tostr"
            },
            "tags":[],
            "kind":"functions",
            "section":"function",
            "description":"",
            "ret":["the converted buffer"]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[]],
              "param":{
                "1":[],
                "2":[],
                "obj":[],
                "tp":[]
              },
              "return":[[]]
            },
            "summary":"is the object of the specified type?",
            "lineno":172,
            "retgroups":[{
                "1":{
                  "text":"boolean",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(obj, tp)",
            "usage":["utils.is_type(\"hello world\", \"string\")   --> true\n-- or check metatable\nlocal my_mt = {}\nlocal my_obj = setmetatable(my_obj, my_mt)\nutils.is_type(my_obj, my_mt)  --> true\n"],
            "type":"function",
            "name":"is_type",
            "parameter":"param",
            "params":{
              "1":"obj",
              "2":"tp",
              "map":{
                "obj":" An object to check",
                "tp":" String of what type it should be"
              }
            },
            "tags":[],
            "kind":"functions",
            "section":"function",
            "description":"\n If the type is a string, then use type, otherwise compare with metatable",
            "ret":["boolean"]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[]],
              "return":[{
                  "type":"integer"
                },{
                  "type":"any"
                }],
              "param":{
                "1":{
                  "type":"table"
                },
                "2":{
                  "opt":"1",
                  "type":"integer",
                  "optchain":"1"
                },
                "3":{
                  "opt":"t.n or #t",
                  "type":"integer",
                  "optchain":"t.n or #t"
                },
                "4":{
                  "opt":"1",
                  "type":"integer",
                  "optchain":"1"
                },
                "t":{
                  "type":"table"
                },
                "step":{
                  "opt":"1",
                  "type":"integer",
                  "optchain":"1"
                },
                "i_start":{
                  "opt":"1",
                  "type":"integer",
                  "optchain":"1"
                },
                "i_end":{
                  "opt":"t.n or #t",
                  "type":"integer",
                  "optchain":"t.n or #t"
                }
              },
              "see":[[],[]]
            },
            "summary":"an iterator with indices, similar to `ipairs`, but with a range.",
            "lineno":199,
            "retgroups":[{
                "1":{
                  "text":"index",
                  "type":"integer",
                  "mods":{
                    "type":"integer"
                  }
                },
                "2":{
                  "text":"value at index (which can be `nil`!)",
                  "type":"any",
                  "mods":{
                    "type":"any"
                  }
                },
                "g":0
              }],
            "args":"(t[, i_start=1[, i_end=t.n or #t[, step=1]]])",
            "usage":["local t = utils.pack(nil, 123, nil)  -- adds an `n` field when packing\n\nfor i, v in utils.npairs(t, 2) do  -- start at index 2\n  t[i] = tostring(t[i])\nend\n\n-- t = { n = 3, [2] = \"123\", [3] = \"nil\" }\n"],
            "type":"function",
            "name":"npairs",
            "parameter":"param",
            "params":{
              "1":"t",
              "2":"i_start",
              "3":"i_end",
              "4":"step",
              "map":{
                "t":" the table to iterate over",
                "step":" step size",
                "i_start":" start index",
                "i_end":" end index"
              }
            },
            "tags":{
              "see":[]
            },
            "kind":"functions",
            "section":"function",
            "description":"\n This is a nil-safe index based iterator that will return `nil` when there\n is a hole in a list. To be safe ensure that table `t.n` contains the length.",
            "ret":["index","value at index (which can be `nil`!)"]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[]],
              "param":{
                "1":{
                  "type":"table"
                },
                "t":{
                  "type":"table"
                }
              },
              "return":[{
                  "type":"key"
                },{
                  "type":"value"
                }]
            },
            "summary":"an iterator over all non-integer keys (inverse of `ipairs`).",
            "lineno":253,
            "retgroups":[{
                "1":{
                  "text":"",
                  "type":"key",
                  "mods":{
                    "type":"key"
                  }
                },
                "2":{
                  "text":"",
                  "type":"value",
                  "mods":{
                    "type":"value"
                  }
                },
                "g":0
              }],
            "args":"(t)",
            "usage":["local t = {\n  \"hello\",\n  \"world\",\n  hello = \"hallo\",\n  world = \"Welt\",\n}\n\nfor k, v in utils.kpairs(t) do\n  print(\"German: \", v)\nend\n\n-- output;\n-- German: hallo\n-- German: Welt\n"],
            "type":"function",
            "name":"kpairs",
            "parameter":"param",
            "params":{
              "map":{
                "t":" the table to iterate over"
              },
              "1":"t"
            },
            "tags":[],
            "kind":"functions",
            "section":"function",
            "description":"\n It will skip any key that is an integer number, so negative indices or an\n array with holes will not return those either (so it returns slightly less than\n 'the inverse of `ipairs`').\n\n This uses `pairs` under the hood, so any value that is iterable using `pairs`\n will work with this function.",
            "ret":["",""]
          },{
            "name":"Error-handling",
            "inferred":true,
            "description":"",
            "file":"<reference cycle>",
            "summary":"",
            "tags":[],
            "lineno":272,
            "display_name":"Error handling",
            "type":"section",
            "modifiers":[]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[]],
              "param":{
                "1":[],
                "2":[],
                "3":[],
                "4":[],
                "5":[],
                "6":[],
                "n":[],
                "verify":[],
                "val":[],
                "lev":[],
                "msg":[],
                "tp":[]
              },
              "raise":[],
              "return":[[]]
            },
            "summary":"assert that the given argument is in fact of the correct type.",
            "lineno":285,
            "retgroups":[{
                "1":{
                  "text":"the validated value",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(n, val, tp, verify, msg, lev)",
            "usage":["local param1 = assert_arg(1,\"hello\",'table')  --> error: argument 1 expected a 'table', got a 'string'\nlocal param4 = assert_arg(4,'!@#$%^&*','string',path.isdir,'not a directory')\n     --> error: argument 4: '!@#$%^&*' not a directory\n"],
            "raise":"if `val` is not the correct type",
            "name":"assert_arg",
            "params":{
              "1":"n",
              "2":"val",
              "3":"tp",
              "4":"verify",
              "5":"msg",
              "6":"lev",
              "map":{
                "n":" argument index",
                "verify":" an optional verification function",
                "val":" the value",
                "lev":" optional stack position for trace, default 2",
                "msg":" an optional custom message",
                "tp":" the type"
              }
            },
            "tags":[],
            "kind":"error handling ",
            "section":"Error handling",
            "type":"function",
            "parameter":"param",
            "ret":["the validated value"],
            "description":""
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[],[],[]],
              "param":{
                "1":{
                  "type":"table|vararg"
                },
                "...":{
                  "type":"table|vararg"
                }
              },
              "return":[[]]
            },
            "summary":"creates an Enum or constants lookup table for improved error handling.",
            "lineno":355,
            "retgroups":[{
                "1":{
                  "text":"Enum object (read-only table/object)",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(...)",
            "usage":["-- Enum access at runtime\nlocal obj = {}\nobj.MOVEMENT = utils.enum(\"FORWARD\", \"REVERSE\", \"LEFT\", \"RIGHT\")\n\nif current_movement == obj.MOVEMENT.FORWARD then\n  -- do something\n\nelseif current_movement == obj.MOVEMENT.REVERES then\n  -- throws error due to typo 'REVERES', so a silent mistake becomes a hard error\n  -- \"'REVERES' is not a valid value (expected one of: 'FORWARD', 'REVERSE', 'LEFT', 'RIGHT')\"\n\nend\n","-- standardized error codes\nlocal obj = {\n  ERR = utils.enum {\n    NOT_FOUND = \"the item was not found\",\n    OUT_OF_BOUNDS = \"the index is outside the allowed range\"\n  },\n\n  some_method = function(self)\n    return self.ERR.OUT_OF_BOUNDS\n  end,\n}\n\nlocal result, err = obj:some_method()\nif not result then\n  if err == obj.ERR.NOT_FOUND then\n    -- check on error code, not magic strings\n\n  else\n    -- return the error description, contained in the constant\n    return nil, \"error: \"..err  -- \"error: the index is outside the allowed range\"\n  end\nend\n","-- validating/converting user-input\nlocal color = \"purple\"\nlocal ansi_colors = utils.enum {\n  black     = 30,\n  red       = 31,\n  green     = 32,\n}\nlocal color_code, err = ansi_colors(color) -- calling on the object, returns the value from the enum\nif not color_code then\n  print(\"bad 'color', \" .. err)\n  -- \"bad 'color', 'purple' is not a valid value (expected one of: 'black', 'red', 'green')\"\n  os.exit(1)\nend\n"],
            "type":"function",
            "name":"enum",
            "parameter":"param",
            "params":{
              "map":{
                "...":" the input for the Enum. If varargs or an array then the\n values in the Enum will be equal to the names (must be strings), if a hash-table\n then values remain (any type), and the keys must be strings."
              },
              "1":"..."
            },
            "tags":[],
            "kind":"error handling ",
            "section":"Error handling",
            "description":"\n This helps prevent magic strings in code by throwing errors for accessing\n non-existing values, and/or converting strings/identifiers to other values.\n\n Calling on the object does the same, but returns a soft error; `nil + err`, if\n the call is succesful (the key exists), it will return the value.\n\n When calling with varargs or an array the values will be equal to the keys.\n The enum object is read-only.",
            "ret":["Enum object (read-only table/object)"]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "param":{
                "1":[],
                "2":[],
                "3":[],
                "f":[],
                "msg":[],
                "idx":[]
              },
              "raise":[],
              "return":[[]]
            },
            "summary":"process a function argument.",
            "lineno":430,
            "retgroups":[{
                "1":{
                  "text":"a callable",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(idx, f, msg)",
            "type":"function",
            "name":"function_arg",
            "params":{
              "1":"idx",
              "2":"f",
              "map":{
                "f":" a function, operator string, or callable object",
                "msg":" optional error message",
                "idx":" argument index"
              },
              "3":"msg"
            },
            "tags":[],
            "kind":"error handling ",
            "section":"Error handling",
            "description":"\n This is used throughout Penlight and defines what is meant by a function:\n Something that is callable, or an operator string as defined by <code>pl.operator</code>,\n such as '>' or '#'. If a function factory has been registered for the type, it will\n be called to get the function.",
            "raise":"if idx is not a number or if f is not callable",
            "ret":["a callable"],
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[]],
              "param":{
                "1":[],
                "2":[],
                "val":[],
                "n":[]
              },
              "raise":[],
              "return":[[]]
            },
            "summary":"assert the common case that the argument is a string.",
            "lineno":470,
            "retgroups":[{
                "1":{
                  "text":"the validated value",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(n, val)",
            "usage":["local val = 42\nlocal param2 = utils.assert_string(2, val) --> error: argument 2 expected a 'string', got a 'number'\n"],
            "raise":"val must be a string",
            "name":"assert_string",
            "params":{
              "1":"n",
              "2":"val",
              "map":{
                "val":" a value that must be a string",
                "n":" argument index"
              }
            },
            "tags":[],
            "kind":"error handling ",
            "section":"Error handling",
            "type":"function",
            "parameter":"param",
            "ret":["the validated value"],
            "description":""
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "param":{
                "1":[],
                "mode":[]
              },
              "return":[],
              "see":[[]]
            },
            "summary":"control the error strategy used by Penlight.",
            "lineno":483,
            "args":"(mode)",
            "section":"Error handling",
            "name":"on_error",
            "params":{
              "map":{
                "mode":" either 'default', 'quit'  or 'error'"
              },
              "1":"mode"
            },
            "tags":{
              "see":[]
            },
            "kind":"error handling ",
            "description":"\n This is a global setting that controls how `utils.raise` behaves:\n\n - 'default': return `nil + error` (this is the default)\n - 'error': throw a Lua error\n - 'quit': exit the program\n",
            "type":"function",
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":{
                "1":[],
                "err":[]
              },
              "usage":[[]],
              "see":[[]]
            },
            "summary":"used by Penlight functions to return errors.",
            "lineno":507,
            "args":"(err)",
            "usage":["if some_condition then\n  return utils.raise(\"some condition was not met\")  -- MUST use 'return'!\nend\n"],
            "section":"Error handling",
            "name":"raise",
            "parameter":"param",
            "params":{
              "map":{
                "err":" the error string."
              },
              "1":"err"
            },
            "tags":{
              "see":[]
            },
            "kind":"error handling ",
            "description":" Its global behaviour is controlled\n by `utils.on_error`.\n To use this function you MUST use it in conjunction with `return`, since it might\n return `nil + error`.",
            "type":"function"
          },{
            "name":"files",
            "inferred":true,
            "description":"",
            "file":"<reference cycle>",
            "summary":"",
            "tags":[],
            "lineno":523,
            "display_name":"File handling",
            "type":"section",
            "modifiers":[]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[[]],
              "param":{
                "1":[],
                "2":[],
                "filename":[],
                "is_bin":[]
              }
            },
            "summary":"return the contents of a file as a string",
            "lineno":527,
            "retgroups":[{
                "1":{
                  "text":"file contents",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(filename, is_bin)",
            "type":"function",
            "name":"readfile",
            "parameter":"param",
            "params":{
              "1":"filename",
              "2":"is_bin",
              "map":{
                "filename":" The file path",
                "is_bin":" open in binary mode"
              }
            },
            "tags":[],
            "kind":"file handling ",
            "section":"File handling",
            "description":"",
            "ret":["file contents"]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "param":{
                "1":[],
                "2":[],
                "3":[],
                "filename":[],
                "str":[],
                "is_bin":[]
              },
              "raise":[],
              "return":[[],[]]
            },
            "summary":"write a string to a file",
            "lineno":549,
            "retgroups":[{
                "1":{
                  "text":"true or nil",
                  "type":"",
                  "mods":[]
                },
                "2":{
                  "text":"error message",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(filename, str, is_bin)",
            "type":"function",
            "name":"writefile",
            "params":{
              "1":"filename",
              "2":"str",
              "map":{
                "filename":" The file path",
                "str":" The string",
                "is_bin":" open in binary mode"
              },
              "3":"is_bin"
            },
            "tags":[],
            "kind":"file handling ",
            "section":"File handling",
            "description":"",
            "raise":"error if filename or str aren't strings",
            "ret":["true or nil","error message"],
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "param":{
                "1":[],
                "filename":[]
              },
              "raise":[],
              "return":[[]]
            },
            "summary":"return the contents of a file as a list of lines",
            "lineno":569,
            "retgroups":[{
                "1":{
                  "text":"file contents as a table",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(filename)",
            "type":"function",
            "name":"readlines",
            "params":{
              "map":{
                "filename":" The file path"
              },
              "1":"filename"
            },
            "tags":[],
            "kind":"file handling ",
            "section":"File handling",
            "description":"",
            "raise":"error if filename is not a string",
            "ret":["file contents as a table"],
            "parameter":"param"
          },{
            "name":"OS-functions",
            "inferred":true,
            "description":"",
            "file":"<reference cycle>",
            "summary":"",
            "tags":[],
            "lineno":584,
            "display_name":"OS functions",
            "type":"section",
            "modifiers":[]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[[],[],[],[]],
              "param":{
                "1":[],
                "2":[],
                "bin":[],
                "cmd":[]
              }
            },
            "summary":"execute a shell command and return the output.",
            "lineno":592,
            "retgroups":[{
                "1":{
                  "text":"true if successful",
                  "type":"",
                  "mods":[]
                },
                "2":{
                  "text":"actual return code",
                  "type":"",
                  "mods":[]
                },
                "3":{
                  "text":"stdout output (string)",
                  "type":"",
                  "mods":[]
                },
                "4":{
                  "text":"errout output (string)",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(cmd, bin)",
            "type":"function",
            "name":"executeex",
            "parameter":"param",
            "params":{
              "1":"cmd",
              "2":"bin",
              "map":{
                "bin":" boolean, if true, read output as binary file",
                "cmd":" a shell command"
              }
            },
            "tags":[],
            "kind":"os functions ",
            "section":"OS functions",
            "description":"\n This function redirects the output to tempfiles and returns the content of those files.",
            "ret":["true if successful","actual return code","stdout output (string)","errout output (string)"]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[]],
              "param":{
                "1":[],
                "argument":[]
              },
              "return":[[]]
            },
            "summary":"Quote and escape an argument of a command.",
            "lineno":623,
            "retgroups":[{
                "1":{
                  "text":"quoted and escaped argument.",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(argument)",
            "usage":["local options = utils.quote_arg {\n    \"-lluacov\",\n    \"-e\",\n    \"utils = print(require('pl.utils')._VERSION\",\n}\n-- returns: -lluacov -e 'utils = print(require('\\''pl.utils'\\'')._VERSION'\n"],
            "type":"function",
            "name":"quote_arg",
            "parameter":"param",
            "params":{
              "map":{
                "argument":" (string or table/list) the argument to quote. If a list then\n all arguments in the list will be returned as a single string quoted."
              },
              "1":"argument"
            },
            "tags":[],
            "kind":"os functions ",
            "section":"OS functions",
            "description":"\n Quotes a single (or list of) argument(s) of a command to be passed\n to `os.execute`, `pl.utils.execute` or `pl.utils.executeex`.",
            "ret":["quoted and escaped argument."]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":{
                "1":{
                  "opt":true
                },
                "2":[],
                "3":[],
                "msg":[],
                "...":[],
                "code":{
                  "opt":true
                }
              },
              "usage":[[]],
              "see":[[]]
            },
            "summary":"error out of this program gracefully.",
            "lineno":667,
            "args":"([code], msg, ...)",
            "usage":["utils.quit(-1, \"Error '%s' happened\", \"42\")\n-- is equivalent to\nutils.quit(\"Error '%s' happened\", \"42\")  --> Error '42' happened\n"],
            "section":"OS functions",
            "name":"quit",
            "parameter":"param",
            "params":{
              "1":"code",
              "2":"msg",
              "map":{
                "msg":" The exit message will be sent to `stderr` (will be formatted with the extra parameters)",
                "...":" extra arguments for message's format'",
                "code":" The exit code, defaults to -`1` if omitted"
              },
              "3":"..."
            },
            "tags":{
              "see":[]
            },
            "kind":"os functions ",
            "description":"",
            "type":"function"
          },"<reference cycle>",{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":{
                "1":[],
                "s":[]
              }
            },
            "summary":"escape any Lua 'magic' characters in a string",
            "lineno":685,
            "args":"(s)",
            "section":"String functions",
            "name":"escape",
            "params":{
              "map":{
                "s":" The input string"
              },
              "1":"s"
            },
            "tags":[],
            "kind":"string functions ",
            "description":"",
            "type":"function",
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "param":{
                "1":[],
                "2":[],
                "3":[],
                "4":[],
                "re":[],
                "n":[],
                "s":[],
                "plain":[]
              },
              "return":[[]],
              "raise":[],
              "see":[[]]
            },
            "summary":"split a string into a list of strings separated by a delimiter.",
            "lineno":698,
            "retgroups":[{
                "1":{
                  "text":"a list-like table",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s, re, plain, n)",
            "type":"function",
            "name":"split",
            "params":{
              "1":"s",
              "2":"re",
              "3":"plain",
              "4":"n",
              "map":{
                "re":" optional A Lua string pattern; defaults to '%s+'",
                "n":" optional maximum number of elements (if there are more, the last will remian un-split)",
                "s":" The input string",
                "plain":" optional If truthy don't use Lua patterns"
              }
            },
            "tags":{
              "see":[]
            },
            "kind":"string functions ",
            "section":"String functions",
            "description":"",
            "raise":"error if s is not a string",
            "ret":["a list-like table"],
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "param":{
                "1":[],
                "2":[],
                "3":[],
                "4":[],
                "re":[],
                "n":[],
                "s":[],
                "plain":[]
              },
              "return":[[]],
              "usage":[[]],
              "see":[[]]
            },
            "summary":"split a string into a number of return values.",
            "lineno":735,
            "retgroups":[{
                "1":{
                  "text":"n values",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s, re, plain, n)",
            "usage":["first,next = splitv('user=jane=doe','=', false, 2)\nassert(first == \"user\")\nassert(next == \"jane=doe\")\n"],
            "type":"function",
            "name":"splitv",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"re",
              "3":"plain",
              "4":"n",
              "map":{
                "re":" A Lua string pattern; defaults to '%s+'",
                "n":" optional maximum number of splits",
                "s":" the string",
                "plain":" don't use Lua patterns"
              }
            },
            "tags":{
              "see":[]
            },
            "kind":"string functions ",
            "section":"String functions",
            "description":"\n Identical to `split` but returns multiple sub-strings instead of\n a single list of sub-strings.",
            "ret":["n values"]
          },{
            "name":"functional",
            "inferred":true,
            "description":"",
            "file":"<reference cycle>",
            "summary":"",
            "tags":[],
            "lineno":744,
            "display_name":"Functional",
            "type":"section",
            "modifiers":[]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[[]],
              "param":{
                "1":[],
                "func":[]
              }
            },
            "summary":"'memoize' a function (cache returned value for next call).",
            "lineno":750,
            "retgroups":[{
                "1":{
                  "text":"a function with at least one argument, which is used as the key.",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(func)",
            "type":"function",
            "name":"memoize",
            "parameter":"param",
            "params":{
              "map":{
                "func":" a function of at least one argument"
              },
              "1":"func"
            },
            "tags":[],
            "kind":"functional ",
            "section":"Functional",
            "description":"\n This is useful if you have a function which is relatively expensive,\n but you don't know in advance what values will be required, so\n building a table upfront is wasteful/impossible.",
            "ret":["a function with at least one argument, which is used as the key."]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":{
                "1":{
                  "type":"tab"
                },
                "2":{
                  "type":"func"
                },
                "fun":{
                  "type":"func"
                },
                "mt":{
                  "type":"tab"
                }
              }
            },
            "summary":"associate a function factory with a type.",
            "lineno":768,
            "args":"(mt, fun)",
            "section":"Functional",
            "name":"add_function_factory",
            "params":{
              "1":"mt",
              "2":"fun",
              "map":{
                "fun":" a callable that returns a function",
                "mt":" metatable"
              }
            },
            "tags":[],
            "kind":"functional ",
            "description":"\n A function factory takes an object of the given type and\n returns a function for evaluating it",
            "type":"function",
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "param":{
                "1":[],
                "lf":[]
              },
              "return":[[]],
              "usage":[[]]
            },
            "summary":"an anonymous function as a string.",
            "lineno":800,
            "retgroups":[{
                "1":{
                  "text":"a function",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(lf)",
            "usage":["string_lambda '|x|x+1' (2) == 3\nstring_lambda '_+1' (2) == 3\n"],
            "type":"function",
            "name":"string_lambda",
            "params":{
              "map":{
                "lf":" function as a string"
              },
              "1":"lf"
            },
            "tags":[],
            "kind":"functional ",
            "section":"Functional",
            "description":" This string is either of the form\n '|args| expression' or is a function of one argument, '_'",
            "ret":["a function"],
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[[]],
              "see":[[]],
              "param":{
                "1":[],
                "2":[],
                "p":[],
                "fn":[]
              },
              "raise":[],
              "usage":[[]]
            },
            "summary":"bind the first argument of the function to a value.",
            "lineno":817,
            "retgroups":[{
                "1":{
                  "text":"a function such that f(x) is fn(p,x)",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(fn, p)",
            "usage":["local function f(msg, name)\n  print(msg .. \" \" .. name)\nend\n\nlocal hello = utils.bind1(f, \"Hello\")\n\nprint(hello(\"world\"))     --> \"Hello world\"\nprint(hello(\"sunshine\"))  --> \"Hello sunshine\"\n"],
            "raise":"same as @{function_arg}",
            "name":"bind1",
            "params":{
              "1":"fn",
              "2":"p",
              "map":{
                "p":" a value",
                "fn":" a function of at least two values (may be an operator string)"
              }
            },
            "tags":{
              "see":[]
            },
            "kind":"functional ",
            "section":"Functional",
            "type":"function",
            "parameter":"param",
            "ret":["a function such that f(x) is fn(p,x)"],
            "description":""
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[]],
              "param":{
                "1":[],
                "2":[],
                "p":[],
                "fn":[]
              },
              "raise":[],
              "return":[[]]
            },
            "summary":"bind the second argument of the function to a value.",
            "lineno":836,
            "retgroups":[{
                "1":{
                  "text":"a function such that f(x) is fn(x,p)",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(fn, p)",
            "usage":["local function f(a, b, c)\n  print(a .. \" \" .. b .. \" \" .. c)\nend\n\nlocal hello = utils.bind1(f, \"world\")\n\nprint(hello(\"Hello\", \"!\"))  --> \"Hello world !\"\nprint(hello(\"Bye\", \"?\"))    --> \"Bye world ?\"\n"],
            "raise":"same as @{function_arg}",
            "name":"bind2",
            "params":{
              "1":"fn",
              "2":"p",
              "map":{
                "p":" a value",
                "fn":" a function of at least two values (may be an operator string)"
              }
            },
            "tags":[],
            "kind":"functional ",
            "section":"Functional",
            "type":"function",
            "parameter":"param",
            "ret":["a function such that f(x) is fn(x,p)"],
            "description":""
          },{
            "name":"deprecation",
            "inferred":true,
            "description":"",
            "file":"<reference cycle>",
            "summary":"",
            "tags":[],
            "lineno":847,
            "display_name":"Deprecation",
            "type":"section",
            "modifiers":[]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":{
                "1":[],
                "func":[]
              },
              "usage":[[]],
              "see":[[]]
            },
            "summary":"Sets a deprecation warning function.",
            "lineno":875,
            "args":"(func)",
            "usage":["-- write to the Nginx logs with OpenResty\nutils.set_deprecation_func(function(msg, trace)\n  ngx.log(ngx.WARN, msg, (trace and (\" \" .. trace) or nil))\nend)\n\n-- disable deprecation warnings\nutils.set_deprecation_func()\n"],
            "section":"Deprecation",
            "name":"set_deprecation_func",
            "parameter":"param",
            "params":{
              "map":{
                "func":" a callback with signature: `function(msg, trace)` both arguments are strings, the latter being optional."
              },
              "1":"func"
            },
            "tags":{
              "see":[]
            },
            "kind":"deprecation ",
            "description":"\n An application can override this function to support proper output of\n deprecation warnings. The warnings can be generated from libraries or\n functions by calling `utils.raise_deprecation`. The default function\n will write to the 'warn' system (introduced in Lua 5.4, or the compatibility\n function from the `compat` module for earlier versions).\n\n Note: only applications should set/change this function, libraries should not.",
            "type":"function"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":{
                "1":[],
                "opts":[]
              },
              "usage":[[]],
              "see":[[]]
            },
            "summary":"raises a deprecation warning.",
            "lineno":907,
            "args":"(opts)",
            "usage":["warn(\"@on\")   -- enable Lua warnings, they are usually off by default\n\nfunction stringx.islower(str)\n  raise_deprecation {\n    source = \"Penlight \" .. utils._VERSION,                   -- optional\n    message = \"function 'islower' was renamed to 'is_lower'\", -- required\n    version_removed = \"2.0.0\",                                -- optional\n    deprecated_after = \"1.2.3\",                               -- optional\n    no_trace = true,                                          -- optional\n  }\n  return stringx.is_lower(str)\nend\n-- output: \"[Penlight 1.9.2] function 'islower' was renamed to 'is_lower' (deprecated after 1.2.3, scheduled for removal in 2.0.0)\"\n"],
            "section":"Deprecation",
            "name":"raise_deprecation",
            "parameter":"param",
            "params":{
              "map":{
                "opts":" options table"
              },
              "1":"opts"
            },
            "tags":{
              "see":[]
            },
            "kind":"deprecation ",
            "description":"\n For options see the usage example below.\n\n Note: the `opts.deprecated_after` field is the last version in which\n a feature or option was NOT YET deprecated! Because when writing the code it\n is quite often not known in what version the code will land. But the last\n released version is usually known.",
            "type":"function"
          }],
        "sections":[],
        "modules":["<reference cycle>"],
        "args":{
          "one":false,
          "module":false,
          "verbose":false,
          "style":"!",
          "template":"!",
          "date":"system",
          "dir":"doc",
          "quiet":false,
          "all":false,
          "ignore":false,
          "colon":false,
          "not_luadoc":false,
          "ext":"html",
          "boilerplate":false,
          "merge":false,
          "filter":"f.filter",
          "package":"/home/cji/portless/Penlight/lua",
          "dump":false,
          "no_args_infer":false,
          "title":"Reference",
          "project":"ldoc",
          "file":"/home/cji/portless/Penlight/lua/pl",
          "format":"discount",
          "simple":false,
          "tags":"none",
          "define":"none",
          "output":"index",
          "unqualified":false,
          "config":"config.ld",
          "fatalwarnings":false,
          "testing":false
        },
        "error":"<type 'function' is not supported by JSON.>",
        "lang":{
          "line_comment":"^%-%-+",
          "start_comment_":"^%-%-%-+",
          "end_comment_":"[^%-]%-%-+[^-]*\n$",
          "extra":[],
          "block_comment":"^%-%-%[=*%[%-+",
          "empty_comment_":"^%-%-%-+%s*$",
          "method_call":":"
        },
        "base":"/home/cji/portless/Penlight/lua"
      },
      "summary":"",
      "tags":[],
      "lineno":683,
      "display_name":"String functions",
      "type":"section",
      "modifiers":[]
    },
    "5":{
      "name":"functional",
      "inferred":true,
      "description":"",
      "file":{
        "warning":"<type 'function' is not supported by JSON.>",
        "filename":"/home/cji/portless/Penlight/lua/pl/utils.lua",
        "items":["<reference cycle>",{
            "inferred":true,
            "description":"",
            "modifiers":{
              "field":[],
              "return":[]
            },
            "summary":"Some standard patterns",
            "lineno":31,
            "args":"(FLOAT, INTEGER, IDEN, FILE)",
            "type":"table",
            "name":"patterns",
            "parameter":"field",
            "params":{
              "1":"FLOAT",
              "2":"INTEGER",
              "3":"IDEN",
              "4":"FILE",
              "map":{
                "FILE":"file",
                "INTEGER":"integer number",
                "IDEN":"identifier",
                "FLOAT":"floating point number"
              }
            },
            "tags":[],
            "kind":"tables",
            "section":"table",
            "subparams":[]
          },{
            "name":"stdmt",
            "section":"table",
            "inferred":true,
            "description":"",
            "kind":"tables",
            "summary":"Standard meta-tables as used by other Penlight modules",
            "params":{
              "1":"List",
              "2":"Map",
              "3":"Set",
              "4":"MultiMap",
              "map":{
                "Map":" the Map metatable",
                "Set":" the Set metatable",
                "MultiMap":" the MultiMap metatable",
                "List":" the List metatable"
              }
            },
            "tags":[],
            "lineno":45,
            "subparams":[],
            "args":"(List, Map, Set, MultiMap)",
            "parameter":"field",
            "type":"table",
            "modifiers":{
              "field":{
                "1":[],
                "2":[],
                "3":[],
                "4":[],
                "Map":[],
                "Set":[],
                "MultiMap":[],
                "List":[]
              },
              "return":[]
            }
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "param":{
                "1":[],
                "...":[]
              },
              "return":[[]],
              "see":[[],[],[]]
            },
            "summary":"pack an argument list into a table.",
            "lineno":60,
            "retgroups":[{
                "1":{
                  "text":"a table with field `n` set to the length",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(...)",
            "section":"function",
            "name":"pack",
            "params":{
              "map":{
                "...":" any arguments"
              },
              "1":"..."
            },
            "tags":{
              "see":[]
            },
            "kind":"functions",
            "description":"",
            "type":"function",
            "ret":["a table with field `n` set to the length"],
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[[]],
              "usage":[[]],
              "param":{
                "1":[],
                "2":{
                  "optchain":true,
                  "opt":true
                },
                "3":{
                  "optchain":true,
                  "opt":true
                },
                "t":[],
                "j":{
                  "optchain":true,
                  "opt":true
                },
                "i":{
                  "optchain":true,
                  "opt":true
                }
              },
              "see":[[],[],[]]
            },
            "summary":"unpack a table and return its contents.",
            "lineno":79,
            "retgroups":[{
                "1":{
                  "text":"multiple return values from the table",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(t[, i[, j]])",
            "usage":["local t = table.pack(nil, nil, nil, 4)\nlocal a, b, c, d = table.unpack(t)   -- this `unpack` is NOT nil-safe, so d == nil\n\nlocal a, b, c, d = utils.unpack(t)   -- this is nil-safe, so d == 4\n"],
            "type":"function",
            "name":"unpack",
            "params":{
              "1":"t",
              "2":"i",
              "map":{
                "t":" table to unpack",
                "j":" index of the last element to unpack, defaults to `t.n` or else `#t`",
                "i":" index from which to start unpacking, defaults to 1"
              },
              "3":"j"
            },
            "tags":{
              "see":[]
            },
            "kind":"functions",
            "section":"function",
            "description":"\n\n NOTE: this implementation differs from the Lua implementation in the way\n that this one DOES honor the `n` field in the table `t`, such that it is 'nil-safe'.",
            "ret":["multiple return values from the table"],
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":{
                "1":[],
                "2":[],
                "fmt":[],
                "...":[]
              }
            },
            "summary":"print an arbitrary number of arguments using a format.",
            "lineno":87,
            "args":"(fmt, ...)",
            "section":"function",
            "name":"printf",
            "params":{
              "1":"fmt",
              "2":"...",
              "map":{
                "fmt":" The format (see `string.format`)",
                "...":" Extra arguments for format"
              }
            },
            "tags":[],
            "kind":"functions",
            "description":"\n Output will be sent to `stdout`.",
            "type":"function",
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":{
                "1":[],
                "2":[],
                "3":[],
                "fmt":[],
                "f":[],
                "...":[]
              }
            },
            "summary":"write an arbitrary number of arguments to a file using a format.",
            "lineno":96,
            "args":"(f, fmt, ...)",
            "section":"function",
            "name":"fprintf",
            "params":{
              "1":"f",
              "2":"fmt",
              "map":{
                "fmt":" The format (see `string.format`).",
                "f":" File handle to write to.",
                "...":" Extra arguments for format"
              },
              "3":"..."
            },
            "tags":[],
            "kind":"functions",
            "description":"",
            "type":"function",
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":{
                "1":[],
                "2":[],
                "t":[],
                "T":[]
              }
            },
            "summary":"take a table and 'inject' it into the local namespace.",
            "lineno":124,
            "args":"(t, T)",
            "section":"function",
            "name":"import",
            "params":{
              "1":"t",
              "2":"T",
              "map":{
                "t":" The table (table), or module name (string), defaults to this `utils` module table",
                "T":" An optional destination table (defaults to callers environment)"
              }
            },
            "tags":[],
            "kind":"functions",
            "description":"",
            "type":"function",
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":{
                "1":[],
                "2":[],
                "3":[],
                "cond":[],
                "value1":[],
                "value2":[]
              }
            },
            "summary":"return either of two values, depending on a condition.",
            "lineno":143,
            "args":"(cond, value1, value2)",
            "section":"function",
            "name":"choose",
            "params":{
              "1":"cond",
              "2":"value1",
              "map":{
                "cond":" A condition",
                "value1":" Value returned if cond is truthy",
                "value2":" Value returned if cond is falsy"
              },
              "3":"value2"
            },
            "tags":[],
            "kind":"functions",
            "description":"",
            "type":"function",
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[[]],
              "param":{
                "1":[],
                "2":{
                  "optchain":true,
                  "opt":true
                },
                "3":{
                  "optchain":true,
                  "opt":true
                },
                "t":[],
                "temp":{
                  "optchain":true,
                  "opt":true
                },
                "tostr":{
                  "optchain":true,
                  "opt":true
                }
              }
            },
            "summary":"convert an array of values to strings.",
            "lineno":152,
            "retgroups":[{
                "1":{
                  "text":"the converted buffer",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(t[, temp[, tostr]])",
            "type":"function",
            "name":"array_tostring",
            "parameter":"param",
            "params":{
              "1":"t",
              "2":"temp",
              "map":{
                "t":" a list-like table",
                "temp":" (table) buffer to use, otherwise allocate",
                "tostr":" custom tostring function, called with (value,index). Defaults to `tostring`."
              },
              "3":"tostr"
            },
            "tags":[],
            "kind":"functions",
            "section":"function",
            "description":"",
            "ret":["the converted buffer"]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[]],
              "param":{
                "1":[],
                "2":[],
                "obj":[],
                "tp":[]
              },
              "return":[[]]
            },
            "summary":"is the object of the specified type?",
            "lineno":172,
            "retgroups":[{
                "1":{
                  "text":"boolean",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(obj, tp)",
            "usage":["utils.is_type(\"hello world\", \"string\")   --> true\n-- or check metatable\nlocal my_mt = {}\nlocal my_obj = setmetatable(my_obj, my_mt)\nutils.is_type(my_obj, my_mt)  --> true\n"],
            "type":"function",
            "name":"is_type",
            "parameter":"param",
            "params":{
              "1":"obj",
              "2":"tp",
              "map":{
                "obj":" An object to check",
                "tp":" String of what type it should be"
              }
            },
            "tags":[],
            "kind":"functions",
            "section":"function",
            "description":"\n If the type is a string, then use type, otherwise compare with metatable",
            "ret":["boolean"]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[]],
              "return":[{
                  "type":"integer"
                },{
                  "type":"any"
                }],
              "param":{
                "1":{
                  "type":"table"
                },
                "2":{
                  "opt":"1",
                  "type":"integer",
                  "optchain":"1"
                },
                "3":{
                  "opt":"t.n or #t",
                  "type":"integer",
                  "optchain":"t.n or #t"
                },
                "4":{
                  "opt":"1",
                  "type":"integer",
                  "optchain":"1"
                },
                "t":{
                  "type":"table"
                },
                "step":{
                  "opt":"1",
                  "type":"integer",
                  "optchain":"1"
                },
                "i_start":{
                  "opt":"1",
                  "type":"integer",
                  "optchain":"1"
                },
                "i_end":{
                  "opt":"t.n or #t",
                  "type":"integer",
                  "optchain":"t.n or #t"
                }
              },
              "see":[[],[]]
            },
            "summary":"an iterator with indices, similar to `ipairs`, but with a range.",
            "lineno":199,
            "retgroups":[{
                "1":{
                  "text":"index",
                  "type":"integer",
                  "mods":{
                    "type":"integer"
                  }
                },
                "2":{
                  "text":"value at index (which can be `nil`!)",
                  "type":"any",
                  "mods":{
                    "type":"any"
                  }
                },
                "g":0
              }],
            "args":"(t[, i_start=1[, i_end=t.n or #t[, step=1]]])",
            "usage":["local t = utils.pack(nil, 123, nil)  -- adds an `n` field when packing\n\nfor i, v in utils.npairs(t, 2) do  -- start at index 2\n  t[i] = tostring(t[i])\nend\n\n-- t = { n = 3, [2] = \"123\", [3] = \"nil\" }\n"],
            "type":"function",
            "name":"npairs",
            "parameter":"param",
            "params":{
              "1":"t",
              "2":"i_start",
              "3":"i_end",
              "4":"step",
              "map":{
                "t":" the table to iterate over",
                "step":" step size",
                "i_start":" start index",
                "i_end":" end index"
              }
            },
            "tags":{
              "see":[]
            },
            "kind":"functions",
            "section":"function",
            "description":"\n This is a nil-safe index based iterator that will return `nil` when there\n is a hole in a list. To be safe ensure that table `t.n` contains the length.",
            "ret":["index","value at index (which can be `nil`!)"]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[]],
              "param":{
                "1":{
                  "type":"table"
                },
                "t":{
                  "type":"table"
                }
              },
              "return":[{
                  "type":"key"
                },{
                  "type":"value"
                }]
            },
            "summary":"an iterator over all non-integer keys (inverse of `ipairs`).",
            "lineno":253,
            "retgroups":[{
                "1":{
                  "text":"",
                  "type":"key",
                  "mods":{
                    "type":"key"
                  }
                },
                "2":{
                  "text":"",
                  "type":"value",
                  "mods":{
                    "type":"value"
                  }
                },
                "g":0
              }],
            "args":"(t)",
            "usage":["local t = {\n  \"hello\",\n  \"world\",\n  hello = \"hallo\",\n  world = \"Welt\",\n}\n\nfor k, v in utils.kpairs(t) do\n  print(\"German: \", v)\nend\n\n-- output;\n-- German: hallo\n-- German: Welt\n"],
            "type":"function",
            "name":"kpairs",
            "parameter":"param",
            "params":{
              "map":{
                "t":" the table to iterate over"
              },
              "1":"t"
            },
            "tags":[],
            "kind":"functions",
            "section":"function",
            "description":"\n It will skip any key that is an integer number, so negative indices or an\n array with holes will not return those either (so it returns slightly less than\n 'the inverse of `ipairs`').\n\n This uses `pairs` under the hood, so any value that is iterable using `pairs`\n will work with this function.",
            "ret":["",""]
          },{
            "name":"Error-handling",
            "inferred":true,
            "description":"",
            "file":"<reference cycle>",
            "summary":"",
            "tags":[],
            "lineno":272,
            "display_name":"Error handling",
            "type":"section",
            "modifiers":[]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[]],
              "param":{
                "1":[],
                "2":[],
                "3":[],
                "4":[],
                "5":[],
                "6":[],
                "n":[],
                "verify":[],
                "val":[],
                "lev":[],
                "msg":[],
                "tp":[]
              },
              "raise":[],
              "return":[[]]
            },
            "summary":"assert that the given argument is in fact of the correct type.",
            "lineno":285,
            "retgroups":[{
                "1":{
                  "text":"the validated value",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(n, val, tp, verify, msg, lev)",
            "usage":["local param1 = assert_arg(1,\"hello\",'table')  --> error: argument 1 expected a 'table', got a 'string'\nlocal param4 = assert_arg(4,'!@#$%^&*','string',path.isdir,'not a directory')\n     --> error: argument 4: '!@#$%^&*' not a directory\n"],
            "raise":"if `val` is not the correct type",
            "name":"assert_arg",
            "params":{
              "1":"n",
              "2":"val",
              "3":"tp",
              "4":"verify",
              "5":"msg",
              "6":"lev",
              "map":{
                "n":" argument index",
                "verify":" an optional verification function",
                "val":" the value",
                "lev":" optional stack position for trace, default 2",
                "msg":" an optional custom message",
                "tp":" the type"
              }
            },
            "tags":[],
            "kind":"error handling ",
            "section":"Error handling",
            "type":"function",
            "parameter":"param",
            "ret":["the validated value"],
            "description":""
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[],[],[]],
              "param":{
                "1":{
                  "type":"table|vararg"
                },
                "...":{
                  "type":"table|vararg"
                }
              },
              "return":[[]]
            },
            "summary":"creates an Enum or constants lookup table for improved error handling.",
            "lineno":355,
            "retgroups":[{
                "1":{
                  "text":"Enum object (read-only table/object)",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(...)",
            "usage":["-- Enum access at runtime\nlocal obj = {}\nobj.MOVEMENT = utils.enum(\"FORWARD\", \"REVERSE\", \"LEFT\", \"RIGHT\")\n\nif current_movement == obj.MOVEMENT.FORWARD then\n  -- do something\n\nelseif current_movement == obj.MOVEMENT.REVERES then\n  -- throws error due to typo 'REVERES', so a silent mistake becomes a hard error\n  -- \"'REVERES' is not a valid value (expected one of: 'FORWARD', 'REVERSE', 'LEFT', 'RIGHT')\"\n\nend\n","-- standardized error codes\nlocal obj = {\n  ERR = utils.enum {\n    NOT_FOUND = \"the item was not found\",\n    OUT_OF_BOUNDS = \"the index is outside the allowed range\"\n  },\n\n  some_method = function(self)\n    return self.ERR.OUT_OF_BOUNDS\n  end,\n}\n\nlocal result, err = obj:some_method()\nif not result then\n  if err == obj.ERR.NOT_FOUND then\n    -- check on error code, not magic strings\n\n  else\n    -- return the error description, contained in the constant\n    return nil, \"error: \"..err  -- \"error: the index is outside the allowed range\"\n  end\nend\n","-- validating/converting user-input\nlocal color = \"purple\"\nlocal ansi_colors = utils.enum {\n  black     = 30,\n  red       = 31,\n  green     = 32,\n}\nlocal color_code, err = ansi_colors(color) -- calling on the object, returns the value from the enum\nif not color_code then\n  print(\"bad 'color', \" .. err)\n  -- \"bad 'color', 'purple' is not a valid value (expected one of: 'black', 'red', 'green')\"\n  os.exit(1)\nend\n"],
            "type":"function",
            "name":"enum",
            "parameter":"param",
            "params":{
              "map":{
                "...":" the input for the Enum. If varargs or an array then the\n values in the Enum will be equal to the names (must be strings), if a hash-table\n then values remain (any type), and the keys must be strings."
              },
              "1":"..."
            },
            "tags":[],
            "kind":"error handling ",
            "section":"Error handling",
            "description":"\n This helps prevent magic strings in code by throwing errors for accessing\n non-existing values, and/or converting strings/identifiers to other values.\n\n Calling on the object does the same, but returns a soft error; `nil + err`, if\n the call is succesful (the key exists), it will return the value.\n\n When calling with varargs or an array the values will be equal to the keys.\n The enum object is read-only.",
            "ret":["Enum object (read-only table/object)"]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "param":{
                "1":[],
                "2":[],
                "3":[],
                "f":[],
                "msg":[],
                "idx":[]
              },
              "raise":[],
              "return":[[]]
            },
            "summary":"process a function argument.",
            "lineno":430,
            "retgroups":[{
                "1":{
                  "text":"a callable",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(idx, f, msg)",
            "type":"function",
            "name":"function_arg",
            "params":{
              "1":"idx",
              "2":"f",
              "map":{
                "f":" a function, operator string, or callable object",
                "msg":" optional error message",
                "idx":" argument index"
              },
              "3":"msg"
            },
            "tags":[],
            "kind":"error handling ",
            "section":"Error handling",
            "description":"\n This is used throughout Penlight and defines what is meant by a function:\n Something that is callable, or an operator string as defined by <code>pl.operator</code>,\n such as '>' or '#'. If a function factory has been registered for the type, it will\n be called to get the function.",
            "raise":"if idx is not a number or if f is not callable",
            "ret":["a callable"],
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[]],
              "param":{
                "1":[],
                "2":[],
                "val":[],
                "n":[]
              },
              "raise":[],
              "return":[[]]
            },
            "summary":"assert the common case that the argument is a string.",
            "lineno":470,
            "retgroups":[{
                "1":{
                  "text":"the validated value",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(n, val)",
            "usage":["local val = 42\nlocal param2 = utils.assert_string(2, val) --> error: argument 2 expected a 'string', got a 'number'\n"],
            "raise":"val must be a string",
            "name":"assert_string",
            "params":{
              "1":"n",
              "2":"val",
              "map":{
                "val":" a value that must be a string",
                "n":" argument index"
              }
            },
            "tags":[],
            "kind":"error handling ",
            "section":"Error handling",
            "type":"function",
            "parameter":"param",
            "ret":["the validated value"],
            "description":""
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "param":{
                "1":[],
                "mode":[]
              },
              "return":[],
              "see":[[]]
            },
            "summary":"control the error strategy used by Penlight.",
            "lineno":483,
            "args":"(mode)",
            "section":"Error handling",
            "name":"on_error",
            "params":{
              "map":{
                "mode":" either 'default', 'quit'  or 'error'"
              },
              "1":"mode"
            },
            "tags":{
              "see":[]
            },
            "kind":"error handling ",
            "description":"\n This is a global setting that controls how `utils.raise` behaves:\n\n - 'default': return `nil + error` (this is the default)\n - 'error': throw a Lua error\n - 'quit': exit the program\n",
            "type":"function",
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":{
                "1":[],
                "err":[]
              },
              "usage":[[]],
              "see":[[]]
            },
            "summary":"used by Penlight functions to return errors.",
            "lineno":507,
            "args":"(err)",
            "usage":["if some_condition then\n  return utils.raise(\"some condition was not met\")  -- MUST use 'return'!\nend\n"],
            "section":"Error handling",
            "name":"raise",
            "parameter":"param",
            "params":{
              "map":{
                "err":" the error string."
              },
              "1":"err"
            },
            "tags":{
              "see":[]
            },
            "kind":"error handling ",
            "description":" Its global behaviour is controlled\n by `utils.on_error`.\n To use this function you MUST use it in conjunction with `return`, since it might\n return `nil + error`.",
            "type":"function"
          },{
            "name":"files",
            "inferred":true,
            "description":"",
            "file":"<reference cycle>",
            "summary":"",
            "tags":[],
            "lineno":523,
            "display_name":"File handling",
            "type":"section",
            "modifiers":[]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[[]],
              "param":{
                "1":[],
                "2":[],
                "filename":[],
                "is_bin":[]
              }
            },
            "summary":"return the contents of a file as a string",
            "lineno":527,
            "retgroups":[{
                "1":{
                  "text":"file contents",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(filename, is_bin)",
            "type":"function",
            "name":"readfile",
            "parameter":"param",
            "params":{
              "1":"filename",
              "2":"is_bin",
              "map":{
                "filename":" The file path",
                "is_bin":" open in binary mode"
              }
            },
            "tags":[],
            "kind":"file handling ",
            "section":"File handling",
            "description":"",
            "ret":["file contents"]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "param":{
                "1":[],
                "2":[],
                "3":[],
                "filename":[],
                "str":[],
                "is_bin":[]
              },
              "raise":[],
              "return":[[],[]]
            },
            "summary":"write a string to a file",
            "lineno":549,
            "retgroups":[{
                "1":{
                  "text":"true or nil",
                  "type":"",
                  "mods":[]
                },
                "2":{
                  "text":"error message",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(filename, str, is_bin)",
            "type":"function",
            "name":"writefile",
            "params":{
              "1":"filename",
              "2":"str",
              "map":{
                "filename":" The file path",
                "str":" The string",
                "is_bin":" open in binary mode"
              },
              "3":"is_bin"
            },
            "tags":[],
            "kind":"file handling ",
            "section":"File handling",
            "description":"",
            "raise":"error if filename or str aren't strings",
            "ret":["true or nil","error message"],
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "param":{
                "1":[],
                "filename":[]
              },
              "raise":[],
              "return":[[]]
            },
            "summary":"return the contents of a file as a list of lines",
            "lineno":569,
            "retgroups":[{
                "1":{
                  "text":"file contents as a table",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(filename)",
            "type":"function",
            "name":"readlines",
            "params":{
              "map":{
                "filename":" The file path"
              },
              "1":"filename"
            },
            "tags":[],
            "kind":"file handling ",
            "section":"File handling",
            "description":"",
            "raise":"error if filename is not a string",
            "ret":["file contents as a table"],
            "parameter":"param"
          },{
            "name":"OS-functions",
            "inferred":true,
            "description":"",
            "file":"<reference cycle>",
            "summary":"",
            "tags":[],
            "lineno":584,
            "display_name":"OS functions",
            "type":"section",
            "modifiers":[]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[[],[],[],[]],
              "param":{
                "1":[],
                "2":[],
                "bin":[],
                "cmd":[]
              }
            },
            "summary":"execute a shell command and return the output.",
            "lineno":592,
            "retgroups":[{
                "1":{
                  "text":"true if successful",
                  "type":"",
                  "mods":[]
                },
                "2":{
                  "text":"actual return code",
                  "type":"",
                  "mods":[]
                },
                "3":{
                  "text":"stdout output (string)",
                  "type":"",
                  "mods":[]
                },
                "4":{
                  "text":"errout output (string)",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(cmd, bin)",
            "type":"function",
            "name":"executeex",
            "parameter":"param",
            "params":{
              "1":"cmd",
              "2":"bin",
              "map":{
                "bin":" boolean, if true, read output as binary file",
                "cmd":" a shell command"
              }
            },
            "tags":[],
            "kind":"os functions ",
            "section":"OS functions",
            "description":"\n This function redirects the output to tempfiles and returns the content of those files.",
            "ret":["true if successful","actual return code","stdout output (string)","errout output (string)"]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[]],
              "param":{
                "1":[],
                "argument":[]
              },
              "return":[[]]
            },
            "summary":"Quote and escape an argument of a command.",
            "lineno":623,
            "retgroups":[{
                "1":{
                  "text":"quoted and escaped argument.",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(argument)",
            "usage":["local options = utils.quote_arg {\n    \"-lluacov\",\n    \"-e\",\n    \"utils = print(require('pl.utils')._VERSION\",\n}\n-- returns: -lluacov -e 'utils = print(require('\\''pl.utils'\\'')._VERSION'\n"],
            "type":"function",
            "name":"quote_arg",
            "parameter":"param",
            "params":{
              "map":{
                "argument":" (string or table/list) the argument to quote. If a list then\n all arguments in the list will be returned as a single string quoted."
              },
              "1":"argument"
            },
            "tags":[],
            "kind":"os functions ",
            "section":"OS functions",
            "description":"\n Quotes a single (or list of) argument(s) of a command to be passed\n to `os.execute`, `pl.utils.execute` or `pl.utils.executeex`.",
            "ret":["quoted and escaped argument."]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":{
                "1":{
                  "opt":true
                },
                "2":[],
                "3":[],
                "msg":[],
                "...":[],
                "code":{
                  "opt":true
                }
              },
              "usage":[[]],
              "see":[[]]
            },
            "summary":"error out of this program gracefully.",
            "lineno":667,
            "args":"([code], msg, ...)",
            "usage":["utils.quit(-1, \"Error '%s' happened\", \"42\")\n-- is equivalent to\nutils.quit(\"Error '%s' happened\", \"42\")  --> Error '42' happened\n"],
            "section":"OS functions",
            "name":"quit",
            "parameter":"param",
            "params":{
              "1":"code",
              "2":"msg",
              "map":{
                "msg":" The exit message will be sent to `stderr` (will be formatted with the extra parameters)",
                "...":" extra arguments for message's format'",
                "code":" The exit code, defaults to -`1` if omitted"
              },
              "3":"..."
            },
            "tags":{
              "see":[]
            },
            "kind":"os functions ",
            "description":"",
            "type":"function"
          },{
            "name":"string-functions",
            "inferred":true,
            "description":"",
            "file":"<reference cycle>",
            "summary":"",
            "tags":[],
            "lineno":683,
            "display_name":"String functions",
            "type":"section",
            "modifiers":[]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":{
                "1":[],
                "s":[]
              }
            },
            "summary":"escape any Lua 'magic' characters in a string",
            "lineno":685,
            "args":"(s)",
            "section":"String functions",
            "name":"escape",
            "params":{
              "map":{
                "s":" The input string"
              },
              "1":"s"
            },
            "tags":[],
            "kind":"string functions ",
            "description":"",
            "type":"function",
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "param":{
                "1":[],
                "2":[],
                "3":[],
                "4":[],
                "re":[],
                "n":[],
                "s":[],
                "plain":[]
              },
              "return":[[]],
              "raise":[],
              "see":[[]]
            },
            "summary":"split a string into a list of strings separated by a delimiter.",
            "lineno":698,
            "retgroups":[{
                "1":{
                  "text":"a list-like table",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s, re, plain, n)",
            "type":"function",
            "name":"split",
            "params":{
              "1":"s",
              "2":"re",
              "3":"plain",
              "4":"n",
              "map":{
                "re":" optional A Lua string pattern; defaults to '%s+'",
                "n":" optional maximum number of elements (if there are more, the last will remian un-split)",
                "s":" The input string",
                "plain":" optional If truthy don't use Lua patterns"
              }
            },
            "tags":{
              "see":[]
            },
            "kind":"string functions ",
            "section":"String functions",
            "description":"",
            "raise":"error if s is not a string",
            "ret":["a list-like table"],
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "param":{
                "1":[],
                "2":[],
                "3":[],
                "4":[],
                "re":[],
                "n":[],
                "s":[],
                "plain":[]
              },
              "return":[[]],
              "usage":[[]],
              "see":[[]]
            },
            "summary":"split a string into a number of return values.",
            "lineno":735,
            "retgroups":[{
                "1":{
                  "text":"n values",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s, re, plain, n)",
            "usage":["first,next = splitv('user=jane=doe','=', false, 2)\nassert(first == \"user\")\nassert(next == \"jane=doe\")\n"],
            "type":"function",
            "name":"splitv",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"re",
              "3":"plain",
              "4":"n",
              "map":{
                "re":" A Lua string pattern; defaults to '%s+'",
                "n":" optional maximum number of splits",
                "s":" the string",
                "plain":" don't use Lua patterns"
              }
            },
            "tags":{
              "see":[]
            },
            "kind":"string functions ",
            "section":"String functions",
            "description":"\n Identical to `split` but returns multiple sub-strings instead of\n a single list of sub-strings.",
            "ret":["n values"]
          },"<reference cycle>",{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[[]],
              "param":{
                "1":[],
                "func":[]
              }
            },
            "summary":"'memoize' a function (cache returned value for next call).",
            "lineno":750,
            "retgroups":[{
                "1":{
                  "text":"a function with at least one argument, which is used as the key.",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(func)",
            "type":"function",
            "name":"memoize",
            "parameter":"param",
            "params":{
              "map":{
                "func":" a function of at least one argument"
              },
              "1":"func"
            },
            "tags":[],
            "kind":"functional ",
            "section":"Functional",
            "description":"\n This is useful if you have a function which is relatively expensive,\n but you don't know in advance what values will be required, so\n building a table upfront is wasteful/impossible.",
            "ret":["a function with at least one argument, which is used as the key."]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":{
                "1":{
                  "type":"tab"
                },
                "2":{
                  "type":"func"
                },
                "fun":{
                  "type":"func"
                },
                "mt":{
                  "type":"tab"
                }
              }
            },
            "summary":"associate a function factory with a type.",
            "lineno":768,
            "args":"(mt, fun)",
            "section":"Functional",
            "name":"add_function_factory",
            "params":{
              "1":"mt",
              "2":"fun",
              "map":{
                "fun":" a callable that returns a function",
                "mt":" metatable"
              }
            },
            "tags":[],
            "kind":"functional ",
            "description":"\n A function factory takes an object of the given type and\n returns a function for evaluating it",
            "type":"function",
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "param":{
                "1":[],
                "lf":[]
              },
              "return":[[]],
              "usage":[[]]
            },
            "summary":"an anonymous function as a string.",
            "lineno":800,
            "retgroups":[{
                "1":{
                  "text":"a function",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(lf)",
            "usage":["string_lambda '|x|x+1' (2) == 3\nstring_lambda '_+1' (2) == 3\n"],
            "type":"function",
            "name":"string_lambda",
            "params":{
              "map":{
                "lf":" function as a string"
              },
              "1":"lf"
            },
            "tags":[],
            "kind":"functional ",
            "section":"Functional",
            "description":" This string is either of the form\n '|args| expression' or is a function of one argument, '_'",
            "ret":["a function"],
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[[]],
              "see":[[]],
              "param":{
                "1":[],
                "2":[],
                "p":[],
                "fn":[]
              },
              "raise":[],
              "usage":[[]]
            },
            "summary":"bind the first argument of the function to a value.",
            "lineno":817,
            "retgroups":[{
                "1":{
                  "text":"a function such that f(x) is fn(p,x)",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(fn, p)",
            "usage":["local function f(msg, name)\n  print(msg .. \" \" .. name)\nend\n\nlocal hello = utils.bind1(f, \"Hello\")\n\nprint(hello(\"world\"))     --> \"Hello world\"\nprint(hello(\"sunshine\"))  --> \"Hello sunshine\"\n"],
            "raise":"same as @{function_arg}",
            "name":"bind1",
            "params":{
              "1":"fn",
              "2":"p",
              "map":{
                "p":" a value",
                "fn":" a function of at least two values (may be an operator string)"
              }
            },
            "tags":{
              "see":[]
            },
            "kind":"functional ",
            "section":"Functional",
            "type":"function",
            "parameter":"param",
            "ret":["a function such that f(x) is fn(p,x)"],
            "description":""
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[]],
              "param":{
                "1":[],
                "2":[],
                "p":[],
                "fn":[]
              },
              "raise":[],
              "return":[[]]
            },
            "summary":"bind the second argument of the function to a value.",
            "lineno":836,
            "retgroups":[{
                "1":{
                  "text":"a function such that f(x) is fn(x,p)",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(fn, p)",
            "usage":["local function f(a, b, c)\n  print(a .. \" \" .. b .. \" \" .. c)\nend\n\nlocal hello = utils.bind1(f, \"world\")\n\nprint(hello(\"Hello\", \"!\"))  --> \"Hello world !\"\nprint(hello(\"Bye\", \"?\"))    --> \"Bye world ?\"\n"],
            "raise":"same as @{function_arg}",
            "name":"bind2",
            "params":{
              "1":"fn",
              "2":"p",
              "map":{
                "p":" a value",
                "fn":" a function of at least two values (may be an operator string)"
              }
            },
            "tags":[],
            "kind":"functional ",
            "section":"Functional",
            "type":"function",
            "parameter":"param",
            "ret":["a function such that f(x) is fn(x,p)"],
            "description":""
          },{
            "name":"deprecation",
            "inferred":true,
            "description":"",
            "file":"<reference cycle>",
            "summary":"",
            "tags":[],
            "lineno":847,
            "display_name":"Deprecation",
            "type":"section",
            "modifiers":[]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":{
                "1":[],
                "func":[]
              },
              "usage":[[]],
              "see":[[]]
            },
            "summary":"Sets a deprecation warning function.",
            "lineno":875,
            "args":"(func)",
            "usage":["-- write to the Nginx logs with OpenResty\nutils.set_deprecation_func(function(msg, trace)\n  ngx.log(ngx.WARN, msg, (trace and (\" \" .. trace) or nil))\nend)\n\n-- disable deprecation warnings\nutils.set_deprecation_func()\n"],
            "section":"Deprecation",
            "name":"set_deprecation_func",
            "parameter":"param",
            "params":{
              "map":{
                "func":" a callback with signature: `function(msg, trace)` both arguments are strings, the latter being optional."
              },
              "1":"func"
            },
            "tags":{
              "see":[]
            },
            "kind":"deprecation ",
            "description":"\n An application can override this function to support proper output of\n deprecation warnings. The warnings can be generated from libraries or\n functions by calling `utils.raise_deprecation`. The default function\n will write to the 'warn' system (introduced in Lua 5.4, or the compatibility\n function from the `compat` module for earlier versions).\n\n Note: only applications should set/change this function, libraries should not.",
            "type":"function"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":{
                "1":[],
                "opts":[]
              },
              "usage":[[]],
              "see":[[]]
            },
            "summary":"raises a deprecation warning.",
            "lineno":907,
            "args":"(opts)",
            "usage":["warn(\"@on\")   -- enable Lua warnings, they are usually off by default\n\nfunction stringx.islower(str)\n  raise_deprecation {\n    source = \"Penlight \" .. utils._VERSION,                   -- optional\n    message = \"function 'islower' was renamed to 'is_lower'\", -- required\n    version_removed = \"2.0.0\",                                -- optional\n    deprecated_after = \"1.2.3\",                               -- optional\n    no_trace = true,                                          -- optional\n  }\n  return stringx.is_lower(str)\nend\n-- output: \"[Penlight 1.9.2] function 'islower' was renamed to 'is_lower' (deprecated after 1.2.3, scheduled for removal in 2.0.0)\"\n"],
            "section":"Deprecation",
            "name":"raise_deprecation",
            "parameter":"param",
            "params":{
              "map":{
                "opts":" options table"
              },
              "1":"opts"
            },
            "tags":{
              "see":[]
            },
            "kind":"deprecation ",
            "description":"\n For options see the usage example below.\n\n Note: the `opts.deprecated_after` field is the last version in which\n a feature or option was NOT YET deprecated! Because when writing the code it\n is quite often not known in what version the code will land. But the last\n released version is usually known.",
            "type":"function"
          }],
        "sections":[],
        "modules":["<reference cycle>"],
        "args":{
          "one":false,
          "module":false,
          "verbose":false,
          "style":"!",
          "template":"!",
          "date":"system",
          "dir":"doc",
          "quiet":false,
          "all":false,
          "ignore":false,
          "colon":false,
          "not_luadoc":false,
          "ext":"html",
          "boilerplate":false,
          "merge":false,
          "filter":"f.filter",
          "package":"/home/cji/portless/Penlight/lua",
          "dump":false,
          "no_args_infer":false,
          "title":"Reference",
          "project":"ldoc",
          "file":"/home/cji/portless/Penlight/lua/pl",
          "format":"discount",
          "simple":false,
          "tags":"none",
          "define":"none",
          "output":"index",
          "unqualified":false,
          "config":"config.ld",
          "fatalwarnings":false,
          "testing":false
        },
        "error":"<type 'function' is not supported by JSON.>",
        "lang":{
          "line_comment":"^%-%-+",
          "start_comment_":"^%-%-%-+",
          "end_comment_":"[^%-]%-%-+[^-]*\n$",
          "extra":[],
          "block_comment":"^%-%-%[=*%[%-+",
          "empty_comment_":"^%-%-%-+%s*$",
          "method_call":":"
        },
        "base":"/home/cji/portless/Penlight/lua"
      },
      "summary":"",
      "tags":[],
      "lineno":744,
      "display_name":"Functional",
      "type":"section",
      "modifiers":[]
    },
    "6":{
      "name":"deprecation",
      "inferred":true,
      "description":"",
      "file":{
        "warning":"<type 'function' is not supported by JSON.>",
        "filename":"/home/cji/portless/Penlight/lua/pl/utils.lua",
        "items":["<reference cycle>",{
            "inferred":true,
            "description":"",
            "modifiers":{
              "field":[],
              "return":[]
            },
            "summary":"Some standard patterns",
            "lineno":31,
            "args":"(FLOAT, INTEGER, IDEN, FILE)",
            "type":"table",
            "name":"patterns",
            "parameter":"field",
            "params":{
              "1":"FLOAT",
              "2":"INTEGER",
              "3":"IDEN",
              "4":"FILE",
              "map":{
                "FILE":"file",
                "INTEGER":"integer number",
                "IDEN":"identifier",
                "FLOAT":"floating point number"
              }
            },
            "tags":[],
            "kind":"tables",
            "section":"table",
            "subparams":[]
          },{
            "name":"stdmt",
            "section":"table",
            "inferred":true,
            "description":"",
            "kind":"tables",
            "summary":"Standard meta-tables as used by other Penlight modules",
            "params":{
              "1":"List",
              "2":"Map",
              "3":"Set",
              "4":"MultiMap",
              "map":{
                "Map":" the Map metatable",
                "Set":" the Set metatable",
                "MultiMap":" the MultiMap metatable",
                "List":" the List metatable"
              }
            },
            "tags":[],
            "lineno":45,
            "subparams":[],
            "args":"(List, Map, Set, MultiMap)",
            "parameter":"field",
            "type":"table",
            "modifiers":{
              "field":{
                "1":[],
                "2":[],
                "3":[],
                "4":[],
                "Map":[],
                "Set":[],
                "MultiMap":[],
                "List":[]
              },
              "return":[]
            }
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "param":{
                "1":[],
                "...":[]
              },
              "return":[[]],
              "see":[[],[],[]]
            },
            "summary":"pack an argument list into a table.",
            "lineno":60,
            "retgroups":[{
                "1":{
                  "text":"a table with field `n` set to the length",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(...)",
            "section":"function",
            "name":"pack",
            "params":{
              "map":{
                "...":" any arguments"
              },
              "1":"..."
            },
            "tags":{
              "see":[]
            },
            "kind":"functions",
            "description":"",
            "type":"function",
            "ret":["a table with field `n` set to the length"],
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[[]],
              "usage":[[]],
              "param":{
                "1":[],
                "2":{
                  "optchain":true,
                  "opt":true
                },
                "3":{
                  "optchain":true,
                  "opt":true
                },
                "t":[],
                "j":{
                  "optchain":true,
                  "opt":true
                },
                "i":{
                  "optchain":true,
                  "opt":true
                }
              },
              "see":[[],[],[]]
            },
            "summary":"unpack a table and return its contents.",
            "lineno":79,
            "retgroups":[{
                "1":{
                  "text":"multiple return values from the table",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(t[, i[, j]])",
            "usage":["local t = table.pack(nil, nil, nil, 4)\nlocal a, b, c, d = table.unpack(t)   -- this `unpack` is NOT nil-safe, so d == nil\n\nlocal a, b, c, d = utils.unpack(t)   -- this is nil-safe, so d == 4\n"],
            "type":"function",
            "name":"unpack",
            "params":{
              "1":"t",
              "2":"i",
              "map":{
                "t":" table to unpack",
                "j":" index of the last element to unpack, defaults to `t.n` or else `#t`",
                "i":" index from which to start unpacking, defaults to 1"
              },
              "3":"j"
            },
            "tags":{
              "see":[]
            },
            "kind":"functions",
            "section":"function",
            "description":"\n\n NOTE: this implementation differs from the Lua implementation in the way\n that this one DOES honor the `n` field in the table `t`, such that it is 'nil-safe'.",
            "ret":["multiple return values from the table"],
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":{
                "1":[],
                "2":[],
                "fmt":[],
                "...":[]
              }
            },
            "summary":"print an arbitrary number of arguments using a format.",
            "lineno":87,
            "args":"(fmt, ...)",
            "section":"function",
            "name":"printf",
            "params":{
              "1":"fmt",
              "2":"...",
              "map":{
                "fmt":" The format (see `string.format`)",
                "...":" Extra arguments for format"
              }
            },
            "tags":[],
            "kind":"functions",
            "description":"\n Output will be sent to `stdout`.",
            "type":"function",
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":{
                "1":[],
                "2":[],
                "3":[],
                "fmt":[],
                "f":[],
                "...":[]
              }
            },
            "summary":"write an arbitrary number of arguments to a file using a format.",
            "lineno":96,
            "args":"(f, fmt, ...)",
            "section":"function",
            "name":"fprintf",
            "params":{
              "1":"f",
              "2":"fmt",
              "map":{
                "fmt":" The format (see `string.format`).",
                "f":" File handle to write to.",
                "...":" Extra arguments for format"
              },
              "3":"..."
            },
            "tags":[],
            "kind":"functions",
            "description":"",
            "type":"function",
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":{
                "1":[],
                "2":[],
                "t":[],
                "T":[]
              }
            },
            "summary":"take a table and 'inject' it into the local namespace.",
            "lineno":124,
            "args":"(t, T)",
            "section":"function",
            "name":"import",
            "params":{
              "1":"t",
              "2":"T",
              "map":{
                "t":" The table (table), or module name (string), defaults to this `utils` module table",
                "T":" An optional destination table (defaults to callers environment)"
              }
            },
            "tags":[],
            "kind":"functions",
            "description":"",
            "type":"function",
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":{
                "1":[],
                "2":[],
                "3":[],
                "cond":[],
                "value1":[],
                "value2":[]
              }
            },
            "summary":"return either of two values, depending on a condition.",
            "lineno":143,
            "args":"(cond, value1, value2)",
            "section":"function",
            "name":"choose",
            "params":{
              "1":"cond",
              "2":"value1",
              "map":{
                "cond":" A condition",
                "value1":" Value returned if cond is truthy",
                "value2":" Value returned if cond is falsy"
              },
              "3":"value2"
            },
            "tags":[],
            "kind":"functions",
            "description":"",
            "type":"function",
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[[]],
              "param":{
                "1":[],
                "2":{
                  "optchain":true,
                  "opt":true
                },
                "3":{
                  "optchain":true,
                  "opt":true
                },
                "t":[],
                "temp":{
                  "optchain":true,
                  "opt":true
                },
                "tostr":{
                  "optchain":true,
                  "opt":true
                }
              }
            },
            "summary":"convert an array of values to strings.",
            "lineno":152,
            "retgroups":[{
                "1":{
                  "text":"the converted buffer",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(t[, temp[, tostr]])",
            "type":"function",
            "name":"array_tostring",
            "parameter":"param",
            "params":{
              "1":"t",
              "2":"temp",
              "map":{
                "t":" a list-like table",
                "temp":" (table) buffer to use, otherwise allocate",
                "tostr":" custom tostring function, called with (value,index). Defaults to `tostring`."
              },
              "3":"tostr"
            },
            "tags":[],
            "kind":"functions",
            "section":"function",
            "description":"",
            "ret":["the converted buffer"]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[]],
              "param":{
                "1":[],
                "2":[],
                "obj":[],
                "tp":[]
              },
              "return":[[]]
            },
            "summary":"is the object of the specified type?",
            "lineno":172,
            "retgroups":[{
                "1":{
                  "text":"boolean",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(obj, tp)",
            "usage":["utils.is_type(\"hello world\", \"string\")   --> true\n-- or check metatable\nlocal my_mt = {}\nlocal my_obj = setmetatable(my_obj, my_mt)\nutils.is_type(my_obj, my_mt)  --> true\n"],
            "type":"function",
            "name":"is_type",
            "parameter":"param",
            "params":{
              "1":"obj",
              "2":"tp",
              "map":{
                "obj":" An object to check",
                "tp":" String of what type it should be"
              }
            },
            "tags":[],
            "kind":"functions",
            "section":"function",
            "description":"\n If the type is a string, then use type, otherwise compare with metatable",
            "ret":["boolean"]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[]],
              "return":[{
                  "type":"integer"
                },{
                  "type":"any"
                }],
              "param":{
                "1":{
                  "type":"table"
                },
                "2":{
                  "opt":"1",
                  "type":"integer",
                  "optchain":"1"
                },
                "3":{
                  "opt":"t.n or #t",
                  "type":"integer",
                  "optchain":"t.n or #t"
                },
                "4":{
                  "opt":"1",
                  "type":"integer",
                  "optchain":"1"
                },
                "t":{
                  "type":"table"
                },
                "step":{
                  "opt":"1",
                  "type":"integer",
                  "optchain":"1"
                },
                "i_start":{
                  "opt":"1",
                  "type":"integer",
                  "optchain":"1"
                },
                "i_end":{
                  "opt":"t.n or #t",
                  "type":"integer",
                  "optchain":"t.n or #t"
                }
              },
              "see":[[],[]]
            },
            "summary":"an iterator with indices, similar to `ipairs`, but with a range.",
            "lineno":199,
            "retgroups":[{
                "1":{
                  "text":"index",
                  "type":"integer",
                  "mods":{
                    "type":"integer"
                  }
                },
                "2":{
                  "text":"value at index (which can be `nil`!)",
                  "type":"any",
                  "mods":{
                    "type":"any"
                  }
                },
                "g":0
              }],
            "args":"(t[, i_start=1[, i_end=t.n or #t[, step=1]]])",
            "usage":["local t = utils.pack(nil, 123, nil)  -- adds an `n` field when packing\n\nfor i, v in utils.npairs(t, 2) do  -- start at index 2\n  t[i] = tostring(t[i])\nend\n\n-- t = { n = 3, [2] = \"123\", [3] = \"nil\" }\n"],
            "type":"function",
            "name":"npairs",
            "parameter":"param",
            "params":{
              "1":"t",
              "2":"i_start",
              "3":"i_end",
              "4":"step",
              "map":{
                "t":" the table to iterate over",
                "step":" step size",
                "i_start":" start index",
                "i_end":" end index"
              }
            },
            "tags":{
              "see":[]
            },
            "kind":"functions",
            "section":"function",
            "description":"\n This is a nil-safe index based iterator that will return `nil` when there\n is a hole in a list. To be safe ensure that table `t.n` contains the length.",
            "ret":["index","value at index (which can be `nil`!)"]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[]],
              "param":{
                "1":{
                  "type":"table"
                },
                "t":{
                  "type":"table"
                }
              },
              "return":[{
                  "type":"key"
                },{
                  "type":"value"
                }]
            },
            "summary":"an iterator over all non-integer keys (inverse of `ipairs`).",
            "lineno":253,
            "retgroups":[{
                "1":{
                  "text":"",
                  "type":"key",
                  "mods":{
                    "type":"key"
                  }
                },
                "2":{
                  "text":"",
                  "type":"value",
                  "mods":{
                    "type":"value"
                  }
                },
                "g":0
              }],
            "args":"(t)",
            "usage":["local t = {\n  \"hello\",\n  \"world\",\n  hello = \"hallo\",\n  world = \"Welt\",\n}\n\nfor k, v in utils.kpairs(t) do\n  print(\"German: \", v)\nend\n\n-- output;\n-- German: hallo\n-- German: Welt\n"],
            "type":"function",
            "name":"kpairs",
            "parameter":"param",
            "params":{
              "map":{
                "t":" the table to iterate over"
              },
              "1":"t"
            },
            "tags":[],
            "kind":"functions",
            "section":"function",
            "description":"\n It will skip any key that is an integer number, so negative indices or an\n array with holes will not return those either (so it returns slightly less than\n 'the inverse of `ipairs`').\n\n This uses `pairs` under the hood, so any value that is iterable using `pairs`\n will work with this function.",
            "ret":["",""]
          },{
            "name":"Error-handling",
            "inferred":true,
            "description":"",
            "file":"<reference cycle>",
            "summary":"",
            "tags":[],
            "lineno":272,
            "display_name":"Error handling",
            "type":"section",
            "modifiers":[]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[]],
              "param":{
                "1":[],
                "2":[],
                "3":[],
                "4":[],
                "5":[],
                "6":[],
                "n":[],
                "verify":[],
                "val":[],
                "lev":[],
                "msg":[],
                "tp":[]
              },
              "raise":[],
              "return":[[]]
            },
            "summary":"assert that the given argument is in fact of the correct type.",
            "lineno":285,
            "retgroups":[{
                "1":{
                  "text":"the validated value",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(n, val, tp, verify, msg, lev)",
            "usage":["local param1 = assert_arg(1,\"hello\",'table')  --> error: argument 1 expected a 'table', got a 'string'\nlocal param4 = assert_arg(4,'!@#$%^&*','string',path.isdir,'not a directory')\n     --> error: argument 4: '!@#$%^&*' not a directory\n"],
            "raise":"if `val` is not the correct type",
            "name":"assert_arg",
            "params":{
              "1":"n",
              "2":"val",
              "3":"tp",
              "4":"verify",
              "5":"msg",
              "6":"lev",
              "map":{
                "n":" argument index",
                "verify":" an optional verification function",
                "val":" the value",
                "lev":" optional stack position for trace, default 2",
                "msg":" an optional custom message",
                "tp":" the type"
              }
            },
            "tags":[],
            "kind":"error handling ",
            "section":"Error handling",
            "type":"function",
            "parameter":"param",
            "ret":["the validated value"],
            "description":""
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[],[],[]],
              "param":{
                "1":{
                  "type":"table|vararg"
                },
                "...":{
                  "type":"table|vararg"
                }
              },
              "return":[[]]
            },
            "summary":"creates an Enum or constants lookup table for improved error handling.",
            "lineno":355,
            "retgroups":[{
                "1":{
                  "text":"Enum object (read-only table/object)",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(...)",
            "usage":["-- Enum access at runtime\nlocal obj = {}\nobj.MOVEMENT = utils.enum(\"FORWARD\", \"REVERSE\", \"LEFT\", \"RIGHT\")\n\nif current_movement == obj.MOVEMENT.FORWARD then\n  -- do something\n\nelseif current_movement == obj.MOVEMENT.REVERES then\n  -- throws error due to typo 'REVERES', so a silent mistake becomes a hard error\n  -- \"'REVERES' is not a valid value (expected one of: 'FORWARD', 'REVERSE', 'LEFT', 'RIGHT')\"\n\nend\n","-- standardized error codes\nlocal obj = {\n  ERR = utils.enum {\n    NOT_FOUND = \"the item was not found\",\n    OUT_OF_BOUNDS = \"the index is outside the allowed range\"\n  },\n\n  some_method = function(self)\n    return self.ERR.OUT_OF_BOUNDS\n  end,\n}\n\nlocal result, err = obj:some_method()\nif not result then\n  if err == obj.ERR.NOT_FOUND then\n    -- check on error code, not magic strings\n\n  else\n    -- return the error description, contained in the constant\n    return nil, \"error: \"..err  -- \"error: the index is outside the allowed range\"\n  end\nend\n","-- validating/converting user-input\nlocal color = \"purple\"\nlocal ansi_colors = utils.enum {\n  black     = 30,\n  red       = 31,\n  green     = 32,\n}\nlocal color_code, err = ansi_colors(color) -- calling on the object, returns the value from the enum\nif not color_code then\n  print(\"bad 'color', \" .. err)\n  -- \"bad 'color', 'purple' is not a valid value (expected one of: 'black', 'red', 'green')\"\n  os.exit(1)\nend\n"],
            "type":"function",
            "name":"enum",
            "parameter":"param",
            "params":{
              "map":{
                "...":" the input for the Enum. If varargs or an array then the\n values in the Enum will be equal to the names (must be strings), if a hash-table\n then values remain (any type), and the keys must be strings."
              },
              "1":"..."
            },
            "tags":[],
            "kind":"error handling ",
            "section":"Error handling",
            "description":"\n This helps prevent magic strings in code by throwing errors for accessing\n non-existing values, and/or converting strings/identifiers to other values.\n\n Calling on the object does the same, but returns a soft error; `nil + err`, if\n the call is succesful (the key exists), it will return the value.\n\n When calling with varargs or an array the values will be equal to the keys.\n The enum object is read-only.",
            "ret":["Enum object (read-only table/object)"]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "param":{
                "1":[],
                "2":[],
                "3":[],
                "f":[],
                "msg":[],
                "idx":[]
              },
              "raise":[],
              "return":[[]]
            },
            "summary":"process a function argument.",
            "lineno":430,
            "retgroups":[{
                "1":{
                  "text":"a callable",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(idx, f, msg)",
            "type":"function",
            "name":"function_arg",
            "params":{
              "1":"idx",
              "2":"f",
              "map":{
                "f":" a function, operator string, or callable object",
                "msg":" optional error message",
                "idx":" argument index"
              },
              "3":"msg"
            },
            "tags":[],
            "kind":"error handling ",
            "section":"Error handling",
            "description":"\n This is used throughout Penlight and defines what is meant by a function:\n Something that is callable, or an operator string as defined by <code>pl.operator</code>,\n such as '>' or '#'. If a function factory has been registered for the type, it will\n be called to get the function.",
            "raise":"if idx is not a number or if f is not callable",
            "ret":["a callable"],
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[]],
              "param":{
                "1":[],
                "2":[],
                "val":[],
                "n":[]
              },
              "raise":[],
              "return":[[]]
            },
            "summary":"assert the common case that the argument is a string.",
            "lineno":470,
            "retgroups":[{
                "1":{
                  "text":"the validated value",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(n, val)",
            "usage":["local val = 42\nlocal param2 = utils.assert_string(2, val) --> error: argument 2 expected a 'string', got a 'number'\n"],
            "raise":"val must be a string",
            "name":"assert_string",
            "params":{
              "1":"n",
              "2":"val",
              "map":{
                "val":" a value that must be a string",
                "n":" argument index"
              }
            },
            "tags":[],
            "kind":"error handling ",
            "section":"Error handling",
            "type":"function",
            "parameter":"param",
            "ret":["the validated value"],
            "description":""
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "param":{
                "1":[],
                "mode":[]
              },
              "return":[],
              "see":[[]]
            },
            "summary":"control the error strategy used by Penlight.",
            "lineno":483,
            "args":"(mode)",
            "section":"Error handling",
            "name":"on_error",
            "params":{
              "map":{
                "mode":" either 'default', 'quit'  or 'error'"
              },
              "1":"mode"
            },
            "tags":{
              "see":[]
            },
            "kind":"error handling ",
            "description":"\n This is a global setting that controls how `utils.raise` behaves:\n\n - 'default': return `nil + error` (this is the default)\n - 'error': throw a Lua error\n - 'quit': exit the program\n",
            "type":"function",
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":{
                "1":[],
                "err":[]
              },
              "usage":[[]],
              "see":[[]]
            },
            "summary":"used by Penlight functions to return errors.",
            "lineno":507,
            "args":"(err)",
            "usage":["if some_condition then\n  return utils.raise(\"some condition was not met\")  -- MUST use 'return'!\nend\n"],
            "section":"Error handling",
            "name":"raise",
            "parameter":"param",
            "params":{
              "map":{
                "err":" the error string."
              },
              "1":"err"
            },
            "tags":{
              "see":[]
            },
            "kind":"error handling ",
            "description":" Its global behaviour is controlled\n by `utils.on_error`.\n To use this function you MUST use it in conjunction with `return`, since it might\n return `nil + error`.",
            "type":"function"
          },{
            "name":"files",
            "inferred":true,
            "description":"",
            "file":"<reference cycle>",
            "summary":"",
            "tags":[],
            "lineno":523,
            "display_name":"File handling",
            "type":"section",
            "modifiers":[]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[[]],
              "param":{
                "1":[],
                "2":[],
                "filename":[],
                "is_bin":[]
              }
            },
            "summary":"return the contents of a file as a string",
            "lineno":527,
            "retgroups":[{
                "1":{
                  "text":"file contents",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(filename, is_bin)",
            "type":"function",
            "name":"readfile",
            "parameter":"param",
            "params":{
              "1":"filename",
              "2":"is_bin",
              "map":{
                "filename":" The file path",
                "is_bin":" open in binary mode"
              }
            },
            "tags":[],
            "kind":"file handling ",
            "section":"File handling",
            "description":"",
            "ret":["file contents"]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "param":{
                "1":[],
                "2":[],
                "3":[],
                "filename":[],
                "str":[],
                "is_bin":[]
              },
              "raise":[],
              "return":[[],[]]
            },
            "summary":"write a string to a file",
            "lineno":549,
            "retgroups":[{
                "1":{
                  "text":"true or nil",
                  "type":"",
                  "mods":[]
                },
                "2":{
                  "text":"error message",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(filename, str, is_bin)",
            "type":"function",
            "name":"writefile",
            "params":{
              "1":"filename",
              "2":"str",
              "map":{
                "filename":" The file path",
                "str":" The string",
                "is_bin":" open in binary mode"
              },
              "3":"is_bin"
            },
            "tags":[],
            "kind":"file handling ",
            "section":"File handling",
            "description":"",
            "raise":"error if filename or str aren't strings",
            "ret":["true or nil","error message"],
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "param":{
                "1":[],
                "filename":[]
              },
              "raise":[],
              "return":[[]]
            },
            "summary":"return the contents of a file as a list of lines",
            "lineno":569,
            "retgroups":[{
                "1":{
                  "text":"file contents as a table",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(filename)",
            "type":"function",
            "name":"readlines",
            "params":{
              "map":{
                "filename":" The file path"
              },
              "1":"filename"
            },
            "tags":[],
            "kind":"file handling ",
            "section":"File handling",
            "description":"",
            "raise":"error if filename is not a string",
            "ret":["file contents as a table"],
            "parameter":"param"
          },{
            "name":"OS-functions",
            "inferred":true,
            "description":"",
            "file":"<reference cycle>",
            "summary":"",
            "tags":[],
            "lineno":584,
            "display_name":"OS functions",
            "type":"section",
            "modifiers":[]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[[],[],[],[]],
              "param":{
                "1":[],
                "2":[],
                "bin":[],
                "cmd":[]
              }
            },
            "summary":"execute a shell command and return the output.",
            "lineno":592,
            "retgroups":[{
                "1":{
                  "text":"true if successful",
                  "type":"",
                  "mods":[]
                },
                "2":{
                  "text":"actual return code",
                  "type":"",
                  "mods":[]
                },
                "3":{
                  "text":"stdout output (string)",
                  "type":"",
                  "mods":[]
                },
                "4":{
                  "text":"errout output (string)",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(cmd, bin)",
            "type":"function",
            "name":"executeex",
            "parameter":"param",
            "params":{
              "1":"cmd",
              "2":"bin",
              "map":{
                "bin":" boolean, if true, read output as binary file",
                "cmd":" a shell command"
              }
            },
            "tags":[],
            "kind":"os functions ",
            "section":"OS functions",
            "description":"\n This function redirects the output to tempfiles and returns the content of those files.",
            "ret":["true if successful","actual return code","stdout output (string)","errout output (string)"]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[]],
              "param":{
                "1":[],
                "argument":[]
              },
              "return":[[]]
            },
            "summary":"Quote and escape an argument of a command.",
            "lineno":623,
            "retgroups":[{
                "1":{
                  "text":"quoted and escaped argument.",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(argument)",
            "usage":["local options = utils.quote_arg {\n    \"-lluacov\",\n    \"-e\",\n    \"utils = print(require('pl.utils')._VERSION\",\n}\n-- returns: -lluacov -e 'utils = print(require('\\''pl.utils'\\'')._VERSION'\n"],
            "type":"function",
            "name":"quote_arg",
            "parameter":"param",
            "params":{
              "map":{
                "argument":" (string or table/list) the argument to quote. If a list then\n all arguments in the list will be returned as a single string quoted."
              },
              "1":"argument"
            },
            "tags":[],
            "kind":"os functions ",
            "section":"OS functions",
            "description":"\n Quotes a single (or list of) argument(s) of a command to be passed\n to `os.execute`, `pl.utils.execute` or `pl.utils.executeex`.",
            "ret":["quoted and escaped argument."]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":{
                "1":{
                  "opt":true
                },
                "2":[],
                "3":[],
                "msg":[],
                "...":[],
                "code":{
                  "opt":true
                }
              },
              "usage":[[]],
              "see":[[]]
            },
            "summary":"error out of this program gracefully.",
            "lineno":667,
            "args":"([code], msg, ...)",
            "usage":["utils.quit(-1, \"Error '%s' happened\", \"42\")\n-- is equivalent to\nutils.quit(\"Error '%s' happened\", \"42\")  --> Error '42' happened\n"],
            "section":"OS functions",
            "name":"quit",
            "parameter":"param",
            "params":{
              "1":"code",
              "2":"msg",
              "map":{
                "msg":" The exit message will be sent to `stderr` (will be formatted with the extra parameters)",
                "...":" extra arguments for message's format'",
                "code":" The exit code, defaults to -`1` if omitted"
              },
              "3":"..."
            },
            "tags":{
              "see":[]
            },
            "kind":"os functions ",
            "description":"",
            "type":"function"
          },{
            "name":"string-functions",
            "inferred":true,
            "description":"",
            "file":"<reference cycle>",
            "summary":"",
            "tags":[],
            "lineno":683,
            "display_name":"String functions",
            "type":"section",
            "modifiers":[]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":{
                "1":[],
                "s":[]
              }
            },
            "summary":"escape any Lua 'magic' characters in a string",
            "lineno":685,
            "args":"(s)",
            "section":"String functions",
            "name":"escape",
            "params":{
              "map":{
                "s":" The input string"
              },
              "1":"s"
            },
            "tags":[],
            "kind":"string functions ",
            "description":"",
            "type":"function",
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "param":{
                "1":[],
                "2":[],
                "3":[],
                "4":[],
                "re":[],
                "n":[],
                "s":[],
                "plain":[]
              },
              "return":[[]],
              "raise":[],
              "see":[[]]
            },
            "summary":"split a string into a list of strings separated by a delimiter.",
            "lineno":698,
            "retgroups":[{
                "1":{
                  "text":"a list-like table",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s, re, plain, n)",
            "type":"function",
            "name":"split",
            "params":{
              "1":"s",
              "2":"re",
              "3":"plain",
              "4":"n",
              "map":{
                "re":" optional A Lua string pattern; defaults to '%s+'",
                "n":" optional maximum number of elements (if there are more, the last will remian un-split)",
                "s":" The input string",
                "plain":" optional If truthy don't use Lua patterns"
              }
            },
            "tags":{
              "see":[]
            },
            "kind":"string functions ",
            "section":"String functions",
            "description":"",
            "raise":"error if s is not a string",
            "ret":["a list-like table"],
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "param":{
                "1":[],
                "2":[],
                "3":[],
                "4":[],
                "re":[],
                "n":[],
                "s":[],
                "plain":[]
              },
              "return":[[]],
              "usage":[[]],
              "see":[[]]
            },
            "summary":"split a string into a number of return values.",
            "lineno":735,
            "retgroups":[{
                "1":{
                  "text":"n values",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(s, re, plain, n)",
            "usage":["first,next = splitv('user=jane=doe','=', false, 2)\nassert(first == \"user\")\nassert(next == \"jane=doe\")\n"],
            "type":"function",
            "name":"splitv",
            "parameter":"param",
            "params":{
              "1":"s",
              "2":"re",
              "3":"plain",
              "4":"n",
              "map":{
                "re":" A Lua string pattern; defaults to '%s+'",
                "n":" optional maximum number of splits",
                "s":" the string",
                "plain":" don't use Lua patterns"
              }
            },
            "tags":{
              "see":[]
            },
            "kind":"string functions ",
            "section":"String functions",
            "description":"\n Identical to `split` but returns multiple sub-strings instead of\n a single list of sub-strings.",
            "ret":["n values"]
          },{
            "name":"functional",
            "inferred":true,
            "description":"",
            "file":"<reference cycle>",
            "summary":"",
            "tags":[],
            "lineno":744,
            "display_name":"Functional",
            "type":"section",
            "modifiers":[]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[[]],
              "param":{
                "1":[],
                "func":[]
              }
            },
            "summary":"'memoize' a function (cache returned value for next call).",
            "lineno":750,
            "retgroups":[{
                "1":{
                  "text":"a function with at least one argument, which is used as the key.",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(func)",
            "type":"function",
            "name":"memoize",
            "parameter":"param",
            "params":{
              "map":{
                "func":" a function of at least one argument"
              },
              "1":"func"
            },
            "tags":[],
            "kind":"functional ",
            "section":"Functional",
            "description":"\n This is useful if you have a function which is relatively expensive,\n but you don't know in advance what values will be required, so\n building a table upfront is wasteful/impossible.",
            "ret":["a function with at least one argument, which is used as the key."]
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":{
                "1":{
                  "type":"tab"
                },
                "2":{
                  "type":"func"
                },
                "fun":{
                  "type":"func"
                },
                "mt":{
                  "type":"tab"
                }
              }
            },
            "summary":"associate a function factory with a type.",
            "lineno":768,
            "args":"(mt, fun)",
            "section":"Functional",
            "name":"add_function_factory",
            "params":{
              "1":"mt",
              "2":"fun",
              "map":{
                "fun":" a callable that returns a function",
                "mt":" metatable"
              }
            },
            "tags":[],
            "kind":"functional ",
            "description":"\n A function factory takes an object of the given type and\n returns a function for evaluating it",
            "type":"function",
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "param":{
                "1":[],
                "lf":[]
              },
              "return":[[]],
              "usage":[[]]
            },
            "summary":"an anonymous function as a string.",
            "lineno":800,
            "retgroups":[{
                "1":{
                  "text":"a function",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(lf)",
            "usage":["string_lambda '|x|x+1' (2) == 3\nstring_lambda '_+1' (2) == 3\n"],
            "type":"function",
            "name":"string_lambda",
            "params":{
              "map":{
                "lf":" function as a string"
              },
              "1":"lf"
            },
            "tags":[],
            "kind":"functional ",
            "section":"Functional",
            "description":" This string is either of the form\n '|args| expression' or is a function of one argument, '_'",
            "ret":["a function"],
            "parameter":"param"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[[]],
              "see":[[]],
              "param":{
                "1":[],
                "2":[],
                "p":[],
                "fn":[]
              },
              "raise":[],
              "usage":[[]]
            },
            "summary":"bind the first argument of the function to a value.",
            "lineno":817,
            "retgroups":[{
                "1":{
                  "text":"a function such that f(x) is fn(p,x)",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(fn, p)",
            "usage":["local function f(msg, name)\n  print(msg .. \" \" .. name)\nend\n\nlocal hello = utils.bind1(f, \"Hello\")\n\nprint(hello(\"world\"))     --> \"Hello world\"\nprint(hello(\"sunshine\"))  --> \"Hello sunshine\"\n"],
            "raise":"same as @{function_arg}",
            "name":"bind1",
            "params":{
              "1":"fn",
              "2":"p",
              "map":{
                "p":" a value",
                "fn":" a function of at least two values (may be an operator string)"
              }
            },
            "tags":{
              "see":[]
            },
            "kind":"functional ",
            "section":"Functional",
            "type":"function",
            "parameter":"param",
            "ret":["a function such that f(x) is fn(p,x)"],
            "description":""
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "usage":[[]],
              "param":{
                "1":[],
                "2":[],
                "p":[],
                "fn":[]
              },
              "raise":[],
              "return":[[]]
            },
            "summary":"bind the second argument of the function to a value.",
            "lineno":836,
            "retgroups":[{
                "1":{
                  "text":"a function such that f(x) is fn(x,p)",
                  "type":"",
                  "mods":[]
                },
                "g":0
              }],
            "args":"(fn, p)",
            "usage":["local function f(a, b, c)\n  print(a .. \" \" .. b .. \" \" .. c)\nend\n\nlocal hello = utils.bind1(f, \"world\")\n\nprint(hello(\"Hello\", \"!\"))  --> \"Hello world !\"\nprint(hello(\"Bye\", \"?\"))    --> \"Bye world ?\"\n"],
            "raise":"same as @{function_arg}",
            "name":"bind2",
            "params":{
              "1":"fn",
              "2":"p",
              "map":{
                "p":" a value",
                "fn":" a function of at least two values (may be an operator string)"
              }
            },
            "tags":[],
            "kind":"functional ",
            "section":"Functional",
            "type":"function",
            "parameter":"param",
            "ret":["a function such that f(x) is fn(x,p)"],
            "description":""
          },"<reference cycle>",{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":{
                "1":[],
                "func":[]
              },
              "usage":[[]],
              "see":[[]]
            },
            "summary":"Sets a deprecation warning function.",
            "lineno":875,
            "args":"(func)",
            "usage":["-- write to the Nginx logs with OpenResty\nutils.set_deprecation_func(function(msg, trace)\n  ngx.log(ngx.WARN, msg, (trace and (\" \" .. trace) or nil))\nend)\n\n-- disable deprecation warnings\nutils.set_deprecation_func()\n"],
            "section":"Deprecation",
            "name":"set_deprecation_func",
            "parameter":"param",
            "params":{
              "map":{
                "func":" a callback with signature: `function(msg, trace)` both arguments are strings, the latter being optional."
              },
              "1":"func"
            },
            "tags":{
              "see":[]
            },
            "kind":"deprecation ",
            "description":"\n An application can override this function to support proper output of\n deprecation warnings. The warnings can be generated from libraries or\n functions by calling `utils.raise_deprecation`. The default function\n will write to the 'warn' system (introduced in Lua 5.4, or the compatibility\n function from the `compat` module for earlier versions).\n\n Note: only applications should set/change this function, libraries should not.",
            "type":"function"
          },{
            "inferred":true,
            "subparams":[],
            "modifiers":{
              "return":[],
              "param":{
                "1":[],
                "opts":[]
              },
              "usage":[[]],
              "see":[[]]
            },
            "summary":"raises a deprecation warning.",
            "lineno":907,
            "args":"(opts)",
            "usage":["warn(\"@on\")   -- enable Lua warnings, they are usually off by default\n\nfunction stringx.islower(str)\n  raise_deprecation {\n    source = \"Penlight \" .. utils._VERSION,                   -- optional\n    message = \"function 'islower' was renamed to 'is_lower'\", -- required\n    version_removed = \"2.0.0\",                                -- optional\n    deprecated_after = \"1.2.3\",                               -- optional\n    no_trace = true,                                          -- optional\n  }\n  return stringx.is_lower(str)\nend\n-- output: \"[Penlight 1.9.2] function 'islower' was renamed to 'is_lower' (deprecated after 1.2.3, scheduled for removal in 2.0.0)\"\n"],
            "section":"Deprecation",
            "name":"raise_deprecation",
            "parameter":"param",
            "params":{
              "map":{
                "opts":" options table"
              },
              "1":"opts"
            },
            "tags":{
              "see":[]
            },
            "kind":"deprecation ",
            "description":"\n For options see the usage example below.\n\n Note: the `opts.deprecated_after` field is the last version in which\n a feature or option was NOT YET deprecated! Because when writing the code it\n is quite often not known in what version the code will land. But the last\n released version is usually known.",
            "type":"function"
          }],
        "sections":[],
        "modules":["<reference cycle>"],
        "args":{
          "one":false,
          "module":false,
          "verbose":false,
          "style":"!",
          "template":"!",
          "date":"system",
          "dir":"doc",
          "quiet":false,
          "all":false,
          "ignore":false,
          "colon":false,
          "not_luadoc":false,
          "ext":"html",
          "boilerplate":false,
          "merge":false,
          "filter":"f.filter",
          "package":"/home/cji/portless/Penlight/lua",
          "dump":false,
          "no_args_infer":false,
          "title":"Reference",
          "project":"ldoc",
          "file":"/home/cji/portless/Penlight/lua/pl",
          "format":"discount",
          "simple":false,
          "tags":"none",
          "define":"none",
          "output":"index",
          "unqualified":false,
          "config":"config.ld",
          "fatalwarnings":false,
          "testing":false
        },
        "error":"<type 'function' is not supported by JSON.>",
        "lang":{
          "line_comment":"^%-%-+",
          "start_comment_":"^%-%-%-+",
          "end_comment_":"[^%-]%-%-+[^-]*\n$",
          "extra":[],
          "block_comment":"^%-%-%[=*%[%-+",
          "empty_comment_":"^%-%-%-+%s*$",
          "method_call":":"
        },
        "base":"/home/cji/portless/Penlight/lua"
      },
      "summary":"",
      "tags":[],
      "lineno":847,
      "display_name":"Deprecation",
      "type":"section",
      "modifiers":[]
    },
    "by_name":{
      "File_handling":{
        "name":"files",
        "inferred":true,
        "description":"",
        "file":{
          "warning":"<type 'function' is not supported by JSON.>",
          "filename":"/home/cji/portless/Penlight/lua/pl/utils.lua",
          "items":["<reference cycle>",{
              "inferred":true,
              "description":"",
              "modifiers":{
                "field":[],
                "return":[]
              },
              "summary":"Some standard patterns",
              "lineno":31,
              "args":"(FLOAT, INTEGER, IDEN, FILE)",
              "type":"table",
              "name":"patterns",
              "parameter":"field",
              "params":{
                "1":"FLOAT",
                "2":"INTEGER",
                "3":"IDEN",
                "4":"FILE",
                "map":{
                  "FILE":"file",
                  "INTEGER":"integer number",
                  "IDEN":"identifier",
                  "FLOAT":"floating point number"
                }
              },
              "tags":[],
              "kind":"tables",
              "section":"table",
              "subparams":[]
            },{
              "name":"stdmt",
              "section":"table",
              "inferred":true,
              "description":"",
              "kind":"tables",
              "summary":"Standard meta-tables as used by other Penlight modules",
              "params":{
                "1":"List",
                "2":"Map",
                "3":"Set",
                "4":"MultiMap",
                "map":{
                  "Map":" the Map metatable",
                  "Set":" the Set metatable",
                  "MultiMap":" the MultiMap metatable",
                  "List":" the List metatable"
                }
              },
              "tags":[],
              "lineno":45,
              "subparams":[],
              "args":"(List, Map, Set, MultiMap)",
              "parameter":"field",
              "type":"table",
              "modifiers":{
                "field":{
                  "1":[],
                  "2":[],
                  "3":[],
                  "4":[],
                  "Map":[],
                  "Set":[],
                  "MultiMap":[],
                  "List":[]
                },
                "return":[]
              }
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "param":{
                  "1":[],
                  "...":[]
                },
                "return":[[]],
                "see":[[],[],[]]
              },
              "summary":"pack an argument list into a table.",
              "lineno":60,
              "retgroups":[{
                  "1":{
                    "text":"a table with field `n` set to the length",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(...)",
              "section":"function",
              "name":"pack",
              "params":{
                "map":{
                  "...":" any arguments"
                },
                "1":"..."
              },
              "tags":{
                "see":[]
              },
              "kind":"functions",
              "description":"",
              "type":"function",
              "ret":["a table with field `n` set to the length"],
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[[]],
                "usage":[[]],
                "param":{
                  "1":[],
                  "2":{
                    "optchain":true,
                    "opt":true
                  },
                  "3":{
                    "optchain":true,
                    "opt":true
                  },
                  "t":[],
                  "j":{
                    "optchain":true,
                    "opt":true
                  },
                  "i":{
                    "optchain":true,
                    "opt":true
                  }
                },
                "see":[[],[],[]]
              },
              "summary":"unpack a table and return its contents.",
              "lineno":79,
              "retgroups":[{
                  "1":{
                    "text":"multiple return values from the table",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(t[, i[, j]])",
              "usage":["local t = table.pack(nil, nil, nil, 4)\nlocal a, b, c, d = table.unpack(t)   -- this `unpack` is NOT nil-safe, so d == nil\n\nlocal a, b, c, d = utils.unpack(t)   -- this is nil-safe, so d == 4\n"],
              "type":"function",
              "name":"unpack",
              "params":{
                "1":"t",
                "2":"i",
                "map":{
                  "t":" table to unpack",
                  "j":" index of the last element to unpack, defaults to `t.n` or else `#t`",
                  "i":" index from which to start unpacking, defaults to 1"
                },
                "3":"j"
              },
              "tags":{
                "see":[]
              },
              "kind":"functions",
              "section":"function",
              "description":"\n\n NOTE: this implementation differs from the Lua implementation in the way\n that this one DOES honor the `n` field in the table `t`, such that it is 'nil-safe'.",
              "ret":["multiple return values from the table"],
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":{
                  "1":[],
                  "2":[],
                  "fmt":[],
                  "...":[]
                }
              },
              "summary":"print an arbitrary number of arguments using a format.",
              "lineno":87,
              "args":"(fmt, ...)",
              "section":"function",
              "name":"printf",
              "params":{
                "1":"fmt",
                "2":"...",
                "map":{
                  "fmt":" The format (see `string.format`)",
                  "...":" Extra arguments for format"
                }
              },
              "tags":[],
              "kind":"functions",
              "description":"\n Output will be sent to `stdout`.",
              "type":"function",
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":{
                  "1":[],
                  "2":[],
                  "3":[],
                  "fmt":[],
                  "f":[],
                  "...":[]
                }
              },
              "summary":"write an arbitrary number of arguments to a file using a format.",
              "lineno":96,
              "args":"(f, fmt, ...)",
              "section":"function",
              "name":"fprintf",
              "params":{
                "1":"f",
                "2":"fmt",
                "map":{
                  "fmt":" The format (see `string.format`).",
                  "f":" File handle to write to.",
                  "...":" Extra arguments for format"
                },
                "3":"..."
              },
              "tags":[],
              "kind":"functions",
              "description":"",
              "type":"function",
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":{
                  "1":[],
                  "2":[],
                  "t":[],
                  "T":[]
                }
              },
              "summary":"take a table and 'inject' it into the local namespace.",
              "lineno":124,
              "args":"(t, T)",
              "section":"function",
              "name":"import",
              "params":{
                "1":"t",
                "2":"T",
                "map":{
                  "t":" The table (table), or module name (string), defaults to this `utils` module table",
                  "T":" An optional destination table (defaults to callers environment)"
                }
              },
              "tags":[],
              "kind":"functions",
              "description":"",
              "type":"function",
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":{
                  "1":[],
                  "2":[],
                  "3":[],
                  "cond":[],
                  "value1":[],
                  "value2":[]
                }
              },
              "summary":"return either of two values, depending on a condition.",
              "lineno":143,
              "args":"(cond, value1, value2)",
              "section":"function",
              "name":"choose",
              "params":{
                "1":"cond",
                "2":"value1",
                "map":{
                  "cond":" A condition",
                  "value1":" Value returned if cond is truthy",
                  "value2":" Value returned if cond is falsy"
                },
                "3":"value2"
              },
              "tags":[],
              "kind":"functions",
              "description":"",
              "type":"function",
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[[]],
                "param":{
                  "1":[],
                  "2":{
                    "optchain":true,
                    "opt":true
                  },
                  "3":{
                    "optchain":true,
                    "opt":true
                  },
                  "t":[],
                  "temp":{
                    "optchain":true,
                    "opt":true
                  },
                  "tostr":{
                    "optchain":true,
                    "opt":true
                  }
                }
              },
              "summary":"convert an array of values to strings.",
              "lineno":152,
              "retgroups":[{
                  "1":{
                    "text":"the converted buffer",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(t[, temp[, tostr]])",
              "type":"function",
              "name":"array_tostring",
              "parameter":"param",
              "params":{
                "1":"t",
                "2":"temp",
                "map":{
                  "t":" a list-like table",
                  "temp":" (table) buffer to use, otherwise allocate",
                  "tostr":" custom tostring function, called with (value,index). Defaults to `tostring`."
                },
                "3":"tostr"
              },
              "tags":[],
              "kind":"functions",
              "section":"function",
              "description":"",
              "ret":["the converted buffer"]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[]],
                "param":{
                  "1":[],
                  "2":[],
                  "obj":[],
                  "tp":[]
                },
                "return":[[]]
              },
              "summary":"is the object of the specified type?",
              "lineno":172,
              "retgroups":[{
                  "1":{
                    "text":"boolean",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(obj, tp)",
              "usage":["utils.is_type(\"hello world\", \"string\")   --> true\n-- or check metatable\nlocal my_mt = {}\nlocal my_obj = setmetatable(my_obj, my_mt)\nutils.is_type(my_obj, my_mt)  --> true\n"],
              "type":"function",
              "name":"is_type",
              "parameter":"param",
              "params":{
                "1":"obj",
                "2":"tp",
                "map":{
                  "obj":" An object to check",
                  "tp":" String of what type it should be"
                }
              },
              "tags":[],
              "kind":"functions",
              "section":"function",
              "description":"\n If the type is a string, then use type, otherwise compare with metatable",
              "ret":["boolean"]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[]],
                "return":[{
                    "type":"integer"
                  },{
                    "type":"any"
                  }],
                "param":{
                  "1":{
                    "type":"table"
                  },
                  "2":{
                    "opt":"1",
                    "type":"integer",
                    "optchain":"1"
                  },
                  "3":{
                    "opt":"t.n or #t",
                    "type":"integer",
                    "optchain":"t.n or #t"
                  },
                  "4":{
                    "opt":"1",
                    "type":"integer",
                    "optchain":"1"
                  },
                  "t":{
                    "type":"table"
                  },
                  "step":{
                    "opt":"1",
                    "type":"integer",
                    "optchain":"1"
                  },
                  "i_start":{
                    "opt":"1",
                    "type":"integer",
                    "optchain":"1"
                  },
                  "i_end":{
                    "opt":"t.n or #t",
                    "type":"integer",
                    "optchain":"t.n or #t"
                  }
                },
                "see":[[],[]]
              },
              "summary":"an iterator with indices, similar to `ipairs`, but with a range.",
              "lineno":199,
              "retgroups":[{
                  "1":{
                    "text":"index",
                    "type":"integer",
                    "mods":{
                      "type":"integer"
                    }
                  },
                  "2":{
                    "text":"value at index (which can be `nil`!)",
                    "type":"any",
                    "mods":{
                      "type":"any"
                    }
                  },
                  "g":0
                }],
              "args":"(t[, i_start=1[, i_end=t.n or #t[, step=1]]])",
              "usage":["local t = utils.pack(nil, 123, nil)  -- adds an `n` field when packing\n\nfor i, v in utils.npairs(t, 2) do  -- start at index 2\n  t[i] = tostring(t[i])\nend\n\n-- t = { n = 3, [2] = \"123\", [3] = \"nil\" }\n"],
              "type":"function",
              "name":"npairs",
              "parameter":"param",
              "params":{
                "1":"t",
                "2":"i_start",
                "3":"i_end",
                "4":"step",
                "map":{
                  "t":" the table to iterate over",
                  "step":" step size",
                  "i_start":" start index",
                  "i_end":" end index"
                }
              },
              "tags":{
                "see":[]
              },
              "kind":"functions",
              "section":"function",
              "description":"\n This is a nil-safe index based iterator that will return `nil` when there\n is a hole in a list. To be safe ensure that table `t.n` contains the length.",
              "ret":["index","value at index (which can be `nil`!)"]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[]],
                "param":{
                  "1":{
                    "type":"table"
                  },
                  "t":{
                    "type":"table"
                  }
                },
                "return":[{
                    "type":"key"
                  },{
                    "type":"value"
                  }]
              },
              "summary":"an iterator over all non-integer keys (inverse of `ipairs`).",
              "lineno":253,
              "retgroups":[{
                  "1":{
                    "text":"",
                    "type":"key",
                    "mods":{
                      "type":"key"
                    }
                  },
                  "2":{
                    "text":"",
                    "type":"value",
                    "mods":{
                      "type":"value"
                    }
                  },
                  "g":0
                }],
              "args":"(t)",
              "usage":["local t = {\n  \"hello\",\n  \"world\",\n  hello = \"hallo\",\n  world = \"Welt\",\n}\n\nfor k, v in utils.kpairs(t) do\n  print(\"German: \", v)\nend\n\n-- output;\n-- German: hallo\n-- German: Welt\n"],
              "type":"function",
              "name":"kpairs",
              "parameter":"param",
              "params":{
                "map":{
                  "t":" the table to iterate over"
                },
                "1":"t"
              },
              "tags":[],
              "kind":"functions",
              "section":"function",
              "description":"\n It will skip any key that is an integer number, so negative indices or an\n array with holes will not return those either (so it returns slightly less than\n 'the inverse of `ipairs`').\n\n This uses `pairs` under the hood, so any value that is iterable using `pairs`\n will work with this function.",
              "ret":["",""]
            },{
              "name":"Error-handling",
              "inferred":true,
              "description":"",
              "file":"<reference cycle>",
              "summary":"",
              "tags":[],
              "lineno":272,
              "display_name":"Error handling",
              "type":"section",
              "modifiers":[]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[]],
                "param":{
                  "1":[],
                  "2":[],
                  "3":[],
                  "4":[],
                  "5":[],
                  "6":[],
                  "n":[],
                  "verify":[],
                  "val":[],
                  "lev":[],
                  "msg":[],
                  "tp":[]
                },
                "raise":[],
                "return":[[]]
              },
              "summary":"assert that the given argument is in fact of the correct type.",
              "lineno":285,
              "retgroups":[{
                  "1":{
                    "text":"the validated value",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(n, val, tp, verify, msg, lev)",
              "usage":["local param1 = assert_arg(1,\"hello\",'table')  --> error: argument 1 expected a 'table', got a 'string'\nlocal param4 = assert_arg(4,'!@#$%^&*','string',path.isdir,'not a directory')\n     --> error: argument 4: '!@#$%^&*' not a directory\n"],
              "raise":"if `val` is not the correct type",
              "name":"assert_arg",
              "params":{
                "1":"n",
                "2":"val",
                "3":"tp",
                "4":"verify",
                "5":"msg",
                "6":"lev",
                "map":{
                  "n":" argument index",
                  "verify":" an optional verification function",
                  "val":" the value",
                  "lev":" optional stack position for trace, default 2",
                  "msg":" an optional custom message",
                  "tp":" the type"
                }
              },
              "tags":[],
              "kind":"error handling ",
              "section":"Error handling",
              "type":"function",
              "parameter":"param",
              "ret":["the validated value"],
              "description":""
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[],[],[]],
                "param":{
                  "1":{
                    "type":"table|vararg"
                  },
                  "...":{
                    "type":"table|vararg"
                  }
                },
                "return":[[]]
              },
              "summary":"creates an Enum or constants lookup table for improved error handling.",
              "lineno":355,
              "retgroups":[{
                  "1":{
                    "text":"Enum object (read-only table/object)",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(...)",
              "usage":["-- Enum access at runtime\nlocal obj = {}\nobj.MOVEMENT = utils.enum(\"FORWARD\", \"REVERSE\", \"LEFT\", \"RIGHT\")\n\nif current_movement == obj.MOVEMENT.FORWARD then\n  -- do something\n\nelseif current_movement == obj.MOVEMENT.REVERES then\n  -- throws error due to typo 'REVERES', so a silent mistake becomes a hard error\n  -- \"'REVERES' is not a valid value (expected one of: 'FORWARD', 'REVERSE', 'LEFT', 'RIGHT')\"\n\nend\n","-- standardized error codes\nlocal obj = {\n  ERR = utils.enum {\n    NOT_FOUND = \"the item was not found\",\n    OUT_OF_BOUNDS = \"the index is outside the allowed range\"\n  },\n\n  some_method = function(self)\n    return self.ERR.OUT_OF_BOUNDS\n  end,\n}\n\nlocal result, err = obj:some_method()\nif not result then\n  if err == obj.ERR.NOT_FOUND then\n    -- check on error code, not magic strings\n\n  else\n    -- return the error description, contained in the constant\n    return nil, \"error: \"..err  -- \"error: the index is outside the allowed range\"\n  end\nend\n","-- validating/converting user-input\nlocal color = \"purple\"\nlocal ansi_colors = utils.enum {\n  black     = 30,\n  red       = 31,\n  green     = 32,\n}\nlocal color_code, err = ansi_colors(color) -- calling on the object, returns the value from the enum\nif not color_code then\n  print(\"bad 'color', \" .. err)\n  -- \"bad 'color', 'purple' is not a valid value (expected one of: 'black', 'red', 'green')\"\n  os.exit(1)\nend\n"],
              "type":"function",
              "name":"enum",
              "parameter":"param",
              "params":{
                "map":{
                  "...":" the input for the Enum. If varargs or an array then the\n values in the Enum will be equal to the names (must be strings), if a hash-table\n then values remain (any type), and the keys must be strings."
                },
                "1":"..."
              },
              "tags":[],
              "kind":"error handling ",
              "section":"Error handling",
              "description":"\n This helps prevent magic strings in code by throwing errors for accessing\n non-existing values, and/or converting strings/identifiers to other values.\n\n Calling on the object does the same, but returns a soft error; `nil + err`, if\n the call is succesful (the key exists), it will return the value.\n\n When calling with varargs or an array the values will be equal to the keys.\n The enum object is read-only.",
              "ret":["Enum object (read-only table/object)"]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "param":{
                  "1":[],
                  "2":[],
                  "3":[],
                  "f":[],
                  "msg":[],
                  "idx":[]
                },
                "raise":[],
                "return":[[]]
              },
              "summary":"process a function argument.",
              "lineno":430,
              "retgroups":[{
                  "1":{
                    "text":"a callable",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(idx, f, msg)",
              "type":"function",
              "name":"function_arg",
              "params":{
                "1":"idx",
                "2":"f",
                "map":{
                  "f":" a function, operator string, or callable object",
                  "msg":" optional error message",
                  "idx":" argument index"
                },
                "3":"msg"
              },
              "tags":[],
              "kind":"error handling ",
              "section":"Error handling",
              "description":"\n This is used throughout Penlight and defines what is meant by a function:\n Something that is callable, or an operator string as defined by <code>pl.operator</code>,\n such as '>' or '#'. If a function factory has been registered for the type, it will\n be called to get the function.",
              "raise":"if idx is not a number or if f is not callable",
              "ret":["a callable"],
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[]],
                "param":{
                  "1":[],
                  "2":[],
                  "val":[],
                  "n":[]
                },
                "raise":[],
                "return":[[]]
              },
              "summary":"assert the common case that the argument is a string.",
              "lineno":470,
              "retgroups":[{
                  "1":{
                    "text":"the validated value",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(n, val)",
              "usage":["local val = 42\nlocal param2 = utils.assert_string(2, val) --> error: argument 2 expected a 'string', got a 'number'\n"],
              "raise":"val must be a string",
              "name":"assert_string",
              "params":{
                "1":"n",
                "2":"val",
                "map":{
                  "val":" a value that must be a string",
                  "n":" argument index"
                }
              },
              "tags":[],
              "kind":"error handling ",
              "section":"Error handling",
              "type":"function",
              "parameter":"param",
              "ret":["the validated value"],
              "description":""
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "param":{
                  "1":[],
                  "mode":[]
                },
                "return":[],
                "see":[[]]
              },
              "summary":"control the error strategy used by Penlight.",
              "lineno":483,
              "args":"(mode)",
              "section":"Error handling",
              "name":"on_error",
              "params":{
                "map":{
                  "mode":" either 'default', 'quit'  or 'error'"
                },
                "1":"mode"
              },
              "tags":{
                "see":[]
              },
              "kind":"error handling ",
              "description":"\n This is a global setting that controls how `utils.raise` behaves:\n\n - 'default': return `nil + error` (this is the default)\n - 'error': throw a Lua error\n - 'quit': exit the program\n",
              "type":"function",
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":{
                  "1":[],
                  "err":[]
                },
                "usage":[[]],
                "see":[[]]
              },
              "summary":"used by Penlight functions to return errors.",
              "lineno":507,
              "args":"(err)",
              "usage":["if some_condition then\n  return utils.raise(\"some condition was not met\")  -- MUST use 'return'!\nend\n"],
              "section":"Error handling",
              "name":"raise",
              "parameter":"param",
              "params":{
                "map":{
                  "err":" the error string."
                },
                "1":"err"
              },
              "tags":{
                "see":[]
              },
              "kind":"error handling ",
              "description":" Its global behaviour is controlled\n by `utils.on_error`.\n To use this function you MUST use it in conjunction with `return`, since it might\n return `nil + error`.",
              "type":"function"
            },"<reference cycle>",{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[[]],
                "param":{
                  "1":[],
                  "2":[],
                  "filename":[],
                  "is_bin":[]
                }
              },
              "summary":"return the contents of a file as a string",
              "lineno":527,
              "retgroups":[{
                  "1":{
                    "text":"file contents",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(filename, is_bin)",
              "type":"function",
              "name":"readfile",
              "parameter":"param",
              "params":{
                "1":"filename",
                "2":"is_bin",
                "map":{
                  "filename":" The file path",
                  "is_bin":" open in binary mode"
                }
              },
              "tags":[],
              "kind":"file handling ",
              "section":"File handling",
              "description":"",
              "ret":["file contents"]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "param":{
                  "1":[],
                  "2":[],
                  "3":[],
                  "filename":[],
                  "str":[],
                  "is_bin":[]
                },
                "raise":[],
                "return":[[],[]]
              },
              "summary":"write a string to a file",
              "lineno":549,
              "retgroups":[{
                  "1":{
                    "text":"true or nil",
                    "type":"",
                    "mods":[]
                  },
                  "2":{
                    "text":"error message",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(filename, str, is_bin)",
              "type":"function",
              "name":"writefile",
              "params":{
                "1":"filename",
                "2":"str",
                "map":{
                  "filename":" The file path",
                  "str":" The string",
                  "is_bin":" open in binary mode"
                },
                "3":"is_bin"
              },
              "tags":[],
              "kind":"file handling ",
              "section":"File handling",
              "description":"",
              "raise":"error if filename or str aren't strings",
              "ret":["true or nil","error message"],
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "param":{
                  "1":[],
                  "filename":[]
                },
                "raise":[],
                "return":[[]]
              },
              "summary":"return the contents of a file as a list of lines",
              "lineno":569,
              "retgroups":[{
                  "1":{
                    "text":"file contents as a table",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(filename)",
              "type":"function",
              "name":"readlines",
              "params":{
                "map":{
                  "filename":" The file path"
                },
                "1":"filename"
              },
              "tags":[],
              "kind":"file handling ",
              "section":"File handling",
              "description":"",
              "raise":"error if filename is not a string",
              "ret":["file contents as a table"],
              "parameter":"param"
            },{
              "name":"OS-functions",
              "inferred":true,
              "description":"",
              "file":"<reference cycle>",
              "summary":"",
              "tags":[],
              "lineno":584,
              "display_name":"OS functions",
              "type":"section",
              "modifiers":[]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[[],[],[],[]],
                "param":{
                  "1":[],
                  "2":[],
                  "bin":[],
                  "cmd":[]
                }
              },
              "summary":"execute a shell command and return the output.",
              "lineno":592,
              "retgroups":[{
                  "1":{
                    "text":"true if successful",
                    "type":"",
                    "mods":[]
                  },
                  "2":{
                    "text":"actual return code",
                    "type":"",
                    "mods":[]
                  },
                  "3":{
                    "text":"stdout output (string)",
                    "type":"",
                    "mods":[]
                  },
                  "4":{
                    "text":"errout output (string)",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(cmd, bin)",
              "type":"function",
              "name":"executeex",
              "parameter":"param",
              "params":{
                "1":"cmd",
                "2":"bin",
                "map":{
                  "bin":" boolean, if true, read output as binary file",
                  "cmd":" a shell command"
                }
              },
              "tags":[],
              "kind":"os functions ",
              "section":"OS functions",
              "description":"\n This function redirects the output to tempfiles and returns the content of those files.",
              "ret":["true if successful","actual return code","stdout output (string)","errout output (string)"]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[]],
                "param":{
                  "1":[],
                  "argument":[]
                },
                "return":[[]]
              },
              "summary":"Quote and escape an argument of a command.",
              "lineno":623,
              "retgroups":[{
                  "1":{
                    "text":"quoted and escaped argument.",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(argument)",
              "usage":["local options = utils.quote_arg {\n    \"-lluacov\",\n    \"-e\",\n    \"utils = print(require('pl.utils')._VERSION\",\n}\n-- returns: -lluacov -e 'utils = print(require('\\''pl.utils'\\'')._VERSION'\n"],
              "type":"function",
              "name":"quote_arg",
              "parameter":"param",
              "params":{
                "map":{
                  "argument":" (string or table/list) the argument to quote. If a list then\n all arguments in the list will be returned as a single string quoted."
                },
                "1":"argument"
              },
              "tags":[],
              "kind":"os functions ",
              "section":"OS functions",
              "description":"\n Quotes a single (or list of) argument(s) of a command to be passed\n to `os.execute`, `pl.utils.execute` or `pl.utils.executeex`.",
              "ret":["quoted and escaped argument."]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":{
                  "1":{
                    "opt":true
                  },
                  "2":[],
                  "3":[],
                  "msg":[],
                  "...":[],
                  "code":{
                    "opt":true
                  }
                },
                "usage":[[]],
                "see":[[]]
              },
              "summary":"error out of this program gracefully.",
              "lineno":667,
              "args":"([code], msg, ...)",
              "usage":["utils.quit(-1, \"Error '%s' happened\", \"42\")\n-- is equivalent to\nutils.quit(\"Error '%s' happened\", \"42\")  --> Error '42' happened\n"],
              "section":"OS functions",
              "name":"quit",
              "parameter":"param",
              "params":{
                "1":"code",
                "2":"msg",
                "map":{
                  "msg":" The exit message will be sent to `stderr` (will be formatted with the extra parameters)",
                  "...":" extra arguments for message's format'",
                  "code":" The exit code, defaults to -`1` if omitted"
                },
                "3":"..."
              },
              "tags":{
                "see":[]
              },
              "kind":"os functions ",
              "description":"",
              "type":"function"
            },{
              "name":"string-functions",
              "inferred":true,
              "description":"",
              "file":"<reference cycle>",
              "summary":"",
              "tags":[],
              "lineno":683,
              "display_name":"String functions",
              "type":"section",
              "modifiers":[]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":{
                  "1":[],
                  "s":[]
                }
              },
              "summary":"escape any Lua 'magic' characters in a string",
              "lineno":685,
              "args":"(s)",
              "section":"String functions",
              "name":"escape",
              "params":{
                "map":{
                  "s":" The input string"
                },
                "1":"s"
              },
              "tags":[],
              "kind":"string functions ",
              "description":"",
              "type":"function",
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "param":{
                  "1":[],
                  "2":[],
                  "3":[],
                  "4":[],
                  "re":[],
                  "n":[],
                  "s":[],
                  "plain":[]
                },
                "return":[[]],
                "raise":[],
                "see":[[]]
              },
              "summary":"split a string into a list of strings separated by a delimiter.",
              "lineno":698,
              "retgroups":[{
                  "1":{
                    "text":"a list-like table",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s, re, plain, n)",
              "type":"function",
              "name":"split",
              "params":{
                "1":"s",
                "2":"re",
                "3":"plain",
                "4":"n",
                "map":{
                  "re":" optional A Lua string pattern; defaults to '%s+'",
                  "n":" optional maximum number of elements (if there are more, the last will remian un-split)",
                  "s":" The input string",
                  "plain":" optional If truthy don't use Lua patterns"
                }
              },
              "tags":{
                "see":[]
              },
              "kind":"string functions ",
              "section":"String functions",
              "description":"",
              "raise":"error if s is not a string",
              "ret":["a list-like table"],
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "param":{
                  "1":[],
                  "2":[],
                  "3":[],
                  "4":[],
                  "re":[],
                  "n":[],
                  "s":[],
                  "plain":[]
                },
                "return":[[]],
                "usage":[[]],
                "see":[[]]
              },
              "summary":"split a string into a number of return values.",
              "lineno":735,
              "retgroups":[{
                  "1":{
                    "text":"n values",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s, re, plain, n)",
              "usage":["first,next = splitv('user=jane=doe','=', false, 2)\nassert(first == \"user\")\nassert(next == \"jane=doe\")\n"],
              "type":"function",
              "name":"splitv",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"re",
                "3":"plain",
                "4":"n",
                "map":{
                  "re":" A Lua string pattern; defaults to '%s+'",
                  "n":" optional maximum number of splits",
                  "s":" the string",
                  "plain":" don't use Lua patterns"
                }
              },
              "tags":{
                "see":[]
              },
              "kind":"string functions ",
              "section":"String functions",
              "description":"\n Identical to `split` but returns multiple sub-strings instead of\n a single list of sub-strings.",
              "ret":["n values"]
            },{
              "name":"functional",
              "inferred":true,
              "description":"",
              "file":"<reference cycle>",
              "summary":"",
              "tags":[],
              "lineno":744,
              "display_name":"Functional",
              "type":"section",
              "modifiers":[]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[[]],
                "param":{
                  "1":[],
                  "func":[]
                }
              },
              "summary":"'memoize' a function (cache returned value for next call).",
              "lineno":750,
              "retgroups":[{
                  "1":{
                    "text":"a function with at least one argument, which is used as the key.",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(func)",
              "type":"function",
              "name":"memoize",
              "parameter":"param",
              "params":{
                "map":{
                  "func":" a function of at least one argument"
                },
                "1":"func"
              },
              "tags":[],
              "kind":"functional ",
              "section":"Functional",
              "description":"\n This is useful if you have a function which is relatively expensive,\n but you don't know in advance what values will be required, so\n building a table upfront is wasteful/impossible.",
              "ret":["a function with at least one argument, which is used as the key."]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":{
                  "1":{
                    "type":"tab"
                  },
                  "2":{
                    "type":"func"
                  },
                  "fun":{
                    "type":"func"
                  },
                  "mt":{
                    "type":"tab"
                  }
                }
              },
              "summary":"associate a function factory with a type.",
              "lineno":768,
              "args":"(mt, fun)",
              "section":"Functional",
              "name":"add_function_factory",
              "params":{
                "1":"mt",
                "2":"fun",
                "map":{
                  "fun":" a callable that returns a function",
                  "mt":" metatable"
                }
              },
              "tags":[],
              "kind":"functional ",
              "description":"\n A function factory takes an object of the given type and\n returns a function for evaluating it",
              "type":"function",
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "param":{
                  "1":[],
                  "lf":[]
                },
                "return":[[]],
                "usage":[[]]
              },
              "summary":"an anonymous function as a string.",
              "lineno":800,
              "retgroups":[{
                  "1":{
                    "text":"a function",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(lf)",
              "usage":["string_lambda '|x|x+1' (2) == 3\nstring_lambda '_+1' (2) == 3\n"],
              "type":"function",
              "name":"string_lambda",
              "params":{
                "map":{
                  "lf":" function as a string"
                },
                "1":"lf"
              },
              "tags":[],
              "kind":"functional ",
              "section":"Functional",
              "description":" This string is either of the form\n '|args| expression' or is a function of one argument, '_'",
              "ret":["a function"],
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[[]],
                "see":[[]],
                "param":{
                  "1":[],
                  "2":[],
                  "p":[],
                  "fn":[]
                },
                "raise":[],
                "usage":[[]]
              },
              "summary":"bind the first argument of the function to a value.",
              "lineno":817,
              "retgroups":[{
                  "1":{
                    "text":"a function such that f(x) is fn(p,x)",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(fn, p)",
              "usage":["local function f(msg, name)\n  print(msg .. \" \" .. name)\nend\n\nlocal hello = utils.bind1(f, \"Hello\")\n\nprint(hello(\"world\"))     --> \"Hello world\"\nprint(hello(\"sunshine\"))  --> \"Hello sunshine\"\n"],
              "raise":"same as @{function_arg}",
              "name":"bind1",
              "params":{
                "1":"fn",
                "2":"p",
                "map":{
                  "p":" a value",
                  "fn":" a function of at least two values (may be an operator string)"
                }
              },
              "tags":{
                "see":[]
              },
              "kind":"functional ",
              "section":"Functional",
              "type":"function",
              "parameter":"param",
              "ret":["a function such that f(x) is fn(p,x)"],
              "description":""
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[]],
                "param":{
                  "1":[],
                  "2":[],
                  "p":[],
                  "fn":[]
                },
                "raise":[],
                "return":[[]]
              },
              "summary":"bind the second argument of the function to a value.",
              "lineno":836,
              "retgroups":[{
                  "1":{
                    "text":"a function such that f(x) is fn(x,p)",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(fn, p)",
              "usage":["local function f(a, b, c)\n  print(a .. \" \" .. b .. \" \" .. c)\nend\n\nlocal hello = utils.bind1(f, \"world\")\n\nprint(hello(\"Hello\", \"!\"))  --> \"Hello world !\"\nprint(hello(\"Bye\", \"?\"))    --> \"Bye world ?\"\n"],
              "raise":"same as @{function_arg}",
              "name":"bind2",
              "params":{
                "1":"fn",
                "2":"p",
                "map":{
                  "p":" a value",
                  "fn":" a function of at least two values (may be an operator string)"
                }
              },
              "tags":[],
              "kind":"functional ",
              "section":"Functional",
              "type":"function",
              "parameter":"param",
              "ret":["a function such that f(x) is fn(x,p)"],
              "description":""
            },{
              "name":"deprecation",
              "inferred":true,
              "description":"",
              "file":"<reference cycle>",
              "summary":"",
              "tags":[],
              "lineno":847,
              "display_name":"Deprecation",
              "type":"section",
              "modifiers":[]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":{
                  "1":[],
                  "func":[]
                },
                "usage":[[]],
                "see":[[]]
              },
              "summary":"Sets a deprecation warning function.",
              "lineno":875,
              "args":"(func)",
              "usage":["-- write to the Nginx logs with OpenResty\nutils.set_deprecation_func(function(msg, trace)\n  ngx.log(ngx.WARN, msg, (trace and (\" \" .. trace) or nil))\nend)\n\n-- disable deprecation warnings\nutils.set_deprecation_func()\n"],
              "section":"Deprecation",
              "name":"set_deprecation_func",
              "parameter":"param",
              "params":{
                "map":{
                  "func":" a callback with signature: `function(msg, trace)` both arguments are strings, the latter being optional."
                },
                "1":"func"
              },
              "tags":{
                "see":[]
              },
              "kind":"deprecation ",
              "description":"\n An application can override this function to support proper output of\n deprecation warnings. The warnings can be generated from libraries or\n functions by calling `utils.raise_deprecation`. The default function\n will write to the 'warn' system (introduced in Lua 5.4, or the compatibility\n function from the `compat` module for earlier versions).\n\n Note: only applications should set/change this function, libraries should not.",
              "type":"function"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":{
                  "1":[],
                  "opts":[]
                },
                "usage":[[]],
                "see":[[]]
              },
              "summary":"raises a deprecation warning.",
              "lineno":907,
              "args":"(opts)",
              "usage":["warn(\"@on\")   -- enable Lua warnings, they are usually off by default\n\nfunction stringx.islower(str)\n  raise_deprecation {\n    source = \"Penlight \" .. utils._VERSION,                   -- optional\n    message = \"function 'islower' was renamed to 'is_lower'\", -- required\n    version_removed = \"2.0.0\",                                -- optional\n    deprecated_after = \"1.2.3\",                               -- optional\n    no_trace = true,                                          -- optional\n  }\n  return stringx.is_lower(str)\nend\n-- output: \"[Penlight 1.9.2] function 'islower' was renamed to 'is_lower' (deprecated after 1.2.3, scheduled for removal in 2.0.0)\"\n"],
              "section":"Deprecation",
              "name":"raise_deprecation",
              "parameter":"param",
              "params":{
                "map":{
                  "opts":" options table"
                },
                "1":"opts"
              },
              "tags":{
                "see":[]
              },
              "kind":"deprecation ",
              "description":"\n For options see the usage example below.\n\n Note: the `opts.deprecated_after` field is the last version in which\n a feature or option was NOT YET deprecated! Because when writing the code it\n is quite often not known in what version the code will land. But the last\n released version is usually known.",
              "type":"function"
            }],
          "sections":[],
          "modules":["<reference cycle>"],
          "args":{
            "one":false,
            "module":false,
            "verbose":false,
            "style":"!",
            "template":"!",
            "date":"system",
            "dir":"doc",
            "quiet":false,
            "all":false,
            "ignore":false,
            "colon":false,
            "not_luadoc":false,
            "ext":"html",
            "boilerplate":false,
            "merge":false,
            "filter":"f.filter",
            "package":"/home/cji/portless/Penlight/lua",
            "dump":false,
            "no_args_infer":false,
            "title":"Reference",
            "project":"ldoc",
            "file":"/home/cji/portless/Penlight/lua/pl",
            "format":"discount",
            "simple":false,
            "tags":"none",
            "define":"none",
            "output":"index",
            "unqualified":false,
            "config":"config.ld",
            "fatalwarnings":false,
            "testing":false
          },
          "error":"<type 'function' is not supported by JSON.>",
          "lang":{
            "line_comment":"^%-%-+",
            "start_comment_":"^%-%-%-+",
            "end_comment_":"[^%-]%-%-+[^-]*\n$",
            "extra":[],
            "block_comment":"^%-%-%[=*%[%-+",
            "empty_comment_":"^%-%-%-+%s*$",
            "method_call":":"
          },
          "base":"/home/cji/portless/Penlight/lua"
        },
        "summary":"",
        "tags":[],
        "lineno":523,
        "display_name":"File handling",
        "type":"section",
        "modifiers":[]
      },
      "Deprecation":{
        "name":"deprecation",
        "inferred":true,
        "description":"",
        "file":{
          "warning":"<type 'function' is not supported by JSON.>",
          "filename":"/home/cji/portless/Penlight/lua/pl/utils.lua",
          "items":["<reference cycle>",{
              "inferred":true,
              "description":"",
              "modifiers":{
                "field":[],
                "return":[]
              },
              "summary":"Some standard patterns",
              "lineno":31,
              "args":"(FLOAT, INTEGER, IDEN, FILE)",
              "type":"table",
              "name":"patterns",
              "parameter":"field",
              "params":{
                "1":"FLOAT",
                "2":"INTEGER",
                "3":"IDEN",
                "4":"FILE",
                "map":{
                  "FILE":"file",
                  "INTEGER":"integer number",
                  "IDEN":"identifier",
                  "FLOAT":"floating point number"
                }
              },
              "tags":[],
              "kind":"tables",
              "section":"table",
              "subparams":[]
            },{
              "name":"stdmt",
              "section":"table",
              "inferred":true,
              "description":"",
              "kind":"tables",
              "summary":"Standard meta-tables as used by other Penlight modules",
              "params":{
                "1":"List",
                "2":"Map",
                "3":"Set",
                "4":"MultiMap",
                "map":{
                  "Map":" the Map metatable",
                  "Set":" the Set metatable",
                  "MultiMap":" the MultiMap metatable",
                  "List":" the List metatable"
                }
              },
              "tags":[],
              "lineno":45,
              "subparams":[],
              "args":"(List, Map, Set, MultiMap)",
              "parameter":"field",
              "type":"table",
              "modifiers":{
                "field":{
                  "1":[],
                  "2":[],
                  "3":[],
                  "4":[],
                  "Map":[],
                  "Set":[],
                  "MultiMap":[],
                  "List":[]
                },
                "return":[]
              }
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "param":{
                  "1":[],
                  "...":[]
                },
                "return":[[]],
                "see":[[],[],[]]
              },
              "summary":"pack an argument list into a table.",
              "lineno":60,
              "retgroups":[{
                  "1":{
                    "text":"a table with field `n` set to the length",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(...)",
              "section":"function",
              "name":"pack",
              "params":{
                "map":{
                  "...":" any arguments"
                },
                "1":"..."
              },
              "tags":{
                "see":[]
              },
              "kind":"functions",
              "description":"",
              "type":"function",
              "ret":["a table with field `n` set to the length"],
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[[]],
                "usage":[[]],
                "param":{
                  "1":[],
                  "2":{
                    "optchain":true,
                    "opt":true
                  },
                  "3":{
                    "optchain":true,
                    "opt":true
                  },
                  "t":[],
                  "j":{
                    "optchain":true,
                    "opt":true
                  },
                  "i":{
                    "optchain":true,
                    "opt":true
                  }
                },
                "see":[[],[],[]]
              },
              "summary":"unpack a table and return its contents.",
              "lineno":79,
              "retgroups":[{
                  "1":{
                    "text":"multiple return values from the table",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(t[, i[, j]])",
              "usage":["local t = table.pack(nil, nil, nil, 4)\nlocal a, b, c, d = table.unpack(t)   -- this `unpack` is NOT nil-safe, so d == nil\n\nlocal a, b, c, d = utils.unpack(t)   -- this is nil-safe, so d == 4\n"],
              "type":"function",
              "name":"unpack",
              "params":{
                "1":"t",
                "2":"i",
                "map":{
                  "t":" table to unpack",
                  "j":" index of the last element to unpack, defaults to `t.n` or else `#t`",
                  "i":" index from which to start unpacking, defaults to 1"
                },
                "3":"j"
              },
              "tags":{
                "see":[]
              },
              "kind":"functions",
              "section":"function",
              "description":"\n\n NOTE: this implementation differs from the Lua implementation in the way\n that this one DOES honor the `n` field in the table `t`, such that it is 'nil-safe'.",
              "ret":["multiple return values from the table"],
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":{
                  "1":[],
                  "2":[],
                  "fmt":[],
                  "...":[]
                }
              },
              "summary":"print an arbitrary number of arguments using a format.",
              "lineno":87,
              "args":"(fmt, ...)",
              "section":"function",
              "name":"printf",
              "params":{
                "1":"fmt",
                "2":"...",
                "map":{
                  "fmt":" The format (see `string.format`)",
                  "...":" Extra arguments for format"
                }
              },
              "tags":[],
              "kind":"functions",
              "description":"\n Output will be sent to `stdout`.",
              "type":"function",
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":{
                  "1":[],
                  "2":[],
                  "3":[],
                  "fmt":[],
                  "f":[],
                  "...":[]
                }
              },
              "summary":"write an arbitrary number of arguments to a file using a format.",
              "lineno":96,
              "args":"(f, fmt, ...)",
              "section":"function",
              "name":"fprintf",
              "params":{
                "1":"f",
                "2":"fmt",
                "map":{
                  "fmt":" The format (see `string.format`).",
                  "f":" File handle to write to.",
                  "...":" Extra arguments for format"
                },
                "3":"..."
              },
              "tags":[],
              "kind":"functions",
              "description":"",
              "type":"function",
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":{
                  "1":[],
                  "2":[],
                  "t":[],
                  "T":[]
                }
              },
              "summary":"take a table and 'inject' it into the local namespace.",
              "lineno":124,
              "args":"(t, T)",
              "section":"function",
              "name":"import",
              "params":{
                "1":"t",
                "2":"T",
                "map":{
                  "t":" The table (table), or module name (string), defaults to this `utils` module table",
                  "T":" An optional destination table (defaults to callers environment)"
                }
              },
              "tags":[],
              "kind":"functions",
              "description":"",
              "type":"function",
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":{
                  "1":[],
                  "2":[],
                  "3":[],
                  "cond":[],
                  "value1":[],
                  "value2":[]
                }
              },
              "summary":"return either of two values, depending on a condition.",
              "lineno":143,
              "args":"(cond, value1, value2)",
              "section":"function",
              "name":"choose",
              "params":{
                "1":"cond",
                "2":"value1",
                "map":{
                  "cond":" A condition",
                  "value1":" Value returned if cond is truthy",
                  "value2":" Value returned if cond is falsy"
                },
                "3":"value2"
              },
              "tags":[],
              "kind":"functions",
              "description":"",
              "type":"function",
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[[]],
                "param":{
                  "1":[],
                  "2":{
                    "optchain":true,
                    "opt":true
                  },
                  "3":{
                    "optchain":true,
                    "opt":true
                  },
                  "t":[],
                  "temp":{
                    "optchain":true,
                    "opt":true
                  },
                  "tostr":{
                    "optchain":true,
                    "opt":true
                  }
                }
              },
              "summary":"convert an array of values to strings.",
              "lineno":152,
              "retgroups":[{
                  "1":{
                    "text":"the converted buffer",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(t[, temp[, tostr]])",
              "type":"function",
              "name":"array_tostring",
              "parameter":"param",
              "params":{
                "1":"t",
                "2":"temp",
                "map":{
                  "t":" a list-like table",
                  "temp":" (table) buffer to use, otherwise allocate",
                  "tostr":" custom tostring function, called with (value,index). Defaults to `tostring`."
                },
                "3":"tostr"
              },
              "tags":[],
              "kind":"functions",
              "section":"function",
              "description":"",
              "ret":["the converted buffer"]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[]],
                "param":{
                  "1":[],
                  "2":[],
                  "obj":[],
                  "tp":[]
                },
                "return":[[]]
              },
              "summary":"is the object of the specified type?",
              "lineno":172,
              "retgroups":[{
                  "1":{
                    "text":"boolean",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(obj, tp)",
              "usage":["utils.is_type(\"hello world\", \"string\")   --> true\n-- or check metatable\nlocal my_mt = {}\nlocal my_obj = setmetatable(my_obj, my_mt)\nutils.is_type(my_obj, my_mt)  --> true\n"],
              "type":"function",
              "name":"is_type",
              "parameter":"param",
              "params":{
                "1":"obj",
                "2":"tp",
                "map":{
                  "obj":" An object to check",
                  "tp":" String of what type it should be"
                }
              },
              "tags":[],
              "kind":"functions",
              "section":"function",
              "description":"\n If the type is a string, then use type, otherwise compare with metatable",
              "ret":["boolean"]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[]],
                "return":[{
                    "type":"integer"
                  },{
                    "type":"any"
                  }],
                "param":{
                  "1":{
                    "type":"table"
                  },
                  "2":{
                    "opt":"1",
                    "type":"integer",
                    "optchain":"1"
                  },
                  "3":{
                    "opt":"t.n or #t",
                    "type":"integer",
                    "optchain":"t.n or #t"
                  },
                  "4":{
                    "opt":"1",
                    "type":"integer",
                    "optchain":"1"
                  },
                  "t":{
                    "type":"table"
                  },
                  "step":{
                    "opt":"1",
                    "type":"integer",
                    "optchain":"1"
                  },
                  "i_start":{
                    "opt":"1",
                    "type":"integer",
                    "optchain":"1"
                  },
                  "i_end":{
                    "opt":"t.n or #t",
                    "type":"integer",
                    "optchain":"t.n or #t"
                  }
                },
                "see":[[],[]]
              },
              "summary":"an iterator with indices, similar to `ipairs`, but with a range.",
              "lineno":199,
              "retgroups":[{
                  "1":{
                    "text":"index",
                    "type":"integer",
                    "mods":{
                      "type":"integer"
                    }
                  },
                  "2":{
                    "text":"value at index (which can be `nil`!)",
                    "type":"any",
                    "mods":{
                      "type":"any"
                    }
                  },
                  "g":0
                }],
              "args":"(t[, i_start=1[, i_end=t.n or #t[, step=1]]])",
              "usage":["local t = utils.pack(nil, 123, nil)  -- adds an `n` field when packing\n\nfor i, v in utils.npairs(t, 2) do  -- start at index 2\n  t[i] = tostring(t[i])\nend\n\n-- t = { n = 3, [2] = \"123\", [3] = \"nil\" }\n"],
              "type":"function",
              "name":"npairs",
              "parameter":"param",
              "params":{
                "1":"t",
                "2":"i_start",
                "3":"i_end",
                "4":"step",
                "map":{
                  "t":" the table to iterate over",
                  "step":" step size",
                  "i_start":" start index",
                  "i_end":" end index"
                }
              },
              "tags":{
                "see":[]
              },
              "kind":"functions",
              "section":"function",
              "description":"\n This is a nil-safe index based iterator that will return `nil` when there\n is a hole in a list. To be safe ensure that table `t.n` contains the length.",
              "ret":["index","value at index (which can be `nil`!)"]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[]],
                "param":{
                  "1":{
                    "type":"table"
                  },
                  "t":{
                    "type":"table"
                  }
                },
                "return":[{
                    "type":"key"
                  },{
                    "type":"value"
                  }]
              },
              "summary":"an iterator over all non-integer keys (inverse of `ipairs`).",
              "lineno":253,
              "retgroups":[{
                  "1":{
                    "text":"",
                    "type":"key",
                    "mods":{
                      "type":"key"
                    }
                  },
                  "2":{
                    "text":"",
                    "type":"value",
                    "mods":{
                      "type":"value"
                    }
                  },
                  "g":0
                }],
              "args":"(t)",
              "usage":["local t = {\n  \"hello\",\n  \"world\",\n  hello = \"hallo\",\n  world = \"Welt\",\n}\n\nfor k, v in utils.kpairs(t) do\n  print(\"German: \", v)\nend\n\n-- output;\n-- German: hallo\n-- German: Welt\n"],
              "type":"function",
              "name":"kpairs",
              "parameter":"param",
              "params":{
                "map":{
                  "t":" the table to iterate over"
                },
                "1":"t"
              },
              "tags":[],
              "kind":"functions",
              "section":"function",
              "description":"\n It will skip any key that is an integer number, so negative indices or an\n array with holes will not return those either (so it returns slightly less than\n 'the inverse of `ipairs`').\n\n This uses `pairs` under the hood, so any value that is iterable using `pairs`\n will work with this function.",
              "ret":["",""]
            },{
              "name":"Error-handling",
              "inferred":true,
              "description":"",
              "file":"<reference cycle>",
              "summary":"",
              "tags":[],
              "lineno":272,
              "display_name":"Error handling",
              "type":"section",
              "modifiers":[]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[]],
                "param":{
                  "1":[],
                  "2":[],
                  "3":[],
                  "4":[],
                  "5":[],
                  "6":[],
                  "n":[],
                  "verify":[],
                  "val":[],
                  "lev":[],
                  "msg":[],
                  "tp":[]
                },
                "raise":[],
                "return":[[]]
              },
              "summary":"assert that the given argument is in fact of the correct type.",
              "lineno":285,
              "retgroups":[{
                  "1":{
                    "text":"the validated value",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(n, val, tp, verify, msg, lev)",
              "usage":["local param1 = assert_arg(1,\"hello\",'table')  --> error: argument 1 expected a 'table', got a 'string'\nlocal param4 = assert_arg(4,'!@#$%^&*','string',path.isdir,'not a directory')\n     --> error: argument 4: '!@#$%^&*' not a directory\n"],
              "raise":"if `val` is not the correct type",
              "name":"assert_arg",
              "params":{
                "1":"n",
                "2":"val",
                "3":"tp",
                "4":"verify",
                "5":"msg",
                "6":"lev",
                "map":{
                  "n":" argument index",
                  "verify":" an optional verification function",
                  "val":" the value",
                  "lev":" optional stack position for trace, default 2",
                  "msg":" an optional custom message",
                  "tp":" the type"
                }
              },
              "tags":[],
              "kind":"error handling ",
              "section":"Error handling",
              "type":"function",
              "parameter":"param",
              "ret":["the validated value"],
              "description":""
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[],[],[]],
                "param":{
                  "1":{
                    "type":"table|vararg"
                  },
                  "...":{
                    "type":"table|vararg"
                  }
                },
                "return":[[]]
              },
              "summary":"creates an Enum or constants lookup table for improved error handling.",
              "lineno":355,
              "retgroups":[{
                  "1":{
                    "text":"Enum object (read-only table/object)",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(...)",
              "usage":["-- Enum access at runtime\nlocal obj = {}\nobj.MOVEMENT = utils.enum(\"FORWARD\", \"REVERSE\", \"LEFT\", \"RIGHT\")\n\nif current_movement == obj.MOVEMENT.FORWARD then\n  -- do something\n\nelseif current_movement == obj.MOVEMENT.REVERES then\n  -- throws error due to typo 'REVERES', so a silent mistake becomes a hard error\n  -- \"'REVERES' is not a valid value (expected one of: 'FORWARD', 'REVERSE', 'LEFT', 'RIGHT')\"\n\nend\n","-- standardized error codes\nlocal obj = {\n  ERR = utils.enum {\n    NOT_FOUND = \"the item was not found\",\n    OUT_OF_BOUNDS = \"the index is outside the allowed range\"\n  },\n\n  some_method = function(self)\n    return self.ERR.OUT_OF_BOUNDS\n  end,\n}\n\nlocal result, err = obj:some_method()\nif not result then\n  if err == obj.ERR.NOT_FOUND then\n    -- check on error code, not magic strings\n\n  else\n    -- return the error description, contained in the constant\n    return nil, \"error: \"..err  -- \"error: the index is outside the allowed range\"\n  end\nend\n","-- validating/converting user-input\nlocal color = \"purple\"\nlocal ansi_colors = utils.enum {\n  black     = 30,\n  red       = 31,\n  green     = 32,\n}\nlocal color_code, err = ansi_colors(color) -- calling on the object, returns the value from the enum\nif not color_code then\n  print(\"bad 'color', \" .. err)\n  -- \"bad 'color', 'purple' is not a valid value (expected one of: 'black', 'red', 'green')\"\n  os.exit(1)\nend\n"],
              "type":"function",
              "name":"enum",
              "parameter":"param",
              "params":{
                "map":{
                  "...":" the input for the Enum. If varargs or an array then the\n values in the Enum will be equal to the names (must be strings), if a hash-table\n then values remain (any type), and the keys must be strings."
                },
                "1":"..."
              },
              "tags":[],
              "kind":"error handling ",
              "section":"Error handling",
              "description":"\n This helps prevent magic strings in code by throwing errors for accessing\n non-existing values, and/or converting strings/identifiers to other values.\n\n Calling on the object does the same, but returns a soft error; `nil + err`, if\n the call is succesful (the key exists), it will return the value.\n\n When calling with varargs or an array the values will be equal to the keys.\n The enum object is read-only.",
              "ret":["Enum object (read-only table/object)"]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "param":{
                  "1":[],
                  "2":[],
                  "3":[],
                  "f":[],
                  "msg":[],
                  "idx":[]
                },
                "raise":[],
                "return":[[]]
              },
              "summary":"process a function argument.",
              "lineno":430,
              "retgroups":[{
                  "1":{
                    "text":"a callable",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(idx, f, msg)",
              "type":"function",
              "name":"function_arg",
              "params":{
                "1":"idx",
                "2":"f",
                "map":{
                  "f":" a function, operator string, or callable object",
                  "msg":" optional error message",
                  "idx":" argument index"
                },
                "3":"msg"
              },
              "tags":[],
              "kind":"error handling ",
              "section":"Error handling",
              "description":"\n This is used throughout Penlight and defines what is meant by a function:\n Something that is callable, or an operator string as defined by <code>pl.operator</code>,\n such as '>' or '#'. If a function factory has been registered for the type, it will\n be called to get the function.",
              "raise":"if idx is not a number or if f is not callable",
              "ret":["a callable"],
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[]],
                "param":{
                  "1":[],
                  "2":[],
                  "val":[],
                  "n":[]
                },
                "raise":[],
                "return":[[]]
              },
              "summary":"assert the common case that the argument is a string.",
              "lineno":470,
              "retgroups":[{
                  "1":{
                    "text":"the validated value",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(n, val)",
              "usage":["local val = 42\nlocal param2 = utils.assert_string(2, val) --> error: argument 2 expected a 'string', got a 'number'\n"],
              "raise":"val must be a string",
              "name":"assert_string",
              "params":{
                "1":"n",
                "2":"val",
                "map":{
                  "val":" a value that must be a string",
                  "n":" argument index"
                }
              },
              "tags":[],
              "kind":"error handling ",
              "section":"Error handling",
              "type":"function",
              "parameter":"param",
              "ret":["the validated value"],
              "description":""
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "param":{
                  "1":[],
                  "mode":[]
                },
                "return":[],
                "see":[[]]
              },
              "summary":"control the error strategy used by Penlight.",
              "lineno":483,
              "args":"(mode)",
              "section":"Error handling",
              "name":"on_error",
              "params":{
                "map":{
                  "mode":" either 'default', 'quit'  or 'error'"
                },
                "1":"mode"
              },
              "tags":{
                "see":[]
              },
              "kind":"error handling ",
              "description":"\n This is a global setting that controls how `utils.raise` behaves:\n\n - 'default': return `nil + error` (this is the default)\n - 'error': throw a Lua error\n - 'quit': exit the program\n",
              "type":"function",
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":{
                  "1":[],
                  "err":[]
                },
                "usage":[[]],
                "see":[[]]
              },
              "summary":"used by Penlight functions to return errors.",
              "lineno":507,
              "args":"(err)",
              "usage":["if some_condition then\n  return utils.raise(\"some condition was not met\")  -- MUST use 'return'!\nend\n"],
              "section":"Error handling",
              "name":"raise",
              "parameter":"param",
              "params":{
                "map":{
                  "err":" the error string."
                },
                "1":"err"
              },
              "tags":{
                "see":[]
              },
              "kind":"error handling ",
              "description":" Its global behaviour is controlled\n by `utils.on_error`.\n To use this function you MUST use it in conjunction with `return`, since it might\n return `nil + error`.",
              "type":"function"
            },{
              "name":"files",
              "inferred":true,
              "description":"",
              "file":"<reference cycle>",
              "summary":"",
              "tags":[],
              "lineno":523,
              "display_name":"File handling",
              "type":"section",
              "modifiers":[]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[[]],
                "param":{
                  "1":[],
                  "2":[],
                  "filename":[],
                  "is_bin":[]
                }
              },
              "summary":"return the contents of a file as a string",
              "lineno":527,
              "retgroups":[{
                  "1":{
                    "text":"file contents",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(filename, is_bin)",
              "type":"function",
              "name":"readfile",
              "parameter":"param",
              "params":{
                "1":"filename",
                "2":"is_bin",
                "map":{
                  "filename":" The file path",
                  "is_bin":" open in binary mode"
                }
              },
              "tags":[],
              "kind":"file handling ",
              "section":"File handling",
              "description":"",
              "ret":["file contents"]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "param":{
                  "1":[],
                  "2":[],
                  "3":[],
                  "filename":[],
                  "str":[],
                  "is_bin":[]
                },
                "raise":[],
                "return":[[],[]]
              },
              "summary":"write a string to a file",
              "lineno":549,
              "retgroups":[{
                  "1":{
                    "text":"true or nil",
                    "type":"",
                    "mods":[]
                  },
                  "2":{
                    "text":"error message",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(filename, str, is_bin)",
              "type":"function",
              "name":"writefile",
              "params":{
                "1":"filename",
                "2":"str",
                "map":{
                  "filename":" The file path",
                  "str":" The string",
                  "is_bin":" open in binary mode"
                },
                "3":"is_bin"
              },
              "tags":[],
              "kind":"file handling ",
              "section":"File handling",
              "description":"",
              "raise":"error if filename or str aren't strings",
              "ret":["true or nil","error message"],
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "param":{
                  "1":[],
                  "filename":[]
                },
                "raise":[],
                "return":[[]]
              },
              "summary":"return the contents of a file as a list of lines",
              "lineno":569,
              "retgroups":[{
                  "1":{
                    "text":"file contents as a table",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(filename)",
              "type":"function",
              "name":"readlines",
              "params":{
                "map":{
                  "filename":" The file path"
                },
                "1":"filename"
              },
              "tags":[],
              "kind":"file handling ",
              "section":"File handling",
              "description":"",
              "raise":"error if filename is not a string",
              "ret":["file contents as a table"],
              "parameter":"param"
            },{
              "name":"OS-functions",
              "inferred":true,
              "description":"",
              "file":"<reference cycle>",
              "summary":"",
              "tags":[],
              "lineno":584,
              "display_name":"OS functions",
              "type":"section",
              "modifiers":[]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[[],[],[],[]],
                "param":{
                  "1":[],
                  "2":[],
                  "bin":[],
                  "cmd":[]
                }
              },
              "summary":"execute a shell command and return the output.",
              "lineno":592,
              "retgroups":[{
                  "1":{
                    "text":"true if successful",
                    "type":"",
                    "mods":[]
                  },
                  "2":{
                    "text":"actual return code",
                    "type":"",
                    "mods":[]
                  },
                  "3":{
                    "text":"stdout output (string)",
                    "type":"",
                    "mods":[]
                  },
                  "4":{
                    "text":"errout output (string)",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(cmd, bin)",
              "type":"function",
              "name":"executeex",
              "parameter":"param",
              "params":{
                "1":"cmd",
                "2":"bin",
                "map":{
                  "bin":" boolean, if true, read output as binary file",
                  "cmd":" a shell command"
                }
              },
              "tags":[],
              "kind":"os functions ",
              "section":"OS functions",
              "description":"\n This function redirects the output to tempfiles and returns the content of those files.",
              "ret":["true if successful","actual return code","stdout output (string)","errout output (string)"]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[]],
                "param":{
                  "1":[],
                  "argument":[]
                },
                "return":[[]]
              },
              "summary":"Quote and escape an argument of a command.",
              "lineno":623,
              "retgroups":[{
                  "1":{
                    "text":"quoted and escaped argument.",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(argument)",
              "usage":["local options = utils.quote_arg {\n    \"-lluacov\",\n    \"-e\",\n    \"utils = print(require('pl.utils')._VERSION\",\n}\n-- returns: -lluacov -e 'utils = print(require('\\''pl.utils'\\'')._VERSION'\n"],
              "type":"function",
              "name":"quote_arg",
              "parameter":"param",
              "params":{
                "map":{
                  "argument":" (string or table/list) the argument to quote. If a list then\n all arguments in the list will be returned as a single string quoted."
                },
                "1":"argument"
              },
              "tags":[],
              "kind":"os functions ",
              "section":"OS functions",
              "description":"\n Quotes a single (or list of) argument(s) of a command to be passed\n to `os.execute`, `pl.utils.execute` or `pl.utils.executeex`.",
              "ret":["quoted and escaped argument."]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":{
                  "1":{
                    "opt":true
                  },
                  "2":[],
                  "3":[],
                  "msg":[],
                  "...":[],
                  "code":{
                    "opt":true
                  }
                },
                "usage":[[]],
                "see":[[]]
              },
              "summary":"error out of this program gracefully.",
              "lineno":667,
              "args":"([code], msg, ...)",
              "usage":["utils.quit(-1, \"Error '%s' happened\", \"42\")\n-- is equivalent to\nutils.quit(\"Error '%s' happened\", \"42\")  --> Error '42' happened\n"],
              "section":"OS functions",
              "name":"quit",
              "parameter":"param",
              "params":{
                "1":"code",
                "2":"msg",
                "map":{
                  "msg":" The exit message will be sent to `stderr` (will be formatted with the extra parameters)",
                  "...":" extra arguments for message's format'",
                  "code":" The exit code, defaults to -`1` if omitted"
                },
                "3":"..."
              },
              "tags":{
                "see":[]
              },
              "kind":"os functions ",
              "description":"",
              "type":"function"
            },{
              "name":"string-functions",
              "inferred":true,
              "description":"",
              "file":"<reference cycle>",
              "summary":"",
              "tags":[],
              "lineno":683,
              "display_name":"String functions",
              "type":"section",
              "modifiers":[]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":{
                  "1":[],
                  "s":[]
                }
              },
              "summary":"escape any Lua 'magic' characters in a string",
              "lineno":685,
              "args":"(s)",
              "section":"String functions",
              "name":"escape",
              "params":{
                "map":{
                  "s":" The input string"
                },
                "1":"s"
              },
              "tags":[],
              "kind":"string functions ",
              "description":"",
              "type":"function",
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "param":{
                  "1":[],
                  "2":[],
                  "3":[],
                  "4":[],
                  "re":[],
                  "n":[],
                  "s":[],
                  "plain":[]
                },
                "return":[[]],
                "raise":[],
                "see":[[]]
              },
              "summary":"split a string into a list of strings separated by a delimiter.",
              "lineno":698,
              "retgroups":[{
                  "1":{
                    "text":"a list-like table",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s, re, plain, n)",
              "type":"function",
              "name":"split",
              "params":{
                "1":"s",
                "2":"re",
                "3":"plain",
                "4":"n",
                "map":{
                  "re":" optional A Lua string pattern; defaults to '%s+'",
                  "n":" optional maximum number of elements (if there are more, the last will remian un-split)",
                  "s":" The input string",
                  "plain":" optional If truthy don't use Lua patterns"
                }
              },
              "tags":{
                "see":[]
              },
              "kind":"string functions ",
              "section":"String functions",
              "description":"",
              "raise":"error if s is not a string",
              "ret":["a list-like table"],
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "param":{
                  "1":[],
                  "2":[],
                  "3":[],
                  "4":[],
                  "re":[],
                  "n":[],
                  "s":[],
                  "plain":[]
                },
                "return":[[]],
                "usage":[[]],
                "see":[[]]
              },
              "summary":"split a string into a number of return values.",
              "lineno":735,
              "retgroups":[{
                  "1":{
                    "text":"n values",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s, re, plain, n)",
              "usage":["first,next = splitv('user=jane=doe','=', false, 2)\nassert(first == \"user\")\nassert(next == \"jane=doe\")\n"],
              "type":"function",
              "name":"splitv",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"re",
                "3":"plain",
                "4":"n",
                "map":{
                  "re":" A Lua string pattern; defaults to '%s+'",
                  "n":" optional maximum number of splits",
                  "s":" the string",
                  "plain":" don't use Lua patterns"
                }
              },
              "tags":{
                "see":[]
              },
              "kind":"string functions ",
              "section":"String functions",
              "description":"\n Identical to `split` but returns multiple sub-strings instead of\n a single list of sub-strings.",
              "ret":["n values"]
            },{
              "name":"functional",
              "inferred":true,
              "description":"",
              "file":"<reference cycle>",
              "summary":"",
              "tags":[],
              "lineno":744,
              "display_name":"Functional",
              "type":"section",
              "modifiers":[]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[[]],
                "param":{
                  "1":[],
                  "func":[]
                }
              },
              "summary":"'memoize' a function (cache returned value for next call).",
              "lineno":750,
              "retgroups":[{
                  "1":{
                    "text":"a function with at least one argument, which is used as the key.",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(func)",
              "type":"function",
              "name":"memoize",
              "parameter":"param",
              "params":{
                "map":{
                  "func":" a function of at least one argument"
                },
                "1":"func"
              },
              "tags":[],
              "kind":"functional ",
              "section":"Functional",
              "description":"\n This is useful if you have a function which is relatively expensive,\n but you don't know in advance what values will be required, so\n building a table upfront is wasteful/impossible.",
              "ret":["a function with at least one argument, which is used as the key."]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":{
                  "1":{
                    "type":"tab"
                  },
                  "2":{
                    "type":"func"
                  },
                  "fun":{
                    "type":"func"
                  },
                  "mt":{
                    "type":"tab"
                  }
                }
              },
              "summary":"associate a function factory with a type.",
              "lineno":768,
              "args":"(mt, fun)",
              "section":"Functional",
              "name":"add_function_factory",
              "params":{
                "1":"mt",
                "2":"fun",
                "map":{
                  "fun":" a callable that returns a function",
                  "mt":" metatable"
                }
              },
              "tags":[],
              "kind":"functional ",
              "description":"\n A function factory takes an object of the given type and\n returns a function for evaluating it",
              "type":"function",
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "param":{
                  "1":[],
                  "lf":[]
                },
                "return":[[]],
                "usage":[[]]
              },
              "summary":"an anonymous function as a string.",
              "lineno":800,
              "retgroups":[{
                  "1":{
                    "text":"a function",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(lf)",
              "usage":["string_lambda '|x|x+1' (2) == 3\nstring_lambda '_+1' (2) == 3\n"],
              "type":"function",
              "name":"string_lambda",
              "params":{
                "map":{
                  "lf":" function as a string"
                },
                "1":"lf"
              },
              "tags":[],
              "kind":"functional ",
              "section":"Functional",
              "description":" This string is either of the form\n '|args| expression' or is a function of one argument, '_'",
              "ret":["a function"],
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[[]],
                "see":[[]],
                "param":{
                  "1":[],
                  "2":[],
                  "p":[],
                  "fn":[]
                },
                "raise":[],
                "usage":[[]]
              },
              "summary":"bind the first argument of the function to a value.",
              "lineno":817,
              "retgroups":[{
                  "1":{
                    "text":"a function such that f(x) is fn(p,x)",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(fn, p)",
              "usage":["local function f(msg, name)\n  print(msg .. \" \" .. name)\nend\n\nlocal hello = utils.bind1(f, \"Hello\")\n\nprint(hello(\"world\"))     --> \"Hello world\"\nprint(hello(\"sunshine\"))  --> \"Hello sunshine\"\n"],
              "raise":"same as @{function_arg}",
              "name":"bind1",
              "params":{
                "1":"fn",
                "2":"p",
                "map":{
                  "p":" a value",
                  "fn":" a function of at least two values (may be an operator string)"
                }
              },
              "tags":{
                "see":[]
              },
              "kind":"functional ",
              "section":"Functional",
              "type":"function",
              "parameter":"param",
              "ret":["a function such that f(x) is fn(p,x)"],
              "description":""
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[]],
                "param":{
                  "1":[],
                  "2":[],
                  "p":[],
                  "fn":[]
                },
                "raise":[],
                "return":[[]]
              },
              "summary":"bind the second argument of the function to a value.",
              "lineno":836,
              "retgroups":[{
                  "1":{
                    "text":"a function such that f(x) is fn(x,p)",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(fn, p)",
              "usage":["local function f(a, b, c)\n  print(a .. \" \" .. b .. \" \" .. c)\nend\n\nlocal hello = utils.bind1(f, \"world\")\n\nprint(hello(\"Hello\", \"!\"))  --> \"Hello world !\"\nprint(hello(\"Bye\", \"?\"))    --> \"Bye world ?\"\n"],
              "raise":"same as @{function_arg}",
              "name":"bind2",
              "params":{
                "1":"fn",
                "2":"p",
                "map":{
                  "p":" a value",
                  "fn":" a function of at least two values (may be an operator string)"
                }
              },
              "tags":[],
              "kind":"functional ",
              "section":"Functional",
              "type":"function",
              "parameter":"param",
              "ret":["a function such that f(x) is fn(x,p)"],
              "description":""
            },"<reference cycle>",{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":{
                  "1":[],
                  "func":[]
                },
                "usage":[[]],
                "see":[[]]
              },
              "summary":"Sets a deprecation warning function.",
              "lineno":875,
              "args":"(func)",
              "usage":["-- write to the Nginx logs with OpenResty\nutils.set_deprecation_func(function(msg, trace)\n  ngx.log(ngx.WARN, msg, (trace and (\" \" .. trace) or nil))\nend)\n\n-- disable deprecation warnings\nutils.set_deprecation_func()\n"],
              "section":"Deprecation",
              "name":"set_deprecation_func",
              "parameter":"param",
              "params":{
                "map":{
                  "func":" a callback with signature: `function(msg, trace)` both arguments are strings, the latter being optional."
                },
                "1":"func"
              },
              "tags":{
                "see":[]
              },
              "kind":"deprecation ",
              "description":"\n An application can override this function to support proper output of\n deprecation warnings. The warnings can be generated from libraries or\n functions by calling `utils.raise_deprecation`. The default function\n will write to the 'warn' system (introduced in Lua 5.4, or the compatibility\n function from the `compat` module for earlier versions).\n\n Note: only applications should set/change this function, libraries should not.",
              "type":"function"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":{
                  "1":[],
                  "opts":[]
                },
                "usage":[[]],
                "see":[[]]
              },
              "summary":"raises a deprecation warning.",
              "lineno":907,
              "args":"(opts)",
              "usage":["warn(\"@on\")   -- enable Lua warnings, they are usually off by default\n\nfunction stringx.islower(str)\n  raise_deprecation {\n    source = \"Penlight \" .. utils._VERSION,                   -- optional\n    message = \"function 'islower' was renamed to 'is_lower'\", -- required\n    version_removed = \"2.0.0\",                                -- optional\n    deprecated_after = \"1.2.3\",                               -- optional\n    no_trace = true,                                          -- optional\n  }\n  return stringx.is_lower(str)\nend\n-- output: \"[Penlight 1.9.2] function 'islower' was renamed to 'is_lower' (deprecated after 1.2.3, scheduled for removal in 2.0.0)\"\n"],
              "section":"Deprecation",
              "name":"raise_deprecation",
              "parameter":"param",
              "params":{
                "map":{
                  "opts":" options table"
                },
                "1":"opts"
              },
              "tags":{
                "see":[]
              },
              "kind":"deprecation ",
              "description":"\n For options see the usage example below.\n\n Note: the `opts.deprecated_after` field is the last version in which\n a feature or option was NOT YET deprecated! Because when writing the code it\n is quite often not known in what version the code will land. But the last\n released version is usually known.",
              "type":"function"
            }],
          "sections":[],
          "modules":["<reference cycle>"],
          "args":{
            "one":false,
            "module":false,
            "verbose":false,
            "style":"!",
            "template":"!",
            "date":"system",
            "dir":"doc",
            "quiet":false,
            "all":false,
            "ignore":false,
            "colon":false,
            "not_luadoc":false,
            "ext":"html",
            "boilerplate":false,
            "merge":false,
            "filter":"f.filter",
            "package":"/home/cji/portless/Penlight/lua",
            "dump":false,
            "no_args_infer":false,
            "title":"Reference",
            "project":"ldoc",
            "file":"/home/cji/portless/Penlight/lua/pl",
            "format":"discount",
            "simple":false,
            "tags":"none",
            "define":"none",
            "output":"index",
            "unqualified":false,
            "config":"config.ld",
            "fatalwarnings":false,
            "testing":false
          },
          "error":"<type 'function' is not supported by JSON.>",
          "lang":{
            "line_comment":"^%-%-+",
            "start_comment_":"^%-%-%-+",
            "end_comment_":"[^%-]%-%-+[^-]*\n$",
            "extra":[],
            "block_comment":"^%-%-%[=*%[%-+",
            "empty_comment_":"^%-%-%-+%s*$",
            "method_call":":"
          },
          "base":"/home/cji/portless/Penlight/lua"
        },
        "summary":"",
        "tags":[],
        "lineno":847,
        "display_name":"Deprecation",
        "type":"section",
        "modifiers":[]
      },
      "OS_functions":{
        "name":"OS-functions",
        "inferred":true,
        "description":"",
        "file":{
          "warning":"<type 'function' is not supported by JSON.>",
          "filename":"/home/cji/portless/Penlight/lua/pl/utils.lua",
          "items":["<reference cycle>",{
              "inferred":true,
              "description":"",
              "modifiers":{
                "field":[],
                "return":[]
              },
              "summary":"Some standard patterns",
              "lineno":31,
              "args":"(FLOAT, INTEGER, IDEN, FILE)",
              "type":"table",
              "name":"patterns",
              "parameter":"field",
              "params":{
                "1":"FLOAT",
                "2":"INTEGER",
                "3":"IDEN",
                "4":"FILE",
                "map":{
                  "FILE":"file",
                  "INTEGER":"integer number",
                  "IDEN":"identifier",
                  "FLOAT":"floating point number"
                }
              },
              "tags":[],
              "kind":"tables",
              "section":"table",
              "subparams":[]
            },{
              "name":"stdmt",
              "section":"table",
              "inferred":true,
              "description":"",
              "kind":"tables",
              "summary":"Standard meta-tables as used by other Penlight modules",
              "params":{
                "1":"List",
                "2":"Map",
                "3":"Set",
                "4":"MultiMap",
                "map":{
                  "Map":" the Map metatable",
                  "Set":" the Set metatable",
                  "MultiMap":" the MultiMap metatable",
                  "List":" the List metatable"
                }
              },
              "tags":[],
              "lineno":45,
              "subparams":[],
              "args":"(List, Map, Set, MultiMap)",
              "parameter":"field",
              "type":"table",
              "modifiers":{
                "field":{
                  "1":[],
                  "2":[],
                  "3":[],
                  "4":[],
                  "Map":[],
                  "Set":[],
                  "MultiMap":[],
                  "List":[]
                },
                "return":[]
              }
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "param":{
                  "1":[],
                  "...":[]
                },
                "return":[[]],
                "see":[[],[],[]]
              },
              "summary":"pack an argument list into a table.",
              "lineno":60,
              "retgroups":[{
                  "1":{
                    "text":"a table with field `n` set to the length",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(...)",
              "section":"function",
              "name":"pack",
              "params":{
                "map":{
                  "...":" any arguments"
                },
                "1":"..."
              },
              "tags":{
                "see":[]
              },
              "kind":"functions",
              "description":"",
              "type":"function",
              "ret":["a table with field `n` set to the length"],
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[[]],
                "usage":[[]],
                "param":{
                  "1":[],
                  "2":{
                    "optchain":true,
                    "opt":true
                  },
                  "3":{
                    "optchain":true,
                    "opt":true
                  },
                  "t":[],
                  "j":{
                    "optchain":true,
                    "opt":true
                  },
                  "i":{
                    "optchain":true,
                    "opt":true
                  }
                },
                "see":[[],[],[]]
              },
              "summary":"unpack a table and return its contents.",
              "lineno":79,
              "retgroups":[{
                  "1":{
                    "text":"multiple return values from the table",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(t[, i[, j]])",
              "usage":["local t = table.pack(nil, nil, nil, 4)\nlocal a, b, c, d = table.unpack(t)   -- this `unpack` is NOT nil-safe, so d == nil\n\nlocal a, b, c, d = utils.unpack(t)   -- this is nil-safe, so d == 4\n"],
              "type":"function",
              "name":"unpack",
              "params":{
                "1":"t",
                "2":"i",
                "map":{
                  "t":" table to unpack",
                  "j":" index of the last element to unpack, defaults to `t.n` or else `#t`",
                  "i":" index from which to start unpacking, defaults to 1"
                },
                "3":"j"
              },
              "tags":{
                "see":[]
              },
              "kind":"functions",
              "section":"function",
              "description":"\n\n NOTE: this implementation differs from the Lua implementation in the way\n that this one DOES honor the `n` field in the table `t`, such that it is 'nil-safe'.",
              "ret":["multiple return values from the table"],
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":{
                  "1":[],
                  "2":[],
                  "fmt":[],
                  "...":[]
                }
              },
              "summary":"print an arbitrary number of arguments using a format.",
              "lineno":87,
              "args":"(fmt, ...)",
              "section":"function",
              "name":"printf",
              "params":{
                "1":"fmt",
                "2":"...",
                "map":{
                  "fmt":" The format (see `string.format`)",
                  "...":" Extra arguments for format"
                }
              },
              "tags":[],
              "kind":"functions",
              "description":"\n Output will be sent to `stdout`.",
              "type":"function",
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":{
                  "1":[],
                  "2":[],
                  "3":[],
                  "fmt":[],
                  "f":[],
                  "...":[]
                }
              },
              "summary":"write an arbitrary number of arguments to a file using a format.",
              "lineno":96,
              "args":"(f, fmt, ...)",
              "section":"function",
              "name":"fprintf",
              "params":{
                "1":"f",
                "2":"fmt",
                "map":{
                  "fmt":" The format (see `string.format`).",
                  "f":" File handle to write to.",
                  "...":" Extra arguments for format"
                },
                "3":"..."
              },
              "tags":[],
              "kind":"functions",
              "description":"",
              "type":"function",
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":{
                  "1":[],
                  "2":[],
                  "t":[],
                  "T":[]
                }
              },
              "summary":"take a table and 'inject' it into the local namespace.",
              "lineno":124,
              "args":"(t, T)",
              "section":"function",
              "name":"import",
              "params":{
                "1":"t",
                "2":"T",
                "map":{
                  "t":" The table (table), or module name (string), defaults to this `utils` module table",
                  "T":" An optional destination table (defaults to callers environment)"
                }
              },
              "tags":[],
              "kind":"functions",
              "description":"",
              "type":"function",
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":{
                  "1":[],
                  "2":[],
                  "3":[],
                  "cond":[],
                  "value1":[],
                  "value2":[]
                }
              },
              "summary":"return either of two values, depending on a condition.",
              "lineno":143,
              "args":"(cond, value1, value2)",
              "section":"function",
              "name":"choose",
              "params":{
                "1":"cond",
                "2":"value1",
                "map":{
                  "cond":" A condition",
                  "value1":" Value returned if cond is truthy",
                  "value2":" Value returned if cond is falsy"
                },
                "3":"value2"
              },
              "tags":[],
              "kind":"functions",
              "description":"",
              "type":"function",
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[[]],
                "param":{
                  "1":[],
                  "2":{
                    "optchain":true,
                    "opt":true
                  },
                  "3":{
                    "optchain":true,
                    "opt":true
                  },
                  "t":[],
                  "temp":{
                    "optchain":true,
                    "opt":true
                  },
                  "tostr":{
                    "optchain":true,
                    "opt":true
                  }
                }
              },
              "summary":"convert an array of values to strings.",
              "lineno":152,
              "retgroups":[{
                  "1":{
                    "text":"the converted buffer",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(t[, temp[, tostr]])",
              "type":"function",
              "name":"array_tostring",
              "parameter":"param",
              "params":{
                "1":"t",
                "2":"temp",
                "map":{
                  "t":" a list-like table",
                  "temp":" (table) buffer to use, otherwise allocate",
                  "tostr":" custom tostring function, called with (value,index). Defaults to `tostring`."
                },
                "3":"tostr"
              },
              "tags":[],
              "kind":"functions",
              "section":"function",
              "description":"",
              "ret":["the converted buffer"]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[]],
                "param":{
                  "1":[],
                  "2":[],
                  "obj":[],
                  "tp":[]
                },
                "return":[[]]
              },
              "summary":"is the object of the specified type?",
              "lineno":172,
              "retgroups":[{
                  "1":{
                    "text":"boolean",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(obj, tp)",
              "usage":["utils.is_type(\"hello world\", \"string\")   --> true\n-- or check metatable\nlocal my_mt = {}\nlocal my_obj = setmetatable(my_obj, my_mt)\nutils.is_type(my_obj, my_mt)  --> true\n"],
              "type":"function",
              "name":"is_type",
              "parameter":"param",
              "params":{
                "1":"obj",
                "2":"tp",
                "map":{
                  "obj":" An object to check",
                  "tp":" String of what type it should be"
                }
              },
              "tags":[],
              "kind":"functions",
              "section":"function",
              "description":"\n If the type is a string, then use type, otherwise compare with metatable",
              "ret":["boolean"]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[]],
                "return":[{
                    "type":"integer"
                  },{
                    "type":"any"
                  }],
                "param":{
                  "1":{
                    "type":"table"
                  },
                  "2":{
                    "opt":"1",
                    "type":"integer",
                    "optchain":"1"
                  },
                  "3":{
                    "opt":"t.n or #t",
                    "type":"integer",
                    "optchain":"t.n or #t"
                  },
                  "4":{
                    "opt":"1",
                    "type":"integer",
                    "optchain":"1"
                  },
                  "t":{
                    "type":"table"
                  },
                  "step":{
                    "opt":"1",
                    "type":"integer",
                    "optchain":"1"
                  },
                  "i_start":{
                    "opt":"1",
                    "type":"integer",
                    "optchain":"1"
                  },
                  "i_end":{
                    "opt":"t.n or #t",
                    "type":"integer",
                    "optchain":"t.n or #t"
                  }
                },
                "see":[[],[]]
              },
              "summary":"an iterator with indices, similar to `ipairs`, but with a range.",
              "lineno":199,
              "retgroups":[{
                  "1":{
                    "text":"index",
                    "type":"integer",
                    "mods":{
                      "type":"integer"
                    }
                  },
                  "2":{
                    "text":"value at index (which can be `nil`!)",
                    "type":"any",
                    "mods":{
                      "type":"any"
                    }
                  },
                  "g":0
                }],
              "args":"(t[, i_start=1[, i_end=t.n or #t[, step=1]]])",
              "usage":["local t = utils.pack(nil, 123, nil)  -- adds an `n` field when packing\n\nfor i, v in utils.npairs(t, 2) do  -- start at index 2\n  t[i] = tostring(t[i])\nend\n\n-- t = { n = 3, [2] = \"123\", [3] = \"nil\" }\n"],
              "type":"function",
              "name":"npairs",
              "parameter":"param",
              "params":{
                "1":"t",
                "2":"i_start",
                "3":"i_end",
                "4":"step",
                "map":{
                  "t":" the table to iterate over",
                  "step":" step size",
                  "i_start":" start index",
                  "i_end":" end index"
                }
              },
              "tags":{
                "see":[]
              },
              "kind":"functions",
              "section":"function",
              "description":"\n This is a nil-safe index based iterator that will return `nil` when there\n is a hole in a list. To be safe ensure that table `t.n` contains the length.",
              "ret":["index","value at index (which can be `nil`!)"]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[]],
                "param":{
                  "1":{
                    "type":"table"
                  },
                  "t":{
                    "type":"table"
                  }
                },
                "return":[{
                    "type":"key"
                  },{
                    "type":"value"
                  }]
              },
              "summary":"an iterator over all non-integer keys (inverse of `ipairs`).",
              "lineno":253,
              "retgroups":[{
                  "1":{
                    "text":"",
                    "type":"key",
                    "mods":{
                      "type":"key"
                    }
                  },
                  "2":{
                    "text":"",
                    "type":"value",
                    "mods":{
                      "type":"value"
                    }
                  },
                  "g":0
                }],
              "args":"(t)",
              "usage":["local t = {\n  \"hello\",\n  \"world\",\n  hello = \"hallo\",\n  world = \"Welt\",\n}\n\nfor k, v in utils.kpairs(t) do\n  print(\"German: \", v)\nend\n\n-- output;\n-- German: hallo\n-- German: Welt\n"],
              "type":"function",
              "name":"kpairs",
              "parameter":"param",
              "params":{
                "map":{
                  "t":" the table to iterate over"
                },
                "1":"t"
              },
              "tags":[],
              "kind":"functions",
              "section":"function",
              "description":"\n It will skip any key that is an integer number, so negative indices or an\n array with holes will not return those either (so it returns slightly less than\n 'the inverse of `ipairs`').\n\n This uses `pairs` under the hood, so any value that is iterable using `pairs`\n will work with this function.",
              "ret":["",""]
            },{
              "name":"Error-handling",
              "inferred":true,
              "description":"",
              "file":"<reference cycle>",
              "summary":"",
              "tags":[],
              "lineno":272,
              "display_name":"Error handling",
              "type":"section",
              "modifiers":[]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[]],
                "param":{
                  "1":[],
                  "2":[],
                  "3":[],
                  "4":[],
                  "5":[],
                  "6":[],
                  "n":[],
                  "verify":[],
                  "val":[],
                  "lev":[],
                  "msg":[],
                  "tp":[]
                },
                "raise":[],
                "return":[[]]
              },
              "summary":"assert that the given argument is in fact of the correct type.",
              "lineno":285,
              "retgroups":[{
                  "1":{
                    "text":"the validated value",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(n, val, tp, verify, msg, lev)",
              "usage":["local param1 = assert_arg(1,\"hello\",'table')  --> error: argument 1 expected a 'table', got a 'string'\nlocal param4 = assert_arg(4,'!@#$%^&*','string',path.isdir,'not a directory')\n     --> error: argument 4: '!@#$%^&*' not a directory\n"],
              "raise":"if `val` is not the correct type",
              "name":"assert_arg",
              "params":{
                "1":"n",
                "2":"val",
                "3":"tp",
                "4":"verify",
                "5":"msg",
                "6":"lev",
                "map":{
                  "n":" argument index",
                  "verify":" an optional verification function",
                  "val":" the value",
                  "lev":" optional stack position for trace, default 2",
                  "msg":" an optional custom message",
                  "tp":" the type"
                }
              },
              "tags":[],
              "kind":"error handling ",
              "section":"Error handling",
              "type":"function",
              "parameter":"param",
              "ret":["the validated value"],
              "description":""
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[],[],[]],
                "param":{
                  "1":{
                    "type":"table|vararg"
                  },
                  "...":{
                    "type":"table|vararg"
                  }
                },
                "return":[[]]
              },
              "summary":"creates an Enum or constants lookup table for improved error handling.",
              "lineno":355,
              "retgroups":[{
                  "1":{
                    "text":"Enum object (read-only table/object)",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(...)",
              "usage":["-- Enum access at runtime\nlocal obj = {}\nobj.MOVEMENT = utils.enum(\"FORWARD\", \"REVERSE\", \"LEFT\", \"RIGHT\")\n\nif current_movement == obj.MOVEMENT.FORWARD then\n  -- do something\n\nelseif current_movement == obj.MOVEMENT.REVERES then\n  -- throws error due to typo 'REVERES', so a silent mistake becomes a hard error\n  -- \"'REVERES' is not a valid value (expected one of: 'FORWARD', 'REVERSE', 'LEFT', 'RIGHT')\"\n\nend\n","-- standardized error codes\nlocal obj = {\n  ERR = utils.enum {\n    NOT_FOUND = \"the item was not found\",\n    OUT_OF_BOUNDS = \"the index is outside the allowed range\"\n  },\n\n  some_method = function(self)\n    return self.ERR.OUT_OF_BOUNDS\n  end,\n}\n\nlocal result, err = obj:some_method()\nif not result then\n  if err == obj.ERR.NOT_FOUND then\n    -- check on error code, not magic strings\n\n  else\n    -- return the error description, contained in the constant\n    return nil, \"error: \"..err  -- \"error: the index is outside the allowed range\"\n  end\nend\n","-- validating/converting user-input\nlocal color = \"purple\"\nlocal ansi_colors = utils.enum {\n  black     = 30,\n  red       = 31,\n  green     = 32,\n}\nlocal color_code, err = ansi_colors(color) -- calling on the object, returns the value from the enum\nif not color_code then\n  print(\"bad 'color', \" .. err)\n  -- \"bad 'color', 'purple' is not a valid value (expected one of: 'black', 'red', 'green')\"\n  os.exit(1)\nend\n"],
              "type":"function",
              "name":"enum",
              "parameter":"param",
              "params":{
                "map":{
                  "...":" the input for the Enum. If varargs or an array then the\n values in the Enum will be equal to the names (must be strings), if a hash-table\n then values remain (any type), and the keys must be strings."
                },
                "1":"..."
              },
              "tags":[],
              "kind":"error handling ",
              "section":"Error handling",
              "description":"\n This helps prevent magic strings in code by throwing errors for accessing\n non-existing values, and/or converting strings/identifiers to other values.\n\n Calling on the object does the same, but returns a soft error; `nil + err`, if\n the call is succesful (the key exists), it will return the value.\n\n When calling with varargs or an array the values will be equal to the keys.\n The enum object is read-only.",
              "ret":["Enum object (read-only table/object)"]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "param":{
                  "1":[],
                  "2":[],
                  "3":[],
                  "f":[],
                  "msg":[],
                  "idx":[]
                },
                "raise":[],
                "return":[[]]
              },
              "summary":"process a function argument.",
              "lineno":430,
              "retgroups":[{
                  "1":{
                    "text":"a callable",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(idx, f, msg)",
              "type":"function",
              "name":"function_arg",
              "params":{
                "1":"idx",
                "2":"f",
                "map":{
                  "f":" a function, operator string, or callable object",
                  "msg":" optional error message",
                  "idx":" argument index"
                },
                "3":"msg"
              },
              "tags":[],
              "kind":"error handling ",
              "section":"Error handling",
              "description":"\n This is used throughout Penlight and defines what is meant by a function:\n Something that is callable, or an operator string as defined by <code>pl.operator</code>,\n such as '>' or '#'. If a function factory has been registered for the type, it will\n be called to get the function.",
              "raise":"if idx is not a number or if f is not callable",
              "ret":["a callable"],
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[]],
                "param":{
                  "1":[],
                  "2":[],
                  "val":[],
                  "n":[]
                },
                "raise":[],
                "return":[[]]
              },
              "summary":"assert the common case that the argument is a string.",
              "lineno":470,
              "retgroups":[{
                  "1":{
                    "text":"the validated value",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(n, val)",
              "usage":["local val = 42\nlocal param2 = utils.assert_string(2, val) --> error: argument 2 expected a 'string', got a 'number'\n"],
              "raise":"val must be a string",
              "name":"assert_string",
              "params":{
                "1":"n",
                "2":"val",
                "map":{
                  "val":" a value that must be a string",
                  "n":" argument index"
                }
              },
              "tags":[],
              "kind":"error handling ",
              "section":"Error handling",
              "type":"function",
              "parameter":"param",
              "ret":["the validated value"],
              "description":""
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "param":{
                  "1":[],
                  "mode":[]
                },
                "return":[],
                "see":[[]]
              },
              "summary":"control the error strategy used by Penlight.",
              "lineno":483,
              "args":"(mode)",
              "section":"Error handling",
              "name":"on_error",
              "params":{
                "map":{
                  "mode":" either 'default', 'quit'  or 'error'"
                },
                "1":"mode"
              },
              "tags":{
                "see":[]
              },
              "kind":"error handling ",
              "description":"\n This is a global setting that controls how `utils.raise` behaves:\n\n - 'default': return `nil + error` (this is the default)\n - 'error': throw a Lua error\n - 'quit': exit the program\n",
              "type":"function",
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":{
                  "1":[],
                  "err":[]
                },
                "usage":[[]],
                "see":[[]]
              },
              "summary":"used by Penlight functions to return errors.",
              "lineno":507,
              "args":"(err)",
              "usage":["if some_condition then\n  return utils.raise(\"some condition was not met\")  -- MUST use 'return'!\nend\n"],
              "section":"Error handling",
              "name":"raise",
              "parameter":"param",
              "params":{
                "map":{
                  "err":" the error string."
                },
                "1":"err"
              },
              "tags":{
                "see":[]
              },
              "kind":"error handling ",
              "description":" Its global behaviour is controlled\n by `utils.on_error`.\n To use this function you MUST use it in conjunction with `return`, since it might\n return `nil + error`.",
              "type":"function"
            },{
              "name":"files",
              "inferred":true,
              "description":"",
              "file":"<reference cycle>",
              "summary":"",
              "tags":[],
              "lineno":523,
              "display_name":"File handling",
              "type":"section",
              "modifiers":[]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[[]],
                "param":{
                  "1":[],
                  "2":[],
                  "filename":[],
                  "is_bin":[]
                }
              },
              "summary":"return the contents of a file as a string",
              "lineno":527,
              "retgroups":[{
                  "1":{
                    "text":"file contents",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(filename, is_bin)",
              "type":"function",
              "name":"readfile",
              "parameter":"param",
              "params":{
                "1":"filename",
                "2":"is_bin",
                "map":{
                  "filename":" The file path",
                  "is_bin":" open in binary mode"
                }
              },
              "tags":[],
              "kind":"file handling ",
              "section":"File handling",
              "description":"",
              "ret":["file contents"]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "param":{
                  "1":[],
                  "2":[],
                  "3":[],
                  "filename":[],
                  "str":[],
                  "is_bin":[]
                },
                "raise":[],
                "return":[[],[]]
              },
              "summary":"write a string to a file",
              "lineno":549,
              "retgroups":[{
                  "1":{
                    "text":"true or nil",
                    "type":"",
                    "mods":[]
                  },
                  "2":{
                    "text":"error message",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(filename, str, is_bin)",
              "type":"function",
              "name":"writefile",
              "params":{
                "1":"filename",
                "2":"str",
                "map":{
                  "filename":" The file path",
                  "str":" The string",
                  "is_bin":" open in binary mode"
                },
                "3":"is_bin"
              },
              "tags":[],
              "kind":"file handling ",
              "section":"File handling",
              "description":"",
              "raise":"error if filename or str aren't strings",
              "ret":["true or nil","error message"],
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "param":{
                  "1":[],
                  "filename":[]
                },
                "raise":[],
                "return":[[]]
              },
              "summary":"return the contents of a file as a list of lines",
              "lineno":569,
              "retgroups":[{
                  "1":{
                    "text":"file contents as a table",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(filename)",
              "type":"function",
              "name":"readlines",
              "params":{
                "map":{
                  "filename":" The file path"
                },
                "1":"filename"
              },
              "tags":[],
              "kind":"file handling ",
              "section":"File handling",
              "description":"",
              "raise":"error if filename is not a string",
              "ret":["file contents as a table"],
              "parameter":"param"
            },"<reference cycle>",{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[[],[],[],[]],
                "param":{
                  "1":[],
                  "2":[],
                  "bin":[],
                  "cmd":[]
                }
              },
              "summary":"execute a shell command and return the output.",
              "lineno":592,
              "retgroups":[{
                  "1":{
                    "text":"true if successful",
                    "type":"",
                    "mods":[]
                  },
                  "2":{
                    "text":"actual return code",
                    "type":"",
                    "mods":[]
                  },
                  "3":{
                    "text":"stdout output (string)",
                    "type":"",
                    "mods":[]
                  },
                  "4":{
                    "text":"errout output (string)",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(cmd, bin)",
              "type":"function",
              "name":"executeex",
              "parameter":"param",
              "params":{
                "1":"cmd",
                "2":"bin",
                "map":{
                  "bin":" boolean, if true, read output as binary file",
                  "cmd":" a shell command"
                }
              },
              "tags":[],
              "kind":"os functions ",
              "section":"OS functions",
              "description":"\n This function redirects the output to tempfiles and returns the content of those files.",
              "ret":["true if successful","actual return code","stdout output (string)","errout output (string)"]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[]],
                "param":{
                  "1":[],
                  "argument":[]
                },
                "return":[[]]
              },
              "summary":"Quote and escape an argument of a command.",
              "lineno":623,
              "retgroups":[{
                  "1":{
                    "text":"quoted and escaped argument.",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(argument)",
              "usage":["local options = utils.quote_arg {\n    \"-lluacov\",\n    \"-e\",\n    \"utils = print(require('pl.utils')._VERSION\",\n}\n-- returns: -lluacov -e 'utils = print(require('\\''pl.utils'\\'')._VERSION'\n"],
              "type":"function",
              "name":"quote_arg",
              "parameter":"param",
              "params":{
                "map":{
                  "argument":" (string or table/list) the argument to quote. If a list then\n all arguments in the list will be returned as a single string quoted."
                },
                "1":"argument"
              },
              "tags":[],
              "kind":"os functions ",
              "section":"OS functions",
              "description":"\n Quotes a single (or list of) argument(s) of a command to be passed\n to `os.execute`, `pl.utils.execute` or `pl.utils.executeex`.",
              "ret":["quoted and escaped argument."]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":{
                  "1":{
                    "opt":true
                  },
                  "2":[],
                  "3":[],
                  "msg":[],
                  "...":[],
                  "code":{
                    "opt":true
                  }
                },
                "usage":[[]],
                "see":[[]]
              },
              "summary":"error out of this program gracefully.",
              "lineno":667,
              "args":"([code], msg, ...)",
              "usage":["utils.quit(-1, \"Error '%s' happened\", \"42\")\n-- is equivalent to\nutils.quit(\"Error '%s' happened\", \"42\")  --> Error '42' happened\n"],
              "section":"OS functions",
              "name":"quit",
              "parameter":"param",
              "params":{
                "1":"code",
                "2":"msg",
                "map":{
                  "msg":" The exit message will be sent to `stderr` (will be formatted with the extra parameters)",
                  "...":" extra arguments for message's format'",
                  "code":" The exit code, defaults to -`1` if omitted"
                },
                "3":"..."
              },
              "tags":{
                "see":[]
              },
              "kind":"os functions ",
              "description":"",
              "type":"function"
            },{
              "name":"string-functions",
              "inferred":true,
              "description":"",
              "file":"<reference cycle>",
              "summary":"",
              "tags":[],
              "lineno":683,
              "display_name":"String functions",
              "type":"section",
              "modifiers":[]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":{
                  "1":[],
                  "s":[]
                }
              },
              "summary":"escape any Lua 'magic' characters in a string",
              "lineno":685,
              "args":"(s)",
              "section":"String functions",
              "name":"escape",
              "params":{
                "map":{
                  "s":" The input string"
                },
                "1":"s"
              },
              "tags":[],
              "kind":"string functions ",
              "description":"",
              "type":"function",
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "param":{
                  "1":[],
                  "2":[],
                  "3":[],
                  "4":[],
                  "re":[],
                  "n":[],
                  "s":[],
                  "plain":[]
                },
                "return":[[]],
                "raise":[],
                "see":[[]]
              },
              "summary":"split a string into a list of strings separated by a delimiter.",
              "lineno":698,
              "retgroups":[{
                  "1":{
                    "text":"a list-like table",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s, re, plain, n)",
              "type":"function",
              "name":"split",
              "params":{
                "1":"s",
                "2":"re",
                "3":"plain",
                "4":"n",
                "map":{
                  "re":" optional A Lua string pattern; defaults to '%s+'",
                  "n":" optional maximum number of elements (if there are more, the last will remian un-split)",
                  "s":" The input string",
                  "plain":" optional If truthy don't use Lua patterns"
                }
              },
              "tags":{
                "see":[]
              },
              "kind":"string functions ",
              "section":"String functions",
              "description":"",
              "raise":"error if s is not a string",
              "ret":["a list-like table"],
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "param":{
                  "1":[],
                  "2":[],
                  "3":[],
                  "4":[],
                  "re":[],
                  "n":[],
                  "s":[],
                  "plain":[]
                },
                "return":[[]],
                "usage":[[]],
                "see":[[]]
              },
              "summary":"split a string into a number of return values.",
              "lineno":735,
              "retgroups":[{
                  "1":{
                    "text":"n values",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s, re, plain, n)",
              "usage":["first,next = splitv('user=jane=doe','=', false, 2)\nassert(first == \"user\")\nassert(next == \"jane=doe\")\n"],
              "type":"function",
              "name":"splitv",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"re",
                "3":"plain",
                "4":"n",
                "map":{
                  "re":" A Lua string pattern; defaults to '%s+'",
                  "n":" optional maximum number of splits",
                  "s":" the string",
                  "plain":" don't use Lua patterns"
                }
              },
              "tags":{
                "see":[]
              },
              "kind":"string functions ",
              "section":"String functions",
              "description":"\n Identical to `split` but returns multiple sub-strings instead of\n a single list of sub-strings.",
              "ret":["n values"]
            },{
              "name":"functional",
              "inferred":true,
              "description":"",
              "file":"<reference cycle>",
              "summary":"",
              "tags":[],
              "lineno":744,
              "display_name":"Functional",
              "type":"section",
              "modifiers":[]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[[]],
                "param":{
                  "1":[],
                  "func":[]
                }
              },
              "summary":"'memoize' a function (cache returned value for next call).",
              "lineno":750,
              "retgroups":[{
                  "1":{
                    "text":"a function with at least one argument, which is used as the key.",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(func)",
              "type":"function",
              "name":"memoize",
              "parameter":"param",
              "params":{
                "map":{
                  "func":" a function of at least one argument"
                },
                "1":"func"
              },
              "tags":[],
              "kind":"functional ",
              "section":"Functional",
              "description":"\n This is useful if you have a function which is relatively expensive,\n but you don't know in advance what values will be required, so\n building a table upfront is wasteful/impossible.",
              "ret":["a function with at least one argument, which is used as the key."]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":{
                  "1":{
                    "type":"tab"
                  },
                  "2":{
                    "type":"func"
                  },
                  "fun":{
                    "type":"func"
                  },
                  "mt":{
                    "type":"tab"
                  }
                }
              },
              "summary":"associate a function factory with a type.",
              "lineno":768,
              "args":"(mt, fun)",
              "section":"Functional",
              "name":"add_function_factory",
              "params":{
                "1":"mt",
                "2":"fun",
                "map":{
                  "fun":" a callable that returns a function",
                  "mt":" metatable"
                }
              },
              "tags":[],
              "kind":"functional ",
              "description":"\n A function factory takes an object of the given type and\n returns a function for evaluating it",
              "type":"function",
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "param":{
                  "1":[],
                  "lf":[]
                },
                "return":[[]],
                "usage":[[]]
              },
              "summary":"an anonymous function as a string.",
              "lineno":800,
              "retgroups":[{
                  "1":{
                    "text":"a function",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(lf)",
              "usage":["string_lambda '|x|x+1' (2) == 3\nstring_lambda '_+1' (2) == 3\n"],
              "type":"function",
              "name":"string_lambda",
              "params":{
                "map":{
                  "lf":" function as a string"
                },
                "1":"lf"
              },
              "tags":[],
              "kind":"functional ",
              "section":"Functional",
              "description":" This string is either of the form\n '|args| expression' or is a function of one argument, '_'",
              "ret":["a function"],
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[[]],
                "see":[[]],
                "param":{
                  "1":[],
                  "2":[],
                  "p":[],
                  "fn":[]
                },
                "raise":[],
                "usage":[[]]
              },
              "summary":"bind the first argument of the function to a value.",
              "lineno":817,
              "retgroups":[{
                  "1":{
                    "text":"a function such that f(x) is fn(p,x)",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(fn, p)",
              "usage":["local function f(msg, name)\n  print(msg .. \" \" .. name)\nend\n\nlocal hello = utils.bind1(f, \"Hello\")\n\nprint(hello(\"world\"))     --> \"Hello world\"\nprint(hello(\"sunshine\"))  --> \"Hello sunshine\"\n"],
              "raise":"same as @{function_arg}",
              "name":"bind1",
              "params":{
                "1":"fn",
                "2":"p",
                "map":{
                  "p":" a value",
                  "fn":" a function of at least two values (may be an operator string)"
                }
              },
              "tags":{
                "see":[]
              },
              "kind":"functional ",
              "section":"Functional",
              "type":"function",
              "parameter":"param",
              "ret":["a function such that f(x) is fn(p,x)"],
              "description":""
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[]],
                "param":{
                  "1":[],
                  "2":[],
                  "p":[],
                  "fn":[]
                },
                "raise":[],
                "return":[[]]
              },
              "summary":"bind the second argument of the function to a value.",
              "lineno":836,
              "retgroups":[{
                  "1":{
                    "text":"a function such that f(x) is fn(x,p)",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(fn, p)",
              "usage":["local function f(a, b, c)\n  print(a .. \" \" .. b .. \" \" .. c)\nend\n\nlocal hello = utils.bind1(f, \"world\")\n\nprint(hello(\"Hello\", \"!\"))  --> \"Hello world !\"\nprint(hello(\"Bye\", \"?\"))    --> \"Bye world ?\"\n"],
              "raise":"same as @{function_arg}",
              "name":"bind2",
              "params":{
                "1":"fn",
                "2":"p",
                "map":{
                  "p":" a value",
                  "fn":" a function of at least two values (may be an operator string)"
                }
              },
              "tags":[],
              "kind":"functional ",
              "section":"Functional",
              "type":"function",
              "parameter":"param",
              "ret":["a function such that f(x) is fn(x,p)"],
              "description":""
            },{
              "name":"deprecation",
              "inferred":true,
              "description":"",
              "file":"<reference cycle>",
              "summary":"",
              "tags":[],
              "lineno":847,
              "display_name":"Deprecation",
              "type":"section",
              "modifiers":[]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":{
                  "1":[],
                  "func":[]
                },
                "usage":[[]],
                "see":[[]]
              },
              "summary":"Sets a deprecation warning function.",
              "lineno":875,
              "args":"(func)",
              "usage":["-- write to the Nginx logs with OpenResty\nutils.set_deprecation_func(function(msg, trace)\n  ngx.log(ngx.WARN, msg, (trace and (\" \" .. trace) or nil))\nend)\n\n-- disable deprecation warnings\nutils.set_deprecation_func()\n"],
              "section":"Deprecation",
              "name":"set_deprecation_func",
              "parameter":"param",
              "params":{
                "map":{
                  "func":" a callback with signature: `function(msg, trace)` both arguments are strings, the latter being optional."
                },
                "1":"func"
              },
              "tags":{
                "see":[]
              },
              "kind":"deprecation ",
              "description":"\n An application can override this function to support proper output of\n deprecation warnings. The warnings can be generated from libraries or\n functions by calling `utils.raise_deprecation`. The default function\n will write to the 'warn' system (introduced in Lua 5.4, or the compatibility\n function from the `compat` module for earlier versions).\n\n Note: only applications should set/change this function, libraries should not.",
              "type":"function"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":{
                  "1":[],
                  "opts":[]
                },
                "usage":[[]],
                "see":[[]]
              },
              "summary":"raises a deprecation warning.",
              "lineno":907,
              "args":"(opts)",
              "usage":["warn(\"@on\")   -- enable Lua warnings, they are usually off by default\n\nfunction stringx.islower(str)\n  raise_deprecation {\n    source = \"Penlight \" .. utils._VERSION,                   -- optional\n    message = \"function 'islower' was renamed to 'is_lower'\", -- required\n    version_removed = \"2.0.0\",                                -- optional\n    deprecated_after = \"1.2.3\",                               -- optional\n    no_trace = true,                                          -- optional\n  }\n  return stringx.is_lower(str)\nend\n-- output: \"[Penlight 1.9.2] function 'islower' was renamed to 'is_lower' (deprecated after 1.2.3, scheduled for removal in 2.0.0)\"\n"],
              "section":"Deprecation",
              "name":"raise_deprecation",
              "parameter":"param",
              "params":{
                "map":{
                  "opts":" options table"
                },
                "1":"opts"
              },
              "tags":{
                "see":[]
              },
              "kind":"deprecation ",
              "description":"\n For options see the usage example below.\n\n Note: the `opts.deprecated_after` field is the last version in which\n a feature or option was NOT YET deprecated! Because when writing the code it\n is quite often not known in what version the code will land. But the last\n released version is usually known.",
              "type":"function"
            }],
          "sections":[],
          "modules":["<reference cycle>"],
          "args":{
            "one":false,
            "module":false,
            "verbose":false,
            "style":"!",
            "template":"!",
            "date":"system",
            "dir":"doc",
            "quiet":false,
            "all":false,
            "ignore":false,
            "colon":false,
            "not_luadoc":false,
            "ext":"html",
            "boilerplate":false,
            "merge":false,
            "filter":"f.filter",
            "package":"/home/cji/portless/Penlight/lua",
            "dump":false,
            "no_args_infer":false,
            "title":"Reference",
            "project":"ldoc",
            "file":"/home/cji/portless/Penlight/lua/pl",
            "format":"discount",
            "simple":false,
            "tags":"none",
            "define":"none",
            "output":"index",
            "unqualified":false,
            "config":"config.ld",
            "fatalwarnings":false,
            "testing":false
          },
          "error":"<type 'function' is not supported by JSON.>",
          "lang":{
            "line_comment":"^%-%-+",
            "start_comment_":"^%-%-%-+",
            "end_comment_":"[^%-]%-%-+[^-]*\n$",
            "extra":[],
            "block_comment":"^%-%-%[=*%[%-+",
            "empty_comment_":"^%-%-%-+%s*$",
            "method_call":":"
          },
          "base":"/home/cji/portless/Penlight/lua"
        },
        "summary":"",
        "tags":[],
        "lineno":584,
        "display_name":"OS functions",
        "type":"section",
        "modifiers":[]
      },
      "String_functions":{
        "name":"string-functions",
        "inferred":true,
        "description":"",
        "file":{
          "warning":"<type 'function' is not supported by JSON.>",
          "filename":"/home/cji/portless/Penlight/lua/pl/utils.lua",
          "items":["<reference cycle>",{
              "inferred":true,
              "description":"",
              "modifiers":{
                "field":[],
                "return":[]
              },
              "summary":"Some standard patterns",
              "lineno":31,
              "args":"(FLOAT, INTEGER, IDEN, FILE)",
              "type":"table",
              "name":"patterns",
              "parameter":"field",
              "params":{
                "1":"FLOAT",
                "2":"INTEGER",
                "3":"IDEN",
                "4":"FILE",
                "map":{
                  "FILE":"file",
                  "INTEGER":"integer number",
                  "IDEN":"identifier",
                  "FLOAT":"floating point number"
                }
              },
              "tags":[],
              "kind":"tables",
              "section":"table",
              "subparams":[]
            },{
              "name":"stdmt",
              "section":"table",
              "inferred":true,
              "description":"",
              "kind":"tables",
              "summary":"Standard meta-tables as used by other Penlight modules",
              "params":{
                "1":"List",
                "2":"Map",
                "3":"Set",
                "4":"MultiMap",
                "map":{
                  "Map":" the Map metatable",
                  "Set":" the Set metatable",
                  "MultiMap":" the MultiMap metatable",
                  "List":" the List metatable"
                }
              },
              "tags":[],
              "lineno":45,
              "subparams":[],
              "args":"(List, Map, Set, MultiMap)",
              "parameter":"field",
              "type":"table",
              "modifiers":{
                "field":{
                  "1":[],
                  "2":[],
                  "3":[],
                  "4":[],
                  "Map":[],
                  "Set":[],
                  "MultiMap":[],
                  "List":[]
                },
                "return":[]
              }
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "param":{
                  "1":[],
                  "...":[]
                },
                "return":[[]],
                "see":[[],[],[]]
              },
              "summary":"pack an argument list into a table.",
              "lineno":60,
              "retgroups":[{
                  "1":{
                    "text":"a table with field `n` set to the length",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(...)",
              "section":"function",
              "name":"pack",
              "params":{
                "map":{
                  "...":" any arguments"
                },
                "1":"..."
              },
              "tags":{
                "see":[]
              },
              "kind":"functions",
              "description":"",
              "type":"function",
              "ret":["a table with field `n` set to the length"],
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[[]],
                "usage":[[]],
                "param":{
                  "1":[],
                  "2":{
                    "optchain":true,
                    "opt":true
                  },
                  "3":{
                    "optchain":true,
                    "opt":true
                  },
                  "t":[],
                  "j":{
                    "optchain":true,
                    "opt":true
                  },
                  "i":{
                    "optchain":true,
                    "opt":true
                  }
                },
                "see":[[],[],[]]
              },
              "summary":"unpack a table and return its contents.",
              "lineno":79,
              "retgroups":[{
                  "1":{
                    "text":"multiple return values from the table",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(t[, i[, j]])",
              "usage":["local t = table.pack(nil, nil, nil, 4)\nlocal a, b, c, d = table.unpack(t)   -- this `unpack` is NOT nil-safe, so d == nil\n\nlocal a, b, c, d = utils.unpack(t)   -- this is nil-safe, so d == 4\n"],
              "type":"function",
              "name":"unpack",
              "params":{
                "1":"t",
                "2":"i",
                "map":{
                  "t":" table to unpack",
                  "j":" index of the last element to unpack, defaults to `t.n` or else `#t`",
                  "i":" index from which to start unpacking, defaults to 1"
                },
                "3":"j"
              },
              "tags":{
                "see":[]
              },
              "kind":"functions",
              "section":"function",
              "description":"\n\n NOTE: this implementation differs from the Lua implementation in the way\n that this one DOES honor the `n` field in the table `t`, such that it is 'nil-safe'.",
              "ret":["multiple return values from the table"],
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":{
                  "1":[],
                  "2":[],
                  "fmt":[],
                  "...":[]
                }
              },
              "summary":"print an arbitrary number of arguments using a format.",
              "lineno":87,
              "args":"(fmt, ...)",
              "section":"function",
              "name":"printf",
              "params":{
                "1":"fmt",
                "2":"...",
                "map":{
                  "fmt":" The format (see `string.format`)",
                  "...":" Extra arguments for format"
                }
              },
              "tags":[],
              "kind":"functions",
              "description":"\n Output will be sent to `stdout`.",
              "type":"function",
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":{
                  "1":[],
                  "2":[],
                  "3":[],
                  "fmt":[],
                  "f":[],
                  "...":[]
                }
              },
              "summary":"write an arbitrary number of arguments to a file using a format.",
              "lineno":96,
              "args":"(f, fmt, ...)",
              "section":"function",
              "name":"fprintf",
              "params":{
                "1":"f",
                "2":"fmt",
                "map":{
                  "fmt":" The format (see `string.format`).",
                  "f":" File handle to write to.",
                  "...":" Extra arguments for format"
                },
                "3":"..."
              },
              "tags":[],
              "kind":"functions",
              "description":"",
              "type":"function",
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":{
                  "1":[],
                  "2":[],
                  "t":[],
                  "T":[]
                }
              },
              "summary":"take a table and 'inject' it into the local namespace.",
              "lineno":124,
              "args":"(t, T)",
              "section":"function",
              "name":"import",
              "params":{
                "1":"t",
                "2":"T",
                "map":{
                  "t":" The table (table), or module name (string), defaults to this `utils` module table",
                  "T":" An optional destination table (defaults to callers environment)"
                }
              },
              "tags":[],
              "kind":"functions",
              "description":"",
              "type":"function",
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":{
                  "1":[],
                  "2":[],
                  "3":[],
                  "cond":[],
                  "value1":[],
                  "value2":[]
                }
              },
              "summary":"return either of two values, depending on a condition.",
              "lineno":143,
              "args":"(cond, value1, value2)",
              "section":"function",
              "name":"choose",
              "params":{
                "1":"cond",
                "2":"value1",
                "map":{
                  "cond":" A condition",
                  "value1":" Value returned if cond is truthy",
                  "value2":" Value returned if cond is falsy"
                },
                "3":"value2"
              },
              "tags":[],
              "kind":"functions",
              "description":"",
              "type":"function",
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[[]],
                "param":{
                  "1":[],
                  "2":{
                    "optchain":true,
                    "opt":true
                  },
                  "3":{
                    "optchain":true,
                    "opt":true
                  },
                  "t":[],
                  "temp":{
                    "optchain":true,
                    "opt":true
                  },
                  "tostr":{
                    "optchain":true,
                    "opt":true
                  }
                }
              },
              "summary":"convert an array of values to strings.",
              "lineno":152,
              "retgroups":[{
                  "1":{
                    "text":"the converted buffer",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(t[, temp[, tostr]])",
              "type":"function",
              "name":"array_tostring",
              "parameter":"param",
              "params":{
                "1":"t",
                "2":"temp",
                "map":{
                  "t":" a list-like table",
                  "temp":" (table) buffer to use, otherwise allocate",
                  "tostr":" custom tostring function, called with (value,index). Defaults to `tostring`."
                },
                "3":"tostr"
              },
              "tags":[],
              "kind":"functions",
              "section":"function",
              "description":"",
              "ret":["the converted buffer"]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[]],
                "param":{
                  "1":[],
                  "2":[],
                  "obj":[],
                  "tp":[]
                },
                "return":[[]]
              },
              "summary":"is the object of the specified type?",
              "lineno":172,
              "retgroups":[{
                  "1":{
                    "text":"boolean",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(obj, tp)",
              "usage":["utils.is_type(\"hello world\", \"string\")   --> true\n-- or check metatable\nlocal my_mt = {}\nlocal my_obj = setmetatable(my_obj, my_mt)\nutils.is_type(my_obj, my_mt)  --> true\n"],
              "type":"function",
              "name":"is_type",
              "parameter":"param",
              "params":{
                "1":"obj",
                "2":"tp",
                "map":{
                  "obj":" An object to check",
                  "tp":" String of what type it should be"
                }
              },
              "tags":[],
              "kind":"functions",
              "section":"function",
              "description":"\n If the type is a string, then use type, otherwise compare with metatable",
              "ret":["boolean"]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[]],
                "return":[{
                    "type":"integer"
                  },{
                    "type":"any"
                  }],
                "param":{
                  "1":{
                    "type":"table"
                  },
                  "2":{
                    "opt":"1",
                    "type":"integer",
                    "optchain":"1"
                  },
                  "3":{
                    "opt":"t.n or #t",
                    "type":"integer",
                    "optchain":"t.n or #t"
                  },
                  "4":{
                    "opt":"1",
                    "type":"integer",
                    "optchain":"1"
                  },
                  "t":{
                    "type":"table"
                  },
                  "step":{
                    "opt":"1",
                    "type":"integer",
                    "optchain":"1"
                  },
                  "i_start":{
                    "opt":"1",
                    "type":"integer",
                    "optchain":"1"
                  },
                  "i_end":{
                    "opt":"t.n or #t",
                    "type":"integer",
                    "optchain":"t.n or #t"
                  }
                },
                "see":[[],[]]
              },
              "summary":"an iterator with indices, similar to `ipairs`, but with a range.",
              "lineno":199,
              "retgroups":[{
                  "1":{
                    "text":"index",
                    "type":"integer",
                    "mods":{
                      "type":"integer"
                    }
                  },
                  "2":{
                    "text":"value at index (which can be `nil`!)",
                    "type":"any",
                    "mods":{
                      "type":"any"
                    }
                  },
                  "g":0
                }],
              "args":"(t[, i_start=1[, i_end=t.n or #t[, step=1]]])",
              "usage":["local t = utils.pack(nil, 123, nil)  -- adds an `n` field when packing\n\nfor i, v in utils.npairs(t, 2) do  -- start at index 2\n  t[i] = tostring(t[i])\nend\n\n-- t = { n = 3, [2] = \"123\", [3] = \"nil\" }\n"],
              "type":"function",
              "name":"npairs",
              "parameter":"param",
              "params":{
                "1":"t",
                "2":"i_start",
                "3":"i_end",
                "4":"step",
                "map":{
                  "t":" the table to iterate over",
                  "step":" step size",
                  "i_start":" start index",
                  "i_end":" end index"
                }
              },
              "tags":{
                "see":[]
              },
              "kind":"functions",
              "section":"function",
              "description":"\n This is a nil-safe index based iterator that will return `nil` when there\n is a hole in a list. To be safe ensure that table `t.n` contains the length.",
              "ret":["index","value at index (which can be `nil`!)"]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[]],
                "param":{
                  "1":{
                    "type":"table"
                  },
                  "t":{
                    "type":"table"
                  }
                },
                "return":[{
                    "type":"key"
                  },{
                    "type":"value"
                  }]
              },
              "summary":"an iterator over all non-integer keys (inverse of `ipairs`).",
              "lineno":253,
              "retgroups":[{
                  "1":{
                    "text":"",
                    "type":"key",
                    "mods":{
                      "type":"key"
                    }
                  },
                  "2":{
                    "text":"",
                    "type":"value",
                    "mods":{
                      "type":"value"
                    }
                  },
                  "g":0
                }],
              "args":"(t)",
              "usage":["local t = {\n  \"hello\",\n  \"world\",\n  hello = \"hallo\",\n  world = \"Welt\",\n}\n\nfor k, v in utils.kpairs(t) do\n  print(\"German: \", v)\nend\n\n-- output;\n-- German: hallo\n-- German: Welt\n"],
              "type":"function",
              "name":"kpairs",
              "parameter":"param",
              "params":{
                "map":{
                  "t":" the table to iterate over"
                },
                "1":"t"
              },
              "tags":[],
              "kind":"functions",
              "section":"function",
              "description":"\n It will skip any key that is an integer number, so negative indices or an\n array with holes will not return those either (so it returns slightly less than\n 'the inverse of `ipairs`').\n\n This uses `pairs` under the hood, so any value that is iterable using `pairs`\n will work with this function.",
              "ret":["",""]
            },{
              "name":"Error-handling",
              "inferred":true,
              "description":"",
              "file":"<reference cycle>",
              "summary":"",
              "tags":[],
              "lineno":272,
              "display_name":"Error handling",
              "type":"section",
              "modifiers":[]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[]],
                "param":{
                  "1":[],
                  "2":[],
                  "3":[],
                  "4":[],
                  "5":[],
                  "6":[],
                  "n":[],
                  "verify":[],
                  "val":[],
                  "lev":[],
                  "msg":[],
                  "tp":[]
                },
                "raise":[],
                "return":[[]]
              },
              "summary":"assert that the given argument is in fact of the correct type.",
              "lineno":285,
              "retgroups":[{
                  "1":{
                    "text":"the validated value",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(n, val, tp, verify, msg, lev)",
              "usage":["local param1 = assert_arg(1,\"hello\",'table')  --> error: argument 1 expected a 'table', got a 'string'\nlocal param4 = assert_arg(4,'!@#$%^&*','string',path.isdir,'not a directory')\n     --> error: argument 4: '!@#$%^&*' not a directory\n"],
              "raise":"if `val` is not the correct type",
              "name":"assert_arg",
              "params":{
                "1":"n",
                "2":"val",
                "3":"tp",
                "4":"verify",
                "5":"msg",
                "6":"lev",
                "map":{
                  "n":" argument index",
                  "verify":" an optional verification function",
                  "val":" the value",
                  "lev":" optional stack position for trace, default 2",
                  "msg":" an optional custom message",
                  "tp":" the type"
                }
              },
              "tags":[],
              "kind":"error handling ",
              "section":"Error handling",
              "type":"function",
              "parameter":"param",
              "ret":["the validated value"],
              "description":""
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[],[],[]],
                "param":{
                  "1":{
                    "type":"table|vararg"
                  },
                  "...":{
                    "type":"table|vararg"
                  }
                },
                "return":[[]]
              },
              "summary":"creates an Enum or constants lookup table for improved error handling.",
              "lineno":355,
              "retgroups":[{
                  "1":{
                    "text":"Enum object (read-only table/object)",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(...)",
              "usage":["-- Enum access at runtime\nlocal obj = {}\nobj.MOVEMENT = utils.enum(\"FORWARD\", \"REVERSE\", \"LEFT\", \"RIGHT\")\n\nif current_movement == obj.MOVEMENT.FORWARD then\n  -- do something\n\nelseif current_movement == obj.MOVEMENT.REVERES then\n  -- throws error due to typo 'REVERES', so a silent mistake becomes a hard error\n  -- \"'REVERES' is not a valid value (expected one of: 'FORWARD', 'REVERSE', 'LEFT', 'RIGHT')\"\n\nend\n","-- standardized error codes\nlocal obj = {\n  ERR = utils.enum {\n    NOT_FOUND = \"the item was not found\",\n    OUT_OF_BOUNDS = \"the index is outside the allowed range\"\n  },\n\n  some_method = function(self)\n    return self.ERR.OUT_OF_BOUNDS\n  end,\n}\n\nlocal result, err = obj:some_method()\nif not result then\n  if err == obj.ERR.NOT_FOUND then\n    -- check on error code, not magic strings\n\n  else\n    -- return the error description, contained in the constant\n    return nil, \"error: \"..err  -- \"error: the index is outside the allowed range\"\n  end\nend\n","-- validating/converting user-input\nlocal color = \"purple\"\nlocal ansi_colors = utils.enum {\n  black     = 30,\n  red       = 31,\n  green     = 32,\n}\nlocal color_code, err = ansi_colors(color) -- calling on the object, returns the value from the enum\nif not color_code then\n  print(\"bad 'color', \" .. err)\n  -- \"bad 'color', 'purple' is not a valid value (expected one of: 'black', 'red', 'green')\"\n  os.exit(1)\nend\n"],
              "type":"function",
              "name":"enum",
              "parameter":"param",
              "params":{
                "map":{
                  "...":" the input for the Enum. If varargs or an array then the\n values in the Enum will be equal to the names (must be strings), if a hash-table\n then values remain (any type), and the keys must be strings."
                },
                "1":"..."
              },
              "tags":[],
              "kind":"error handling ",
              "section":"Error handling",
              "description":"\n This helps prevent magic strings in code by throwing errors for accessing\n non-existing values, and/or converting strings/identifiers to other values.\n\n Calling on the object does the same, but returns a soft error; `nil + err`, if\n the call is succesful (the key exists), it will return the value.\n\n When calling with varargs or an array the values will be equal to the keys.\n The enum object is read-only.",
              "ret":["Enum object (read-only table/object)"]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "param":{
                  "1":[],
                  "2":[],
                  "3":[],
                  "f":[],
                  "msg":[],
                  "idx":[]
                },
                "raise":[],
                "return":[[]]
              },
              "summary":"process a function argument.",
              "lineno":430,
              "retgroups":[{
                  "1":{
                    "text":"a callable",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(idx, f, msg)",
              "type":"function",
              "name":"function_arg",
              "params":{
                "1":"idx",
                "2":"f",
                "map":{
                  "f":" a function, operator string, or callable object",
                  "msg":" optional error message",
                  "idx":" argument index"
                },
                "3":"msg"
              },
              "tags":[],
              "kind":"error handling ",
              "section":"Error handling",
              "description":"\n This is used throughout Penlight and defines what is meant by a function:\n Something that is callable, or an operator string as defined by <code>pl.operator</code>,\n such as '>' or '#'. If a function factory has been registered for the type, it will\n be called to get the function.",
              "raise":"if idx is not a number or if f is not callable",
              "ret":["a callable"],
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[]],
                "param":{
                  "1":[],
                  "2":[],
                  "val":[],
                  "n":[]
                },
                "raise":[],
                "return":[[]]
              },
              "summary":"assert the common case that the argument is a string.",
              "lineno":470,
              "retgroups":[{
                  "1":{
                    "text":"the validated value",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(n, val)",
              "usage":["local val = 42\nlocal param2 = utils.assert_string(2, val) --> error: argument 2 expected a 'string', got a 'number'\n"],
              "raise":"val must be a string",
              "name":"assert_string",
              "params":{
                "1":"n",
                "2":"val",
                "map":{
                  "val":" a value that must be a string",
                  "n":" argument index"
                }
              },
              "tags":[],
              "kind":"error handling ",
              "section":"Error handling",
              "type":"function",
              "parameter":"param",
              "ret":["the validated value"],
              "description":""
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "param":{
                  "1":[],
                  "mode":[]
                },
                "return":[],
                "see":[[]]
              },
              "summary":"control the error strategy used by Penlight.",
              "lineno":483,
              "args":"(mode)",
              "section":"Error handling",
              "name":"on_error",
              "params":{
                "map":{
                  "mode":" either 'default', 'quit'  or 'error'"
                },
                "1":"mode"
              },
              "tags":{
                "see":[]
              },
              "kind":"error handling ",
              "description":"\n This is a global setting that controls how `utils.raise` behaves:\n\n - 'default': return `nil + error` (this is the default)\n - 'error': throw a Lua error\n - 'quit': exit the program\n",
              "type":"function",
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":{
                  "1":[],
                  "err":[]
                },
                "usage":[[]],
                "see":[[]]
              },
              "summary":"used by Penlight functions to return errors.",
              "lineno":507,
              "args":"(err)",
              "usage":["if some_condition then\n  return utils.raise(\"some condition was not met\")  -- MUST use 'return'!\nend\n"],
              "section":"Error handling",
              "name":"raise",
              "parameter":"param",
              "params":{
                "map":{
                  "err":" the error string."
                },
                "1":"err"
              },
              "tags":{
                "see":[]
              },
              "kind":"error handling ",
              "description":" Its global behaviour is controlled\n by `utils.on_error`.\n To use this function you MUST use it in conjunction with `return`, since it might\n return `nil + error`.",
              "type":"function"
            },{
              "name":"files",
              "inferred":true,
              "description":"",
              "file":"<reference cycle>",
              "summary":"",
              "tags":[],
              "lineno":523,
              "display_name":"File handling",
              "type":"section",
              "modifiers":[]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[[]],
                "param":{
                  "1":[],
                  "2":[],
                  "filename":[],
                  "is_bin":[]
                }
              },
              "summary":"return the contents of a file as a string",
              "lineno":527,
              "retgroups":[{
                  "1":{
                    "text":"file contents",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(filename, is_bin)",
              "type":"function",
              "name":"readfile",
              "parameter":"param",
              "params":{
                "1":"filename",
                "2":"is_bin",
                "map":{
                  "filename":" The file path",
                  "is_bin":" open in binary mode"
                }
              },
              "tags":[],
              "kind":"file handling ",
              "section":"File handling",
              "description":"",
              "ret":["file contents"]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "param":{
                  "1":[],
                  "2":[],
                  "3":[],
                  "filename":[],
                  "str":[],
                  "is_bin":[]
                },
                "raise":[],
                "return":[[],[]]
              },
              "summary":"write a string to a file",
              "lineno":549,
              "retgroups":[{
                  "1":{
                    "text":"true or nil",
                    "type":"",
                    "mods":[]
                  },
                  "2":{
                    "text":"error message",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(filename, str, is_bin)",
              "type":"function",
              "name":"writefile",
              "params":{
                "1":"filename",
                "2":"str",
                "map":{
                  "filename":" The file path",
                  "str":" The string",
                  "is_bin":" open in binary mode"
                },
                "3":"is_bin"
              },
              "tags":[],
              "kind":"file handling ",
              "section":"File handling",
              "description":"",
              "raise":"error if filename or str aren't strings",
              "ret":["true or nil","error message"],
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "param":{
                  "1":[],
                  "filename":[]
                },
                "raise":[],
                "return":[[]]
              },
              "summary":"return the contents of a file as a list of lines",
              "lineno":569,
              "retgroups":[{
                  "1":{
                    "text":"file contents as a table",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(filename)",
              "type":"function",
              "name":"readlines",
              "params":{
                "map":{
                  "filename":" The file path"
                },
                "1":"filename"
              },
              "tags":[],
              "kind":"file handling ",
              "section":"File handling",
              "description":"",
              "raise":"error if filename is not a string",
              "ret":["file contents as a table"],
              "parameter":"param"
            },{
              "name":"OS-functions",
              "inferred":true,
              "description":"",
              "file":"<reference cycle>",
              "summary":"",
              "tags":[],
              "lineno":584,
              "display_name":"OS functions",
              "type":"section",
              "modifiers":[]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[[],[],[],[]],
                "param":{
                  "1":[],
                  "2":[],
                  "bin":[],
                  "cmd":[]
                }
              },
              "summary":"execute a shell command and return the output.",
              "lineno":592,
              "retgroups":[{
                  "1":{
                    "text":"true if successful",
                    "type":"",
                    "mods":[]
                  },
                  "2":{
                    "text":"actual return code",
                    "type":"",
                    "mods":[]
                  },
                  "3":{
                    "text":"stdout output (string)",
                    "type":"",
                    "mods":[]
                  },
                  "4":{
                    "text":"errout output (string)",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(cmd, bin)",
              "type":"function",
              "name":"executeex",
              "parameter":"param",
              "params":{
                "1":"cmd",
                "2":"bin",
                "map":{
                  "bin":" boolean, if true, read output as binary file",
                  "cmd":" a shell command"
                }
              },
              "tags":[],
              "kind":"os functions ",
              "section":"OS functions",
              "description":"\n This function redirects the output to tempfiles and returns the content of those files.",
              "ret":["true if successful","actual return code","stdout output (string)","errout output (string)"]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[]],
                "param":{
                  "1":[],
                  "argument":[]
                },
                "return":[[]]
              },
              "summary":"Quote and escape an argument of a command.",
              "lineno":623,
              "retgroups":[{
                  "1":{
                    "text":"quoted and escaped argument.",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(argument)",
              "usage":["local options = utils.quote_arg {\n    \"-lluacov\",\n    \"-e\",\n    \"utils = print(require('pl.utils')._VERSION\",\n}\n-- returns: -lluacov -e 'utils = print(require('\\''pl.utils'\\'')._VERSION'\n"],
              "type":"function",
              "name":"quote_arg",
              "parameter":"param",
              "params":{
                "map":{
                  "argument":" (string or table/list) the argument to quote. If a list then\n all arguments in the list will be returned as a single string quoted."
                },
                "1":"argument"
              },
              "tags":[],
              "kind":"os functions ",
              "section":"OS functions",
              "description":"\n Quotes a single (or list of) argument(s) of a command to be passed\n to `os.execute`, `pl.utils.execute` or `pl.utils.executeex`.",
              "ret":["quoted and escaped argument."]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":{
                  "1":{
                    "opt":true
                  },
                  "2":[],
                  "3":[],
                  "msg":[],
                  "...":[],
                  "code":{
                    "opt":true
                  }
                },
                "usage":[[]],
                "see":[[]]
              },
              "summary":"error out of this program gracefully.",
              "lineno":667,
              "args":"([code], msg, ...)",
              "usage":["utils.quit(-1, \"Error '%s' happened\", \"42\")\n-- is equivalent to\nutils.quit(\"Error '%s' happened\", \"42\")  --> Error '42' happened\n"],
              "section":"OS functions",
              "name":"quit",
              "parameter":"param",
              "params":{
                "1":"code",
                "2":"msg",
                "map":{
                  "msg":" The exit message will be sent to `stderr` (will be formatted with the extra parameters)",
                  "...":" extra arguments for message's format'",
                  "code":" The exit code, defaults to -`1` if omitted"
                },
                "3":"..."
              },
              "tags":{
                "see":[]
              },
              "kind":"os functions ",
              "description":"",
              "type":"function"
            },"<reference cycle>",{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":{
                  "1":[],
                  "s":[]
                }
              },
              "summary":"escape any Lua 'magic' characters in a string",
              "lineno":685,
              "args":"(s)",
              "section":"String functions",
              "name":"escape",
              "params":{
                "map":{
                  "s":" The input string"
                },
                "1":"s"
              },
              "tags":[],
              "kind":"string functions ",
              "description":"",
              "type":"function",
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "param":{
                  "1":[],
                  "2":[],
                  "3":[],
                  "4":[],
                  "re":[],
                  "n":[],
                  "s":[],
                  "plain":[]
                },
                "return":[[]],
                "raise":[],
                "see":[[]]
              },
              "summary":"split a string into a list of strings separated by a delimiter.",
              "lineno":698,
              "retgroups":[{
                  "1":{
                    "text":"a list-like table",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s, re, plain, n)",
              "type":"function",
              "name":"split",
              "params":{
                "1":"s",
                "2":"re",
                "3":"plain",
                "4":"n",
                "map":{
                  "re":" optional A Lua string pattern; defaults to '%s+'",
                  "n":" optional maximum number of elements (if there are more, the last will remian un-split)",
                  "s":" The input string",
                  "plain":" optional If truthy don't use Lua patterns"
                }
              },
              "tags":{
                "see":[]
              },
              "kind":"string functions ",
              "section":"String functions",
              "description":"",
              "raise":"error if s is not a string",
              "ret":["a list-like table"],
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "param":{
                  "1":[],
                  "2":[],
                  "3":[],
                  "4":[],
                  "re":[],
                  "n":[],
                  "s":[],
                  "plain":[]
                },
                "return":[[]],
                "usage":[[]],
                "see":[[]]
              },
              "summary":"split a string into a number of return values.",
              "lineno":735,
              "retgroups":[{
                  "1":{
                    "text":"n values",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s, re, plain, n)",
              "usage":["first,next = splitv('user=jane=doe','=', false, 2)\nassert(first == \"user\")\nassert(next == \"jane=doe\")\n"],
              "type":"function",
              "name":"splitv",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"re",
                "3":"plain",
                "4":"n",
                "map":{
                  "re":" A Lua string pattern; defaults to '%s+'",
                  "n":" optional maximum number of splits",
                  "s":" the string",
                  "plain":" don't use Lua patterns"
                }
              },
              "tags":{
                "see":[]
              },
              "kind":"string functions ",
              "section":"String functions",
              "description":"\n Identical to `split` but returns multiple sub-strings instead of\n a single list of sub-strings.",
              "ret":["n values"]
            },{
              "name":"functional",
              "inferred":true,
              "description":"",
              "file":"<reference cycle>",
              "summary":"",
              "tags":[],
              "lineno":744,
              "display_name":"Functional",
              "type":"section",
              "modifiers":[]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[[]],
                "param":{
                  "1":[],
                  "func":[]
                }
              },
              "summary":"'memoize' a function (cache returned value for next call).",
              "lineno":750,
              "retgroups":[{
                  "1":{
                    "text":"a function with at least one argument, which is used as the key.",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(func)",
              "type":"function",
              "name":"memoize",
              "parameter":"param",
              "params":{
                "map":{
                  "func":" a function of at least one argument"
                },
                "1":"func"
              },
              "tags":[],
              "kind":"functional ",
              "section":"Functional",
              "description":"\n This is useful if you have a function which is relatively expensive,\n but you don't know in advance what values will be required, so\n building a table upfront is wasteful/impossible.",
              "ret":["a function with at least one argument, which is used as the key."]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":{
                  "1":{
                    "type":"tab"
                  },
                  "2":{
                    "type":"func"
                  },
                  "fun":{
                    "type":"func"
                  },
                  "mt":{
                    "type":"tab"
                  }
                }
              },
              "summary":"associate a function factory with a type.",
              "lineno":768,
              "args":"(mt, fun)",
              "section":"Functional",
              "name":"add_function_factory",
              "params":{
                "1":"mt",
                "2":"fun",
                "map":{
                  "fun":" a callable that returns a function",
                  "mt":" metatable"
                }
              },
              "tags":[],
              "kind":"functional ",
              "description":"\n A function factory takes an object of the given type and\n returns a function for evaluating it",
              "type":"function",
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "param":{
                  "1":[],
                  "lf":[]
                },
                "return":[[]],
                "usage":[[]]
              },
              "summary":"an anonymous function as a string.",
              "lineno":800,
              "retgroups":[{
                  "1":{
                    "text":"a function",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(lf)",
              "usage":["string_lambda '|x|x+1' (2) == 3\nstring_lambda '_+1' (2) == 3\n"],
              "type":"function",
              "name":"string_lambda",
              "params":{
                "map":{
                  "lf":" function as a string"
                },
                "1":"lf"
              },
              "tags":[],
              "kind":"functional ",
              "section":"Functional",
              "description":" This string is either of the form\n '|args| expression' or is a function of one argument, '_'",
              "ret":["a function"],
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[[]],
                "see":[[]],
                "param":{
                  "1":[],
                  "2":[],
                  "p":[],
                  "fn":[]
                },
                "raise":[],
                "usage":[[]]
              },
              "summary":"bind the first argument of the function to a value.",
              "lineno":817,
              "retgroups":[{
                  "1":{
                    "text":"a function such that f(x) is fn(p,x)",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(fn, p)",
              "usage":["local function f(msg, name)\n  print(msg .. \" \" .. name)\nend\n\nlocal hello = utils.bind1(f, \"Hello\")\n\nprint(hello(\"world\"))     --> \"Hello world\"\nprint(hello(\"sunshine\"))  --> \"Hello sunshine\"\n"],
              "raise":"same as @{function_arg}",
              "name":"bind1",
              "params":{
                "1":"fn",
                "2":"p",
                "map":{
                  "p":" a value",
                  "fn":" a function of at least two values (may be an operator string)"
                }
              },
              "tags":{
                "see":[]
              },
              "kind":"functional ",
              "section":"Functional",
              "type":"function",
              "parameter":"param",
              "ret":["a function such that f(x) is fn(p,x)"],
              "description":""
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[]],
                "param":{
                  "1":[],
                  "2":[],
                  "p":[],
                  "fn":[]
                },
                "raise":[],
                "return":[[]]
              },
              "summary":"bind the second argument of the function to a value.",
              "lineno":836,
              "retgroups":[{
                  "1":{
                    "text":"a function such that f(x) is fn(x,p)",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(fn, p)",
              "usage":["local function f(a, b, c)\n  print(a .. \" \" .. b .. \" \" .. c)\nend\n\nlocal hello = utils.bind1(f, \"world\")\n\nprint(hello(\"Hello\", \"!\"))  --> \"Hello world !\"\nprint(hello(\"Bye\", \"?\"))    --> \"Bye world ?\"\n"],
              "raise":"same as @{function_arg}",
              "name":"bind2",
              "params":{
                "1":"fn",
                "2":"p",
                "map":{
                  "p":" a value",
                  "fn":" a function of at least two values (may be an operator string)"
                }
              },
              "tags":[],
              "kind":"functional ",
              "section":"Functional",
              "type":"function",
              "parameter":"param",
              "ret":["a function such that f(x) is fn(x,p)"],
              "description":""
            },{
              "name":"deprecation",
              "inferred":true,
              "description":"",
              "file":"<reference cycle>",
              "summary":"",
              "tags":[],
              "lineno":847,
              "display_name":"Deprecation",
              "type":"section",
              "modifiers":[]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":{
                  "1":[],
                  "func":[]
                },
                "usage":[[]],
                "see":[[]]
              },
              "summary":"Sets a deprecation warning function.",
              "lineno":875,
              "args":"(func)",
              "usage":["-- write to the Nginx logs with OpenResty\nutils.set_deprecation_func(function(msg, trace)\n  ngx.log(ngx.WARN, msg, (trace and (\" \" .. trace) or nil))\nend)\n\n-- disable deprecation warnings\nutils.set_deprecation_func()\n"],
              "section":"Deprecation",
              "name":"set_deprecation_func",
              "parameter":"param",
              "params":{
                "map":{
                  "func":" a callback with signature: `function(msg, trace)` both arguments are strings, the latter being optional."
                },
                "1":"func"
              },
              "tags":{
                "see":[]
              },
              "kind":"deprecation ",
              "description":"\n An application can override this function to support proper output of\n deprecation warnings. The warnings can be generated from libraries or\n functions by calling `utils.raise_deprecation`. The default function\n will write to the 'warn' system (introduced in Lua 5.4, or the compatibility\n function from the `compat` module for earlier versions).\n\n Note: only applications should set/change this function, libraries should not.",
              "type":"function"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":{
                  "1":[],
                  "opts":[]
                },
                "usage":[[]],
                "see":[[]]
              },
              "summary":"raises a deprecation warning.",
              "lineno":907,
              "args":"(opts)",
              "usage":["warn(\"@on\")   -- enable Lua warnings, they are usually off by default\n\nfunction stringx.islower(str)\n  raise_deprecation {\n    source = \"Penlight \" .. utils._VERSION,                   -- optional\n    message = \"function 'islower' was renamed to 'is_lower'\", -- required\n    version_removed = \"2.0.0\",                                -- optional\n    deprecated_after = \"1.2.3\",                               -- optional\n    no_trace = true,                                          -- optional\n  }\n  return stringx.is_lower(str)\nend\n-- output: \"[Penlight 1.9.2] function 'islower' was renamed to 'is_lower' (deprecated after 1.2.3, scheduled for removal in 2.0.0)\"\n"],
              "section":"Deprecation",
              "name":"raise_deprecation",
              "parameter":"param",
              "params":{
                "map":{
                  "opts":" options table"
                },
                "1":"opts"
              },
              "tags":{
                "see":[]
              },
              "kind":"deprecation ",
              "description":"\n For options see the usage example below.\n\n Note: the `opts.deprecated_after` field is the last version in which\n a feature or option was NOT YET deprecated! Because when writing the code it\n is quite often not known in what version the code will land. But the last\n released version is usually known.",
              "type":"function"
            }],
          "sections":[],
          "modules":["<reference cycle>"],
          "args":{
            "one":false,
            "module":false,
            "verbose":false,
            "style":"!",
            "template":"!",
            "date":"system",
            "dir":"doc",
            "quiet":false,
            "all":false,
            "ignore":false,
            "colon":false,
            "not_luadoc":false,
            "ext":"html",
            "boilerplate":false,
            "merge":false,
            "filter":"f.filter",
            "package":"/home/cji/portless/Penlight/lua",
            "dump":false,
            "no_args_infer":false,
            "title":"Reference",
            "project":"ldoc",
            "file":"/home/cji/portless/Penlight/lua/pl",
            "format":"discount",
            "simple":false,
            "tags":"none",
            "define":"none",
            "output":"index",
            "unqualified":false,
            "config":"config.ld",
            "fatalwarnings":false,
            "testing":false
          },
          "error":"<type 'function' is not supported by JSON.>",
          "lang":{
            "line_comment":"^%-%-+",
            "start_comment_":"^%-%-%-+",
            "end_comment_":"[^%-]%-%-+[^-]*\n$",
            "extra":[],
            "block_comment":"^%-%-%[=*%[%-+",
            "empty_comment_":"^%-%-%-+%s*$",
            "method_call":":"
          },
          "base":"/home/cji/portless/Penlight/lua"
        },
        "summary":"",
        "tags":[],
        "lineno":683,
        "display_name":"String functions",
        "type":"section",
        "modifiers":[]
      },
      "Error_handling":{
        "name":"Error-handling",
        "inferred":true,
        "description":"",
        "file":{
          "warning":"<type 'function' is not supported by JSON.>",
          "filename":"/home/cji/portless/Penlight/lua/pl/utils.lua",
          "items":["<reference cycle>",{
              "inferred":true,
              "description":"",
              "modifiers":{
                "field":[],
                "return":[]
              },
              "summary":"Some standard patterns",
              "lineno":31,
              "args":"(FLOAT, INTEGER, IDEN, FILE)",
              "type":"table",
              "name":"patterns",
              "parameter":"field",
              "params":{
                "1":"FLOAT",
                "2":"INTEGER",
                "3":"IDEN",
                "4":"FILE",
                "map":{
                  "FILE":"file",
                  "INTEGER":"integer number",
                  "IDEN":"identifier",
                  "FLOAT":"floating point number"
                }
              },
              "tags":[],
              "kind":"tables",
              "section":"table",
              "subparams":[]
            },{
              "name":"stdmt",
              "section":"table",
              "inferred":true,
              "description":"",
              "kind":"tables",
              "summary":"Standard meta-tables as used by other Penlight modules",
              "params":{
                "1":"List",
                "2":"Map",
                "3":"Set",
                "4":"MultiMap",
                "map":{
                  "Map":" the Map metatable",
                  "Set":" the Set metatable",
                  "MultiMap":" the MultiMap metatable",
                  "List":" the List metatable"
                }
              },
              "tags":[],
              "lineno":45,
              "subparams":[],
              "args":"(List, Map, Set, MultiMap)",
              "parameter":"field",
              "type":"table",
              "modifiers":{
                "field":{
                  "1":[],
                  "2":[],
                  "3":[],
                  "4":[],
                  "Map":[],
                  "Set":[],
                  "MultiMap":[],
                  "List":[]
                },
                "return":[]
              }
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "param":{
                  "1":[],
                  "...":[]
                },
                "return":[[]],
                "see":[[],[],[]]
              },
              "summary":"pack an argument list into a table.",
              "lineno":60,
              "retgroups":[{
                  "1":{
                    "text":"a table with field `n` set to the length",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(...)",
              "section":"function",
              "name":"pack",
              "params":{
                "map":{
                  "...":" any arguments"
                },
                "1":"..."
              },
              "tags":{
                "see":[]
              },
              "kind":"functions",
              "description":"",
              "type":"function",
              "ret":["a table with field `n` set to the length"],
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[[]],
                "usage":[[]],
                "param":{
                  "1":[],
                  "2":{
                    "optchain":true,
                    "opt":true
                  },
                  "3":{
                    "optchain":true,
                    "opt":true
                  },
                  "t":[],
                  "j":{
                    "optchain":true,
                    "opt":true
                  },
                  "i":{
                    "optchain":true,
                    "opt":true
                  }
                },
                "see":[[],[],[]]
              },
              "summary":"unpack a table and return its contents.",
              "lineno":79,
              "retgroups":[{
                  "1":{
                    "text":"multiple return values from the table",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(t[, i[, j]])",
              "usage":["local t = table.pack(nil, nil, nil, 4)\nlocal a, b, c, d = table.unpack(t)   -- this `unpack` is NOT nil-safe, so d == nil\n\nlocal a, b, c, d = utils.unpack(t)   -- this is nil-safe, so d == 4\n"],
              "type":"function",
              "name":"unpack",
              "params":{
                "1":"t",
                "2":"i",
                "map":{
                  "t":" table to unpack",
                  "j":" index of the last element to unpack, defaults to `t.n` or else `#t`",
                  "i":" index from which to start unpacking, defaults to 1"
                },
                "3":"j"
              },
              "tags":{
                "see":[]
              },
              "kind":"functions",
              "section":"function",
              "description":"\n\n NOTE: this implementation differs from the Lua implementation in the way\n that this one DOES honor the `n` field in the table `t`, such that it is 'nil-safe'.",
              "ret":["multiple return values from the table"],
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":{
                  "1":[],
                  "2":[],
                  "fmt":[],
                  "...":[]
                }
              },
              "summary":"print an arbitrary number of arguments using a format.",
              "lineno":87,
              "args":"(fmt, ...)",
              "section":"function",
              "name":"printf",
              "params":{
                "1":"fmt",
                "2":"...",
                "map":{
                  "fmt":" The format (see `string.format`)",
                  "...":" Extra arguments for format"
                }
              },
              "tags":[],
              "kind":"functions",
              "description":"\n Output will be sent to `stdout`.",
              "type":"function",
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":{
                  "1":[],
                  "2":[],
                  "3":[],
                  "fmt":[],
                  "f":[],
                  "...":[]
                }
              },
              "summary":"write an arbitrary number of arguments to a file using a format.",
              "lineno":96,
              "args":"(f, fmt, ...)",
              "section":"function",
              "name":"fprintf",
              "params":{
                "1":"f",
                "2":"fmt",
                "map":{
                  "fmt":" The format (see `string.format`).",
                  "f":" File handle to write to.",
                  "...":" Extra arguments for format"
                },
                "3":"..."
              },
              "tags":[],
              "kind":"functions",
              "description":"",
              "type":"function",
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":{
                  "1":[],
                  "2":[],
                  "t":[],
                  "T":[]
                }
              },
              "summary":"take a table and 'inject' it into the local namespace.",
              "lineno":124,
              "args":"(t, T)",
              "section":"function",
              "name":"import",
              "params":{
                "1":"t",
                "2":"T",
                "map":{
                  "t":" The table (table), or module name (string), defaults to this `utils` module table",
                  "T":" An optional destination table (defaults to callers environment)"
                }
              },
              "tags":[],
              "kind":"functions",
              "description":"",
              "type":"function",
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":{
                  "1":[],
                  "2":[],
                  "3":[],
                  "cond":[],
                  "value1":[],
                  "value2":[]
                }
              },
              "summary":"return either of two values, depending on a condition.",
              "lineno":143,
              "args":"(cond, value1, value2)",
              "section":"function",
              "name":"choose",
              "params":{
                "1":"cond",
                "2":"value1",
                "map":{
                  "cond":" A condition",
                  "value1":" Value returned if cond is truthy",
                  "value2":" Value returned if cond is falsy"
                },
                "3":"value2"
              },
              "tags":[],
              "kind":"functions",
              "description":"",
              "type":"function",
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[[]],
                "param":{
                  "1":[],
                  "2":{
                    "optchain":true,
                    "opt":true
                  },
                  "3":{
                    "optchain":true,
                    "opt":true
                  },
                  "t":[],
                  "temp":{
                    "optchain":true,
                    "opt":true
                  },
                  "tostr":{
                    "optchain":true,
                    "opt":true
                  }
                }
              },
              "summary":"convert an array of values to strings.",
              "lineno":152,
              "retgroups":[{
                  "1":{
                    "text":"the converted buffer",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(t[, temp[, tostr]])",
              "type":"function",
              "name":"array_tostring",
              "parameter":"param",
              "params":{
                "1":"t",
                "2":"temp",
                "map":{
                  "t":" a list-like table",
                  "temp":" (table) buffer to use, otherwise allocate",
                  "tostr":" custom tostring function, called with (value,index). Defaults to `tostring`."
                },
                "3":"tostr"
              },
              "tags":[],
              "kind":"functions",
              "section":"function",
              "description":"",
              "ret":["the converted buffer"]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[]],
                "param":{
                  "1":[],
                  "2":[],
                  "obj":[],
                  "tp":[]
                },
                "return":[[]]
              },
              "summary":"is the object of the specified type?",
              "lineno":172,
              "retgroups":[{
                  "1":{
                    "text":"boolean",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(obj, tp)",
              "usage":["utils.is_type(\"hello world\", \"string\")   --> true\n-- or check metatable\nlocal my_mt = {}\nlocal my_obj = setmetatable(my_obj, my_mt)\nutils.is_type(my_obj, my_mt)  --> true\n"],
              "type":"function",
              "name":"is_type",
              "parameter":"param",
              "params":{
                "1":"obj",
                "2":"tp",
                "map":{
                  "obj":" An object to check",
                  "tp":" String of what type it should be"
                }
              },
              "tags":[],
              "kind":"functions",
              "section":"function",
              "description":"\n If the type is a string, then use type, otherwise compare with metatable",
              "ret":["boolean"]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[]],
                "return":[{
                    "type":"integer"
                  },{
                    "type":"any"
                  }],
                "param":{
                  "1":{
                    "type":"table"
                  },
                  "2":{
                    "opt":"1",
                    "type":"integer",
                    "optchain":"1"
                  },
                  "3":{
                    "opt":"t.n or #t",
                    "type":"integer",
                    "optchain":"t.n or #t"
                  },
                  "4":{
                    "opt":"1",
                    "type":"integer",
                    "optchain":"1"
                  },
                  "t":{
                    "type":"table"
                  },
                  "step":{
                    "opt":"1",
                    "type":"integer",
                    "optchain":"1"
                  },
                  "i_start":{
                    "opt":"1",
                    "type":"integer",
                    "optchain":"1"
                  },
                  "i_end":{
                    "opt":"t.n or #t",
                    "type":"integer",
                    "optchain":"t.n or #t"
                  }
                },
                "see":[[],[]]
              },
              "summary":"an iterator with indices, similar to `ipairs`, but with a range.",
              "lineno":199,
              "retgroups":[{
                  "1":{
                    "text":"index",
                    "type":"integer",
                    "mods":{
                      "type":"integer"
                    }
                  },
                  "2":{
                    "text":"value at index (which can be `nil`!)",
                    "type":"any",
                    "mods":{
                      "type":"any"
                    }
                  },
                  "g":0
                }],
              "args":"(t[, i_start=1[, i_end=t.n or #t[, step=1]]])",
              "usage":["local t = utils.pack(nil, 123, nil)  -- adds an `n` field when packing\n\nfor i, v in utils.npairs(t, 2) do  -- start at index 2\n  t[i] = tostring(t[i])\nend\n\n-- t = { n = 3, [2] = \"123\", [3] = \"nil\" }\n"],
              "type":"function",
              "name":"npairs",
              "parameter":"param",
              "params":{
                "1":"t",
                "2":"i_start",
                "3":"i_end",
                "4":"step",
                "map":{
                  "t":" the table to iterate over",
                  "step":" step size",
                  "i_start":" start index",
                  "i_end":" end index"
                }
              },
              "tags":{
                "see":[]
              },
              "kind":"functions",
              "section":"function",
              "description":"\n This is a nil-safe index based iterator that will return `nil` when there\n is a hole in a list. To be safe ensure that table `t.n` contains the length.",
              "ret":["index","value at index (which can be `nil`!)"]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[]],
                "param":{
                  "1":{
                    "type":"table"
                  },
                  "t":{
                    "type":"table"
                  }
                },
                "return":[{
                    "type":"key"
                  },{
                    "type":"value"
                  }]
              },
              "summary":"an iterator over all non-integer keys (inverse of `ipairs`).",
              "lineno":253,
              "retgroups":[{
                  "1":{
                    "text":"",
                    "type":"key",
                    "mods":{
                      "type":"key"
                    }
                  },
                  "2":{
                    "text":"",
                    "type":"value",
                    "mods":{
                      "type":"value"
                    }
                  },
                  "g":0
                }],
              "args":"(t)",
              "usage":["local t = {\n  \"hello\",\n  \"world\",\n  hello = \"hallo\",\n  world = \"Welt\",\n}\n\nfor k, v in utils.kpairs(t) do\n  print(\"German: \", v)\nend\n\n-- output;\n-- German: hallo\n-- German: Welt\n"],
              "type":"function",
              "name":"kpairs",
              "parameter":"param",
              "params":{
                "map":{
                  "t":" the table to iterate over"
                },
                "1":"t"
              },
              "tags":[],
              "kind":"functions",
              "section":"function",
              "description":"\n It will skip any key that is an integer number, so negative indices or an\n array with holes will not return those either (so it returns slightly less than\n 'the inverse of `ipairs`').\n\n This uses `pairs` under the hood, so any value that is iterable using `pairs`\n will work with this function.",
              "ret":["",""]
            },"<reference cycle>",{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[]],
                "param":{
                  "1":[],
                  "2":[],
                  "3":[],
                  "4":[],
                  "5":[],
                  "6":[],
                  "n":[],
                  "verify":[],
                  "val":[],
                  "lev":[],
                  "msg":[],
                  "tp":[]
                },
                "raise":[],
                "return":[[]]
              },
              "summary":"assert that the given argument is in fact of the correct type.",
              "lineno":285,
              "retgroups":[{
                  "1":{
                    "text":"the validated value",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(n, val, tp, verify, msg, lev)",
              "usage":["local param1 = assert_arg(1,\"hello\",'table')  --> error: argument 1 expected a 'table', got a 'string'\nlocal param4 = assert_arg(4,'!@#$%^&*','string',path.isdir,'not a directory')\n     --> error: argument 4: '!@#$%^&*' not a directory\n"],
              "raise":"if `val` is not the correct type",
              "name":"assert_arg",
              "params":{
                "1":"n",
                "2":"val",
                "3":"tp",
                "4":"verify",
                "5":"msg",
                "6":"lev",
                "map":{
                  "n":" argument index",
                  "verify":" an optional verification function",
                  "val":" the value",
                  "lev":" optional stack position for trace, default 2",
                  "msg":" an optional custom message",
                  "tp":" the type"
                }
              },
              "tags":[],
              "kind":"error handling ",
              "section":"Error handling",
              "type":"function",
              "parameter":"param",
              "ret":["the validated value"],
              "description":""
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[],[],[]],
                "param":{
                  "1":{
                    "type":"table|vararg"
                  },
                  "...":{
                    "type":"table|vararg"
                  }
                },
                "return":[[]]
              },
              "summary":"creates an Enum or constants lookup table for improved error handling.",
              "lineno":355,
              "retgroups":[{
                  "1":{
                    "text":"Enum object (read-only table/object)",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(...)",
              "usage":["-- Enum access at runtime\nlocal obj = {}\nobj.MOVEMENT = utils.enum(\"FORWARD\", \"REVERSE\", \"LEFT\", \"RIGHT\")\n\nif current_movement == obj.MOVEMENT.FORWARD then\n  -- do something\n\nelseif current_movement == obj.MOVEMENT.REVERES then\n  -- throws error due to typo 'REVERES', so a silent mistake becomes a hard error\n  -- \"'REVERES' is not a valid value (expected one of: 'FORWARD', 'REVERSE', 'LEFT', 'RIGHT')\"\n\nend\n","-- standardized error codes\nlocal obj = {\n  ERR = utils.enum {\n    NOT_FOUND = \"the item was not found\",\n    OUT_OF_BOUNDS = \"the index is outside the allowed range\"\n  },\n\n  some_method = function(self)\n    return self.ERR.OUT_OF_BOUNDS\n  end,\n}\n\nlocal result, err = obj:some_method()\nif not result then\n  if err == obj.ERR.NOT_FOUND then\n    -- check on error code, not magic strings\n\n  else\n    -- return the error description, contained in the constant\n    return nil, \"error: \"..err  -- \"error: the index is outside the allowed range\"\n  end\nend\n","-- validating/converting user-input\nlocal color = \"purple\"\nlocal ansi_colors = utils.enum {\n  black     = 30,\n  red       = 31,\n  green     = 32,\n}\nlocal color_code, err = ansi_colors(color) -- calling on the object, returns the value from the enum\nif not color_code then\n  print(\"bad 'color', \" .. err)\n  -- \"bad 'color', 'purple' is not a valid value (expected one of: 'black', 'red', 'green')\"\n  os.exit(1)\nend\n"],
              "type":"function",
              "name":"enum",
              "parameter":"param",
              "params":{
                "map":{
                  "...":" the input for the Enum. If varargs or an array then the\n values in the Enum will be equal to the names (must be strings), if a hash-table\n then values remain (any type), and the keys must be strings."
                },
                "1":"..."
              },
              "tags":[],
              "kind":"error handling ",
              "section":"Error handling",
              "description":"\n This helps prevent magic strings in code by throwing errors for accessing\n non-existing values, and/or converting strings/identifiers to other values.\n\n Calling on the object does the same, but returns a soft error; `nil + err`, if\n the call is succesful (the key exists), it will return the value.\n\n When calling with varargs or an array the values will be equal to the keys.\n The enum object is read-only.",
              "ret":["Enum object (read-only table/object)"]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "param":{
                  "1":[],
                  "2":[],
                  "3":[],
                  "f":[],
                  "msg":[],
                  "idx":[]
                },
                "raise":[],
                "return":[[]]
              },
              "summary":"process a function argument.",
              "lineno":430,
              "retgroups":[{
                  "1":{
                    "text":"a callable",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(idx, f, msg)",
              "type":"function",
              "name":"function_arg",
              "params":{
                "1":"idx",
                "2":"f",
                "map":{
                  "f":" a function, operator string, or callable object",
                  "msg":" optional error message",
                  "idx":" argument index"
                },
                "3":"msg"
              },
              "tags":[],
              "kind":"error handling ",
              "section":"Error handling",
              "description":"\n This is used throughout Penlight and defines what is meant by a function:\n Something that is callable, or an operator string as defined by <code>pl.operator</code>,\n such as '>' or '#'. If a function factory has been registered for the type, it will\n be called to get the function.",
              "raise":"if idx is not a number or if f is not callable",
              "ret":["a callable"],
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[]],
                "param":{
                  "1":[],
                  "2":[],
                  "val":[],
                  "n":[]
                },
                "raise":[],
                "return":[[]]
              },
              "summary":"assert the common case that the argument is a string.",
              "lineno":470,
              "retgroups":[{
                  "1":{
                    "text":"the validated value",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(n, val)",
              "usage":["local val = 42\nlocal param2 = utils.assert_string(2, val) --> error: argument 2 expected a 'string', got a 'number'\n"],
              "raise":"val must be a string",
              "name":"assert_string",
              "params":{
                "1":"n",
                "2":"val",
                "map":{
                  "val":" a value that must be a string",
                  "n":" argument index"
                }
              },
              "tags":[],
              "kind":"error handling ",
              "section":"Error handling",
              "type":"function",
              "parameter":"param",
              "ret":["the validated value"],
              "description":""
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "param":{
                  "1":[],
                  "mode":[]
                },
                "return":[],
                "see":[[]]
              },
              "summary":"control the error strategy used by Penlight.",
              "lineno":483,
              "args":"(mode)",
              "section":"Error handling",
              "name":"on_error",
              "params":{
                "map":{
                  "mode":" either 'default', 'quit'  or 'error'"
                },
                "1":"mode"
              },
              "tags":{
                "see":[]
              },
              "kind":"error handling ",
              "description":"\n This is a global setting that controls how `utils.raise` behaves:\n\n - 'default': return `nil + error` (this is the default)\n - 'error': throw a Lua error\n - 'quit': exit the program\n",
              "type":"function",
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":{
                  "1":[],
                  "err":[]
                },
                "usage":[[]],
                "see":[[]]
              },
              "summary":"used by Penlight functions to return errors.",
              "lineno":507,
              "args":"(err)",
              "usage":["if some_condition then\n  return utils.raise(\"some condition was not met\")  -- MUST use 'return'!\nend\n"],
              "section":"Error handling",
              "name":"raise",
              "parameter":"param",
              "params":{
                "map":{
                  "err":" the error string."
                },
                "1":"err"
              },
              "tags":{
                "see":[]
              },
              "kind":"error handling ",
              "description":" Its global behaviour is controlled\n by `utils.on_error`.\n To use this function you MUST use it in conjunction with `return`, since it might\n return `nil + error`.",
              "type":"function"
            },{
              "name":"files",
              "inferred":true,
              "description":"",
              "file":"<reference cycle>",
              "summary":"",
              "tags":[],
              "lineno":523,
              "display_name":"File handling",
              "type":"section",
              "modifiers":[]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[[]],
                "param":{
                  "1":[],
                  "2":[],
                  "filename":[],
                  "is_bin":[]
                }
              },
              "summary":"return the contents of a file as a string",
              "lineno":527,
              "retgroups":[{
                  "1":{
                    "text":"file contents",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(filename, is_bin)",
              "type":"function",
              "name":"readfile",
              "parameter":"param",
              "params":{
                "1":"filename",
                "2":"is_bin",
                "map":{
                  "filename":" The file path",
                  "is_bin":" open in binary mode"
                }
              },
              "tags":[],
              "kind":"file handling ",
              "section":"File handling",
              "description":"",
              "ret":["file contents"]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "param":{
                  "1":[],
                  "2":[],
                  "3":[],
                  "filename":[],
                  "str":[],
                  "is_bin":[]
                },
                "raise":[],
                "return":[[],[]]
              },
              "summary":"write a string to a file",
              "lineno":549,
              "retgroups":[{
                  "1":{
                    "text":"true or nil",
                    "type":"",
                    "mods":[]
                  },
                  "2":{
                    "text":"error message",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(filename, str, is_bin)",
              "type":"function",
              "name":"writefile",
              "params":{
                "1":"filename",
                "2":"str",
                "map":{
                  "filename":" The file path",
                  "str":" The string",
                  "is_bin":" open in binary mode"
                },
                "3":"is_bin"
              },
              "tags":[],
              "kind":"file handling ",
              "section":"File handling",
              "description":"",
              "raise":"error if filename or str aren't strings",
              "ret":["true or nil","error message"],
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "param":{
                  "1":[],
                  "filename":[]
                },
                "raise":[],
                "return":[[]]
              },
              "summary":"return the contents of a file as a list of lines",
              "lineno":569,
              "retgroups":[{
                  "1":{
                    "text":"file contents as a table",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(filename)",
              "type":"function",
              "name":"readlines",
              "params":{
                "map":{
                  "filename":" The file path"
                },
                "1":"filename"
              },
              "tags":[],
              "kind":"file handling ",
              "section":"File handling",
              "description":"",
              "raise":"error if filename is not a string",
              "ret":["file contents as a table"],
              "parameter":"param"
            },{
              "name":"OS-functions",
              "inferred":true,
              "description":"",
              "file":"<reference cycle>",
              "summary":"",
              "tags":[],
              "lineno":584,
              "display_name":"OS functions",
              "type":"section",
              "modifiers":[]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[[],[],[],[]],
                "param":{
                  "1":[],
                  "2":[],
                  "bin":[],
                  "cmd":[]
                }
              },
              "summary":"execute a shell command and return the output.",
              "lineno":592,
              "retgroups":[{
                  "1":{
                    "text":"true if successful",
                    "type":"",
                    "mods":[]
                  },
                  "2":{
                    "text":"actual return code",
                    "type":"",
                    "mods":[]
                  },
                  "3":{
                    "text":"stdout output (string)",
                    "type":"",
                    "mods":[]
                  },
                  "4":{
                    "text":"errout output (string)",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(cmd, bin)",
              "type":"function",
              "name":"executeex",
              "parameter":"param",
              "params":{
                "1":"cmd",
                "2":"bin",
                "map":{
                  "bin":" boolean, if true, read output as binary file",
                  "cmd":" a shell command"
                }
              },
              "tags":[],
              "kind":"os functions ",
              "section":"OS functions",
              "description":"\n This function redirects the output to tempfiles and returns the content of those files.",
              "ret":["true if successful","actual return code","stdout output (string)","errout output (string)"]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[]],
                "param":{
                  "1":[],
                  "argument":[]
                },
                "return":[[]]
              },
              "summary":"Quote and escape an argument of a command.",
              "lineno":623,
              "retgroups":[{
                  "1":{
                    "text":"quoted and escaped argument.",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(argument)",
              "usage":["local options = utils.quote_arg {\n    \"-lluacov\",\n    \"-e\",\n    \"utils = print(require('pl.utils')._VERSION\",\n}\n-- returns: -lluacov -e 'utils = print(require('\\''pl.utils'\\'')._VERSION'\n"],
              "type":"function",
              "name":"quote_arg",
              "parameter":"param",
              "params":{
                "map":{
                  "argument":" (string or table/list) the argument to quote. If a list then\n all arguments in the list will be returned as a single string quoted."
                },
                "1":"argument"
              },
              "tags":[],
              "kind":"os functions ",
              "section":"OS functions",
              "description":"\n Quotes a single (or list of) argument(s) of a command to be passed\n to `os.execute`, `pl.utils.execute` or `pl.utils.executeex`.",
              "ret":["quoted and escaped argument."]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":{
                  "1":{
                    "opt":true
                  },
                  "2":[],
                  "3":[],
                  "msg":[],
                  "...":[],
                  "code":{
                    "opt":true
                  }
                },
                "usage":[[]],
                "see":[[]]
              },
              "summary":"error out of this program gracefully.",
              "lineno":667,
              "args":"([code], msg, ...)",
              "usage":["utils.quit(-1, \"Error '%s' happened\", \"42\")\n-- is equivalent to\nutils.quit(\"Error '%s' happened\", \"42\")  --> Error '42' happened\n"],
              "section":"OS functions",
              "name":"quit",
              "parameter":"param",
              "params":{
                "1":"code",
                "2":"msg",
                "map":{
                  "msg":" The exit message will be sent to `stderr` (will be formatted with the extra parameters)",
                  "...":" extra arguments for message's format'",
                  "code":" The exit code, defaults to -`1` if omitted"
                },
                "3":"..."
              },
              "tags":{
                "see":[]
              },
              "kind":"os functions ",
              "description":"",
              "type":"function"
            },{
              "name":"string-functions",
              "inferred":true,
              "description":"",
              "file":"<reference cycle>",
              "summary":"",
              "tags":[],
              "lineno":683,
              "display_name":"String functions",
              "type":"section",
              "modifiers":[]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":{
                  "1":[],
                  "s":[]
                }
              },
              "summary":"escape any Lua 'magic' characters in a string",
              "lineno":685,
              "args":"(s)",
              "section":"String functions",
              "name":"escape",
              "params":{
                "map":{
                  "s":" The input string"
                },
                "1":"s"
              },
              "tags":[],
              "kind":"string functions ",
              "description":"",
              "type":"function",
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "param":{
                  "1":[],
                  "2":[],
                  "3":[],
                  "4":[],
                  "re":[],
                  "n":[],
                  "s":[],
                  "plain":[]
                },
                "return":[[]],
                "raise":[],
                "see":[[]]
              },
              "summary":"split a string into a list of strings separated by a delimiter.",
              "lineno":698,
              "retgroups":[{
                  "1":{
                    "text":"a list-like table",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s, re, plain, n)",
              "type":"function",
              "name":"split",
              "params":{
                "1":"s",
                "2":"re",
                "3":"plain",
                "4":"n",
                "map":{
                  "re":" optional A Lua string pattern; defaults to '%s+'",
                  "n":" optional maximum number of elements (if there are more, the last will remian un-split)",
                  "s":" The input string",
                  "plain":" optional If truthy don't use Lua patterns"
                }
              },
              "tags":{
                "see":[]
              },
              "kind":"string functions ",
              "section":"String functions",
              "description":"",
              "raise":"error if s is not a string",
              "ret":["a list-like table"],
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "param":{
                  "1":[],
                  "2":[],
                  "3":[],
                  "4":[],
                  "re":[],
                  "n":[],
                  "s":[],
                  "plain":[]
                },
                "return":[[]],
                "usage":[[]],
                "see":[[]]
              },
              "summary":"split a string into a number of return values.",
              "lineno":735,
              "retgroups":[{
                  "1":{
                    "text":"n values",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s, re, plain, n)",
              "usage":["first,next = splitv('user=jane=doe','=', false, 2)\nassert(first == \"user\")\nassert(next == \"jane=doe\")\n"],
              "type":"function",
              "name":"splitv",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"re",
                "3":"plain",
                "4":"n",
                "map":{
                  "re":" A Lua string pattern; defaults to '%s+'",
                  "n":" optional maximum number of splits",
                  "s":" the string",
                  "plain":" don't use Lua patterns"
                }
              },
              "tags":{
                "see":[]
              },
              "kind":"string functions ",
              "section":"String functions",
              "description":"\n Identical to `split` but returns multiple sub-strings instead of\n a single list of sub-strings.",
              "ret":["n values"]
            },{
              "name":"functional",
              "inferred":true,
              "description":"",
              "file":"<reference cycle>",
              "summary":"",
              "tags":[],
              "lineno":744,
              "display_name":"Functional",
              "type":"section",
              "modifiers":[]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[[]],
                "param":{
                  "1":[],
                  "func":[]
                }
              },
              "summary":"'memoize' a function (cache returned value for next call).",
              "lineno":750,
              "retgroups":[{
                  "1":{
                    "text":"a function with at least one argument, which is used as the key.",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(func)",
              "type":"function",
              "name":"memoize",
              "parameter":"param",
              "params":{
                "map":{
                  "func":" a function of at least one argument"
                },
                "1":"func"
              },
              "tags":[],
              "kind":"functional ",
              "section":"Functional",
              "description":"\n This is useful if you have a function which is relatively expensive,\n but you don't know in advance what values will be required, so\n building a table upfront is wasteful/impossible.",
              "ret":["a function with at least one argument, which is used as the key."]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":{
                  "1":{
                    "type":"tab"
                  },
                  "2":{
                    "type":"func"
                  },
                  "fun":{
                    "type":"func"
                  },
                  "mt":{
                    "type":"tab"
                  }
                }
              },
              "summary":"associate a function factory with a type.",
              "lineno":768,
              "args":"(mt, fun)",
              "section":"Functional",
              "name":"add_function_factory",
              "params":{
                "1":"mt",
                "2":"fun",
                "map":{
                  "fun":" a callable that returns a function",
                  "mt":" metatable"
                }
              },
              "tags":[],
              "kind":"functional ",
              "description":"\n A function factory takes an object of the given type and\n returns a function for evaluating it",
              "type":"function",
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "param":{
                  "1":[],
                  "lf":[]
                },
                "return":[[]],
                "usage":[[]]
              },
              "summary":"an anonymous function as a string.",
              "lineno":800,
              "retgroups":[{
                  "1":{
                    "text":"a function",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(lf)",
              "usage":["string_lambda '|x|x+1' (2) == 3\nstring_lambda '_+1' (2) == 3\n"],
              "type":"function",
              "name":"string_lambda",
              "params":{
                "map":{
                  "lf":" function as a string"
                },
                "1":"lf"
              },
              "tags":[],
              "kind":"functional ",
              "section":"Functional",
              "description":" This string is either of the form\n '|args| expression' or is a function of one argument, '_'",
              "ret":["a function"],
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[[]],
                "see":[[]],
                "param":{
                  "1":[],
                  "2":[],
                  "p":[],
                  "fn":[]
                },
                "raise":[],
                "usage":[[]]
              },
              "summary":"bind the first argument of the function to a value.",
              "lineno":817,
              "retgroups":[{
                  "1":{
                    "text":"a function such that f(x) is fn(p,x)",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(fn, p)",
              "usage":["local function f(msg, name)\n  print(msg .. \" \" .. name)\nend\n\nlocal hello = utils.bind1(f, \"Hello\")\n\nprint(hello(\"world\"))     --> \"Hello world\"\nprint(hello(\"sunshine\"))  --> \"Hello sunshine\"\n"],
              "raise":"same as @{function_arg}",
              "name":"bind1",
              "params":{
                "1":"fn",
                "2":"p",
                "map":{
                  "p":" a value",
                  "fn":" a function of at least two values (may be an operator string)"
                }
              },
              "tags":{
                "see":[]
              },
              "kind":"functional ",
              "section":"Functional",
              "type":"function",
              "parameter":"param",
              "ret":["a function such that f(x) is fn(p,x)"],
              "description":""
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[]],
                "param":{
                  "1":[],
                  "2":[],
                  "p":[],
                  "fn":[]
                },
                "raise":[],
                "return":[[]]
              },
              "summary":"bind the second argument of the function to a value.",
              "lineno":836,
              "retgroups":[{
                  "1":{
                    "text":"a function such that f(x) is fn(x,p)",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(fn, p)",
              "usage":["local function f(a, b, c)\n  print(a .. \" \" .. b .. \" \" .. c)\nend\n\nlocal hello = utils.bind1(f, \"world\")\n\nprint(hello(\"Hello\", \"!\"))  --> \"Hello world !\"\nprint(hello(\"Bye\", \"?\"))    --> \"Bye world ?\"\n"],
              "raise":"same as @{function_arg}",
              "name":"bind2",
              "params":{
                "1":"fn",
                "2":"p",
                "map":{
                  "p":" a value",
                  "fn":" a function of at least two values (may be an operator string)"
                }
              },
              "tags":[],
              "kind":"functional ",
              "section":"Functional",
              "type":"function",
              "parameter":"param",
              "ret":["a function such that f(x) is fn(x,p)"],
              "description":""
            },{
              "name":"deprecation",
              "inferred":true,
              "description":"",
              "file":"<reference cycle>",
              "summary":"",
              "tags":[],
              "lineno":847,
              "display_name":"Deprecation",
              "type":"section",
              "modifiers":[]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":{
                  "1":[],
                  "func":[]
                },
                "usage":[[]],
                "see":[[]]
              },
              "summary":"Sets a deprecation warning function.",
              "lineno":875,
              "args":"(func)",
              "usage":["-- write to the Nginx logs with OpenResty\nutils.set_deprecation_func(function(msg, trace)\n  ngx.log(ngx.WARN, msg, (trace and (\" \" .. trace) or nil))\nend)\n\n-- disable deprecation warnings\nutils.set_deprecation_func()\n"],
              "section":"Deprecation",
              "name":"set_deprecation_func",
              "parameter":"param",
              "params":{
                "map":{
                  "func":" a callback with signature: `function(msg, trace)` both arguments are strings, the latter being optional."
                },
                "1":"func"
              },
              "tags":{
                "see":[]
              },
              "kind":"deprecation ",
              "description":"\n An application can override this function to support proper output of\n deprecation warnings. The warnings can be generated from libraries or\n functions by calling `utils.raise_deprecation`. The default function\n will write to the 'warn' system (introduced in Lua 5.4, or the compatibility\n function from the `compat` module for earlier versions).\n\n Note: only applications should set/change this function, libraries should not.",
              "type":"function"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":{
                  "1":[],
                  "opts":[]
                },
                "usage":[[]],
                "see":[[]]
              },
              "summary":"raises a deprecation warning.",
              "lineno":907,
              "args":"(opts)",
              "usage":["warn(\"@on\")   -- enable Lua warnings, they are usually off by default\n\nfunction stringx.islower(str)\n  raise_deprecation {\n    source = \"Penlight \" .. utils._VERSION,                   -- optional\n    message = \"function 'islower' was renamed to 'is_lower'\", -- required\n    version_removed = \"2.0.0\",                                -- optional\n    deprecated_after = \"1.2.3\",                               -- optional\n    no_trace = true,                                          -- optional\n  }\n  return stringx.is_lower(str)\nend\n-- output: \"[Penlight 1.9.2] function 'islower' was renamed to 'is_lower' (deprecated after 1.2.3, scheduled for removal in 2.0.0)\"\n"],
              "section":"Deprecation",
              "name":"raise_deprecation",
              "parameter":"param",
              "params":{
                "map":{
                  "opts":" options table"
                },
                "1":"opts"
              },
              "tags":{
                "see":[]
              },
              "kind":"deprecation ",
              "description":"\n For options see the usage example below.\n\n Note: the `opts.deprecated_after` field is the last version in which\n a feature or option was NOT YET deprecated! Because when writing the code it\n is quite often not known in what version the code will land. But the last\n released version is usually known.",
              "type":"function"
            }],
          "sections":[],
          "modules":["<reference cycle>"],
          "args":{
            "one":false,
            "module":false,
            "verbose":false,
            "style":"!",
            "template":"!",
            "date":"system",
            "dir":"doc",
            "quiet":false,
            "all":false,
            "ignore":false,
            "colon":false,
            "not_luadoc":false,
            "ext":"html",
            "boilerplate":false,
            "merge":false,
            "filter":"f.filter",
            "package":"/home/cji/portless/Penlight/lua",
            "dump":false,
            "no_args_infer":false,
            "title":"Reference",
            "project":"ldoc",
            "file":"/home/cji/portless/Penlight/lua/pl",
            "format":"discount",
            "simple":false,
            "tags":"none",
            "define":"none",
            "output":"index",
            "unqualified":false,
            "config":"config.ld",
            "fatalwarnings":false,
            "testing":false
          },
          "error":"<type 'function' is not supported by JSON.>",
          "lang":{
            "line_comment":"^%-%-+",
            "start_comment_":"^%-%-%-+",
            "end_comment_":"[^%-]%-%-+[^-]*\n$",
            "extra":[],
            "block_comment":"^%-%-%[=*%[%-+",
            "empty_comment_":"^%-%-%-+%s*$",
            "method_call":":"
          },
          "base":"/home/cji/portless/Penlight/lua"
        },
        "summary":"",
        "tags":[],
        "lineno":272,
        "display_name":"Error handling",
        "type":"section",
        "modifiers":[]
      },
      "Functional":{
        "name":"functional",
        "inferred":true,
        "description":"",
        "file":{
          "warning":"<type 'function' is not supported by JSON.>",
          "filename":"/home/cji/portless/Penlight/lua/pl/utils.lua",
          "items":["<reference cycle>",{
              "inferred":true,
              "description":"",
              "modifiers":{
                "field":[],
                "return":[]
              },
              "summary":"Some standard patterns",
              "lineno":31,
              "args":"(FLOAT, INTEGER, IDEN, FILE)",
              "type":"table",
              "name":"patterns",
              "parameter":"field",
              "params":{
                "1":"FLOAT",
                "2":"INTEGER",
                "3":"IDEN",
                "4":"FILE",
                "map":{
                  "FILE":"file",
                  "INTEGER":"integer number",
                  "IDEN":"identifier",
                  "FLOAT":"floating point number"
                }
              },
              "tags":[],
              "kind":"tables",
              "section":"table",
              "subparams":[]
            },{
              "name":"stdmt",
              "section":"table",
              "inferred":true,
              "description":"",
              "kind":"tables",
              "summary":"Standard meta-tables as used by other Penlight modules",
              "params":{
                "1":"List",
                "2":"Map",
                "3":"Set",
                "4":"MultiMap",
                "map":{
                  "Map":" the Map metatable",
                  "Set":" the Set metatable",
                  "MultiMap":" the MultiMap metatable",
                  "List":" the List metatable"
                }
              },
              "tags":[],
              "lineno":45,
              "subparams":[],
              "args":"(List, Map, Set, MultiMap)",
              "parameter":"field",
              "type":"table",
              "modifiers":{
                "field":{
                  "1":[],
                  "2":[],
                  "3":[],
                  "4":[],
                  "Map":[],
                  "Set":[],
                  "MultiMap":[],
                  "List":[]
                },
                "return":[]
              }
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "param":{
                  "1":[],
                  "...":[]
                },
                "return":[[]],
                "see":[[],[],[]]
              },
              "summary":"pack an argument list into a table.",
              "lineno":60,
              "retgroups":[{
                  "1":{
                    "text":"a table with field `n` set to the length",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(...)",
              "section":"function",
              "name":"pack",
              "params":{
                "map":{
                  "...":" any arguments"
                },
                "1":"..."
              },
              "tags":{
                "see":[]
              },
              "kind":"functions",
              "description":"",
              "type":"function",
              "ret":["a table with field `n` set to the length"],
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[[]],
                "usage":[[]],
                "param":{
                  "1":[],
                  "2":{
                    "optchain":true,
                    "opt":true
                  },
                  "3":{
                    "optchain":true,
                    "opt":true
                  },
                  "t":[],
                  "j":{
                    "optchain":true,
                    "opt":true
                  },
                  "i":{
                    "optchain":true,
                    "opt":true
                  }
                },
                "see":[[],[],[]]
              },
              "summary":"unpack a table and return its contents.",
              "lineno":79,
              "retgroups":[{
                  "1":{
                    "text":"multiple return values from the table",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(t[, i[, j]])",
              "usage":["local t = table.pack(nil, nil, nil, 4)\nlocal a, b, c, d = table.unpack(t)   -- this `unpack` is NOT nil-safe, so d == nil\n\nlocal a, b, c, d = utils.unpack(t)   -- this is nil-safe, so d == 4\n"],
              "type":"function",
              "name":"unpack",
              "params":{
                "1":"t",
                "2":"i",
                "map":{
                  "t":" table to unpack",
                  "j":" index of the last element to unpack, defaults to `t.n` or else `#t`",
                  "i":" index from which to start unpacking, defaults to 1"
                },
                "3":"j"
              },
              "tags":{
                "see":[]
              },
              "kind":"functions",
              "section":"function",
              "description":"\n\n NOTE: this implementation differs from the Lua implementation in the way\n that this one DOES honor the `n` field in the table `t`, such that it is 'nil-safe'.",
              "ret":["multiple return values from the table"],
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":{
                  "1":[],
                  "2":[],
                  "fmt":[],
                  "...":[]
                }
              },
              "summary":"print an arbitrary number of arguments using a format.",
              "lineno":87,
              "args":"(fmt, ...)",
              "section":"function",
              "name":"printf",
              "params":{
                "1":"fmt",
                "2":"...",
                "map":{
                  "fmt":" The format (see `string.format`)",
                  "...":" Extra arguments for format"
                }
              },
              "tags":[],
              "kind":"functions",
              "description":"\n Output will be sent to `stdout`.",
              "type":"function",
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":{
                  "1":[],
                  "2":[],
                  "3":[],
                  "fmt":[],
                  "f":[],
                  "...":[]
                }
              },
              "summary":"write an arbitrary number of arguments to a file using a format.",
              "lineno":96,
              "args":"(f, fmt, ...)",
              "section":"function",
              "name":"fprintf",
              "params":{
                "1":"f",
                "2":"fmt",
                "map":{
                  "fmt":" The format (see `string.format`).",
                  "f":" File handle to write to.",
                  "...":" Extra arguments for format"
                },
                "3":"..."
              },
              "tags":[],
              "kind":"functions",
              "description":"",
              "type":"function",
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":{
                  "1":[],
                  "2":[],
                  "t":[],
                  "T":[]
                }
              },
              "summary":"take a table and 'inject' it into the local namespace.",
              "lineno":124,
              "args":"(t, T)",
              "section":"function",
              "name":"import",
              "params":{
                "1":"t",
                "2":"T",
                "map":{
                  "t":" The table (table), or module name (string), defaults to this `utils` module table",
                  "T":" An optional destination table (defaults to callers environment)"
                }
              },
              "tags":[],
              "kind":"functions",
              "description":"",
              "type":"function",
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":{
                  "1":[],
                  "2":[],
                  "3":[],
                  "cond":[],
                  "value1":[],
                  "value2":[]
                }
              },
              "summary":"return either of two values, depending on a condition.",
              "lineno":143,
              "args":"(cond, value1, value2)",
              "section":"function",
              "name":"choose",
              "params":{
                "1":"cond",
                "2":"value1",
                "map":{
                  "cond":" A condition",
                  "value1":" Value returned if cond is truthy",
                  "value2":" Value returned if cond is falsy"
                },
                "3":"value2"
              },
              "tags":[],
              "kind":"functions",
              "description":"",
              "type":"function",
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[[]],
                "param":{
                  "1":[],
                  "2":{
                    "optchain":true,
                    "opt":true
                  },
                  "3":{
                    "optchain":true,
                    "opt":true
                  },
                  "t":[],
                  "temp":{
                    "optchain":true,
                    "opt":true
                  },
                  "tostr":{
                    "optchain":true,
                    "opt":true
                  }
                }
              },
              "summary":"convert an array of values to strings.",
              "lineno":152,
              "retgroups":[{
                  "1":{
                    "text":"the converted buffer",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(t[, temp[, tostr]])",
              "type":"function",
              "name":"array_tostring",
              "parameter":"param",
              "params":{
                "1":"t",
                "2":"temp",
                "map":{
                  "t":" a list-like table",
                  "temp":" (table) buffer to use, otherwise allocate",
                  "tostr":" custom tostring function, called with (value,index). Defaults to `tostring`."
                },
                "3":"tostr"
              },
              "tags":[],
              "kind":"functions",
              "section":"function",
              "description":"",
              "ret":["the converted buffer"]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[]],
                "param":{
                  "1":[],
                  "2":[],
                  "obj":[],
                  "tp":[]
                },
                "return":[[]]
              },
              "summary":"is the object of the specified type?",
              "lineno":172,
              "retgroups":[{
                  "1":{
                    "text":"boolean",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(obj, tp)",
              "usage":["utils.is_type(\"hello world\", \"string\")   --> true\n-- or check metatable\nlocal my_mt = {}\nlocal my_obj = setmetatable(my_obj, my_mt)\nutils.is_type(my_obj, my_mt)  --> true\n"],
              "type":"function",
              "name":"is_type",
              "parameter":"param",
              "params":{
                "1":"obj",
                "2":"tp",
                "map":{
                  "obj":" An object to check",
                  "tp":" String of what type it should be"
                }
              },
              "tags":[],
              "kind":"functions",
              "section":"function",
              "description":"\n If the type is a string, then use type, otherwise compare with metatable",
              "ret":["boolean"]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[]],
                "return":[{
                    "type":"integer"
                  },{
                    "type":"any"
                  }],
                "param":{
                  "1":{
                    "type":"table"
                  },
                  "2":{
                    "opt":"1",
                    "type":"integer",
                    "optchain":"1"
                  },
                  "3":{
                    "opt":"t.n or #t",
                    "type":"integer",
                    "optchain":"t.n or #t"
                  },
                  "4":{
                    "opt":"1",
                    "type":"integer",
                    "optchain":"1"
                  },
                  "t":{
                    "type":"table"
                  },
                  "step":{
                    "opt":"1",
                    "type":"integer",
                    "optchain":"1"
                  },
                  "i_start":{
                    "opt":"1",
                    "type":"integer",
                    "optchain":"1"
                  },
                  "i_end":{
                    "opt":"t.n or #t",
                    "type":"integer",
                    "optchain":"t.n or #t"
                  }
                },
                "see":[[],[]]
              },
              "summary":"an iterator with indices, similar to `ipairs`, but with a range.",
              "lineno":199,
              "retgroups":[{
                  "1":{
                    "text":"index",
                    "type":"integer",
                    "mods":{
                      "type":"integer"
                    }
                  },
                  "2":{
                    "text":"value at index (which can be `nil`!)",
                    "type":"any",
                    "mods":{
                      "type":"any"
                    }
                  },
                  "g":0
                }],
              "args":"(t[, i_start=1[, i_end=t.n or #t[, step=1]]])",
              "usage":["local t = utils.pack(nil, 123, nil)  -- adds an `n` field when packing\n\nfor i, v in utils.npairs(t, 2) do  -- start at index 2\n  t[i] = tostring(t[i])\nend\n\n-- t = { n = 3, [2] = \"123\", [3] = \"nil\" }\n"],
              "type":"function",
              "name":"npairs",
              "parameter":"param",
              "params":{
                "1":"t",
                "2":"i_start",
                "3":"i_end",
                "4":"step",
                "map":{
                  "t":" the table to iterate over",
                  "step":" step size",
                  "i_start":" start index",
                  "i_end":" end index"
                }
              },
              "tags":{
                "see":[]
              },
              "kind":"functions",
              "section":"function",
              "description":"\n This is a nil-safe index based iterator that will return `nil` when there\n is a hole in a list. To be safe ensure that table `t.n` contains the length.",
              "ret":["index","value at index (which can be `nil`!)"]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[]],
                "param":{
                  "1":{
                    "type":"table"
                  },
                  "t":{
                    "type":"table"
                  }
                },
                "return":[{
                    "type":"key"
                  },{
                    "type":"value"
                  }]
              },
              "summary":"an iterator over all non-integer keys (inverse of `ipairs`).",
              "lineno":253,
              "retgroups":[{
                  "1":{
                    "text":"",
                    "type":"key",
                    "mods":{
                      "type":"key"
                    }
                  },
                  "2":{
                    "text":"",
                    "type":"value",
                    "mods":{
                      "type":"value"
                    }
                  },
                  "g":0
                }],
              "args":"(t)",
              "usage":["local t = {\n  \"hello\",\n  \"world\",\n  hello = \"hallo\",\n  world = \"Welt\",\n}\n\nfor k, v in utils.kpairs(t) do\n  print(\"German: \", v)\nend\n\n-- output;\n-- German: hallo\n-- German: Welt\n"],
              "type":"function",
              "name":"kpairs",
              "parameter":"param",
              "params":{
                "map":{
                  "t":" the table to iterate over"
                },
                "1":"t"
              },
              "tags":[],
              "kind":"functions",
              "section":"function",
              "description":"\n It will skip any key that is an integer number, so negative indices or an\n array with holes will not return those either (so it returns slightly less than\n 'the inverse of `ipairs`').\n\n This uses `pairs` under the hood, so any value that is iterable using `pairs`\n will work with this function.",
              "ret":["",""]
            },{
              "name":"Error-handling",
              "inferred":true,
              "description":"",
              "file":"<reference cycle>",
              "summary":"",
              "tags":[],
              "lineno":272,
              "display_name":"Error handling",
              "type":"section",
              "modifiers":[]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[]],
                "param":{
                  "1":[],
                  "2":[],
                  "3":[],
                  "4":[],
                  "5":[],
                  "6":[],
                  "n":[],
                  "verify":[],
                  "val":[],
                  "lev":[],
                  "msg":[],
                  "tp":[]
                },
                "raise":[],
                "return":[[]]
              },
              "summary":"assert that the given argument is in fact of the correct type.",
              "lineno":285,
              "retgroups":[{
                  "1":{
                    "text":"the validated value",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(n, val, tp, verify, msg, lev)",
              "usage":["local param1 = assert_arg(1,\"hello\",'table')  --> error: argument 1 expected a 'table', got a 'string'\nlocal param4 = assert_arg(4,'!@#$%^&*','string',path.isdir,'not a directory')\n     --> error: argument 4: '!@#$%^&*' not a directory\n"],
              "raise":"if `val` is not the correct type",
              "name":"assert_arg",
              "params":{
                "1":"n",
                "2":"val",
                "3":"tp",
                "4":"verify",
                "5":"msg",
                "6":"lev",
                "map":{
                  "n":" argument index",
                  "verify":" an optional verification function",
                  "val":" the value",
                  "lev":" optional stack position for trace, default 2",
                  "msg":" an optional custom message",
                  "tp":" the type"
                }
              },
              "tags":[],
              "kind":"error handling ",
              "section":"Error handling",
              "type":"function",
              "parameter":"param",
              "ret":["the validated value"],
              "description":""
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[],[],[]],
                "param":{
                  "1":{
                    "type":"table|vararg"
                  },
                  "...":{
                    "type":"table|vararg"
                  }
                },
                "return":[[]]
              },
              "summary":"creates an Enum or constants lookup table for improved error handling.",
              "lineno":355,
              "retgroups":[{
                  "1":{
                    "text":"Enum object (read-only table/object)",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(...)",
              "usage":["-- Enum access at runtime\nlocal obj = {}\nobj.MOVEMENT = utils.enum(\"FORWARD\", \"REVERSE\", \"LEFT\", \"RIGHT\")\n\nif current_movement == obj.MOVEMENT.FORWARD then\n  -- do something\n\nelseif current_movement == obj.MOVEMENT.REVERES then\n  -- throws error due to typo 'REVERES', so a silent mistake becomes a hard error\n  -- \"'REVERES' is not a valid value (expected one of: 'FORWARD', 'REVERSE', 'LEFT', 'RIGHT')\"\n\nend\n","-- standardized error codes\nlocal obj = {\n  ERR = utils.enum {\n    NOT_FOUND = \"the item was not found\",\n    OUT_OF_BOUNDS = \"the index is outside the allowed range\"\n  },\n\n  some_method = function(self)\n    return self.ERR.OUT_OF_BOUNDS\n  end,\n}\n\nlocal result, err = obj:some_method()\nif not result then\n  if err == obj.ERR.NOT_FOUND then\n    -- check on error code, not magic strings\n\n  else\n    -- return the error description, contained in the constant\n    return nil, \"error: \"..err  -- \"error: the index is outside the allowed range\"\n  end\nend\n","-- validating/converting user-input\nlocal color = \"purple\"\nlocal ansi_colors = utils.enum {\n  black     = 30,\n  red       = 31,\n  green     = 32,\n}\nlocal color_code, err = ansi_colors(color) -- calling on the object, returns the value from the enum\nif not color_code then\n  print(\"bad 'color', \" .. err)\n  -- \"bad 'color', 'purple' is not a valid value (expected one of: 'black', 'red', 'green')\"\n  os.exit(1)\nend\n"],
              "type":"function",
              "name":"enum",
              "parameter":"param",
              "params":{
                "map":{
                  "...":" the input for the Enum. If varargs or an array then the\n values in the Enum will be equal to the names (must be strings), if a hash-table\n then values remain (any type), and the keys must be strings."
                },
                "1":"..."
              },
              "tags":[],
              "kind":"error handling ",
              "section":"Error handling",
              "description":"\n This helps prevent magic strings in code by throwing errors for accessing\n non-existing values, and/or converting strings/identifiers to other values.\n\n Calling on the object does the same, but returns a soft error; `nil + err`, if\n the call is succesful (the key exists), it will return the value.\n\n When calling with varargs or an array the values will be equal to the keys.\n The enum object is read-only.",
              "ret":["Enum object (read-only table/object)"]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "param":{
                  "1":[],
                  "2":[],
                  "3":[],
                  "f":[],
                  "msg":[],
                  "idx":[]
                },
                "raise":[],
                "return":[[]]
              },
              "summary":"process a function argument.",
              "lineno":430,
              "retgroups":[{
                  "1":{
                    "text":"a callable",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(idx, f, msg)",
              "type":"function",
              "name":"function_arg",
              "params":{
                "1":"idx",
                "2":"f",
                "map":{
                  "f":" a function, operator string, or callable object",
                  "msg":" optional error message",
                  "idx":" argument index"
                },
                "3":"msg"
              },
              "tags":[],
              "kind":"error handling ",
              "section":"Error handling",
              "description":"\n This is used throughout Penlight and defines what is meant by a function:\n Something that is callable, or an operator string as defined by <code>pl.operator</code>,\n such as '>' or '#'. If a function factory has been registered for the type, it will\n be called to get the function.",
              "raise":"if idx is not a number or if f is not callable",
              "ret":["a callable"],
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[]],
                "param":{
                  "1":[],
                  "2":[],
                  "val":[],
                  "n":[]
                },
                "raise":[],
                "return":[[]]
              },
              "summary":"assert the common case that the argument is a string.",
              "lineno":470,
              "retgroups":[{
                  "1":{
                    "text":"the validated value",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(n, val)",
              "usage":["local val = 42\nlocal param2 = utils.assert_string(2, val) --> error: argument 2 expected a 'string', got a 'number'\n"],
              "raise":"val must be a string",
              "name":"assert_string",
              "params":{
                "1":"n",
                "2":"val",
                "map":{
                  "val":" a value that must be a string",
                  "n":" argument index"
                }
              },
              "tags":[],
              "kind":"error handling ",
              "section":"Error handling",
              "type":"function",
              "parameter":"param",
              "ret":["the validated value"],
              "description":""
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "param":{
                  "1":[],
                  "mode":[]
                },
                "return":[],
                "see":[[]]
              },
              "summary":"control the error strategy used by Penlight.",
              "lineno":483,
              "args":"(mode)",
              "section":"Error handling",
              "name":"on_error",
              "params":{
                "map":{
                  "mode":" either 'default', 'quit'  or 'error'"
                },
                "1":"mode"
              },
              "tags":{
                "see":[]
              },
              "kind":"error handling ",
              "description":"\n This is a global setting that controls how `utils.raise` behaves:\n\n - 'default': return `nil + error` (this is the default)\n - 'error': throw a Lua error\n - 'quit': exit the program\n",
              "type":"function",
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":{
                  "1":[],
                  "err":[]
                },
                "usage":[[]],
                "see":[[]]
              },
              "summary":"used by Penlight functions to return errors.",
              "lineno":507,
              "args":"(err)",
              "usage":["if some_condition then\n  return utils.raise(\"some condition was not met\")  -- MUST use 'return'!\nend\n"],
              "section":"Error handling",
              "name":"raise",
              "parameter":"param",
              "params":{
                "map":{
                  "err":" the error string."
                },
                "1":"err"
              },
              "tags":{
                "see":[]
              },
              "kind":"error handling ",
              "description":" Its global behaviour is controlled\n by `utils.on_error`.\n To use this function you MUST use it in conjunction with `return`, since it might\n return `nil + error`.",
              "type":"function"
            },{
              "name":"files",
              "inferred":true,
              "description":"",
              "file":"<reference cycle>",
              "summary":"",
              "tags":[],
              "lineno":523,
              "display_name":"File handling",
              "type":"section",
              "modifiers":[]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[[]],
                "param":{
                  "1":[],
                  "2":[],
                  "filename":[],
                  "is_bin":[]
                }
              },
              "summary":"return the contents of a file as a string",
              "lineno":527,
              "retgroups":[{
                  "1":{
                    "text":"file contents",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(filename, is_bin)",
              "type":"function",
              "name":"readfile",
              "parameter":"param",
              "params":{
                "1":"filename",
                "2":"is_bin",
                "map":{
                  "filename":" The file path",
                  "is_bin":" open in binary mode"
                }
              },
              "tags":[],
              "kind":"file handling ",
              "section":"File handling",
              "description":"",
              "ret":["file contents"]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "param":{
                  "1":[],
                  "2":[],
                  "3":[],
                  "filename":[],
                  "str":[],
                  "is_bin":[]
                },
                "raise":[],
                "return":[[],[]]
              },
              "summary":"write a string to a file",
              "lineno":549,
              "retgroups":[{
                  "1":{
                    "text":"true or nil",
                    "type":"",
                    "mods":[]
                  },
                  "2":{
                    "text":"error message",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(filename, str, is_bin)",
              "type":"function",
              "name":"writefile",
              "params":{
                "1":"filename",
                "2":"str",
                "map":{
                  "filename":" The file path",
                  "str":" The string",
                  "is_bin":" open in binary mode"
                },
                "3":"is_bin"
              },
              "tags":[],
              "kind":"file handling ",
              "section":"File handling",
              "description":"",
              "raise":"error if filename or str aren't strings",
              "ret":["true or nil","error message"],
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "param":{
                  "1":[],
                  "filename":[]
                },
                "raise":[],
                "return":[[]]
              },
              "summary":"return the contents of a file as a list of lines",
              "lineno":569,
              "retgroups":[{
                  "1":{
                    "text":"file contents as a table",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(filename)",
              "type":"function",
              "name":"readlines",
              "params":{
                "map":{
                  "filename":" The file path"
                },
                "1":"filename"
              },
              "tags":[],
              "kind":"file handling ",
              "section":"File handling",
              "description":"",
              "raise":"error if filename is not a string",
              "ret":["file contents as a table"],
              "parameter":"param"
            },{
              "name":"OS-functions",
              "inferred":true,
              "description":"",
              "file":"<reference cycle>",
              "summary":"",
              "tags":[],
              "lineno":584,
              "display_name":"OS functions",
              "type":"section",
              "modifiers":[]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[[],[],[],[]],
                "param":{
                  "1":[],
                  "2":[],
                  "bin":[],
                  "cmd":[]
                }
              },
              "summary":"execute a shell command and return the output.",
              "lineno":592,
              "retgroups":[{
                  "1":{
                    "text":"true if successful",
                    "type":"",
                    "mods":[]
                  },
                  "2":{
                    "text":"actual return code",
                    "type":"",
                    "mods":[]
                  },
                  "3":{
                    "text":"stdout output (string)",
                    "type":"",
                    "mods":[]
                  },
                  "4":{
                    "text":"errout output (string)",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(cmd, bin)",
              "type":"function",
              "name":"executeex",
              "parameter":"param",
              "params":{
                "1":"cmd",
                "2":"bin",
                "map":{
                  "bin":" boolean, if true, read output as binary file",
                  "cmd":" a shell command"
                }
              },
              "tags":[],
              "kind":"os functions ",
              "section":"OS functions",
              "description":"\n This function redirects the output to tempfiles and returns the content of those files.",
              "ret":["true if successful","actual return code","stdout output (string)","errout output (string)"]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[]],
                "param":{
                  "1":[],
                  "argument":[]
                },
                "return":[[]]
              },
              "summary":"Quote and escape an argument of a command.",
              "lineno":623,
              "retgroups":[{
                  "1":{
                    "text":"quoted and escaped argument.",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(argument)",
              "usage":["local options = utils.quote_arg {\n    \"-lluacov\",\n    \"-e\",\n    \"utils = print(require('pl.utils')._VERSION\",\n}\n-- returns: -lluacov -e 'utils = print(require('\\''pl.utils'\\'')._VERSION'\n"],
              "type":"function",
              "name":"quote_arg",
              "parameter":"param",
              "params":{
                "map":{
                  "argument":" (string or table/list) the argument to quote. If a list then\n all arguments in the list will be returned as a single string quoted."
                },
                "1":"argument"
              },
              "tags":[],
              "kind":"os functions ",
              "section":"OS functions",
              "description":"\n Quotes a single (or list of) argument(s) of a command to be passed\n to `os.execute`, `pl.utils.execute` or `pl.utils.executeex`.",
              "ret":["quoted and escaped argument."]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":{
                  "1":{
                    "opt":true
                  },
                  "2":[],
                  "3":[],
                  "msg":[],
                  "...":[],
                  "code":{
                    "opt":true
                  }
                },
                "usage":[[]],
                "see":[[]]
              },
              "summary":"error out of this program gracefully.",
              "lineno":667,
              "args":"([code], msg, ...)",
              "usage":["utils.quit(-1, \"Error '%s' happened\", \"42\")\n-- is equivalent to\nutils.quit(\"Error '%s' happened\", \"42\")  --> Error '42' happened\n"],
              "section":"OS functions",
              "name":"quit",
              "parameter":"param",
              "params":{
                "1":"code",
                "2":"msg",
                "map":{
                  "msg":" The exit message will be sent to `stderr` (will be formatted with the extra parameters)",
                  "...":" extra arguments for message's format'",
                  "code":" The exit code, defaults to -`1` if omitted"
                },
                "3":"..."
              },
              "tags":{
                "see":[]
              },
              "kind":"os functions ",
              "description":"",
              "type":"function"
            },{
              "name":"string-functions",
              "inferred":true,
              "description":"",
              "file":"<reference cycle>",
              "summary":"",
              "tags":[],
              "lineno":683,
              "display_name":"String functions",
              "type":"section",
              "modifiers":[]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":{
                  "1":[],
                  "s":[]
                }
              },
              "summary":"escape any Lua 'magic' characters in a string",
              "lineno":685,
              "args":"(s)",
              "section":"String functions",
              "name":"escape",
              "params":{
                "map":{
                  "s":" The input string"
                },
                "1":"s"
              },
              "tags":[],
              "kind":"string functions ",
              "description":"",
              "type":"function",
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "param":{
                  "1":[],
                  "2":[],
                  "3":[],
                  "4":[],
                  "re":[],
                  "n":[],
                  "s":[],
                  "plain":[]
                },
                "return":[[]],
                "raise":[],
                "see":[[]]
              },
              "summary":"split a string into a list of strings separated by a delimiter.",
              "lineno":698,
              "retgroups":[{
                  "1":{
                    "text":"a list-like table",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s, re, plain, n)",
              "type":"function",
              "name":"split",
              "params":{
                "1":"s",
                "2":"re",
                "3":"plain",
                "4":"n",
                "map":{
                  "re":" optional A Lua string pattern; defaults to '%s+'",
                  "n":" optional maximum number of elements (if there are more, the last will remian un-split)",
                  "s":" The input string",
                  "plain":" optional If truthy don't use Lua patterns"
                }
              },
              "tags":{
                "see":[]
              },
              "kind":"string functions ",
              "section":"String functions",
              "description":"",
              "raise":"error if s is not a string",
              "ret":["a list-like table"],
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "param":{
                  "1":[],
                  "2":[],
                  "3":[],
                  "4":[],
                  "re":[],
                  "n":[],
                  "s":[],
                  "plain":[]
                },
                "return":[[]],
                "usage":[[]],
                "see":[[]]
              },
              "summary":"split a string into a number of return values.",
              "lineno":735,
              "retgroups":[{
                  "1":{
                    "text":"n values",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(s, re, plain, n)",
              "usage":["first,next = splitv('user=jane=doe','=', false, 2)\nassert(first == \"user\")\nassert(next == \"jane=doe\")\n"],
              "type":"function",
              "name":"splitv",
              "parameter":"param",
              "params":{
                "1":"s",
                "2":"re",
                "3":"plain",
                "4":"n",
                "map":{
                  "re":" A Lua string pattern; defaults to '%s+'",
                  "n":" optional maximum number of splits",
                  "s":" the string",
                  "plain":" don't use Lua patterns"
                }
              },
              "tags":{
                "see":[]
              },
              "kind":"string functions ",
              "section":"String functions",
              "description":"\n Identical to `split` but returns multiple sub-strings instead of\n a single list of sub-strings.",
              "ret":["n values"]
            },"<reference cycle>",{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[[]],
                "param":{
                  "1":[],
                  "func":[]
                }
              },
              "summary":"'memoize' a function (cache returned value for next call).",
              "lineno":750,
              "retgroups":[{
                  "1":{
                    "text":"a function with at least one argument, which is used as the key.",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(func)",
              "type":"function",
              "name":"memoize",
              "parameter":"param",
              "params":{
                "map":{
                  "func":" a function of at least one argument"
                },
                "1":"func"
              },
              "tags":[],
              "kind":"functional ",
              "section":"Functional",
              "description":"\n This is useful if you have a function which is relatively expensive,\n but you don't know in advance what values will be required, so\n building a table upfront is wasteful/impossible.",
              "ret":["a function with at least one argument, which is used as the key."]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":{
                  "1":{
                    "type":"tab"
                  },
                  "2":{
                    "type":"func"
                  },
                  "fun":{
                    "type":"func"
                  },
                  "mt":{
                    "type":"tab"
                  }
                }
              },
              "summary":"associate a function factory with a type.",
              "lineno":768,
              "args":"(mt, fun)",
              "section":"Functional",
              "name":"add_function_factory",
              "params":{
                "1":"mt",
                "2":"fun",
                "map":{
                  "fun":" a callable that returns a function",
                  "mt":" metatable"
                }
              },
              "tags":[],
              "kind":"functional ",
              "description":"\n A function factory takes an object of the given type and\n returns a function for evaluating it",
              "type":"function",
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "param":{
                  "1":[],
                  "lf":[]
                },
                "return":[[]],
                "usage":[[]]
              },
              "summary":"an anonymous function as a string.",
              "lineno":800,
              "retgroups":[{
                  "1":{
                    "text":"a function",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(lf)",
              "usage":["string_lambda '|x|x+1' (2) == 3\nstring_lambda '_+1' (2) == 3\n"],
              "type":"function",
              "name":"string_lambda",
              "params":{
                "map":{
                  "lf":" function as a string"
                },
                "1":"lf"
              },
              "tags":[],
              "kind":"functional ",
              "section":"Functional",
              "description":" This string is either of the form\n '|args| expression' or is a function of one argument, '_'",
              "ret":["a function"],
              "parameter":"param"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[[]],
                "see":[[]],
                "param":{
                  "1":[],
                  "2":[],
                  "p":[],
                  "fn":[]
                },
                "raise":[],
                "usage":[[]]
              },
              "summary":"bind the first argument of the function to a value.",
              "lineno":817,
              "retgroups":[{
                  "1":{
                    "text":"a function such that f(x) is fn(p,x)",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(fn, p)",
              "usage":["local function f(msg, name)\n  print(msg .. \" \" .. name)\nend\n\nlocal hello = utils.bind1(f, \"Hello\")\n\nprint(hello(\"world\"))     --> \"Hello world\"\nprint(hello(\"sunshine\"))  --> \"Hello sunshine\"\n"],
              "raise":"same as @{function_arg}",
              "name":"bind1",
              "params":{
                "1":"fn",
                "2":"p",
                "map":{
                  "p":" a value",
                  "fn":" a function of at least two values (may be an operator string)"
                }
              },
              "tags":{
                "see":[]
              },
              "kind":"functional ",
              "section":"Functional",
              "type":"function",
              "parameter":"param",
              "ret":["a function such that f(x) is fn(p,x)"],
              "description":""
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "usage":[[]],
                "param":{
                  "1":[],
                  "2":[],
                  "p":[],
                  "fn":[]
                },
                "raise":[],
                "return":[[]]
              },
              "summary":"bind the second argument of the function to a value.",
              "lineno":836,
              "retgroups":[{
                  "1":{
                    "text":"a function such that f(x) is fn(x,p)",
                    "type":"",
                    "mods":[]
                  },
                  "g":0
                }],
              "args":"(fn, p)",
              "usage":["local function f(a, b, c)\n  print(a .. \" \" .. b .. \" \" .. c)\nend\n\nlocal hello = utils.bind1(f, \"world\")\n\nprint(hello(\"Hello\", \"!\"))  --> \"Hello world !\"\nprint(hello(\"Bye\", \"?\"))    --> \"Bye world ?\"\n"],
              "raise":"same as @{function_arg}",
              "name":"bind2",
              "params":{
                "1":"fn",
                "2":"p",
                "map":{
                  "p":" a value",
                  "fn":" a function of at least two values (may be an operator string)"
                }
              },
              "tags":[],
              "kind":"functional ",
              "section":"Functional",
              "type":"function",
              "parameter":"param",
              "ret":["a function such that f(x) is fn(x,p)"],
              "description":""
            },{
              "name":"deprecation",
              "inferred":true,
              "description":"",
              "file":"<reference cycle>",
              "summary":"",
              "tags":[],
              "lineno":847,
              "display_name":"Deprecation",
              "type":"section",
              "modifiers":[]
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":{
                  "1":[],
                  "func":[]
                },
                "usage":[[]],
                "see":[[]]
              },
              "summary":"Sets a deprecation warning function.",
              "lineno":875,
              "args":"(func)",
              "usage":["-- write to the Nginx logs with OpenResty\nutils.set_deprecation_func(function(msg, trace)\n  ngx.log(ngx.WARN, msg, (trace and (\" \" .. trace) or nil))\nend)\n\n-- disable deprecation warnings\nutils.set_deprecation_func()\n"],
              "section":"Deprecation",
              "name":"set_deprecation_func",
              "parameter":"param",
              "params":{
                "map":{
                  "func":" a callback with signature: `function(msg, trace)` both arguments are strings, the latter being optional."
                },
                "1":"func"
              },
              "tags":{
                "see":[]
              },
              "kind":"deprecation ",
              "description":"\n An application can override this function to support proper output of\n deprecation warnings. The warnings can be generated from libraries or\n functions by calling `utils.raise_deprecation`. The default function\n will write to the 'warn' system (introduced in Lua 5.4, or the compatibility\n function from the `compat` module for earlier versions).\n\n Note: only applications should set/change this function, libraries should not.",
              "type":"function"
            },{
              "inferred":true,
              "subparams":[],
              "modifiers":{
                "return":[],
                "param":{
                  "1":[],
                  "opts":[]
                },
                "usage":[[]],
                "see":[[]]
              },
              "summary":"raises a deprecation warning.",
              "lineno":907,
              "args":"(opts)",
              "usage":["warn(\"@on\")   -- enable Lua warnings, they are usually off by default\n\nfunction stringx.islower(str)\n  raise_deprecation {\n    source = \"Penlight \" .. utils._VERSION,                   -- optional\n    message = \"function 'islower' was renamed to 'is_lower'\", -- required\n    version_removed = \"2.0.0\",                                -- optional\n    deprecated_after = \"1.2.3\",                               -- optional\n    no_trace = true,                                          -- optional\n  }\n  return stringx.is_lower(str)\nend\n-- output: \"[Penlight 1.9.2] function 'islower' was renamed to 'is_lower' (deprecated after 1.2.3, scheduled for removal in 2.0.0)\"\n"],
              "section":"Deprecation",
              "name":"raise_deprecation",
              "parameter":"param",
              "params":{
                "map":{
                  "opts":" options table"
                },
                "1":"opts"
              },
              "tags":{
                "see":[]
              },
              "kind":"deprecation ",
              "description":"\n For options see the usage example below.\n\n Note: the `opts.deprecated_after` field is the last version in which\n a feature or option was NOT YET deprecated! Because when writing the code it\n is quite often not known in what version the code will land. But the last\n released version is usually known.",
              "type":"function"
            }],
          "sections":[],
          "modules":["<reference cycle>"],
          "args":{
            "one":false,
            "module":false,
            "verbose":false,
            "style":"!",
            "template":"!",
            "date":"system",
            "dir":"doc",
            "quiet":false,
            "all":false,
            "ignore":false,
            "colon":false,
            "not_luadoc":false,
            "ext":"html",
            "boilerplate":false,
            "merge":false,
            "filter":"f.filter",
            "package":"/home/cji/portless/Penlight/lua",
            "dump":false,
            "no_args_infer":false,
            "title":"Reference",
            "project":"ldoc",
            "file":"/home/cji/portless/Penlight/lua/pl",
            "format":"discount",
            "simple":false,
            "tags":"none",
            "define":"none",
            "output":"index",
            "unqualified":false,
            "config":"config.ld",
            "fatalwarnings":false,
            "testing":false
          },
          "error":"<type 'function' is not supported by JSON.>",
          "lang":{
            "line_comment":"^%-%-+",
            "start_comment_":"^%-%-%-+",
            "end_comment_":"[^%-]%-%-+[^-]*\n$",
            "extra":[],
            "block_comment":"^%-%-%[=*%[%-+",
            "empty_comment_":"^%-%-%-+%s*$",
            "method_call":":"
          },
          "base":"/home/cji/portless/Penlight/lua"
        },
        "summary":"",
        "tags":[],
        "lineno":744,
        "display_name":"Functional",
        "type":"section",
        "modifiers":[]
      }
    }
  },
  "mod_name":"utils",
  "lineno":8,
  "items":[{
      "inferred":true,
      "description":"",
      "modifiers":{
        "field":[],
        "return":[]
      },
      "summary":"Some standard patterns",
      "lineno":31,
      "args":"(FLOAT, INTEGER, IDEN, FILE)",
      "type":"table",
      "name":"patterns",
      "parameter":"field",
      "params":{
        "1":"FLOAT",
        "2":"INTEGER",
        "3":"IDEN",
        "4":"FILE",
        "map":{
          "FILE":"file",
          "INTEGER":"integer number",
          "IDEN":"identifier",
          "FLOAT":"floating point number"
        }
      },
      "tags":[],
      "kind":"tables",
      "section":"table",
      "subparams":[]
    },{
      "name":"stdmt",
      "section":"table",
      "inferred":true,
      "description":"",
      "kind":"tables",
      "summary":"Standard meta-tables as used by other Penlight modules",
      "params":{
        "1":"List",
        "2":"Map",
        "3":"Set",
        "4":"MultiMap",
        "map":{
          "Map":" the Map metatable",
          "Set":" the Set metatable",
          "MultiMap":" the MultiMap metatable",
          "List":" the List metatable"
        }
      },
      "tags":[],
      "lineno":45,
      "subparams":[],
      "args":"(List, Map, Set, MultiMap)",
      "parameter":"field",
      "type":"table",
      "modifiers":{
        "field":{
          "1":[],
          "2":[],
          "3":[],
          "4":[],
          "Map":[],
          "Set":[],
          "MultiMap":[],
          "List":[]
        },
        "return":[]
      }
    },{
      "inferred":true,
      "subparams":[],
      "modifiers":{
        "param":{
          "1":[],
          "...":[]
        },
        "return":[[]],
        "see":[[],[],[]]
      },
      "summary":"pack an argument list into a table.",
      "lineno":60,
      "retgroups":[{
          "1":{
            "text":"a table with field `n` set to the length",
            "type":"",
            "mods":[]
          },
          "g":0
        }],
      "args":"(...)",
      "section":"function",
      "name":"pack",
      "params":{
        "map":{
          "...":" any arguments"
        },
        "1":"..."
      },
      "tags":{
        "see":[]
      },
      "kind":"functions",
      "description":"",
      "type":"function",
      "ret":["a table with field `n` set to the length"],
      "parameter":"param"
    },{
      "inferred":true,
      "subparams":[],
      "modifiers":{
        "return":[[]],
        "usage":[[]],
        "param":{
          "1":[],
          "2":{
            "optchain":true,
            "opt":true
          },
          "3":{
            "optchain":true,
            "opt":true
          },
          "t":[],
          "j":{
            "optchain":true,
            "opt":true
          },
          "i":{
            "optchain":true,
            "opt":true
          }
        },
        "see":[[],[],[]]
      },
      "summary":"unpack a table and return its contents.",
      "lineno":79,
      "retgroups":[{
          "1":{
            "text":"multiple return values from the table",
            "type":"",
            "mods":[]
          },
          "g":0
        }],
      "args":"(t[, i[, j]])",
      "usage":["local t = table.pack(nil, nil, nil, 4)\nlocal a, b, c, d = table.unpack(t)   -- this `unpack` is NOT nil-safe, so d == nil\n\nlocal a, b, c, d = utils.unpack(t)   -- this is nil-safe, so d == 4\n"],
      "type":"function",
      "name":"unpack",
      "params":{
        "1":"t",
        "2":"i",
        "map":{
          "t":" table to unpack",
          "j":" index of the last element to unpack, defaults to `t.n` or else `#t`",
          "i":" index from which to start unpacking, defaults to 1"
        },
        "3":"j"
      },
      "tags":{
        "see":[]
      },
      "kind":"functions",
      "section":"function",
      "description":"\n\n NOTE: this implementation differs from the Lua implementation in the way\n that this one DOES honor the `n` field in the table `t`, such that it is 'nil-safe'.",
      "ret":["multiple return values from the table"],
      "parameter":"param"
    },{
      "inferred":true,
      "subparams":[],
      "modifiers":{
        "return":[],
        "param":{
          "1":[],
          "2":[],
          "fmt":[],
          "...":[]
        }
      },
      "summary":"print an arbitrary number of arguments using a format.",
      "lineno":87,
      "args":"(fmt, ...)",
      "section":"function",
      "name":"printf",
      "params":{
        "1":"fmt",
        "2":"...",
        "map":{
          "fmt":" The format (see `string.format`)",
          "...":" Extra arguments for format"
        }
      },
      "tags":[],
      "kind":"functions",
      "description":"\n Output will be sent to `stdout`.",
      "type":"function",
      "parameter":"param"
    },{
      "inferred":true,
      "subparams":[],
      "modifiers":{
        "return":[],
        "param":{
          "1":[],
          "2":[],
          "3":[],
          "fmt":[],
          "f":[],
          "...":[]
        }
      },
      "summary":"write an arbitrary number of arguments to a file using a format.",
      "lineno":96,
      "args":"(f, fmt, ...)",
      "section":"function",
      "name":"fprintf",
      "params":{
        "1":"f",
        "2":"fmt",
        "map":{
          "fmt":" The format (see `string.format`).",
          "f":" File handle to write to.",
          "...":" Extra arguments for format"
        },
        "3":"..."
      },
      "tags":[],
      "kind":"functions",
      "description":"",
      "type":"function",
      "parameter":"param"
    },{
      "inferred":true,
      "subparams":[],
      "modifiers":{
        "return":[],
        "param":{
          "1":[],
          "2":[],
          "t":[],
          "T":[]
        }
      },
      "summary":"take a table and 'inject' it into the local namespace.",
      "lineno":124,
      "args":"(t, T)",
      "section":"function",
      "name":"import",
      "params":{
        "1":"t",
        "2":"T",
        "map":{
          "t":" The table (table), or module name (string), defaults to this `utils` module table",
          "T":" An optional destination table (defaults to callers environment)"
        }
      },
      "tags":[],
      "kind":"functions",
      "description":"",
      "type":"function",
      "parameter":"param"
    },{
      "inferred":true,
      "subparams":[],
      "modifiers":{
        "return":[],
        "param":{
          "1":[],
          "2":[],
          "3":[],
          "cond":[],
          "value1":[],
          "value2":[]
        }
      },
      "summary":"return either of two values, depending on a condition.",
      "lineno":143,
      "args":"(cond, value1, value2)",
      "section":"function",
      "name":"choose",
      "params":{
        "1":"cond",
        "2":"value1",
        "map":{
          "cond":" A condition",
          "value1":" Value returned if cond is truthy",
          "value2":" Value returned if cond is falsy"
        },
        "3":"value2"
      },
      "tags":[],
      "kind":"functions",
      "description":"",
      "type":"function",
      "parameter":"param"
    },{
      "inferred":true,
      "subparams":[],
      "modifiers":{
        "return":[[]],
        "param":{
          "1":[],
          "2":{
            "optchain":true,
            "opt":true
          },
          "3":{
            "optchain":true,
            "opt":true
          },
          "t":[],
          "temp":{
            "optchain":true,
            "opt":true
          },
          "tostr":{
            "optchain":true,
            "opt":true
          }
        }
      },
      "summary":"convert an array of values to strings.",
      "lineno":152,
      "retgroups":[{
          "1":{
            "text":"the converted buffer",
            "type":"",
            "mods":[]
          },
          "g":0
        }],
      "args":"(t[, temp[, tostr]])",
      "type":"function",
      "name":"array_tostring",
      "parameter":"param",
      "params":{
        "1":"t",
        "2":"temp",
        "map":{
          "t":" a list-like table",
          "temp":" (table) buffer to use, otherwise allocate",
          "tostr":" custom tostring function, called with (value,index). Defaults to `tostring`."
        },
        "3":"tostr"
      },
      "tags":[],
      "kind":"functions",
      "section":"function",
      "description":"",
      "ret":["the converted buffer"]
    },{
      "inferred":true,
      "subparams":[],
      "modifiers":{
        "usage":[[]],
        "param":{
          "1":[],
          "2":[],
          "obj":[],
          "tp":[]
        },
        "return":[[]]
      },
      "summary":"is the object of the specified type?",
      "lineno":172,
      "retgroups":[{
          "1":{
            "text":"boolean",
            "type":"",
            "mods":[]
          },
          "g":0
        }],
      "args":"(obj, tp)",
      "usage":["utils.is_type(\"hello world\", \"string\")   --> true\n-- or check metatable\nlocal my_mt = {}\nlocal my_obj = setmetatable(my_obj, my_mt)\nutils.is_type(my_obj, my_mt)  --> true\n"],
      "type":"function",
      "name":"is_type",
      "parameter":"param",
      "params":{
        "1":"obj",
        "2":"tp",
        "map":{
          "obj":" An object to check",
          "tp":" String of what type it should be"
        }
      },
      "tags":[],
      "kind":"functions",
      "section":"function",
      "description":"\n If the type is a string, then use type, otherwise compare with metatable",
      "ret":["boolean"]
    },{
      "inferred":true,
      "subparams":[],
      "modifiers":{
        "usage":[[]],
        "return":[{
            "type":"integer"
          },{
            "type":"any"
          }],
        "param":{
          "1":{
            "type":"table"
          },
          "2":{
            "opt":"1",
            "type":"integer",
            "optchain":"1"
          },
          "3":{
            "opt":"t.n or #t",
            "type":"integer",
            "optchain":"t.n or #t"
          },
          "4":{
            "opt":"1",
            "type":"integer",
            "optchain":"1"
          },
          "t":{
            "type":"table"
          },
          "step":{
            "opt":"1",
            "type":"integer",
            "optchain":"1"
          },
          "i_start":{
            "opt":"1",
            "type":"integer",
            "optchain":"1"
          },
          "i_end":{
            "opt":"t.n or #t",
            "type":"integer",
            "optchain":"t.n or #t"
          }
        },
        "see":[[],[]]
      },
      "summary":"an iterator with indices, similar to `ipairs`, but with a range.",
      "lineno":199,
      "retgroups":[{
          "1":{
            "text":"index",
            "type":"integer",
            "mods":{
              "type":"integer"
            }
          },
          "2":{
            "text":"value at index (which can be `nil`!)",
            "type":"any",
            "mods":{
              "type":"any"
            }
          },
          "g":0
        }],
      "args":"(t[, i_start=1[, i_end=t.n or #t[, step=1]]])",
      "usage":["local t = utils.pack(nil, 123, nil)  -- adds an `n` field when packing\n\nfor i, v in utils.npairs(t, 2) do  -- start at index 2\n  t[i] = tostring(t[i])\nend\n\n-- t = { n = 3, [2] = \"123\", [3] = \"nil\" }\n"],
      "type":"function",
      "name":"npairs",
      "parameter":"param",
      "params":{
        "1":"t",
        "2":"i_start",
        "3":"i_end",
        "4":"step",
        "map":{
          "t":" the table to iterate over",
          "step":" step size",
          "i_start":" start index",
          "i_end":" end index"
        }
      },
      "tags":{
        "see":[]
      },
      "kind":"functions",
      "section":"function",
      "description":"\n This is a nil-safe index based iterator that will return `nil` when there\n is a hole in a list. To be safe ensure that table `t.n` contains the length.",
      "ret":["index","value at index (which can be `nil`!)"]
    },{
      "inferred":true,
      "subparams":[],
      "modifiers":{
        "usage":[[]],
        "param":{
          "1":{
            "type":"table"
          },
          "t":{
            "type":"table"
          }
        },
        "return":[{
            "type":"key"
          },{
            "type":"value"
          }]
      },
      "summary":"an iterator over all non-integer keys (inverse of `ipairs`).",
      "lineno":253,
      "retgroups":[{
          "1":{
            "text":"",
            "type":"key",
            "mods":{
              "type":"key"
            }
          },
          "2":{
            "text":"",
            "type":"value",
            "mods":{
              "type":"value"
            }
          },
          "g":0
        }],
      "args":"(t)",
      "usage":["local t = {\n  \"hello\",\n  \"world\",\n  hello = \"hallo\",\n  world = \"Welt\",\n}\n\nfor k, v in utils.kpairs(t) do\n  print(\"German: \", v)\nend\n\n-- output;\n-- German: hallo\n-- German: Welt\n"],
      "type":"function",
      "name":"kpairs",
      "parameter":"param",
      "params":{
        "map":{
          "t":" the table to iterate over"
        },
        "1":"t"
      },
      "tags":[],
      "kind":"functions",
      "section":"function",
      "description":"\n It will skip any key that is an integer number, so negative indices or an\n array with holes will not return those either (so it returns slightly less than\n 'the inverse of `ipairs`').\n\n This uses `pairs` under the hood, so any value that is iterable using `pairs`\n will work with this function.",
      "ret":["",""]
    },{
      "inferred":true,
      "subparams":[],
      "modifiers":{
        "usage":[[]],
        "param":{
          "1":[],
          "2":[],
          "3":[],
          "4":[],
          "5":[],
          "6":[],
          "n":[],
          "verify":[],
          "val":[],
          "lev":[],
          "msg":[],
          "tp":[]
        },
        "raise":[],
        "return":[[]]
      },
      "summary":"assert that the given argument is in fact of the correct type.",
      "lineno":285,
      "retgroups":[{
          "1":{
            "text":"the validated value",
            "type":"",
            "mods":[]
          },
          "g":0
        }],
      "args":"(n, val, tp, verify, msg, lev)",
      "usage":["local param1 = assert_arg(1,\"hello\",'table')  --> error: argument 1 expected a 'table', got a 'string'\nlocal param4 = assert_arg(4,'!@#$%^&*','string',path.isdir,'not a directory')\n     --> error: argument 4: '!@#$%^&*' not a directory\n"],
      "raise":"if `val` is not the correct type",
      "name":"assert_arg",
      "params":{
        "1":"n",
        "2":"val",
        "3":"tp",
        "4":"verify",
        "5":"msg",
        "6":"lev",
        "map":{
          "n":" argument index",
          "verify":" an optional verification function",
          "val":" the value",
          "lev":" optional stack position for trace, default 2",
          "msg":" an optional custom message",
          "tp":" the type"
        }
      },
      "tags":[],
      "kind":"error handling ",
      "section":"Error handling",
      "type":"function",
      "parameter":"param",
      "ret":["the validated value"],
      "description":""
    },{
      "inferred":true,
      "subparams":[],
      "modifiers":{
        "usage":[[],[],[]],
        "param":{
          "1":{
            "type":"table|vararg"
          },
          "...":{
            "type":"table|vararg"
          }
        },
        "return":[[]]
      },
      "summary":"creates an Enum or constants lookup table for improved error handling.",
      "lineno":355,
      "retgroups":[{
          "1":{
            "text":"Enum object (read-only table/object)",
            "type":"",
            "mods":[]
          },
          "g":0
        }],
      "args":"(...)",
      "usage":["-- Enum access at runtime\nlocal obj = {}\nobj.MOVEMENT = utils.enum(\"FORWARD\", \"REVERSE\", \"LEFT\", \"RIGHT\")\n\nif current_movement == obj.MOVEMENT.FORWARD then\n  -- do something\n\nelseif current_movement == obj.MOVEMENT.REVERES then\n  -- throws error due to typo 'REVERES', so a silent mistake becomes a hard error\n  -- \"'REVERES' is not a valid value (expected one of: 'FORWARD', 'REVERSE', 'LEFT', 'RIGHT')\"\n\nend\n","-- standardized error codes\nlocal obj = {\n  ERR = utils.enum {\n    NOT_FOUND = \"the item was not found\",\n    OUT_OF_BOUNDS = \"the index is outside the allowed range\"\n  },\n\n  some_method = function(self)\n    return self.ERR.OUT_OF_BOUNDS\n  end,\n}\n\nlocal result, err = obj:some_method()\nif not result then\n  if err == obj.ERR.NOT_FOUND then\n    -- check on error code, not magic strings\n\n  else\n    -- return the error description, contained in the constant\n    return nil, \"error: \"..err  -- \"error: the index is outside the allowed range\"\n  end\nend\n","-- validating/converting user-input\nlocal color = \"purple\"\nlocal ansi_colors = utils.enum {\n  black     = 30,\n  red       = 31,\n  green     = 32,\n}\nlocal color_code, err = ansi_colors(color) -- calling on the object, returns the value from the enum\nif not color_code then\n  print(\"bad 'color', \" .. err)\n  -- \"bad 'color', 'purple' is not a valid value (expected one of: 'black', 'red', 'green')\"\n  os.exit(1)\nend\n"],
      "type":"function",
      "name":"enum",
      "parameter":"param",
      "params":{
        "map":{
          "...":" the input for the Enum. If varargs or an array then the\n values in the Enum will be equal to the names (must be strings), if a hash-table\n then values remain (any type), and the keys must be strings."
        },
        "1":"..."
      },
      "tags":[],
      "kind":"error handling ",
      "section":"Error handling",
      "description":"\n This helps prevent magic strings in code by throwing errors for accessing\n non-existing values, and/or converting strings/identifiers to other values.\n\n Calling on the object does the same, but returns a soft error; `nil + err`, if\n the call is succesful (the key exists), it will return the value.\n\n When calling with varargs or an array the values will be equal to the keys.\n The enum object is read-only.",
      "ret":["Enum object (read-only table/object)"]
    },{
      "inferred":true,
      "subparams":[],
      "modifiers":{
        "param":{
          "1":[],
          "2":[],
          "3":[],
          "f":[],
          "msg":[],
          "idx":[]
        },
        "raise":[],
        "return":[[]]
      },
      "summary":"process a function argument.",
      "lineno":430,
      "retgroups":[{
          "1":{
            "text":"a callable",
            "type":"",
            "mods":[]
          },
          "g":0
        }],
      "args":"(idx, f, msg)",
      "type":"function",
      "name":"function_arg",
      "params":{
        "1":"idx",
        "2":"f",
        "map":{
          "f":" a function, operator string, or callable object",
          "msg":" optional error message",
          "idx":" argument index"
        },
        "3":"msg"
      },
      "tags":[],
      "kind":"error handling ",
      "section":"Error handling",
      "description":"\n This is used throughout Penlight and defines what is meant by a function:\n Something that is callable, or an operator string as defined by <code>pl.operator</code>,\n such as '>' or '#'. If a function factory has been registered for the type, it will\n be called to get the function.",
      "raise":"if idx is not a number or if f is not callable",
      "ret":["a callable"],
      "parameter":"param"
    },{
      "inferred":true,
      "subparams":[],
      "modifiers":{
        "usage":[[]],
        "param":{
          "1":[],
          "2":[],
          "val":[],
          "n":[]
        },
        "raise":[],
        "return":[[]]
      },
      "summary":"assert the common case that the argument is a string.",
      "lineno":470,
      "retgroups":[{
          "1":{
            "text":"the validated value",
            "type":"",
            "mods":[]
          },
          "g":0
        }],
      "args":"(n, val)",
      "usage":["local val = 42\nlocal param2 = utils.assert_string(2, val) --> error: argument 2 expected a 'string', got a 'number'\n"],
      "raise":"val must be a string",
      "name":"assert_string",
      "params":{
        "1":"n",
        "2":"val",
        "map":{
          "val":" a value that must be a string",
          "n":" argument index"
        }
      },
      "tags":[],
      "kind":"error handling ",
      "section":"Error handling",
      "type":"function",
      "parameter":"param",
      "ret":["the validated value"],
      "description":""
    },{
      "inferred":true,
      "subparams":[],
      "modifiers":{
        "param":{
          "1":[],
          "mode":[]
        },
        "return":[],
        "see":[[]]
      },
      "summary":"control the error strategy used by Penlight.",
      "lineno":483,
      "args":"(mode)",
      "section":"Error handling",
      "name":"on_error",
      "params":{
        "map":{
          "mode":" either 'default', 'quit'  or 'error'"
        },
        "1":"mode"
      },
      "tags":{
        "see":[]
      },
      "kind":"error handling ",
      "description":"\n This is a global setting that controls how `utils.raise` behaves:\n\n - 'default': return `nil + error` (this is the default)\n - 'error': throw a Lua error\n - 'quit': exit the program\n",
      "type":"function",
      "parameter":"param"
    },{
      "inferred":true,
      "subparams":[],
      "modifiers":{
        "return":[],
        "param":{
          "1":[],
          "err":[]
        },
        "usage":[[]],
        "see":[[]]
      },
      "summary":"used by Penlight functions to return errors.",
      "lineno":507,
      "args":"(err)",
      "usage":["if some_condition then\n  return utils.raise(\"some condition was not met\")  -- MUST use 'return'!\nend\n"],
      "section":"Error handling",
      "name":"raise",
      "parameter":"param",
      "params":{
        "map":{
          "err":" the error string."
        },
        "1":"err"
      },
      "tags":{
        "see":[]
      },
      "kind":"error handling ",
      "description":" Its global behaviour is controlled\n by `utils.on_error`.\n To use this function you MUST use it in conjunction with `return`, since it might\n return `nil + error`.",
      "type":"function"
    },{
      "inferred":true,
      "subparams":[],
      "modifiers":{
        "return":[[]],
        "param":{
          "1":[],
          "2":[],
          "filename":[],
          "is_bin":[]
        }
      },
      "summary":"return the contents of a file as a string",
      "lineno":527,
      "retgroups":[{
          "1":{
            "text":"file contents",
            "type":"",
            "mods":[]
          },
          "g":0
        }],
      "args":"(filename, is_bin)",
      "type":"function",
      "name":"readfile",
      "parameter":"param",
      "params":{
        "1":"filename",
        "2":"is_bin",
        "map":{
          "filename":" The file path",
          "is_bin":" open in binary mode"
        }
      },
      "tags":[],
      "kind":"file handling ",
      "section":"File handling",
      "description":"",
      "ret":["file contents"]
    },{
      "inferred":true,
      "subparams":[],
      "modifiers":{
        "param":{
          "1":[],
          "2":[],
          "3":[],
          "filename":[],
          "str":[],
          "is_bin":[]
        },
        "raise":[],
        "return":[[],[]]
      },
      "summary":"write a string to a file",
      "lineno":549,
      "retgroups":[{
          "1":{
            "text":"true or nil",
            "type":"",
            "mods":[]
          },
          "2":{
            "text":"error message",
            "type":"",
            "mods":[]
          },
          "g":0
        }],
      "args":"(filename, str, is_bin)",
      "type":"function",
      "name":"writefile",
      "params":{
        "1":"filename",
        "2":"str",
        "map":{
          "filename":" The file path",
          "str":" The string",
          "is_bin":" open in binary mode"
        },
        "3":"is_bin"
      },
      "tags":[],
      "kind":"file handling ",
      "section":"File handling",
      "description":"",
      "raise":"error if filename or str aren't strings",
      "ret":["true or nil","error message"],
      "parameter":"param"
    },{
      "inferred":true,
      "subparams":[],
      "modifiers":{
        "param":{
          "1":[],
          "filename":[]
        },
        "raise":[],
        "return":[[]]
      },
      "summary":"return the contents of a file as a list of lines",
      "lineno":569,
      "retgroups":[{
          "1":{
            "text":"file contents as a table",
            "type":"",
            "mods":[]
          },
          "g":0
        }],
      "args":"(filename)",
      "type":"function",
      "name":"readlines",
      "params":{
        "map":{
          "filename":" The file path"
        },
        "1":"filename"
      },
      "tags":[],
      "kind":"file handling ",
      "section":"File handling",
      "description":"",
      "raise":"error if filename is not a string",
      "ret":["file contents as a table"],
      "parameter":"param"
    },{
      "inferred":true,
      "subparams":[],
      "modifiers":{
        "return":[[],[],[],[]],
        "param":{
          "1":[],
          "2":[],
          "bin":[],
          "cmd":[]
        }
      },
      "summary":"execute a shell command and return the output.",
      "lineno":592,
      "retgroups":[{
          "1":{
            "text":"true if successful",
            "type":"",
            "mods":[]
          },
          "2":{
            "text":"actual return code",
            "type":"",
            "mods":[]
          },
          "3":{
            "text":"stdout output (string)",
            "type":"",
            "mods":[]
          },
          "4":{
            "text":"errout output (string)",
            "type":"",
            "mods":[]
          },
          "g":0
        }],
      "args":"(cmd, bin)",
      "type":"function",
      "name":"executeex",
      "parameter":"param",
      "params":{
        "1":"cmd",
        "2":"bin",
        "map":{
          "bin":" boolean, if true, read output as binary file",
          "cmd":" a shell command"
        }
      },
      "tags":[],
      "kind":"os functions ",
      "section":"OS functions",
      "description":"\n This function redirects the output to tempfiles and returns the content of those files.",
      "ret":["true if successful","actual return code","stdout output (string)","errout output (string)"]
    },{
      "inferred":true,
      "subparams":[],
      "modifiers":{
        "usage":[[]],
        "param":{
          "1":[],
          "argument":[]
        },
        "return":[[]]
      },
      "summary":"Quote and escape an argument of a command.",
      "lineno":623,
      "retgroups":[{
          "1":{
            "text":"quoted and escaped argument.",
            "type":"",
            "mods":[]
          },
          "g":0
        }],
      "args":"(argument)",
      "usage":["local options = utils.quote_arg {\n    \"-lluacov\",\n    \"-e\",\n    \"utils = print(require('pl.utils')._VERSION\",\n}\n-- returns: -lluacov -e 'utils = print(require('\\''pl.utils'\\'')._VERSION'\n"],
      "type":"function",
      "name":"quote_arg",
      "parameter":"param",
      "params":{
        "map":{
          "argument":" (string or table/list) the argument to quote. If a list then\n all arguments in the list will be returned as a single string quoted."
        },
        "1":"argument"
      },
      "tags":[],
      "kind":"os functions ",
      "section":"OS functions",
      "description":"\n Quotes a single (or list of) argument(s) of a command to be passed\n to `os.execute`, `pl.utils.execute` or `pl.utils.executeex`.",
      "ret":["quoted and escaped argument."]
    },{
      "inferred":true,
      "subparams":[],
      "modifiers":{
        "return":[],
        "param":{
          "1":{
            "opt":true
          },
          "2":[],
          "3":[],
          "msg":[],
          "...":[],
          "code":{
            "opt":true
          }
        },
        "usage":[[]],
        "see":[[]]
      },
      "summary":"error out of this program gracefully.",
      "lineno":667,
      "args":"([code], msg, ...)",
      "usage":["utils.quit(-1, \"Error '%s' happened\", \"42\")\n-- is equivalent to\nutils.quit(\"Error '%s' happened\", \"42\")  --> Error '42' happened\n"],
      "section":"OS functions",
      "name":"quit",
      "parameter":"param",
      "params":{
        "1":"code",
        "2":"msg",
        "map":{
          "msg":" The exit message will be sent to `stderr` (will be formatted with the extra parameters)",
          "...":" extra arguments for message's format'",
          "code":" The exit code, defaults to -`1` if omitted"
        },
        "3":"..."
      },
      "tags":{
        "see":[]
      },
      "kind":"os functions ",
      "description":"",
      "type":"function"
    },{
      "inferred":true,
      "subparams":[],
      "modifiers":{
        "return":[],
        "param":{
          "1":[],
          "s":[]
        }
      },
      "summary":"escape any Lua 'magic' characters in a string",
      "lineno":685,
      "args":"(s)",
      "section":"String functions",
      "name":"escape",
      "params":{
        "map":{
          "s":" The input string"
        },
        "1":"s"
      },
      "tags":[],
      "kind":"string functions ",
      "description":"",
      "type":"function",
      "parameter":"param"
    },{
      "inferred":true,
      "subparams":[],
      "modifiers":{
        "param":{
          "1":[],
          "2":[],
          "3":[],
          "4":[],
          "re":[],
          "n":[],
          "s":[],
          "plain":[]
        },
        "return":[[]],
        "raise":[],
        "see":[[]]
      },
      "summary":"split a string into a list of strings separated by a delimiter.",
      "lineno":698,
      "retgroups":[{
          "1":{
            "text":"a list-like table",
            "type":"",
            "mods":[]
          },
          "g":0
        }],
      "args":"(s, re, plain, n)",
      "type":"function",
      "name":"split",
      "params":{
        "1":"s",
        "2":"re",
        "3":"plain",
        "4":"n",
        "map":{
          "re":" optional A Lua string pattern; defaults to '%s+'",
          "n":" optional maximum number of elements (if there are more, the last will remian un-split)",
          "s":" The input string",
          "plain":" optional If truthy don't use Lua patterns"
        }
      },
      "tags":{
        "see":[]
      },
      "kind":"string functions ",
      "section":"String functions",
      "description":"",
      "raise":"error if s is not a string",
      "ret":["a list-like table"],
      "parameter":"param"
    },{
      "inferred":true,
      "subparams":[],
      "modifiers":{
        "param":{
          "1":[],
          "2":[],
          "3":[],
          "4":[],
          "re":[],
          "n":[],
          "s":[],
          "plain":[]
        },
        "return":[[]],
        "usage":[[]],
        "see":[[]]
      },
      "summary":"split a string into a number of return values.",
      "lineno":735,
      "retgroups":[{
          "1":{
            "text":"n values",
            "type":"",
            "mods":[]
          },
          "g":0
        }],
      "args":"(s, re, plain, n)",
      "usage":["first,next = splitv('user=jane=doe','=', false, 2)\nassert(first == \"user\")\nassert(next == \"jane=doe\")\n"],
      "type":"function",
      "name":"splitv",
      "parameter":"param",
      "params":{
        "1":"s",
        "2":"re",
        "3":"plain",
        "4":"n",
        "map":{
          "re":" A Lua string pattern; defaults to '%s+'",
          "n":" optional maximum number of splits",
          "s":" the string",
          "plain":" don't use Lua patterns"
        }
      },
      "tags":{
        "see":[]
      },
      "kind":"string functions ",
      "section":"String functions",
      "description":"\n Identical to `split` but returns multiple sub-strings instead of\n a single list of sub-strings.",
      "ret":["n values"]
    },{
      "inferred":true,
      "subparams":[],
      "modifiers":{
        "return":[[]],
        "param":{
          "1":[],
          "func":[]
        }
      },
      "summary":"'memoize' a function (cache returned value for next call).",
      "lineno":750,
      "retgroups":[{
          "1":{
            "text":"a function with at least one argument, which is used as the key.",
            "type":"",
            "mods":[]
          },
          "g":0
        }],
      "args":"(func)",
      "type":"function",
      "name":"memoize",
      "parameter":"param",
      "params":{
        "map":{
          "func":" a function of at least one argument"
        },
        "1":"func"
      },
      "tags":[],
      "kind":"functional ",
      "section":"Functional",
      "description":"\n This is useful if you have a function which is relatively expensive,\n but you don't know in advance what values will be required, so\n building a table upfront is wasteful/impossible.",
      "ret":["a function with at least one argument, which is used as the key."]
    },{
      "inferred":true,
      "subparams":[],
      "modifiers":{
        "return":[],
        "param":{
          "1":{
            "type":"tab"
          },
          "2":{
            "type":"func"
          },
          "fun":{
            "type":"func"
          },
          "mt":{
            "type":"tab"
          }
        }
      },
      "summary":"associate a function factory with a type.",
      "lineno":768,
      "args":"(mt, fun)",
      "section":"Functional",
      "name":"add_function_factory",
      "params":{
        "1":"mt",
        "2":"fun",
        "map":{
          "fun":" a callable that returns a function",
          "mt":" metatable"
        }
      },
      "tags":[],
      "kind":"functional ",
      "description":"\n A function factory takes an object of the given type and\n returns a function for evaluating it",
      "type":"function",
      "parameter":"param"
    },{
      "inferred":true,
      "subparams":[],
      "modifiers":{
        "param":{
          "1":[],
          "lf":[]
        },
        "return":[[]],
        "usage":[[]]
      },
      "summary":"an anonymous function as a string.",
      "lineno":800,
      "retgroups":[{
          "1":{
            "text":"a function",
            "type":"",
            "mods":[]
          },
          "g":0
        }],
      "args":"(lf)",
      "usage":["string_lambda '|x|x+1' (2) == 3\nstring_lambda '_+1' (2) == 3\n"],
      "type":"function",
      "name":"string_lambda",
      "params":{
        "map":{
          "lf":" function as a string"
        },
        "1":"lf"
      },
      "tags":[],
      "kind":"functional ",
      "section":"Functional",
      "description":" This string is either of the form\n '|args| expression' or is a function of one argument, '_'",
      "ret":["a function"],
      "parameter":"param"
    },{
      "inferred":true,
      "subparams":[],
      "modifiers":{
        "return":[[]],
        "see":[[]],
        "param":{
          "1":[],
          "2":[],
          "p":[],
          "fn":[]
        },
        "raise":[],
        "usage":[[]]
      },
      "summary":"bind the first argument of the function to a value.",
      "lineno":817,
      "retgroups":[{
          "1":{
            "text":"a function such that f(x) is fn(p,x)",
            "type":"",
            "mods":[]
          },
          "g":0
        }],
      "args":"(fn, p)",
      "usage":["local function f(msg, name)\n  print(msg .. \" \" .. name)\nend\n\nlocal hello = utils.bind1(f, \"Hello\")\n\nprint(hello(\"world\"))     --> \"Hello world\"\nprint(hello(\"sunshine\"))  --> \"Hello sunshine\"\n"],
      "raise":"same as @{function_arg}",
      "name":"bind1",
      "params":{
        "1":"fn",
        "2":"p",
        "map":{
          "p":" a value",
          "fn":" a function of at least two values (may be an operator string)"
        }
      },
      "tags":{
        "see":[]
      },
      "kind":"functional ",
      "section":"Functional",
      "type":"function",
      "parameter":"param",
      "ret":["a function such that f(x) is fn(p,x)"],
      "description":""
    },{
      "inferred":true,
      "subparams":[],
      "modifiers":{
        "usage":[[]],
        "param":{
          "1":[],
          "2":[],
          "p":[],
          "fn":[]
        },
        "raise":[],
        "return":[[]]
      },
      "summary":"bind the second argument of the function to a value.",
      "lineno":836,
      "retgroups":[{
          "1":{
            "text":"a function such that f(x) is fn(x,p)",
            "type":"",
            "mods":[]
          },
          "g":0
        }],
      "args":"(fn, p)",
      "usage":["local function f(a, b, c)\n  print(a .. \" \" .. b .. \" \" .. c)\nend\n\nlocal hello = utils.bind1(f, \"world\")\n\nprint(hello(\"Hello\", \"!\"))  --> \"Hello world !\"\nprint(hello(\"Bye\", \"?\"))    --> \"Bye world ?\"\n"],
      "raise":"same as @{function_arg}",
      "name":"bind2",
      "params":{
        "1":"fn",
        "2":"p",
        "map":{
          "p":" a value",
          "fn":" a function of at least two values (may be an operator string)"
        }
      },
      "tags":[],
      "kind":"functional ",
      "section":"Functional",
      "type":"function",
      "parameter":"param",
      "ret":["a function such that f(x) is fn(x,p)"],
      "description":""
    },{
      "inferred":true,
      "subparams":[],
      "modifiers":{
        "return":[],
        "param":{
          "1":[],
          "func":[]
        },
        "usage":[[]],
        "see":[[]]
      },
      "summary":"Sets a deprecation warning function.",
      "lineno":875,
      "args":"(func)",
      "usage":["-- write to the Nginx logs with OpenResty\nutils.set_deprecation_func(function(msg, trace)\n  ngx.log(ngx.WARN, msg, (trace and (\" \" .. trace) or nil))\nend)\n\n-- disable deprecation warnings\nutils.set_deprecation_func()\n"],
      "section":"Deprecation",
      "name":"set_deprecation_func",
      "parameter":"param",
      "params":{
        "map":{
          "func":" a callback with signature: `function(msg, trace)` both arguments are strings, the latter being optional."
        },
        "1":"func"
      },
      "tags":{
        "see":[]
      },
      "kind":"deprecation ",
      "description":"\n An application can override this function to support proper output of\n deprecation warnings. The warnings can be generated from libraries or\n functions by calling `utils.raise_deprecation`. The default function\n will write to the 'warn' system (introduced in Lua 5.4, or the compatibility\n function from the `compat` module for earlier versions).\n\n Note: only applications should set/change this function, libraries should not.",
      "type":"function"
    },{
      "inferred":true,
      "subparams":[],
      "modifiers":{
        "return":[],
        "param":{
          "1":[],
          "opts":[]
        },
        "usage":[[]],
        "see":[[]]
      },
      "summary":"raises a deprecation warning.",
      "lineno":907,
      "args":"(opts)",
      "usage":["warn(\"@on\")   -- enable Lua warnings, they are usually off by default\n\nfunction stringx.islower(str)\n  raise_deprecation {\n    source = \"Penlight \" .. utils._VERSION,                   -- optional\n    message = \"function 'islower' was renamed to 'is_lower'\", -- required\n    version_removed = \"2.0.0\",                                -- optional\n    deprecated_after = \"1.2.3\",                               -- optional\n    no_trace = true,                                          -- optional\n  }\n  return stringx.is_lower(str)\nend\n-- output: \"[Penlight 1.9.2] function 'islower' was renamed to 'is_lower' (deprecated after 1.2.3, scheduled for removal in 2.0.0)\"\n"],
      "section":"Deprecation",
      "name":"raise_deprecation",
      "parameter":"param",
      "params":{
        "map":{
          "opts":" options table"
        },
        "1":"opts"
      },
      "tags":{
        "see":[]
      },
      "kind":"deprecation ",
      "description":"\n For options see the usage example below.\n\n Note: the `opts.deprecated_after` field is the last version in which\n a feature or option was NOT YET deprecated! Because when writing the code it\n is quite often not known in what version the code will land. But the last\n released version is usually known.",
      "type":"function"
    }],
  "package":"pl",
  "tags":[],
  "section":{
    "name":"deprecation",
    "inferred":true,
    "description":"",
    "file":{
      "warning":"<type 'function' is not supported by JSON.>",
      "filename":"/home/cji/portless/Penlight/lua/pl/utils.lua",
      "items":["<reference cycle>",{
          "inferred":true,
          "description":"",
          "modifiers":{
            "field":[],
            "return":[]
          },
          "summary":"Some standard patterns",
          "lineno":31,
          "args":"(FLOAT, INTEGER, IDEN, FILE)",
          "type":"table",
          "name":"patterns",
          "parameter":"field",
          "params":{
            "1":"FLOAT",
            "2":"INTEGER",
            "3":"IDEN",
            "4":"FILE",
            "map":{
              "FILE":"file",
              "INTEGER":"integer number",
              "IDEN":"identifier",
              "FLOAT":"floating point number"
            }
          },
          "tags":[],
          "kind":"tables",
          "section":"table",
          "subparams":[]
        },{
          "name":"stdmt",
          "section":"table",
          "inferred":true,
          "description":"",
          "kind":"tables",
          "summary":"Standard meta-tables as used by other Penlight modules",
          "params":{
            "1":"List",
            "2":"Map",
            "3":"Set",
            "4":"MultiMap",
            "map":{
              "Map":" the Map metatable",
              "Set":" the Set metatable",
              "MultiMap":" the MultiMap metatable",
              "List":" the List metatable"
            }
          },
          "tags":[],
          "lineno":45,
          "subparams":[],
          "args":"(List, Map, Set, MultiMap)",
          "parameter":"field",
          "type":"table",
          "modifiers":{
            "field":{
              "1":[],
              "2":[],
              "3":[],
              "4":[],
              "Map":[],
              "Set":[],
              "MultiMap":[],
              "List":[]
            },
            "return":[]
          }
        },{
          "inferred":true,
          "subparams":[],
          "modifiers":{
            "param":{
              "1":[],
              "...":[]
            },
            "return":[[]],
            "see":[[],[],[]]
          },
          "summary":"pack an argument list into a table.",
          "lineno":60,
          "retgroups":[{
              "1":{
                "text":"a table with field `n` set to the length",
                "type":"",
                "mods":[]
              },
              "g":0
            }],
          "args":"(...)",
          "section":"function",
          "name":"pack",
          "params":{
            "map":{
              "...":" any arguments"
            },
            "1":"..."
          },
          "tags":{
            "see":[]
          },
          "kind":"functions",
          "description":"",
          "type":"function",
          "ret":["a table with field `n` set to the length"],
          "parameter":"param"
        },{
          "inferred":true,
          "subparams":[],
          "modifiers":{
            "return":[[]],
            "usage":[[]],
            "param":{
              "1":[],
              "2":{
                "optchain":true,
                "opt":true
              },
              "3":{
                "optchain":true,
                "opt":true
              },
              "t":[],
              "j":{
                "optchain":true,
                "opt":true
              },
              "i":{
                "optchain":true,
                "opt":true
              }
            },
            "see":[[],[],[]]
          },
          "summary":"unpack a table and return its contents.",
          "lineno":79,
          "retgroups":[{
              "1":{
                "text":"multiple return values from the table",
                "type":"",
                "mods":[]
              },
              "g":0
            }],
          "args":"(t[, i[, j]])",
          "usage":["local t = table.pack(nil, nil, nil, 4)\nlocal a, b, c, d = table.unpack(t)   -- this `unpack` is NOT nil-safe, so d == nil\n\nlocal a, b, c, d = utils.unpack(t)   -- this is nil-safe, so d == 4\n"],
          "type":"function",
          "name":"unpack",
          "params":{
            "1":"t",
            "2":"i",
            "map":{
              "t":" table to unpack",
              "j":" index of the last element to unpack, defaults to `t.n` or else `#t`",
              "i":" index from which to start unpacking, defaults to 1"
            },
            "3":"j"
          },
          "tags":{
            "see":[]
          },
          "kind":"functions",
          "section":"function",
          "description":"\n\n NOTE: this implementation differs from the Lua implementation in the way\n that this one DOES honor the `n` field in the table `t`, such that it is 'nil-safe'.",
          "ret":["multiple return values from the table"],
          "parameter":"param"
        },{
          "inferred":true,
          "subparams":[],
          "modifiers":{
            "return":[],
            "param":{
              "1":[],
              "2":[],
              "fmt":[],
              "...":[]
            }
          },
          "summary":"print an arbitrary number of arguments using a format.",
          "lineno":87,
          "args":"(fmt, ...)",
          "section":"function",
          "name":"printf",
          "params":{
            "1":"fmt",
            "2":"...",
            "map":{
              "fmt":" The format (see `string.format`)",
              "...":" Extra arguments for format"
            }
          },
          "tags":[],
          "kind":"functions",
          "description":"\n Output will be sent to `stdout`.",
          "type":"function",
          "parameter":"param"
        },{
          "inferred":true,
          "subparams":[],
          "modifiers":{
            "return":[],
            "param":{
              "1":[],
              "2":[],
              "3":[],
              "fmt":[],
              "f":[],
              "...":[]
            }
          },
          "summary":"write an arbitrary number of arguments to a file using a format.",
          "lineno":96,
          "args":"(f, fmt, ...)",
          "section":"function",
          "name":"fprintf",
          "params":{
            "1":"f",
            "2":"fmt",
            "map":{
              "fmt":" The format (see `string.format`).",
              "f":" File handle to write to.",
              "...":" Extra arguments for format"
            },
            "3":"..."
          },
          "tags":[],
          "kind":"functions",
          "description":"",
          "type":"function",
          "parameter":"param"
        },{
          "inferred":true,
          "subparams":[],
          "modifiers":{
            "return":[],
            "param":{
              "1":[],
              "2":[],
              "t":[],
              "T":[]
            }
          },
          "summary":"take a table and 'inject' it into the local namespace.",
          "lineno":124,
          "args":"(t, T)",
          "section":"function",
          "name":"import",
          "params":{
            "1":"t",
            "2":"T",
            "map":{
              "t":" The table (table), or module name (string), defaults to this `utils` module table",
              "T":" An optional destination table (defaults to callers environment)"
            }
          },
          "tags":[],
          "kind":"functions",
          "description":"",
          "type":"function",
          "parameter":"param"
        },{
          "inferred":true,
          "subparams":[],
          "modifiers":{
            "return":[],
            "param":{
              "1":[],
              "2":[],
              "3":[],
              "cond":[],
              "value1":[],
              "value2":[]
            }
          },
          "summary":"return either of two values, depending on a condition.",
          "lineno":143,
          "args":"(cond, value1, value2)",
          "section":"function",
          "name":"choose",
          "params":{
            "1":"cond",
            "2":"value1",
            "map":{
              "cond":" A condition",
              "value1":" Value returned if cond is truthy",
              "value2":" Value returned if cond is falsy"
            },
            "3":"value2"
          },
          "tags":[],
          "kind":"functions",
          "description":"",
          "type":"function",
          "parameter":"param"
        },{
          "inferred":true,
          "subparams":[],
          "modifiers":{
            "return":[[]],
            "param":{
              "1":[],
              "2":{
                "optchain":true,
                "opt":true
              },
              "3":{
                "optchain":true,
                "opt":true
              },
              "t":[],
              "temp":{
                "optchain":true,
                "opt":true
              },
              "tostr":{
                "optchain":true,
                "opt":true
              }
            }
          },
          "summary":"convert an array of values to strings.",
          "lineno":152,
          "retgroups":[{
              "1":{
                "text":"the converted buffer",
                "type":"",
                "mods":[]
              },
              "g":0
            }],
          "args":"(t[, temp[, tostr]])",
          "type":"function",
          "name":"array_tostring",
          "parameter":"param",
          "params":{
            "1":"t",
            "2":"temp",
            "map":{
              "t":" a list-like table",
              "temp":" (table) buffer to use, otherwise allocate",
              "tostr":" custom tostring function, called with (value,index). Defaults to `tostring`."
            },
            "3":"tostr"
          },
          "tags":[],
          "kind":"functions",
          "section":"function",
          "description":"",
          "ret":["the converted buffer"]
        },{
          "inferred":true,
          "subparams":[],
          "modifiers":{
            "usage":[[]],
            "param":{
              "1":[],
              "2":[],
              "obj":[],
              "tp":[]
            },
            "return":[[]]
          },
          "summary":"is the object of the specified type?",
          "lineno":172,
          "retgroups":[{
              "1":{
                "text":"boolean",
                "type":"",
                "mods":[]
              },
              "g":0
            }],
          "args":"(obj, tp)",
          "usage":["utils.is_type(\"hello world\", \"string\")   --> true\n-- or check metatable\nlocal my_mt = {}\nlocal my_obj = setmetatable(my_obj, my_mt)\nutils.is_type(my_obj, my_mt)  --> true\n"],
          "type":"function",
          "name":"is_type",
          "parameter":"param",
          "params":{
            "1":"obj",
            "2":"tp",
            "map":{
              "obj":" An object to check",
              "tp":" String of what type it should be"
            }
          },
          "tags":[],
          "kind":"functions",
          "section":"function",
          "description":"\n If the type is a string, then use type, otherwise compare with metatable",
          "ret":["boolean"]
        },{
          "inferred":true,
          "subparams":[],
          "modifiers":{
            "usage":[[]],
            "return":[{
                "type":"integer"
              },{
                "type":"any"
              }],
            "param":{
              "1":{
                "type":"table"
              },
              "2":{
                "opt":"1",
                "type":"integer",
                "optchain":"1"
              },
              "3":{
                "opt":"t.n or #t",
                "type":"integer",
                "optchain":"t.n or #t"
              },
              "4":{
                "opt":"1",
                "type":"integer",
                "optchain":"1"
              },
              "t":{
                "type":"table"
              },
              "step":{
                "opt":"1",
                "type":"integer",
                "optchain":"1"
              },
              "i_start":{
                "opt":"1",
                "type":"integer",
                "optchain":"1"
              },
              "i_end":{
                "opt":"t.n or #t",
                "type":"integer",
                "optchain":"t.n or #t"
              }
            },
            "see":[[],[]]
          },
          "summary":"an iterator with indices, similar to `ipairs`, but with a range.",
          "lineno":199,
          "retgroups":[{
              "1":{
                "text":"index",
                "type":"integer",
                "mods":{
                  "type":"integer"
                }
              },
              "2":{
                "text":"value at index (which can be `nil`!)",
                "type":"any",
                "mods":{
                  "type":"any"
                }
              },
              "g":0
            }],
          "args":"(t[, i_start=1[, i_end=t.n or #t[, step=1]]])",
          "usage":["local t = utils.pack(nil, 123, nil)  -- adds an `n` field when packing\n\nfor i, v in utils.npairs(t, 2) do  -- start at index 2\n  t[i] = tostring(t[i])\nend\n\n-- t = { n = 3, [2] = \"123\", [3] = \"nil\" }\n"],
          "type":"function",
          "name":"npairs",
          "parameter":"param",
          "params":{
            "1":"t",
            "2":"i_start",
            "3":"i_end",
            "4":"step",
            "map":{
              "t":" the table to iterate over",
              "step":" step size",
              "i_start":" start index",
              "i_end":" end index"
            }
          },
          "tags":{
            "see":[]
          },
          "kind":"functions",
          "section":"function",
          "description":"\n This is a nil-safe index based iterator that will return `nil` when there\n is a hole in a list. To be safe ensure that table `t.n` contains the length.",
          "ret":["index","value at index (which can be `nil`!)"]
        },{
          "inferred":true,
          "subparams":[],
          "modifiers":{
            "usage":[[]],
            "param":{
              "1":{
                "type":"table"
              },
              "t":{
                "type":"table"
              }
            },
            "return":[{
                "type":"key"
              },{
                "type":"value"
              }]
          },
          "summary":"an iterator over all non-integer keys (inverse of `ipairs`).",
          "lineno":253,
          "retgroups":[{
              "1":{
                "text":"",
                "type":"key",
                "mods":{
                  "type":"key"
                }
              },
              "2":{
                "text":"",
                "type":"value",
                "mods":{
                  "type":"value"
                }
              },
              "g":0
            }],
          "args":"(t)",
          "usage":["local t = {\n  \"hello\",\n  \"world\",\n  hello = \"hallo\",\n  world = \"Welt\",\n}\n\nfor k, v in utils.kpairs(t) do\n  print(\"German: \", v)\nend\n\n-- output;\n-- German: hallo\n-- German: Welt\n"],
          "type":"function",
          "name":"kpairs",
          "parameter":"param",
          "params":{
            "map":{
              "t":" the table to iterate over"
            },
            "1":"t"
          },
          "tags":[],
          "kind":"functions",
          "section":"function",
          "description":"\n It will skip any key that is an integer number, so negative indices or an\n array with holes will not return those either (so it returns slightly less than\n 'the inverse of `ipairs`').\n\n This uses `pairs` under the hood, so any value that is iterable using `pairs`\n will work with this function.",
          "ret":["",""]
        },{
          "name":"Error-handling",
          "inferred":true,
          "description":"",
          "file":"<reference cycle>",
          "summary":"",
          "tags":[],
          "lineno":272,
          "display_name":"Error handling",
          "type":"section",
          "modifiers":[]
        },{
          "inferred":true,
          "subparams":[],
          "modifiers":{
            "usage":[[]],
            "param":{
              "1":[],
              "2":[],
              "3":[],
              "4":[],
              "5":[],
              "6":[],
              "n":[],
              "verify":[],
              "val":[],
              "lev":[],
              "msg":[],
              "tp":[]
            },
            "raise":[],
            "return":[[]]
          },
          "summary":"assert that the given argument is in fact of the correct type.",
          "lineno":285,
          "retgroups":[{
              "1":{
                "text":"the validated value",
                "type":"",
                "mods":[]
              },
              "g":0
            }],
          "args":"(n, val, tp, verify, msg, lev)",
          "usage":["local param1 = assert_arg(1,\"hello\",'table')  --> error: argument 1 expected a 'table', got a 'string'\nlocal param4 = assert_arg(4,'!@#$%^&*','string',path.isdir,'not a directory')\n     --> error: argument 4: '!@#$%^&*' not a directory\n"],
          "raise":"if `val` is not the correct type",
          "name":"assert_arg",
          "params":{
            "1":"n",
            "2":"val",
            "3":"tp",
            "4":"verify",
            "5":"msg",
            "6":"lev",
            "map":{
              "n":" argument index",
              "verify":" an optional verification function",
              "val":" the value",
              "lev":" optional stack position for trace, default 2",
              "msg":" an optional custom message",
              "tp":" the type"
            }
          },
          "tags":[],
          "kind":"error handling ",
          "section":"Error handling",
          "type":"function",
          "parameter":"param",
          "ret":["the validated value"],
          "description":""
        },{
          "inferred":true,
          "subparams":[],
          "modifiers":{
            "usage":[[],[],[]],
            "param":{
              "1":{
                "type":"table|vararg"
              },
              "...":{
                "type":"table|vararg"
              }
            },
            "return":[[]]
          },
          "summary":"creates an Enum or constants lookup table for improved error handling.",
          "lineno":355,
          "retgroups":[{
              "1":{
                "text":"Enum object (read-only table/object)",
                "type":"",
                "mods":[]
              },
              "g":0
            }],
          "args":"(...)",
          "usage":["-- Enum access at runtime\nlocal obj = {}\nobj.MOVEMENT = utils.enum(\"FORWARD\", \"REVERSE\", \"LEFT\", \"RIGHT\")\n\nif current_movement == obj.MOVEMENT.FORWARD then\n  -- do something\n\nelseif current_movement == obj.MOVEMENT.REVERES then\n  -- throws error due to typo 'REVERES', so a silent mistake becomes a hard error\n  -- \"'REVERES' is not a valid value (expected one of: 'FORWARD', 'REVERSE', 'LEFT', 'RIGHT')\"\n\nend\n","-- standardized error codes\nlocal obj = {\n  ERR = utils.enum {\n    NOT_FOUND = \"the item was not found\",\n    OUT_OF_BOUNDS = \"the index is outside the allowed range\"\n  },\n\n  some_method = function(self)\n    return self.ERR.OUT_OF_BOUNDS\n  end,\n}\n\nlocal result, err = obj:some_method()\nif not result then\n  if err == obj.ERR.NOT_FOUND then\n    -- check on error code, not magic strings\n\n  else\n    -- return the error description, contained in the constant\n    return nil, \"error: \"..err  -- \"error: the index is outside the allowed range\"\n  end\nend\n","-- validating/converting user-input\nlocal color = \"purple\"\nlocal ansi_colors = utils.enum {\n  black     = 30,\n  red       = 31,\n  green     = 32,\n}\nlocal color_code, err = ansi_colors(color) -- calling on the object, returns the value from the enum\nif not color_code then\n  print(\"bad 'color', \" .. err)\n  -- \"bad 'color', 'purple' is not a valid value (expected one of: 'black', 'red', 'green')\"\n  os.exit(1)\nend\n"],
          "type":"function",
          "name":"enum",
          "parameter":"param",
          "params":{
            "map":{
              "...":" the input for the Enum. If varargs or an array then the\n values in the Enum will be equal to the names (must be strings), if a hash-table\n then values remain (any type), and the keys must be strings."
            },
            "1":"..."
          },
          "tags":[],
          "kind":"error handling ",
          "section":"Error handling",
          "description":"\n This helps prevent magic strings in code by throwing errors for accessing\n non-existing values, and/or converting strings/identifiers to other values.\n\n Calling on the object does the same, but returns a soft error; `nil + err`, if\n the call is succesful (the key exists), it will return the value.\n\n When calling with varargs or an array the values will be equal to the keys.\n The enum object is read-only.",
          "ret":["Enum object (read-only table/object)"]
        },{
          "inferred":true,
          "subparams":[],
          "modifiers":{
            "param":{
              "1":[],
              "2":[],
              "3":[],
              "f":[],
              "msg":[],
              "idx":[]
            },
            "raise":[],
            "return":[[]]
          },
          "summary":"process a function argument.",
          "lineno":430,
          "retgroups":[{
              "1":{
                "text":"a callable",
                "type":"",
                "mods":[]
              },
              "g":0
            }],
          "args":"(idx, f, msg)",
          "type":"function",
          "name":"function_arg",
          "params":{
            "1":"idx",
            "2":"f",
            "map":{
              "f":" a function, operator string, or callable object",
              "msg":" optional error message",
              "idx":" argument index"
            },
            "3":"msg"
          },
          "tags":[],
          "kind":"error handling ",
          "section":"Error handling",
          "description":"\n This is used throughout Penlight and defines what is meant by a function:\n Something that is callable, or an operator string as defined by <code>pl.operator</code>,\n such as '>' or '#'. If a function factory has been registered for the type, it will\n be called to get the function.",
          "raise":"if idx is not a number or if f is not callable",
          "ret":["a callable"],
          "parameter":"param"
        },{
          "inferred":true,
          "subparams":[],
          "modifiers":{
            "usage":[[]],
            "param":{
              "1":[],
              "2":[],
              "val":[],
              "n":[]
            },
            "raise":[],
            "return":[[]]
          },
          "summary":"assert the common case that the argument is a string.",
          "lineno":470,
          "retgroups":[{
              "1":{
                "text":"the validated value",
                "type":"",
                "mods":[]
              },
              "g":0
            }],
          "args":"(n, val)",
          "usage":["local val = 42\nlocal param2 = utils.assert_string(2, val) --> error: argument 2 expected a 'string', got a 'number'\n"],
          "raise":"val must be a string",
          "name":"assert_string",
          "params":{
            "1":"n",
            "2":"val",
            "map":{
              "val":" a value that must be a string",
              "n":" argument index"
            }
          },
          "tags":[],
          "kind":"error handling ",
          "section":"Error handling",
          "type":"function",
          "parameter":"param",
          "ret":["the validated value"],
          "description":""
        },{
          "inferred":true,
          "subparams":[],
          "modifiers":{
            "param":{
              "1":[],
              "mode":[]
            },
            "return":[],
            "see":[[]]
          },
          "summary":"control the error strategy used by Penlight.",
          "lineno":483,
          "args":"(mode)",
          "section":"Error handling",
          "name":"on_error",
          "params":{
            "map":{
              "mode":" either 'default', 'quit'  or 'error'"
            },
            "1":"mode"
          },
          "tags":{
            "see":[]
          },
          "kind":"error handling ",
          "description":"\n This is a global setting that controls how `utils.raise` behaves:\n\n - 'default': return `nil + error` (this is the default)\n - 'error': throw a Lua error\n - 'quit': exit the program\n",
          "type":"function",
          "parameter":"param"
        },{
          "inferred":true,
          "subparams":[],
          "modifiers":{
            "return":[],
            "param":{
              "1":[],
              "err":[]
            },
            "usage":[[]],
            "see":[[]]
          },
          "summary":"used by Penlight functions to return errors.",
          "lineno":507,
          "args":"(err)",
          "usage":["if some_condition then\n  return utils.raise(\"some condition was not met\")  -- MUST use 'return'!\nend\n"],
          "section":"Error handling",
          "name":"raise",
          "parameter":"param",
          "params":{
            "map":{
              "err":" the error string."
            },
            "1":"err"
          },
          "tags":{
            "see":[]
          },
          "kind":"error handling ",
          "description":" Its global behaviour is controlled\n by `utils.on_error`.\n To use this function you MUST use it in conjunction with `return`, since it might\n return `nil + error`.",
          "type":"function"
        },{
          "name":"files",
          "inferred":true,
          "description":"",
          "file":"<reference cycle>",
          "summary":"",
          "tags":[],
          "lineno":523,
          "display_name":"File handling",
          "type":"section",
          "modifiers":[]
        },{
          "inferred":true,
          "subparams":[],
          "modifiers":{
            "return":[[]],
            "param":{
              "1":[],
              "2":[],
              "filename":[],
              "is_bin":[]
            }
          },
          "summary":"return the contents of a file as a string",
          "lineno":527,
          "retgroups":[{
              "1":{
                "text":"file contents",
                "type":"",
                "mods":[]
              },
              "g":0
            }],
          "args":"(filename, is_bin)",
          "type":"function",
          "name":"readfile",
          "parameter":"param",
          "params":{
            "1":"filename",
            "2":"is_bin",
            "map":{
              "filename":" The file path",
              "is_bin":" open in binary mode"
            }
          },
          "tags":[],
          "kind":"file handling ",
          "section":"File handling",
          "description":"",
          "ret":["file contents"]
        },{
          "inferred":true,
          "subparams":[],
          "modifiers":{
            "param":{
              "1":[],
              "2":[],
              "3":[],
              "filename":[],
              "str":[],
              "is_bin":[]
            },
            "raise":[],
            "return":[[],[]]
          },
          "summary":"write a string to a file",
          "lineno":549,
          "retgroups":[{
              "1":{
                "text":"true or nil",
                "type":"",
                "mods":[]
              },
              "2":{
                "text":"error message",
                "type":"",
                "mods":[]
              },
              "g":0
            }],
          "args":"(filename, str, is_bin)",
          "type":"function",
          "name":"writefile",
          "params":{
            "1":"filename",
            "2":"str",
            "map":{
              "filename":" The file path",
              "str":" The string",
              "is_bin":" open in binary mode"
            },
            "3":"is_bin"
          },
          "tags":[],
          "kind":"file handling ",
          "section":"File handling",
          "description":"",
          "raise":"error if filename or str aren't strings",
          "ret":["true or nil","error message"],
          "parameter":"param"
        },{
          "inferred":true,
          "subparams":[],
          "modifiers":{
            "param":{
              "1":[],
              "filename":[]
            },
            "raise":[],
            "return":[[]]
          },
          "summary":"return the contents of a file as a list of lines",
          "lineno":569,
          "retgroups":[{
              "1":{
                "text":"file contents as a table",
                "type":"",
                "mods":[]
              },
              "g":0
            }],
          "args":"(filename)",
          "type":"function",
          "name":"readlines",
          "params":{
            "map":{
              "filename":" The file path"
            },
            "1":"filename"
          },
          "tags":[],
          "kind":"file handling ",
          "section":"File handling",
          "description":"",
          "raise":"error if filename is not a string",
          "ret":["file contents as a table"],
          "parameter":"param"
        },{
          "name":"OS-functions",
          "inferred":true,
          "description":"",
          "file":"<reference cycle>",
          "summary":"",
          "tags":[],
          "lineno":584,
          "display_name":"OS functions",
          "type":"section",
          "modifiers":[]
        },{
          "inferred":true,
          "subparams":[],
          "modifiers":{
            "return":[[],[],[],[]],
            "param":{
              "1":[],
              "2":[],
              "bin":[],
              "cmd":[]
            }
          },
          "summary":"execute a shell command and return the output.",
          "lineno":592,
          "retgroups":[{
              "1":{
                "text":"true if successful",
                "type":"",
                "mods":[]
              },
              "2":{
                "text":"actual return code",
                "type":"",
                "mods":[]
              },
              "3":{
                "text":"stdout output (string)",
                "type":"",
                "mods":[]
              },
              "4":{
                "text":"errout output (string)",
                "type":"",
                "mods":[]
              },
              "g":0
            }],
          "args":"(cmd, bin)",
          "type":"function",
          "name":"executeex",
          "parameter":"param",
          "params":{
            "1":"cmd",
            "2":"bin",
            "map":{
              "bin":" boolean, if true, read output as binary file",
              "cmd":" a shell command"
            }
          },
          "tags":[],
          "kind":"os functions ",
          "section":"OS functions",
          "description":"\n This function redirects the output to tempfiles and returns the content of those files.",
          "ret":["true if successful","actual return code","stdout output (string)","errout output (string)"]
        },{
          "inferred":true,
          "subparams":[],
          "modifiers":{
            "usage":[[]],
            "param":{
              "1":[],
              "argument":[]
            },
            "return":[[]]
          },
          "summary":"Quote and escape an argument of a command.",
          "lineno":623,
          "retgroups":[{
              "1":{
                "text":"quoted and escaped argument.",
                "type":"",
                "mods":[]
              },
              "g":0
            }],
          "args":"(argument)",
          "usage":["local options = utils.quote_arg {\n    \"-lluacov\",\n    \"-e\",\n    \"utils = print(require('pl.utils')._VERSION\",\n}\n-- returns: -lluacov -e 'utils = print(require('\\''pl.utils'\\'')._VERSION'\n"],
          "type":"function",
          "name":"quote_arg",
          "parameter":"param",
          "params":{
            "map":{
              "argument":" (string or table/list) the argument to quote. If a list then\n all arguments in the list will be returned as a single string quoted."
            },
            "1":"argument"
          },
          "tags":[],
          "kind":"os functions ",
          "section":"OS functions",
          "description":"\n Quotes a single (or list of) argument(s) of a command to be passed\n to `os.execute`, `pl.utils.execute` or `pl.utils.executeex`.",
          "ret":["quoted and escaped argument."]
        },{
          "inferred":true,
          "subparams":[],
          "modifiers":{
            "return":[],
            "param":{
              "1":{
                "opt":true
              },
              "2":[],
              "3":[],
              "msg":[],
              "...":[],
              "code":{
                "opt":true
              }
            },
            "usage":[[]],
            "see":[[]]
          },
          "summary":"error out of this program gracefully.",
          "lineno":667,
          "args":"([code], msg, ...)",
          "usage":["utils.quit(-1, \"Error '%s' happened\", \"42\")\n-- is equivalent to\nutils.quit(\"Error '%s' happened\", \"42\")  --> Error '42' happened\n"],
          "section":"OS functions",
          "name":"quit",
          "parameter":"param",
          "params":{
            "1":"code",
            "2":"msg",
            "map":{
              "msg":" The exit message will be sent to `stderr` (will be formatted with the extra parameters)",
              "...":" extra arguments for message's format'",
              "code":" The exit code, defaults to -`1` if omitted"
            },
            "3":"..."
          },
          "tags":{
            "see":[]
          },
          "kind":"os functions ",
          "description":"",
          "type":"function"
        },{
          "name":"string-functions",
          "inferred":true,
          "description":"",
          "file":"<reference cycle>",
          "summary":"",
          "tags":[],
          "lineno":683,
          "display_name":"String functions",
          "type":"section",
          "modifiers":[]
        },{
          "inferred":true,
          "subparams":[],
          "modifiers":{
            "return":[],
            "param":{
              "1":[],
              "s":[]
            }
          },
          "summary":"escape any Lua 'magic' characters in a string",
          "lineno":685,
          "args":"(s)",
          "section":"String functions",
          "name":"escape",
          "params":{
            "map":{
              "s":" The input string"
            },
            "1":"s"
          },
          "tags":[],
          "kind":"string functions ",
          "description":"",
          "type":"function",
          "parameter":"param"
        },{
          "inferred":true,
          "subparams":[],
          "modifiers":{
            "param":{
              "1":[],
              "2":[],
              "3":[],
              "4":[],
              "re":[],
              "n":[],
              "s":[],
              "plain":[]
            },
            "return":[[]],
            "raise":[],
            "see":[[]]
          },
          "summary":"split a string into a list of strings separated by a delimiter.",
          "lineno":698,
          "retgroups":[{
              "1":{
                "text":"a list-like table",
                "type":"",
                "mods":[]
              },
              "g":0
            }],
          "args":"(s, re, plain, n)",
          "type":"function",
          "name":"split",
          "params":{
            "1":"s",
            "2":"re",
            "3":"plain",
            "4":"n",
            "map":{
              "re":" optional A Lua string pattern; defaults to '%s+'",
              "n":" optional maximum number of elements (if there are more, the last will remian un-split)",
              "s":" The input string",
              "plain":" optional If truthy don't use Lua patterns"
            }
          },
          "tags":{
            "see":[]
          },
          "kind":"string functions ",
          "section":"String functions",
          "description":"",
          "raise":"error if s is not a string",
          "ret":["a list-like table"],
          "parameter":"param"
        },{
          "inferred":true,
          "subparams":[],
          "modifiers":{
            "param":{
              "1":[],
              "2":[],
              "3":[],
              "4":[],
              "re":[],
              "n":[],
              "s":[],
              "plain":[]
            },
            "return":[[]],
            "usage":[[]],
            "see":[[]]
          },
          "summary":"split a string into a number of return values.",
          "lineno":735,
          "retgroups":[{
              "1":{
                "text":"n values",
                "type":"",
                "mods":[]
              },
              "g":0
            }],
          "args":"(s, re, plain, n)",
          "usage":["first,next = splitv('user=jane=doe','=', false, 2)\nassert(first == \"user\")\nassert(next == \"jane=doe\")\n"],
          "type":"function",
          "name":"splitv",
          "parameter":"param",
          "params":{
            "1":"s",
            "2":"re",
            "3":"plain",
            "4":"n",
            "map":{
              "re":" A Lua string pattern; defaults to '%s+'",
              "n":" optional maximum number of splits",
              "s":" the string",
              "plain":" don't use Lua patterns"
            }
          },
          "tags":{
            "see":[]
          },
          "kind":"string functions ",
          "section":"String functions",
          "description":"\n Identical to `split` but returns multiple sub-strings instead of\n a single list of sub-strings.",
          "ret":["n values"]
        },{
          "name":"functional",
          "inferred":true,
          "description":"",
          "file":"<reference cycle>",
          "summary":"",
          "tags":[],
          "lineno":744,
          "display_name":"Functional",
          "type":"section",
          "modifiers":[]
        },{
          "inferred":true,
          "subparams":[],
          "modifiers":{
            "return":[[]],
            "param":{
              "1":[],
              "func":[]
            }
          },
          "summary":"'memoize' a function (cache returned value for next call).",
          "lineno":750,
          "retgroups":[{
              "1":{
                "text":"a function with at least one argument, which is used as the key.",
                "type":"",
                "mods":[]
              },
              "g":0
            }],
          "args":"(func)",
          "type":"function",
          "name":"memoize",
          "parameter":"param",
          "params":{
            "map":{
              "func":" a function of at least one argument"
            },
            "1":"func"
          },
          "tags":[],
          "kind":"functional ",
          "section":"Functional",
          "description":"\n This is useful if you have a function which is relatively expensive,\n but you don't know in advance what values will be required, so\n building a table upfront is wasteful/impossible.",
          "ret":["a function with at least one argument, which is used as the key."]
        },{
          "inferred":true,
          "subparams":[],
          "modifiers":{
            "return":[],
            "param":{
              "1":{
                "type":"tab"
              },
              "2":{
                "type":"func"
              },
              "fun":{
                "type":"func"
              },
              "mt":{
                "type":"tab"
              }
            }
          },
          "summary":"associate a function factory with a type.",
          "lineno":768,
          "args":"(mt, fun)",
          "section":"Functional",
          "name":"add_function_factory",
          "params":{
            "1":"mt",
            "2":"fun",
            "map":{
              "fun":" a callable that returns a function",
              "mt":" metatable"
            }
          },
          "tags":[],
          "kind":"functional ",
          "description":"\n A function factory takes an object of the given type and\n returns a function for evaluating it",
          "type":"function",
          "parameter":"param"
        },{
          "inferred":true,
          "subparams":[],
          "modifiers":{
            "param":{
              "1":[],
              "lf":[]
            },
            "return":[[]],
            "usage":[[]]
          },
          "summary":"an anonymous function as a string.",
          "lineno":800,
          "retgroups":[{
              "1":{
                "text":"a function",
                "type":"",
                "mods":[]
              },
              "g":0
            }],
          "args":"(lf)",
          "usage":["string_lambda '|x|x+1' (2) == 3\nstring_lambda '_+1' (2) == 3\n"],
          "type":"function",
          "name":"string_lambda",
          "params":{
            "map":{
              "lf":" function as a string"
            },
            "1":"lf"
          },
          "tags":[],
          "kind":"functional ",
          "section":"Functional",
          "description":" This string is either of the form\n '|args| expression' or is a function of one argument, '_'",
          "ret":["a function"],
          "parameter":"param"
        },{
          "inferred":true,
          "subparams":[],
          "modifiers":{
            "return":[[]],
            "see":[[]],
            "param":{
              "1":[],
              "2":[],
              "p":[],
              "fn":[]
            },
            "raise":[],
            "usage":[[]]
          },
          "summary":"bind the first argument of the function to a value.",
          "lineno":817,
          "retgroups":[{
              "1":{
                "text":"a function such that f(x) is fn(p,x)",
                "type":"",
                "mods":[]
              },
              "g":0
            }],
          "args":"(fn, p)",
          "usage":["local function f(msg, name)\n  print(msg .. \" \" .. name)\nend\n\nlocal hello = utils.bind1(f, \"Hello\")\n\nprint(hello(\"world\"))     --> \"Hello world\"\nprint(hello(\"sunshine\"))  --> \"Hello sunshine\"\n"],
          "raise":"same as @{function_arg}",
          "name":"bind1",
          "params":{
            "1":"fn",
            "2":"p",
            "map":{
              "p":" a value",
              "fn":" a function of at least two values (may be an operator string)"
            }
          },
          "tags":{
            "see":[]
          },
          "kind":"functional ",
          "section":"Functional",
          "type":"function",
          "parameter":"param",
          "ret":["a function such that f(x) is fn(p,x)"],
          "description":""
        },{
          "inferred":true,
          "subparams":[],
          "modifiers":{
            "usage":[[]],
            "param":{
              "1":[],
              "2":[],
              "p":[],
              "fn":[]
            },
            "raise":[],
            "return":[[]]
          },
          "summary":"bind the second argument of the function to a value.",
          "lineno":836,
          "retgroups":[{
              "1":{
                "text":"a function such that f(x) is fn(x,p)",
                "type":"",
                "mods":[]
              },
              "g":0
            }],
          "args":"(fn, p)",
          "usage":["local function f(a, b, c)\n  print(a .. \" \" .. b .. \" \" .. c)\nend\n\nlocal hello = utils.bind1(f, \"world\")\n\nprint(hello(\"Hello\", \"!\"))  --> \"Hello world !\"\nprint(hello(\"Bye\", \"?\"))    --> \"Bye world ?\"\n"],
          "raise":"same as @{function_arg}",
          "name":"bind2",
          "params":{
            "1":"fn",
            "2":"p",
            "map":{
              "p":" a value",
              "fn":" a function of at least two values (may be an operator string)"
            }
          },
          "tags":[],
          "kind":"functional ",
          "section":"Functional",
          "type":"function",
          "parameter":"param",
          "ret":["a function such that f(x) is fn(x,p)"],
          "description":""
        },"<reference cycle>",{
          "inferred":true,
          "subparams":[],
          "modifiers":{
            "return":[],
            "param":{
              "1":[],
              "func":[]
            },
            "usage":[[]],
            "see":[[]]
          },
          "summary":"Sets a deprecation warning function.",
          "lineno":875,
          "args":"(func)",
          "usage":["-- write to the Nginx logs with OpenResty\nutils.set_deprecation_func(function(msg, trace)\n  ngx.log(ngx.WARN, msg, (trace and (\" \" .. trace) or nil))\nend)\n\n-- disable deprecation warnings\nutils.set_deprecation_func()\n"],
          "section":"Deprecation",
          "name":"set_deprecation_func",
          "parameter":"param",
          "params":{
            "map":{
              "func":" a callback with signature: `function(msg, trace)` both arguments are strings, the latter being optional."
            },
            "1":"func"
          },
          "tags":{
            "see":[]
          },
          "kind":"deprecation ",
          "description":"\n An application can override this function to support proper output of\n deprecation warnings. The warnings can be generated from libraries or\n functions by calling `utils.raise_deprecation`. The default function\n will write to the 'warn' system (introduced in Lua 5.4, or the compatibility\n function from the `compat` module for earlier versions).\n\n Note: only applications should set/change this function, libraries should not.",
          "type":"function"
        },{
          "inferred":true,
          "subparams":[],
          "modifiers":{
            "return":[],
            "param":{
              "1":[],
              "opts":[]
            },
            "usage":[[]],
            "see":[[]]
          },
          "summary":"raises a deprecation warning.",
          "lineno":907,
          "args":"(opts)",
          "usage":["warn(\"@on\")   -- enable Lua warnings, they are usually off by default\n\nfunction stringx.islower(str)\n  raise_deprecation {\n    source = \"Penlight \" .. utils._VERSION,                   -- optional\n    message = \"function 'islower' was renamed to 'is_lower'\", -- required\n    version_removed = \"2.0.0\",                                -- optional\n    deprecated_after = \"1.2.3\",                               -- optional\n    no_trace = true,                                          -- optional\n  }\n  return stringx.is_lower(str)\nend\n-- output: \"[Penlight 1.9.2] function 'islower' was renamed to 'is_lower' (deprecated after 1.2.3, scheduled for removal in 2.0.0)\"\n"],
          "section":"Deprecation",
          "name":"raise_deprecation",
          "parameter":"param",
          "params":{
            "map":{
              "opts":" options table"
            },
            "1":"opts"
          },
          "tags":{
            "see":[]
          },
          "kind":"deprecation ",
          "description":"\n For options see the usage example below.\n\n Note: the `opts.deprecated_after` field is the last version in which\n a feature or option was NOT YET deprecated! Because when writing the code it\n is quite often not known in what version the code will land. But the last\n released version is usually known.",
          "type":"function"
        }],
      "sections":[],
      "modules":["<reference cycle>"],
      "args":{
        "one":false,
        "module":false,
        "verbose":false,
        "style":"!",
        "template":"!",
        "date":"system",
        "dir":"doc",
        "quiet":false,
        "all":false,
        "ignore":false,
        "colon":false,
        "not_luadoc":false,
        "ext":"html",
        "boilerplate":false,
        "merge":false,
        "filter":"f.filter",
        "package":"/home/cji/portless/Penlight/lua",
        "dump":false,
        "no_args_infer":false,
        "title":"Reference",
        "project":"ldoc",
        "file":"/home/cji/portless/Penlight/lua/pl",
        "format":"discount",
        "simple":false,
        "tags":"none",
        "define":"none",
        "output":"index",
        "unqualified":false,
        "config":"config.ld",
        "fatalwarnings":false,
        "testing":false
      },
      "error":"<type 'function' is not supported by JSON.>",
      "lang":{
        "line_comment":"^%-%-+",
        "start_comment_":"^%-%-%-+",
        "end_comment_":"[^%-]%-%-+[^-]*\n$",
        "extra":[],
        "block_comment":"^%-%-%[=*%[%-+",
        "empty_comment_":"^%-%-%-+%s*$",
        "method_call":":"
      },
      "base":"/home/cji/portless/Penlight/lua"
    },
    "summary":"",
    "tags":[],
    "lineno":847,
    "display_name":"Deprecation",
    "type":"section",
    "modifiers":[]
  },
  "inferred":true
}